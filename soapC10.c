#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif


SOAP_FMAC3 struct tt__VideoOutput ** SOAP_FMAC4 soap_get_PointerTott__VideoOutput(struct soap *soap, struct tt__VideoOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotmd__RelayOutputOptions(struct soap *soap, struct tmd__RelayOutputOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tmd__RelayOutputOptions))
		soap_serialize_tmd__RelayOutputOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotmd__RelayOutputOptions(struct soap *soap, const char *tag, int id, struct tmd__RelayOutputOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tmd__RelayOutputOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tmd__RelayOutputOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tmd__RelayOutputOptions ** SOAP_FMAC4 soap_in_PointerTotmd__RelayOutputOptions(struct soap *soap, const char *tag, struct tmd__RelayOutputOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tmd__RelayOutputOptions **)soap_malloc(soap, sizeof(struct tmd__RelayOutputOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tmd__RelayOutputOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tmd__RelayOutputOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__RelayOutputOptions, sizeof(struct tmd__RelayOutputOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotmd__RelayOutputOptions(struct soap *soap, struct tmd__RelayOutputOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotmd__RelayOutputOptions);
	if (soap_out_PointerTotmd__RelayOutputOptions(soap, tag?tag:"tmd:RelayOutputOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__RelayOutputOptions ** SOAP_FMAC4 soap_get_PointerTotmd__RelayOutputOptions(struct soap *soap, struct tmd__RelayOutputOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotmd__RelayOutputOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotmd__Capabilities(struct soap *soap, struct tmd__Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tmd__Capabilities))
		soap_serialize_tmd__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotmd__Capabilities(struct soap *soap, const char *tag, int id, struct tmd__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tmd__Capabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tmd__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tmd__Capabilities ** SOAP_FMAC4 soap_in_PointerTotmd__Capabilities(struct soap *soap, const char *tag, struct tmd__Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tmd__Capabilities **)soap_malloc(soap, sizeof(struct tmd__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tmd__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tmd__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__Capabilities, sizeof(struct tmd__Capabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotmd__Capabilities(struct soap *soap, struct tmd__Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotmd__Capabilities);
	if (soap_out_PointerTotmd__Capabilities(soap, tag?tag:"tmd:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__Capabilities ** SOAP_FMAC4 soap_get_PointerTotmd__Capabilities(struct soap *soap, struct tmd__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotmd__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotmd__ParityBit(struct soap *soap, enum tmd__ParityBit *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tmd__ParityBit);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotmd__ParityBit(struct soap *soap, const char *tag, int id, enum tmd__ParityBit *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tmd__ParityBit);
	if (id < 0)
		return soap->error;
	return soap_out_tmd__ParityBit(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tmd__ParityBit ** SOAP_FMAC4 soap_in_PointerTotmd__ParityBit(struct soap *soap, const char *tag, enum tmd__ParityBit **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tmd__ParityBit **)soap_malloc(soap, sizeof(enum tmd__ParityBit *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tmd__ParityBit(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tmd__ParityBit **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__ParityBit, sizeof(enum tmd__ParityBit), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotmd__ParityBit(struct soap *soap, enum tmd__ParityBit *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotmd__ParityBit);
	if (soap_out_PointerTotmd__ParityBit(soap, tag?tag:"tmd:ParityBit", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tmd__ParityBit ** SOAP_FMAC4 soap_get_PointerTotmd__ParityBit(struct soap *soap, enum tmd__ParityBit **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotmd__ParityBit(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FloatList(struct soap *soap, struct tt__FloatList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FloatList))
		soap_serialize_tt__FloatList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FloatList(struct soap *soap, const char *tag, int id, struct tt__FloatList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FloatList);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FloatList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FloatList ** SOAP_FMAC4 soap_in_PointerTott__FloatList(struct soap *soap, const char *tag, struct tt__FloatList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FloatList **)soap_malloc(soap, sizeof(struct tt__FloatList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FloatList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FloatList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FloatList, sizeof(struct tt__FloatList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FloatList(struct soap *soap, struct tt__FloatList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FloatList);
	if (soap_out_PointerTott__FloatList(soap, tag?tag:"tt:FloatList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FloatList ** SOAP_FMAC4 soap_get_PointerTott__FloatList(struct soap *soap, struct tt__FloatList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FloatList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotmd__ParityBitList(struct soap *soap, struct tmd__ParityBitList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tmd__ParityBitList))
		soap_serialize_tmd__ParityBitList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotmd__ParityBitList(struct soap *soap, const char *tag, int id, struct tmd__ParityBitList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tmd__ParityBitList);
	if (id < 0)
		return soap->error;
	return soap_out_tmd__ParityBitList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tmd__ParityBitList ** SOAP_FMAC4 soap_in_PointerTotmd__ParityBitList(struct soap *soap, const char *tag, struct tmd__ParityBitList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tmd__ParityBitList **)soap_malloc(soap, sizeof(struct tmd__ParityBitList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tmd__ParityBitList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tmd__ParityBitList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__ParityBitList, sizeof(struct tmd__ParityBitList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotmd__ParityBitList(struct soap *soap, struct tmd__ParityBitList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotmd__ParityBitList);
	if (soap_out_PointerTotmd__ParityBitList(soap, tag?tag:"tmd:ParityBitList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__ParityBitList ** SOAP_FMAC4 soap_get_PointerTotmd__ParityBitList(struct soap *soap, struct tmd__ParityBitList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotmd__ParityBitList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotmd__RelayOutputOptionsExtension(struct soap *soap, struct tmd__RelayOutputOptionsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tmd__RelayOutputOptionsExtension))
		soap_serialize_tmd__RelayOutputOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotmd__RelayOutputOptionsExtension(struct soap *soap, const char *tag, int id, struct tmd__RelayOutputOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tmd__RelayOutputOptionsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tmd__RelayOutputOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tmd__RelayOutputOptionsExtension ** SOAP_FMAC4 soap_in_PointerTotmd__RelayOutputOptionsExtension(struct soap *soap, const char *tag, struct tmd__RelayOutputOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tmd__RelayOutputOptionsExtension **)soap_malloc(soap, sizeof(struct tmd__RelayOutputOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tmd__RelayOutputOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tmd__RelayOutputOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__RelayOutputOptionsExtension, sizeof(struct tmd__RelayOutputOptionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotmd__RelayOutputOptionsExtension(struct soap *soap, struct tmd__RelayOutputOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotmd__RelayOutputOptionsExtension);
	if (soap_out_PointerTotmd__RelayOutputOptionsExtension(soap, tag?tag:"tmd:RelayOutputOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__RelayOutputOptionsExtension ** SOAP_FMAC4 soap_get_PointerTotmd__RelayOutputOptionsExtension(struct soap *soap, struct tmd__RelayOutputOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotmd__RelayOutputOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelayMode(struct soap *soap, enum tt__RelayMode *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__RelayMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelayMode(struct soap *soap, const char *tag, int id, enum tt__RelayMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelayMode);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RelayMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__RelayMode ** SOAP_FMAC4 soap_in_PointerTott__RelayMode(struct soap *soap, const char *tag, enum tt__RelayMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__RelayMode **)soap_malloc(soap, sizeof(enum tt__RelayMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RelayMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__RelayMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelayMode, sizeof(enum tt__RelayMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelayMode(struct soap *soap, enum tt__RelayMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RelayMode);
	if (soap_out_PointerTott__RelayMode(soap, tag?tag:"tt:RelayMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RelayMode ** SOAP_FMAC4 soap_get_PointerTott__RelayMode(struct soap *soap, enum tt__RelayMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelayMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsStateInformation(struct soap *soap, struct tt__AnalyticsStateInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsStateInformation))
		soap_serialize_tt__AnalyticsStateInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsStateInformation(struct soap *soap, const char *tag, int id, struct tt__AnalyticsStateInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsStateInformation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsStateInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsStateInformation ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsStateInformation(struct soap *soap, const char *tag, struct tt__AnalyticsStateInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsStateInformation **)soap_malloc(soap, sizeof(struct tt__AnalyticsStateInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsStateInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsStateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsStateInformation, sizeof(struct tt__AnalyticsStateInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsStateInformation(struct soap *soap, struct tt__AnalyticsStateInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsStateInformation);
	if (soap_out_PointerTott__AnalyticsStateInformation(soap, tag?tag:"tt:AnalyticsStateInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsStateInformation ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsStateInformation(struct soap *soap, struct tt__AnalyticsStateInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsStateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngine(struct soap *soap, struct tt__AnalyticsEngine *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngine))
		soap_serialize_tt__AnalyticsEngine(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngine(struct soap *soap, const char *tag, int id, struct tt__AnalyticsEngine *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngine);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsEngine(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsEngine ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngine(struct soap *soap, const char *tag, struct tt__AnalyticsEngine **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsEngine **)soap_malloc(soap, sizeof(struct tt__AnalyticsEngine *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsEngine(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngine **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngine, sizeof(struct tt__AnalyticsEngine), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngine(struct soap *soap, struct tt__AnalyticsEngine *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsEngine);
	if (soap_out_PointerTott__AnalyticsEngine(soap, tag?tag:"tt:AnalyticsEngine", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngine ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngine(struct soap *soap, struct tt__AnalyticsEngine **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineControl(struct soap *soap, struct tt__AnalyticsEngineControl *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineControl))
		soap_serialize_tt__AnalyticsEngineControl(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineControl(struct soap *soap, const char *tag, int id, struct tt__AnalyticsEngineControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineControl);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsEngineControl(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsEngineControl ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineControl(struct soap *soap, const char *tag, struct tt__AnalyticsEngineControl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsEngineControl **)soap_malloc(soap, sizeof(struct tt__AnalyticsEngineControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsEngineControl(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineControl, sizeof(struct tt__AnalyticsEngineControl), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineControl(struct soap *soap, struct tt__AnalyticsEngineControl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsEngineControl);
	if (soap_out_PointerTott__AnalyticsEngineControl(soap, tag?tag:"tt:AnalyticsEngineControl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineControl ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineControl(struct soap *soap, struct tt__AnalyticsEngineControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineInput(struct soap *soap, struct tt__AnalyticsEngineInput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineInput))
		soap_serialize_tt__AnalyticsEngineInput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineInput(struct soap *soap, const char *tag, int id, struct tt__AnalyticsEngineInput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineInput);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsEngineInput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInput ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineInput(struct soap *soap, const char *tag, struct tt__AnalyticsEngineInput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsEngineInput **)soap_malloc(soap, sizeof(struct tt__AnalyticsEngineInput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsEngineInput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineInput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineInput, sizeof(struct tt__AnalyticsEngineInput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineInput(struct soap *soap, struct tt__AnalyticsEngineInput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsEngineInput);
	if (soap_out_PointerTott__AnalyticsEngineInput(soap, tag?tag:"tt:AnalyticsEngineInput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInput ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineInput(struct soap *soap, struct tt__AnalyticsEngineInput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotad__Capabilities(struct soap *soap, struct tad__Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tad__Capabilities))
		soap_serialize_tad__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotad__Capabilities(struct soap *soap, const char *tag, int id, struct tad__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tad__Capabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tad__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tad__Capabilities ** SOAP_FMAC4 soap_in_PointerTotad__Capabilities(struct soap *soap, const char *tag, struct tad__Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tad__Capabilities **)soap_malloc(soap, sizeof(struct tad__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tad__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tad__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tad__Capabilities, sizeof(struct tad__Capabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotad__Capabilities(struct soap *soap, struct tad__Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotad__Capabilities);
	if (soap_out_PointerTotad__Capabilities(soap, tag?tag:"tad:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tad__Capabilities ** SOAP_FMAC4 soap_get_PointerTotad__Capabilities(struct soap *soap, struct tad__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotad__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportedAnalyticsModules(struct soap *soap, struct tt__SupportedAnalyticsModules *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportedAnalyticsModules))
		soap_serialize_tt__SupportedAnalyticsModules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportedAnalyticsModules(struct soap *soap, const char *tag, int id, struct tt__SupportedAnalyticsModules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportedAnalyticsModules);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SupportedAnalyticsModules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModules ** SOAP_FMAC4 soap_in_PointerTott__SupportedAnalyticsModules(struct soap *soap, const char *tag, struct tt__SupportedAnalyticsModules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SupportedAnalyticsModules **)soap_malloc(soap, sizeof(struct tt__SupportedAnalyticsModules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SupportedAnalyticsModules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedAnalyticsModules, sizeof(struct tt__SupportedAnalyticsModules), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportedAnalyticsModules(struct soap *soap, struct tt__SupportedAnalyticsModules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SupportedAnalyticsModules);
	if (soap_out_PointerTott__SupportedAnalyticsModules(soap, tag?tag:"tt:SupportedAnalyticsModules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModules ** SOAP_FMAC4 soap_get_PointerTott__SupportedAnalyticsModules(struct soap *soap, struct tt__SupportedAnalyticsModules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportedAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportedRules(struct soap *soap, struct tt__SupportedRules *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportedRules))
		soap_serialize_tt__SupportedRules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportedRules(struct soap *soap, const char *tag, int id, struct tt__SupportedRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportedRules);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SupportedRules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SupportedRules ** SOAP_FMAC4 soap_in_PointerTott__SupportedRules(struct soap *soap, const char *tag, struct tt__SupportedRules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SupportedRules **)soap_malloc(soap, sizeof(struct tt__SupportedRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SupportedRules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedRules, sizeof(struct tt__SupportedRules), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportedRules(struct soap *soap, struct tt__SupportedRules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SupportedRules);
	if (soap_out_PointerTott__SupportedRules(soap, tag?tag:"tt:SupportedRules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedRules ** SOAP_FMAC4 soap_get_PointerTott__SupportedRules(struct soap *soap, struct tt__SupportedRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportedRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotan__Capabilities(struct soap *soap, struct tan__Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tan__Capabilities))
		soap_serialize_tan__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotan__Capabilities(struct soap *soap, const char *tag, int id, struct tan__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tan__Capabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tan__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tan__Capabilities ** SOAP_FMAC4 soap_in_PointerTotan__Capabilities(struct soap *soap, const char *tag, struct tan__Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tan__Capabilities **)soap_malloc(soap, sizeof(struct tan__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tan__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tan__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tan__Capabilities, sizeof(struct tan__Capabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotan__Capabilities(struct soap *soap, struct tan__Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotan__Capabilities);
	if (soap_out_PointerTotan__Capabilities(soap, tag?tag:"tan:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tan__Capabilities ** SOAP_FMAC4 soap_get_PointerTotan__Capabilities(struct soap *soap, struct tan__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotan__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__Documentation(struct soap *soap, struct wstop__Documentation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__Documentation))
		soap_serialize_wstop__Documentation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__Documentation(struct soap *soap, const char *tag, int id, struct wstop__Documentation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__Documentation);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__Documentation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wstop__Documentation ** SOAP_FMAC4 soap_in_PointerTowstop__Documentation(struct soap *soap, const char *tag, struct wstop__Documentation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wstop__Documentation **)soap_malloc(soap, sizeof(struct wstop__Documentation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__Documentation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wstop__Documentation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__Documentation, sizeof(struct wstop__Documentation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__Documentation(struct soap *soap, struct wstop__Documentation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowstop__Documentation);
	if (soap_out_PointerTowstop__Documentation(soap, tag?tag:"wstop:Documentation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__Documentation ** SOAP_FMAC4 soap_get_PointerTowstop__Documentation(struct soap *soap, struct wstop__Documentation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause))
		soap_serialize__wsrfbf__BaseFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsrfbf__BaseFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfbf__BaseFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfbf__BaseFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsrfbf__BaseFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfbf__BaseFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(struct _wsrfbf__BaseFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause);
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag?tag:"wsrfbf:BaseFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, struct _wsrfbf__BaseFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_Description))
		soap_serialize__wsrfbf__BaseFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsrfbf__BaseFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfbf__BaseFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfbf__BaseFaultType_Description **)soap_malloc(soap, sizeof(struct _wsrfbf__BaseFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfbf__BaseFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_Description, sizeof(struct _wsrfbf__BaseFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_Description);
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_Description(soap, tag?tag:"wsrfbf:BaseFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, struct _wsrfbf__BaseFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode))
		soap_serialize__wsrfbf__BaseFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfbf__BaseFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsrfbf__BaseFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfbf__BaseFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsrfbf__BaseFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfbf__BaseFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfbf__BaseFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(struct _wsrfbf__BaseFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode);
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag?tag:"wsrfbf:BaseFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, struct _wsrfbf__BaseFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy))
		soap_serialize__wsnt__Subscribe_SubscriptionPolicy(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, struct _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__Subscribe_SubscriptionPolicy(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, struct _wsnt__Subscribe_SubscriptionPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__Subscribe_SubscriptionPolicy **)soap_malloc(soap, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__Subscribe_SubscriptionPolicy(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Subscribe_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(struct _wsnt__Subscribe_SubscriptionPolicy), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy);
	if (soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag?tag:"wsnt:Subscribe-SubscriptionPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, struct _wsnt__Subscribe_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__SubscriptionPolicyType))
		soap_serialize_wsnt__SubscriptionPolicyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, struct wsnt__SubscriptionPolicyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__SubscriptionPolicyType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__SubscriptionPolicyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_in_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, struct wsnt__SubscriptionPolicyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__SubscriptionPolicyType **)soap_malloc(soap, sizeof(struct wsnt__SubscriptionPolicyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__SubscriptionPolicyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__SubscriptionPolicyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(struct wsnt__SubscriptionPolicyType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType);
	if (soap_out_PointerTowsnt__SubscriptionPolicyType(soap, tag?tag:"wsnt:SubscriptionPolicyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_get_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, struct wsnt__SubscriptionPolicyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicSetType))
		soap_serialize_wstop__TopicSetType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, int id, struct wstop__TopicSetType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicSetType);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__TopicSetType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wstop__TopicSetType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, struct wstop__TopicSetType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wstop__TopicSetType **)soap_malloc(soap, sizeof(struct wstop__TopicSetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__TopicSetType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicSetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicSetType, sizeof(struct wstop__TopicSetType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowstop__TopicSetType);
	if (soap_out_PointerTowstop__TopicSetType(soap, tag?tag:"wstop:TopicSetType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicSetType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicSetType(struct soap *soap, struct wstop__TopicSetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__EndpointReferenceType))
		soap_serialize_wsa5__EndpointReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__EndpointReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__EndpointReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__EndpointReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa5__EndpointReferenceType);
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, tag?tag:"wsa5:EndpointReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__PropertyOperation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PropertyOperation(struct soap *soap, const char *tag, int id, enum tt__PropertyOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PropertyOperation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PropertyOperation(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__PropertyOperation ** SOAP_FMAC4 soap_in_PointerTott__PropertyOperation(struct soap *soap, const char *tag, enum tt__PropertyOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__PropertyOperation **)soap_malloc(soap, sizeof(enum tt__PropertyOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PropertyOperation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__PropertyOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PropertyOperation, sizeof(enum tt__PropertyOperation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PropertyOperation);
	if (soap_out_PointerTott__PropertyOperation(soap, tag?tag:"tt:PropertyOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PropertyOperation ** SOAP_FMAC4 soap_get_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PropertyOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MessageExtension(struct soap *soap, struct tt__MessageExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MessageExtension))
		soap_serialize_tt__MessageExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MessageExtension(struct soap *soap, const char *tag, int id, struct tt__MessageExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MessageExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MessageExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MessageExtension ** SOAP_FMAC4 soap_in_PointerTott__MessageExtension(struct soap *soap, const char *tag, struct tt__MessageExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MessageExtension **)soap_malloc(soap, sizeof(struct tt__MessageExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MessageExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MessageExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MessageExtension, sizeof(struct tt__MessageExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MessageExtension(struct soap *soap, struct tt__MessageExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MessageExtension);
	if (soap_out_PointerTott__MessageExtension(soap, tag?tag:"tt:MessageExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageExtension ** SOAP_FMAC4 soap_get_PointerTott__MessageExtension(struct soap *soap, struct tt__MessageExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MessageExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, struct tt__ActionEngineEventPayloadExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension))
		soap_serialize_tt__ActionEngineEventPayloadExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, const char *tag, int id, struct tt__ActionEngineEventPayloadExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ActionEngineEventPayloadExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ActionEngineEventPayloadExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ActionEngineEventPayloadExtension ** SOAP_FMAC4 soap_in_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, const char *tag, struct tt__ActionEngineEventPayloadExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ActionEngineEventPayloadExtension **)soap_malloc(soap, sizeof(struct tt__ActionEngineEventPayloadExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ActionEngineEventPayloadExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ActionEngineEventPayloadExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, sizeof(struct tt__ActionEngineEventPayloadExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, struct tt__ActionEngineEventPayloadExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ActionEngineEventPayloadExtension);
	if (soap_out_PointerTott__ActionEngineEventPayloadExtension(soap, tag?tag:"tt:ActionEngineEventPayloadExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ActionEngineEventPayloadExtension ** SOAP_FMAC4 soap_get_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, struct tt__ActionEngineEventPayloadExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ActionEngineEventPayloadExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Fault))
		soap_serialize_SOAP_ENV__Fault(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Fault(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Fault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Fault);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Fault(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Fault ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Fault **)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Fault(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Fault);
	if (soap_out_PointerToSOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Envelope))
		soap_serialize_SOAP_ENV__Envelope(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Envelope(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Envelope *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Envelope);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Envelope(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Envelope(struct soap *soap, const char *tag, struct SOAP_ENV__Envelope **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Envelope **)soap_malloc(soap, sizeof(struct SOAP_ENV__Envelope *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Envelope(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Envelope **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Envelope);
	if (soap_out_PointerToSOAP_ENV__Envelope(soap, tag?tag:"SOAP-ENV:Envelope", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Envelope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsState(struct soap *soap, struct tt__AnalyticsState *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsState))
		soap_serialize_tt__AnalyticsState(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsState(struct soap *soap, const char *tag, int id, struct tt__AnalyticsState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsState);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsState(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsState ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsState(struct soap *soap, const char *tag, struct tt__AnalyticsState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsState **)soap_malloc(soap, sizeof(struct tt__AnalyticsState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsState, sizeof(struct tt__AnalyticsState), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsState(struct soap *soap, struct tt__AnalyticsState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsState);
	if (soap_out_PointerTott__AnalyticsState(soap, tag?tag:"tt:AnalyticsState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsState ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsState(struct soap *soap, struct tt__AnalyticsState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataInputExtension(struct soap *soap, struct tt__MetadataInputExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataInputExtension))
		soap_serialize_tt__MetadataInputExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataInputExtension(struct soap *soap, const char *tag, int id, struct tt__MetadataInputExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataInputExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataInputExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataInputExtension ** SOAP_FMAC4 soap_in_PointerTott__MetadataInputExtension(struct soap *soap, const char *tag, struct tt__MetadataInputExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataInputExtension **)soap_malloc(soap, sizeof(struct tt__MetadataInputExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataInputExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataInputExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataInputExtension, sizeof(struct tt__MetadataInputExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataInputExtension(struct soap *soap, struct tt__MetadataInputExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MetadataInputExtension);
	if (soap_out_PointerTott__MetadataInputExtension(soap, tag?tag:"tt:MetadataInputExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataInputExtension ** SOAP_FMAC4 soap_get_PointerTott__MetadataInputExtension(struct soap *soap, struct tt__MetadataInputExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataInputExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SourceIdentificationExtension(struct soap *soap, struct tt__SourceIdentificationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SourceIdentificationExtension))
		soap_serialize_tt__SourceIdentificationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SourceIdentificationExtension(struct soap *soap, const char *tag, int id, struct tt__SourceIdentificationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SourceIdentificationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SourceIdentificationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SourceIdentificationExtension ** SOAP_FMAC4 soap_in_PointerTott__SourceIdentificationExtension(struct soap *soap, const char *tag, struct tt__SourceIdentificationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SourceIdentificationExtension **)soap_malloc(soap, sizeof(struct tt__SourceIdentificationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SourceIdentificationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SourceIdentificationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SourceIdentificationExtension, sizeof(struct tt__SourceIdentificationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SourceIdentificationExtension(struct soap *soap, struct tt__SourceIdentificationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SourceIdentificationExtension);
	if (soap_out_PointerTott__SourceIdentificationExtension(soap, tag?tag:"tt:SourceIdentificationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceIdentificationExtension ** SOAP_FMAC4 soap_get_PointerTott__SourceIdentificationExtension(struct soap *soap, struct tt__SourceIdentificationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SourceIdentificationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, struct tt__AnalyticsEngineInputInfoExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension))
		soap_serialize_tt__AnalyticsEngineInputInfoExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, int id, struct tt__AnalyticsEngineInputInfoExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsEngineInputInfoExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfoExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, struct tt__AnalyticsEngineInputInfoExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsEngineInputInfoExtension **)soap_malloc(soap, sizeof(struct tt__AnalyticsEngineInputInfoExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsEngineInputInfoExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineInputInfoExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, sizeof(struct tt__AnalyticsEngineInputInfoExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, struct tt__AnalyticsEngineInputInfoExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsEngineInputInfoExtension);
	if (soap_out_PointerTott__AnalyticsEngineInputInfoExtension(soap, tag?tag:"tt:AnalyticsEngineInputInfoExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfoExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, struct tt__AnalyticsEngineInputInfoExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineInputInfoExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, struct tt__AnalyticsEngineInputInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineInputInfo))
		soap_serialize_tt__AnalyticsEngineInputInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, int id, struct tt__AnalyticsEngineInputInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineInputInfo);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsEngineInputInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfo ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, struct tt__AnalyticsEngineInputInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsEngineInputInfo **)soap_malloc(soap, sizeof(struct tt__AnalyticsEngineInputInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsEngineInputInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineInputInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineInputInfo, sizeof(struct tt__AnalyticsEngineInputInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, struct tt__AnalyticsEngineInputInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsEngineInputInfo);
	if (soap_out_PointerTott__AnalyticsEngineInputInfo(soap, tag?tag:"tt:AnalyticsEngineInputInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineInputInfo ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, struct tt__AnalyticsEngineInputInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineInputInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsDeviceEngineConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension))
		soap_serialize_tt__AnalyticsDeviceEngineConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__AnalyticsDeviceEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsDeviceEngineConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceEngineConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsDeviceEngineConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__AnalyticsDeviceEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsDeviceEngineConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, sizeof(struct tt__AnalyticsDeviceEngineConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsDeviceEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsDeviceEngineConfigurationExtension);
	if (soap_out_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, tag?tag:"tt:AnalyticsDeviceEngineConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsDeviceEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EngineConfiguration(struct soap *soap, struct tt__EngineConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EngineConfiguration))
		soap_serialize_tt__EngineConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EngineConfiguration(struct soap *soap, const char *tag, int id, struct tt__EngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EngineConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EngineConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__EngineConfiguration(struct soap *soap, const char *tag, struct tt__EngineConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EngineConfiguration **)soap_malloc(soap, sizeof(struct tt__EngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EngineConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EngineConfiguration, sizeof(struct tt__EngineConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EngineConfiguration(struct soap *soap, struct tt__EngineConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__EngineConfiguration);
	if (soap_out_PointerTott__EngineConfiguration(soap, tag?tag:"tt:EngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__EngineConfiguration(struct soap *soap, struct tt__EngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobConfiguration(struct soap *soap, struct tt__RecordingJobConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobConfiguration))
		soap_serialize_tt__RecordingJobConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobConfiguration(struct soap *soap, const char *tag, int id, struct tt__RecordingJobConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobConfiguration ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobConfiguration(struct soap *soap, const char *tag, struct tt__RecordingJobConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobConfiguration **)soap_malloc(soap, sizeof(struct tt__RecordingJobConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobConfiguration, sizeof(struct tt__RecordingJobConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobConfiguration(struct soap *soap, struct tt__RecordingJobConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingJobConfiguration);
	if (soap_out_PointerTott__RecordingJobConfiguration(soap, tag?tag:"tt:RecordingJobConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobConfiguration ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobConfiguration(struct soap *soap, struct tt__RecordingJobConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateTrack(struct soap *soap, struct tt__RecordingJobStateTrack *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateTrack))
		soap_serialize_tt__RecordingJobStateTrack(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateTrack(struct soap *soap, const char *tag, int id, struct tt__RecordingJobStateTrack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateTrack);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobStateTrack(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobStateTrack ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateTrack(struct soap *soap, const char *tag, struct tt__RecordingJobStateTrack **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobStateTrack **)soap_malloc(soap, sizeof(struct tt__RecordingJobStateTrack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobStateTrack(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateTrack, sizeof(struct tt__RecordingJobStateTrack), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateTrack(struct soap *soap, struct tt__RecordingJobStateTrack *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingJobStateTrack);
	if (soap_out_PointerTott__RecordingJobStateTrack(soap, tag?tag:"tt:RecordingJobStateTrack", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateTrack ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateTrack(struct soap *soap, struct tt__RecordingJobStateTrack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateTracks(struct soap *soap, struct tt__RecordingJobStateTracks *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateTracks))
		soap_serialize_tt__RecordingJobStateTracks(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateTracks(struct soap *soap, const char *tag, int id, struct tt__RecordingJobStateTracks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateTracks);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobStateTracks(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobStateTracks ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateTracks(struct soap *soap, const char *tag, struct tt__RecordingJobStateTracks **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobStateTracks **)soap_malloc(soap, sizeof(struct tt__RecordingJobStateTracks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobStateTracks(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateTracks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateTracks, sizeof(struct tt__RecordingJobStateTracks), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateTracks(struct soap *soap, struct tt__RecordingJobStateTracks *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingJobStateTracks);
	if (soap_out_PointerTott__RecordingJobStateTracks(soap, tag?tag:"tt:RecordingJobStateTracks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateTracks ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateTracks(struct soap *soap, struct tt__RecordingJobStateTracks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateTracks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, struct tt__RecordingJobStateInformationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateInformationExtension))
		soap_serialize_tt__RecordingJobStateInformationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, const char *tag, int id, struct tt__RecordingJobStateInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateInformationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobStateInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, const char *tag, struct tt__RecordingJobStateInformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobStateInformationExtension **)soap_malloc(soap, sizeof(struct tt__RecordingJobStateInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobStateInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateInformationExtension, sizeof(struct tt__RecordingJobStateInformationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, struct tt__RecordingJobStateInformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingJobStateInformationExtension);
	if (soap_out_PointerTott__RecordingJobStateInformationExtension(soap, tag?tag:"tt:RecordingJobStateInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, struct tt__RecordingJobStateInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateSource(struct soap *soap, struct tt__RecordingJobStateSource *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateSource))
		soap_serialize_tt__RecordingJobStateSource(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateSource(struct soap *soap, const char *tag, int id, struct tt__RecordingJobStateSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateSource);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobStateSource(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobStateSource ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateSource(struct soap *soap, const char *tag, struct tt__RecordingJobStateSource **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobStateSource **)soap_malloc(soap, sizeof(struct tt__RecordingJobStateSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobStateSource(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateSource, sizeof(struct tt__RecordingJobStateSource), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateSource(struct soap *soap, struct tt__RecordingJobStateSource *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingJobStateSource);
	if (soap_out_PointerTott__RecordingJobStateSource(soap, tag?tag:"tt:RecordingJobStateSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateSource ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateSource(struct soap *soap, struct tt__RecordingJobStateSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobSourceExtension(struct soap *soap, struct tt__RecordingJobSourceExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobSourceExtension))
		soap_serialize_tt__RecordingJobSourceExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobSourceExtension(struct soap *soap, const char *tag, int id, struct tt__RecordingJobSourceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobSourceExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobSourceExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobSourceExtension ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobSourceExtension(struct soap *soap, const char *tag, struct tt__RecordingJobSourceExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobSourceExtension **)soap_malloc(soap, sizeof(struct tt__RecordingJobSourceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobSourceExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobSourceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobSourceExtension, sizeof(struct tt__RecordingJobSourceExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobSourceExtension(struct soap *soap, struct tt__RecordingJobSourceExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingJobSourceExtension);
	if (soap_out_PointerTott__RecordingJobSourceExtension(soap, tag?tag:"tt:RecordingJobSourceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobSourceExtension ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobSourceExtension(struct soap *soap, struct tt__RecordingJobSourceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobTrack(struct soap *soap, struct tt__RecordingJobTrack *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobTrack))
		soap_serialize_tt__RecordingJobTrack(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobTrack(struct soap *soap, const char *tag, int id, struct tt__RecordingJobTrack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobTrack);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobTrack(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobTrack ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobTrack(struct soap *soap, const char *tag, struct tt__RecordingJobTrack **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobTrack **)soap_malloc(soap, sizeof(struct tt__RecordingJobTrack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobTrack(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobTrack, sizeof(struct tt__RecordingJobTrack), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobTrack(struct soap *soap, struct tt__RecordingJobTrack *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingJobTrack);
	if (soap_out_PointerTott__RecordingJobTrack(soap, tag?tag:"tt:RecordingJobTrack", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobTrack ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobTrack(struct soap *soap, struct tt__RecordingJobTrack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, struct tt__RecordingJobConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobConfigurationExtension))
		soap_serialize_tt__RecordingJobConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__RecordingJobConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, const char *tag, struct tt__RecordingJobConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__RecordingJobConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobConfigurationExtension, sizeof(struct tt__RecordingJobConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, struct tt__RecordingJobConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingJobConfigurationExtension);
	if (soap_out_PointerTott__RecordingJobConfigurationExtension(soap, tag?tag:"tt:RecordingJobConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, struct tt__RecordingJobConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobSource(struct soap *soap, struct tt__RecordingJobSource *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobSource))
		soap_serialize_tt__RecordingJobSource(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobSource(struct soap *soap, const char *tag, int id, struct tt__RecordingJobSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobSource);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobSource(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobSource ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobSource(struct soap *soap, const char *tag, struct tt__RecordingJobSource **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobSource **)soap_malloc(soap, sizeof(struct tt__RecordingJobSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobSource(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobSource, sizeof(struct tt__RecordingJobSource), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobSource(struct soap *soap, struct tt__RecordingJobSource *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingJobSource);
	if (soap_out_PointerTott__RecordingJobSource(soap, tag?tag:"tt:RecordingJobSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobSource ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobSource(struct soap *soap, struct tt__RecordingJobSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackConfiguration(struct soap *soap, struct tt__TrackConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackConfiguration))
		soap_serialize_tt__TrackConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackConfiguration(struct soap *soap, const char *tag, int id, struct tt__TrackConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TrackConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TrackConfiguration ** SOAP_FMAC4 soap_in_PointerTott__TrackConfiguration(struct soap *soap, const char *tag, struct tt__TrackConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TrackConfiguration **)soap_malloc(soap, sizeof(struct tt__TrackConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TrackConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TrackConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackConfiguration, sizeof(struct tt__TrackConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackConfiguration(struct soap *soap, struct tt__TrackConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__TrackConfiguration);
	if (soap_out_PointerTott__TrackConfiguration(soap, tag?tag:"tt:TrackConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackConfiguration ** SOAP_FMAC4 soap_get_PointerTott__TrackConfiguration(struct soap *soap, struct tt__TrackConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GetTracksResponseItem(struct soap *soap, struct tt__GetTracksResponseItem *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GetTracksResponseItem))
		soap_serialize_tt__GetTracksResponseItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GetTracksResponseItem(struct soap *soap, const char *tag, int id, struct tt__GetTracksResponseItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GetTracksResponseItem);
	if (id < 0)
		return soap->error;
	return soap_out_tt__GetTracksResponseItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__GetTracksResponseItem ** SOAP_FMAC4 soap_in_PointerTott__GetTracksResponseItem(struct soap *soap, const char *tag, struct tt__GetTracksResponseItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__GetTracksResponseItem **)soap_malloc(soap, sizeof(struct tt__GetTracksResponseItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__GetTracksResponseItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__GetTracksResponseItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GetTracksResponseItem, sizeof(struct tt__GetTracksResponseItem), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GetTracksResponseItem(struct soap *soap, struct tt__GetTracksResponseItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__GetTracksResponseItem);
	if (soap_out_PointerTott__GetTracksResponseItem(soap, tag?tag:"tt:GetTracksResponseItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetTracksResponseItem ** SOAP_FMAC4 soap_get_PointerTott__GetTracksResponseItem(struct soap *soap, struct tt__GetTracksResponseItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GetTracksResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GetTracksResponseList(struct soap *soap, struct tt__GetTracksResponseList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GetTracksResponseList))
		soap_serialize_tt__GetTracksResponseList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GetTracksResponseList(struct soap *soap, const char *tag, int id, struct tt__GetTracksResponseList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GetTracksResponseList);
	if (id < 0)
		return soap->error;
	return soap_out_tt__GetTracksResponseList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__GetTracksResponseList ** SOAP_FMAC4 soap_in_PointerTott__GetTracksResponseList(struct soap *soap, const char *tag, struct tt__GetTracksResponseList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__GetTracksResponseList **)soap_malloc(soap, sizeof(struct tt__GetTracksResponseList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__GetTracksResponseList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__GetTracksResponseList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GetTracksResponseList, sizeof(struct tt__GetTracksResponseList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GetTracksResponseList(struct soap *soap, struct tt__GetTracksResponseList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__GetTracksResponseList);
	if (soap_out_PointerTott__GetTracksResponseList(soap, tag?tag:"tt:GetTracksResponseList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetTracksResponseList ** SOAP_FMAC4 soap_get_PointerTott__GetTracksResponseList(struct soap *soap, struct tt__GetTracksResponseList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GetTracksResponseList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingConfiguration(struct soap *soap, struct tt__RecordingConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingConfiguration))
		soap_serialize_tt__RecordingConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingConfiguration(struct soap *soap, const char *tag, int id, struct tt__RecordingConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingConfiguration ** SOAP_FMAC4 soap_in_PointerTott__RecordingConfiguration(struct soap *soap, const char *tag, struct tt__RecordingConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingConfiguration **)soap_malloc(soap, sizeof(struct tt__RecordingConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingConfiguration, sizeof(struct tt__RecordingConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingConfiguration(struct soap *soap, struct tt__RecordingConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingConfiguration);
	if (soap_out_PointerTott__RecordingConfiguration(soap, tag?tag:"tt:RecordingConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingConfiguration ** SOAP_FMAC4 soap_get_PointerTott__RecordingConfiguration(struct soap *soap, struct tt__RecordingConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackAttributesExtension(struct soap *soap, struct tt__TrackAttributesExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackAttributesExtension))
		soap_serialize_tt__TrackAttributesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackAttributesExtension(struct soap *soap, const char *tag, int id, struct tt__TrackAttributesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackAttributesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TrackAttributesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TrackAttributesExtension ** SOAP_FMAC4 soap_in_PointerTott__TrackAttributesExtension(struct soap *soap, const char *tag, struct tt__TrackAttributesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TrackAttributesExtension **)soap_malloc(soap, sizeof(struct tt__TrackAttributesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TrackAttributesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TrackAttributesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackAttributesExtension, sizeof(struct tt__TrackAttributesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackAttributesExtension(struct soap *soap, struct tt__TrackAttributesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__TrackAttributesExtension);
	if (soap_out_PointerTott__TrackAttributesExtension(soap, tag?tag:"tt:TrackAttributesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackAttributesExtension ** SOAP_FMAC4 soap_get_PointerTott__TrackAttributesExtension(struct soap *soap, struct tt__TrackAttributesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackAttributesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataAttributes(struct soap *soap, struct tt__MetadataAttributes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataAttributes))
		soap_serialize_tt__MetadataAttributes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataAttributes(struct soap *soap, const char *tag, int id, struct tt__MetadataAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataAttributes);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataAttributes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataAttributes ** SOAP_FMAC4 soap_in_PointerTott__MetadataAttributes(struct soap *soap, const char *tag, struct tt__MetadataAttributes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataAttributes **)soap_malloc(soap, sizeof(struct tt__MetadataAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataAttributes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataAttributes, sizeof(struct tt__MetadataAttributes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataAttributes(struct soap *soap, struct tt__MetadataAttributes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MetadataAttributes);
	if (soap_out_PointerTott__MetadataAttributes(soap, tag?tag:"tt:MetadataAttributes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataAttributes ** SOAP_FMAC4 soap_get_PointerTott__MetadataAttributes(struct soap *soap, struct tt__MetadataAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioAttributes(struct soap *soap, struct tt__AudioAttributes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioAttributes))
		soap_serialize_tt__AudioAttributes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioAttributes(struct soap *soap, const char *tag, int id, struct tt__AudioAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioAttributes);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioAttributes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioAttributes ** SOAP_FMAC4 soap_in_PointerTott__AudioAttributes(struct soap *soap, const char *tag, struct tt__AudioAttributes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioAttributes **)soap_malloc(soap, sizeof(struct tt__AudioAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioAttributes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioAttributes, sizeof(struct tt__AudioAttributes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioAttributes(struct soap *soap, struct tt__AudioAttributes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioAttributes);
	if (soap_out_PointerTott__AudioAttributes(soap, tag?tag:"tt:AudioAttributes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioAttributes ** SOAP_FMAC4 soap_get_PointerTott__AudioAttributes(struct soap *soap, struct tt__AudioAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoAttributes(struct soap *soap, struct tt__VideoAttributes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoAttributes))
		soap_serialize_tt__VideoAttributes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoAttributes(struct soap *soap, const char *tag, int id, struct tt__VideoAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoAttributes);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoAttributes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoAttributes ** SOAP_FMAC4 soap_in_PointerTott__VideoAttributes(struct soap *soap, const char *tag, struct tt__VideoAttributes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoAttributes **)soap_malloc(soap, sizeof(struct tt__VideoAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoAttributes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoAttributes, sizeof(struct tt__VideoAttributes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoAttributes(struct soap *soap, struct tt__VideoAttributes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoAttributes);
	if (soap_out_PointerTott__VideoAttributes(soap, tag?tag:"tt:VideoAttributes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAttributes ** SOAP_FMAC4 soap_get_PointerTott__VideoAttributes(struct soap *soap, struct tt__VideoAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackAttributes(struct soap *soap, struct tt__TrackAttributes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackAttributes))
		soap_serialize_tt__TrackAttributes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackAttributes(struct soap *soap, const char *tag, int id, struct tt__TrackAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackAttributes);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TrackAttributes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TrackAttributes ** SOAP_FMAC4 soap_in_PointerTott__TrackAttributes(struct soap *soap, const char *tag, struct tt__TrackAttributes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TrackAttributes **)soap_malloc(soap, sizeof(struct tt__TrackAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TrackAttributes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TrackAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackAttributes, sizeof(struct tt__TrackAttributes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackAttributes(struct soap *soap, struct tt__TrackAttributes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__TrackAttributes);
	if (soap_out_PointerTott__TrackAttributes(soap, tag?tag:"tt:TrackAttributes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackAttributes ** SOAP_FMAC4 soap_get_PointerTott__TrackAttributes(struct soap *soap, struct tt__TrackAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackInformation(struct soap *soap, struct tt__TrackInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackInformation))
		soap_serialize_tt__TrackInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackInformation(struct soap *soap, const char *tag, int id, struct tt__TrackInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackInformation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TrackInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TrackInformation ** SOAP_FMAC4 soap_in_PointerTott__TrackInformation(struct soap *soap, const char *tag, struct tt__TrackInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TrackInformation **)soap_malloc(soap, sizeof(struct tt__TrackInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TrackInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TrackInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackInformation, sizeof(struct tt__TrackInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackInformation(struct soap *soap, struct tt__TrackInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__TrackInformation);
	if (soap_out_PointerTott__TrackInformation(soap, tag?tag:"tt:TrackInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TrackInformation ** SOAP_FMAC4 soap_get_PointerTott__TrackInformation(struct soap *soap, struct tt__TrackInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotime(struct soap *soap, time_t *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_time);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotime(struct soap *soap, const char *tag, int id, time_t *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_time);
	if (id < 0)
		return soap->error;
	return soap_out_time(soap, tag, id, *a, type);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_in_PointerTotime(struct soap *soap, const char *tag, time_t **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (time_t **)soap_malloc(soap, sizeof(time_t *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (time_t **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_time, sizeof(time_t), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotime(struct soap *soap, time_t *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotime);
	if (soap_out_PointerTotime(soap, tag?tag:"dateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 time_t ** SOAP_FMAC4 soap_get_PointerTotime(struct soap *soap, time_t **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingSourceInformation(struct soap *soap, struct tt__RecordingSourceInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingSourceInformation))
		soap_serialize_tt__RecordingSourceInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingSourceInformation(struct soap *soap, const char *tag, int id, struct tt__RecordingSourceInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingSourceInformation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingSourceInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingSourceInformation ** SOAP_FMAC4 soap_in_PointerTott__RecordingSourceInformation(struct soap *soap, const char *tag, struct tt__RecordingSourceInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingSourceInformation **)soap_malloc(soap, sizeof(struct tt__RecordingSourceInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingSourceInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingSourceInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingSourceInformation, sizeof(struct tt__RecordingSourceInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingSourceInformation(struct soap *soap, struct tt__RecordingSourceInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingSourceInformation);
	if (soap_out_PointerTott__RecordingSourceInformation(soap, tag?tag:"tt:RecordingSourceInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingSourceInformation ** SOAP_FMAC4 soap_get_PointerTott__RecordingSourceInformation(struct soap *soap, struct tt__RecordingSourceInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingSourceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindMetadataResult(struct soap *soap, struct tt__FindMetadataResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindMetadataResult))
		soap_serialize_tt__FindMetadataResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindMetadataResult(struct soap *soap, const char *tag, int id, struct tt__FindMetadataResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindMetadataResult);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FindMetadataResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FindMetadataResult ** SOAP_FMAC4 soap_in_PointerTott__FindMetadataResult(struct soap *soap, const char *tag, struct tt__FindMetadataResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FindMetadataResult **)soap_malloc(soap, sizeof(struct tt__FindMetadataResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FindMetadataResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FindMetadataResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindMetadataResult, sizeof(struct tt__FindMetadataResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindMetadataResult(struct soap *soap, struct tt__FindMetadataResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FindMetadataResult);
	if (soap_out_PointerTott__FindMetadataResult(soap, tag?tag:"tt:FindMetadataResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindMetadataResult ** SOAP_FMAC4 soap_get_PointerTott__FindMetadataResult(struct soap *soap, struct tt__FindMetadataResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindMetadataResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindPTZPositionResult(struct soap *soap, struct tt__FindPTZPositionResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindPTZPositionResult))
		soap_serialize_tt__FindPTZPositionResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindPTZPositionResult(struct soap *soap, const char *tag, int id, struct tt__FindPTZPositionResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindPTZPositionResult);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FindPTZPositionResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FindPTZPositionResult ** SOAP_FMAC4 soap_in_PointerTott__FindPTZPositionResult(struct soap *soap, const char *tag, struct tt__FindPTZPositionResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FindPTZPositionResult **)soap_malloc(soap, sizeof(struct tt__FindPTZPositionResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FindPTZPositionResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FindPTZPositionResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindPTZPositionResult, sizeof(struct tt__FindPTZPositionResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindPTZPositionResult(struct soap *soap, struct tt__FindPTZPositionResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FindPTZPositionResult);
	if (soap_out_PointerTott__FindPTZPositionResult(soap, tag?tag:"tt:FindPTZPositionResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindPTZPositionResult ** SOAP_FMAC4 soap_get_PointerTott__FindPTZPositionResult(struct soap *soap, struct tt__FindPTZPositionResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindPTZPositionResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindEventResult(struct soap *soap, struct tt__FindEventResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindEventResult))
		soap_serialize_tt__FindEventResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindEventResult(struct soap *soap, const char *tag, int id, struct tt__FindEventResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindEventResult);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FindEventResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FindEventResult ** SOAP_FMAC4 soap_in_PointerTott__FindEventResult(struct soap *soap, const char *tag, struct tt__FindEventResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FindEventResult **)soap_malloc(soap, sizeof(struct tt__FindEventResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FindEventResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FindEventResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindEventResult, sizeof(struct tt__FindEventResult), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindEventResult(struct soap *soap, struct tt__FindEventResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FindEventResult);
	if (soap_out_PointerTott__FindEventResult(soap, tag?tag:"tt:FindEventResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindEventResult ** SOAP_FMAC4 soap_get_PointerTott__FindEventResult(struct soap *soap, struct tt__FindEventResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindEventResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingInformation(struct soap *soap, struct tt__RecordingInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingInformation))
		soap_serialize_tt__RecordingInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingInformation(struct soap *soap, const char *tag, int id, struct tt__RecordingInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingInformation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingInformation ** SOAP_FMAC4 soap_in_PointerTott__RecordingInformation(struct soap *soap, const char *tag, struct tt__RecordingInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingInformation **)soap_malloc(soap, sizeof(struct tt__RecordingInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingInformation, sizeof(struct tt__RecordingInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingInformation(struct soap *soap, struct tt__RecordingInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingInformation);
	if (soap_out_PointerTott__RecordingInformation(soap, tag?tag:"tt:RecordingInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingInformation ** SOAP_FMAC4 soap_get_PointerTott__RecordingInformation(struct soap *soap, struct tt__RecordingInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SearchScopeExtension(struct soap *soap, struct tt__SearchScopeExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SearchScopeExtension))
		soap_serialize_tt__SearchScopeExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SearchScopeExtension(struct soap *soap, const char *tag, int id, struct tt__SearchScopeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SearchScopeExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SearchScopeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SearchScopeExtension ** SOAP_FMAC4 soap_in_PointerTott__SearchScopeExtension(struct soap *soap, const char *tag, struct tt__SearchScopeExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SearchScopeExtension **)soap_malloc(soap, sizeof(struct tt__SearchScopeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SearchScopeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SearchScopeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SearchScopeExtension, sizeof(struct tt__SearchScopeExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SearchScopeExtension(struct soap *soap, struct tt__SearchScopeExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SearchScopeExtension);
	if (soap_out_PointerTott__SearchScopeExtension(soap, tag?tag:"tt:SearchScopeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SearchScopeExtension ** SOAP_FMAC4 soap_get_PointerTott__SearchScopeExtension(struct soap *soap, struct tt__SearchScopeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SearchScopeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingReference(struct soap *soap, char **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingReference))
		soap_serialize_tt__RecordingReference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingReference(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingReference);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTott__RecordingReference(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingReference, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingReference(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingReference);
	if (soap_out_PointerTott__RecordingReference(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTott__RecordingReference(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SourceReference(struct soap *soap, struct tt__SourceReference *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SourceReference))
		soap_serialize_tt__SourceReference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SourceReference(struct soap *soap, const char *tag, int id, struct tt__SourceReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SourceReference);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SourceReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SourceReference ** SOAP_FMAC4 soap_in_PointerTott__SourceReference(struct soap *soap, const char *tag, struct tt__SourceReference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SourceReference **)soap_malloc(soap, sizeof(struct tt__SourceReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SourceReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SourceReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SourceReference, sizeof(struct tt__SourceReference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SourceReference(struct soap *soap, struct tt__SourceReference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SourceReference);
	if (soap_out_PointerTott__SourceReference(soap, tag?tag:"tt:SourceReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceReference ** SOAP_FMAC4 soap_get_PointerTott__SourceReference(struct soap *soap, struct tt__SourceReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SourceReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__StreamSetup(struct soap *soap, struct tt__StreamSetup *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__StreamSetup))
		soap_serialize_tt__StreamSetup(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__StreamSetup(struct soap *soap, const char *tag, int id, struct tt__StreamSetup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__StreamSetup);
	if (id < 0)
		return soap->error;
	return soap_out_tt__StreamSetup(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__StreamSetup ** SOAP_FMAC4 soap_in_PointerTott__StreamSetup(struct soap *soap, const char *tag, struct tt__StreamSetup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__StreamSetup **)soap_malloc(soap, sizeof(struct tt__StreamSetup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__StreamSetup(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__StreamSetup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__StreamSetup, sizeof(struct tt__StreamSetup), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__StreamSetup(struct soap *soap, struct tt__StreamSetup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__StreamSetup);
	if (soap_out_PointerTott__StreamSetup(soap, tag?tag:"tt:StreamSetup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__StreamSetup ** SOAP_FMAC4 soap_get_PointerTott__StreamSetup(struct soap *soap, struct tt__StreamSetup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__StreamSetup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReceiverConfiguration(struct soap *soap, struct tt__ReceiverConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReceiverConfiguration))
		soap_serialize_tt__ReceiverConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReceiverConfiguration(struct soap *soap, const char *tag, int id, struct tt__ReceiverConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReceiverConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReceiverConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ReceiverConfiguration ** SOAP_FMAC4 soap_in_PointerTott__ReceiverConfiguration(struct soap *soap, const char *tag, struct tt__ReceiverConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ReceiverConfiguration **)soap_malloc(soap, sizeof(struct tt__ReceiverConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReceiverConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ReceiverConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReceiverConfiguration, sizeof(struct tt__ReceiverConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReceiverConfiguration(struct soap *soap, struct tt__ReceiverConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ReceiverConfiguration);
	if (soap_out_PointerTott__ReceiverConfiguration(soap, tag?tag:"tt:ReceiverConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReceiverConfiguration ** SOAP_FMAC4 soap_get_PointerTott__ReceiverConfiguration(struct soap *soap, struct tt__ReceiverConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReceiverConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PaneOptionExtension(struct soap *soap, struct tt__PaneOptionExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PaneOptionExtension))
		soap_serialize_tt__PaneOptionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PaneOptionExtension(struct soap *soap, const char *tag, int id, struct tt__PaneOptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PaneOptionExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PaneOptionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PaneOptionExtension ** SOAP_FMAC4 soap_in_PointerTott__PaneOptionExtension(struct soap *soap, const char *tag, struct tt__PaneOptionExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PaneOptionExtension **)soap_malloc(soap, sizeof(struct tt__PaneOptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PaneOptionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PaneOptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PaneOptionExtension, sizeof(struct tt__PaneOptionExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PaneOptionExtension(struct soap *soap, struct tt__PaneOptionExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PaneOptionExtension);
	if (soap_out_PointerTott__PaneOptionExtension(soap, tag?tag:"tt:PaneOptionExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneOptionExtension ** SOAP_FMAC4 soap_get_PointerTott__PaneOptionExtension(struct soap *soap, struct tt__PaneOptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PaneOptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LayoutOptionsExtension(struct soap *soap, struct tt__LayoutOptionsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LayoutOptionsExtension))
		soap_serialize_tt__LayoutOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LayoutOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__LayoutOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LayoutOptionsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LayoutOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LayoutOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__LayoutOptionsExtension(struct soap *soap, const char *tag, struct tt__LayoutOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LayoutOptionsExtension **)soap_malloc(soap, sizeof(struct tt__LayoutOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LayoutOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LayoutOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LayoutOptionsExtension, sizeof(struct tt__LayoutOptionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LayoutOptionsExtension(struct soap *soap, struct tt__LayoutOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__LayoutOptionsExtension);
	if (soap_out_PointerTott__LayoutOptionsExtension(soap, tag?tag:"tt:LayoutOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LayoutOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__LayoutOptionsExtension(struct soap *soap, struct tt__LayoutOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LayoutOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PaneLayoutOptions(struct soap *soap, struct tt__PaneLayoutOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PaneLayoutOptions))
		soap_serialize_tt__PaneLayoutOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PaneLayoutOptions(struct soap *soap, const char *tag, int id, struct tt__PaneLayoutOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PaneLayoutOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PaneLayoutOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PaneLayoutOptions ** SOAP_FMAC4 soap_in_PointerTott__PaneLayoutOptions(struct soap *soap, const char *tag, struct tt__PaneLayoutOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PaneLayoutOptions **)soap_malloc(soap, sizeof(struct tt__PaneLayoutOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PaneLayoutOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PaneLayoutOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PaneLayoutOptions, sizeof(struct tt__PaneLayoutOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PaneLayoutOptions(struct soap *soap, struct tt__PaneLayoutOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PaneLayoutOptions);
	if (soap_out_PointerTott__PaneLayoutOptions(soap, tag?tag:"tt:PaneLayoutOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneLayoutOptions ** SOAP_FMAC4 soap_get_PointerTott__PaneLayoutOptions(struct soap *soap, struct tt__PaneLayoutOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PaneLayoutOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, struct tt__VideoDecoderConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoDecoderConfigurationOptions))
		soap_serialize_tt__VideoDecoderConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__VideoDecoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoDecoderConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoDecoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoDecoderConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoDecoderConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__VideoDecoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoDecoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoDecoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoDecoderConfigurationOptions, sizeof(struct tt__VideoDecoderConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, struct tt__VideoDecoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoDecoderConfigurationOptions);
	if (soap_out_PointerTott__VideoDecoderConfigurationOptions(soap, tag?tag:"tt:VideoDecoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__VideoDecoderConfigurationOptions(struct soap *soap, struct tt__VideoDecoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, struct tt__AudioDecoderConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions))
		soap_serialize_tt__AudioDecoderConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__AudioDecoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioDecoderConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioDecoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioDecoderConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioDecoderConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__AudioDecoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioDecoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioDecoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioDecoderConfigurationOptions, sizeof(struct tt__AudioDecoderConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, struct tt__AudioDecoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioDecoderConfigurationOptions);
	if (soap_out_PointerTott__AudioDecoderConfigurationOptions(soap, tag?tag:"tt:AudioDecoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioDecoderConfigurationOptions(struct soap *soap, struct tt__AudioDecoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, struct tt__AudioEncoderConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions))
		soap_serialize_tt__AudioEncoderConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__AudioEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioEncoderConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioEncoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioEncoderConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioEncoderConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__AudioEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioEncoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, sizeof(struct tt__AudioEncoderConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, struct tt__AudioEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioEncoderConfigurationOptions);
	if (soap_out_PointerTott__AudioEncoderConfigurationOptions(soap, tag?tag:"tt:AudioEncoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioEncoderConfigurationOptions(struct soap *soap, struct tt__AudioEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LayoutExtension(struct soap *soap, struct tt__LayoutExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LayoutExtension))
		soap_serialize_tt__LayoutExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LayoutExtension(struct soap *soap, const char *tag, int id, struct tt__LayoutExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LayoutExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LayoutExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LayoutExtension ** SOAP_FMAC4 soap_in_PointerTott__LayoutExtension(struct soap *soap, const char *tag, struct tt__LayoutExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LayoutExtension **)soap_malloc(soap, sizeof(struct tt__LayoutExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LayoutExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LayoutExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LayoutExtension, sizeof(struct tt__LayoutExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LayoutExtension(struct soap *soap, struct tt__LayoutExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__LayoutExtension);
	if (soap_out_PointerTott__LayoutExtension(soap, tag?tag:"tt:LayoutExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LayoutExtension ** SOAP_FMAC4 soap_get_PointerTott__LayoutExtension(struct soap *soap, struct tt__LayoutExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LayoutExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PaneLayout(struct soap *soap, struct tt__PaneLayout *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PaneLayout))
		soap_serialize_tt__PaneLayout(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PaneLayout(struct soap *soap, const char *tag, int id, struct tt__PaneLayout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PaneLayout);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PaneLayout(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PaneLayout ** SOAP_FMAC4 soap_in_PointerTott__PaneLayout(struct soap *soap, const char *tag, struct tt__PaneLayout **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PaneLayout **)soap_malloc(soap, sizeof(struct tt__PaneLayout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PaneLayout(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PaneLayout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PaneLayout, sizeof(struct tt__PaneLayout), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PaneLayout(struct soap *soap, struct tt__PaneLayout *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PaneLayout);
	if (soap_out_PointerTott__PaneLayout(soap, tag?tag:"tt:PaneLayout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneLayout ** SOAP_FMAC4 soap_get_PointerTott__PaneLayout(struct soap *soap, struct tt__PaneLayout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PaneLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__tt__union_EventStream(struct soap *soap, struct __tt__union_EventStream *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___tt__union_EventStream))
		soap_serialize___tt__union_EventStream(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__tt__union_EventStream(struct soap *soap, const char *tag, int id, struct __tt__union_EventStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___tt__union_EventStream);
	if (id < 0)
		return soap->error;
	return soap_out___tt__union_EventStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __tt__union_EventStream ** SOAP_FMAC4 soap_in_PointerTo__tt__union_EventStream(struct soap *soap, const char *tag, struct __tt__union_EventStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __tt__union_EventStream **)soap_malloc(soap, sizeof(struct __tt__union_EventStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___tt__union_EventStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __tt__union_EventStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___tt__union_EventStream, sizeof(struct __tt__union_EventStream), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__tt__union_EventStream(struct soap *soap, struct __tt__union_EventStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__tt__union_EventStream);
	if (soap_out_PointerTo__tt__union_EventStream(soap, tag?tag:"-tt:union-EventStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __tt__union_EventStream ** SOAP_FMAC4 soap_get_PointerTo__tt__union_EventStream(struct soap *soap, struct __tt__union_EventStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__tt__union_EventStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventStreamExtension(struct soap *soap, struct tt__EventStreamExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventStreamExtension))
		soap_serialize_tt__EventStreamExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventStreamExtension(struct soap *soap, const char *tag, int id, struct tt__EventStreamExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventStreamExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EventStreamExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EventStreamExtension ** SOAP_FMAC4 soap_in_PointerTott__EventStreamExtension(struct soap *soap, const char *tag, struct tt__EventStreamExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EventStreamExtension **)soap_malloc(soap, sizeof(struct tt__EventStreamExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EventStreamExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EventStreamExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventStreamExtension, sizeof(struct tt__EventStreamExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventStreamExtension(struct soap *soap, struct tt__EventStreamExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__EventStreamExtension);
	if (soap_out_PointerTott__EventStreamExtension(soap, tag?tag:"tt:EventStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventStreamExtension ** SOAP_FMAC4 soap_get_PointerTott__EventStreamExtension(struct soap *soap, struct tt__EventStreamExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__NotificationMessageHolderType))
		soap_serialize_wsnt__NotificationMessageHolderType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, struct wsnt__NotificationMessageHolderType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__NotificationMessageHolderType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__NotificationMessageHolderType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_in_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, struct wsnt__NotificationMessageHolderType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__NotificationMessageHolderType **)soap_malloc(soap, sizeof(struct wsnt__NotificationMessageHolderType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__NotificationMessageHolderType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__NotificationMessageHolderType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NotificationMessageHolderType, sizeof(struct wsnt__NotificationMessageHolderType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType);
	if (soap_out_PointerTowsnt__NotificationMessageHolderType(soap, tag?tag:"wsnt:NotificationMessageHolderType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NotificationMessageHolderType ** SOAP_FMAC4 soap_get_PointerTowsnt__NotificationMessageHolderType(struct soap *soap, struct wsnt__NotificationMessageHolderType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__tt__union_PTZStream(struct soap *soap, struct __tt__union_PTZStream *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___tt__union_PTZStream))
		soap_serialize___tt__union_PTZStream(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__tt__union_PTZStream(struct soap *soap, const char *tag, int id, struct __tt__union_PTZStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___tt__union_PTZStream);
	if (id < 0)
		return soap->error;
	return soap_out___tt__union_PTZStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __tt__union_PTZStream ** SOAP_FMAC4 soap_in_PointerTo__tt__union_PTZStream(struct soap *soap, const char *tag, struct __tt__union_PTZStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __tt__union_PTZStream **)soap_malloc(soap, sizeof(struct __tt__union_PTZStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___tt__union_PTZStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __tt__union_PTZStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___tt__union_PTZStream, sizeof(struct __tt__union_PTZStream), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__tt__union_PTZStream(struct soap *soap, struct __tt__union_PTZStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__tt__union_PTZStream);
	if (soap_out_PointerTo__tt__union_PTZStream(soap, tag?tag:"-tt:union-PTZStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __tt__union_PTZStream ** SOAP_FMAC4 soap_get_PointerTo__tt__union_PTZStream(struct soap *soap, struct __tt__union_PTZStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__tt__union_PTZStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZStreamExtension(struct soap *soap, struct tt__PTZStreamExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZStreamExtension))
		soap_serialize_tt__PTZStreamExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZStreamExtension(struct soap *soap, const char *tag, int id, struct tt__PTZStreamExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZStreamExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZStreamExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZStreamExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZStreamExtension(struct soap *soap, const char *tag, struct tt__PTZStreamExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZStreamExtension **)soap_malloc(soap, sizeof(struct tt__PTZStreamExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZStreamExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStreamExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStreamExtension, sizeof(struct tt__PTZStreamExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZStreamExtension(struct soap *soap, struct tt__PTZStreamExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZStreamExtension);
	if (soap_out_PointerTott__PTZStreamExtension(soap, tag?tag:"tt:PTZStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStreamExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZStreamExtension(struct soap *soap, struct tt__PTZStreamExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__tt__union_VideoAnalyticsStream(struct soap *soap, struct __tt__union_VideoAnalyticsStream *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___tt__union_VideoAnalyticsStream))
		soap_serialize___tt__union_VideoAnalyticsStream(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__tt__union_VideoAnalyticsStream(struct soap *soap, const char *tag, int id, struct __tt__union_VideoAnalyticsStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___tt__union_VideoAnalyticsStream);
	if (id < 0)
		return soap->error;
	return soap_out___tt__union_VideoAnalyticsStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __tt__union_VideoAnalyticsStream ** SOAP_FMAC4 soap_in_PointerTo__tt__union_VideoAnalyticsStream(struct soap *soap, const char *tag, struct __tt__union_VideoAnalyticsStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __tt__union_VideoAnalyticsStream **)soap_malloc(soap, sizeof(struct __tt__union_VideoAnalyticsStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___tt__union_VideoAnalyticsStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __tt__union_VideoAnalyticsStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___tt__union_VideoAnalyticsStream, sizeof(struct __tt__union_VideoAnalyticsStream), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__tt__union_VideoAnalyticsStream(struct soap *soap, struct __tt__union_VideoAnalyticsStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__tt__union_VideoAnalyticsStream);
	if (soap_out_PointerTo__tt__union_VideoAnalyticsStream(soap, tag?tag:"-tt:union-VideoAnalyticsStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __tt__union_VideoAnalyticsStream ** SOAP_FMAC4 soap_get_PointerTo__tt__union_VideoAnalyticsStream(struct soap *soap, struct __tt__union_VideoAnalyticsStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__tt__union_VideoAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoAnalyticsStreamExtension(struct soap *soap, struct tt__VideoAnalyticsStreamExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoAnalyticsStreamExtension))
		soap_serialize_tt__VideoAnalyticsStreamExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoAnalyticsStreamExtension(struct soap *soap, const char *tag, int id, struct tt__VideoAnalyticsStreamExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoAnalyticsStreamExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoAnalyticsStreamExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStreamExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoAnalyticsStreamExtension(struct soap *soap, const char *tag, struct tt__VideoAnalyticsStreamExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoAnalyticsStreamExtension **)soap_malloc(soap, sizeof(struct tt__VideoAnalyticsStreamExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoAnalyticsStreamExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoAnalyticsStreamExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoAnalyticsStreamExtension, sizeof(struct tt__VideoAnalyticsStreamExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoAnalyticsStreamExtension(struct soap *soap, struct tt__VideoAnalyticsStreamExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoAnalyticsStreamExtension);
	if (soap_out_PointerTott__VideoAnalyticsStreamExtension(soap, tag?tag:"tt:VideoAnalyticsStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStreamExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoAnalyticsStreamExtension(struct soap *soap, struct tt__VideoAnalyticsStreamExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoAnalyticsStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Frame(struct soap *soap, struct tt__Frame *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Frame))
		soap_serialize_tt__Frame(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Frame(struct soap *soap, const char *tag, int id, struct tt__Frame *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Frame);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Frame(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Frame ** SOAP_FMAC4 soap_in_PointerTott__Frame(struct soap *soap, const char *tag, struct tt__Frame **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Frame **)soap_malloc(soap, sizeof(struct tt__Frame *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Frame(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Frame **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Frame, sizeof(struct tt__Frame), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Frame(struct soap *soap, struct tt__Frame *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Frame);
	if (soap_out_PointerTott__Frame(soap, tag?tag:"tt:Frame", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Frame ** SOAP_FMAC4 soap_get_PointerTott__Frame(struct soap *soap, struct tt__Frame **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Frame(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__tt__union_MetadataStream(struct soap *soap, struct __tt__union_MetadataStream *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___tt__union_MetadataStream))
		soap_serialize___tt__union_MetadataStream(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__tt__union_MetadataStream(struct soap *soap, const char *tag, int id, struct __tt__union_MetadataStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___tt__union_MetadataStream);
	if (id < 0)
		return soap->error;
	return soap_out___tt__union_MetadataStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __tt__union_MetadataStream ** SOAP_FMAC4 soap_in_PointerTo__tt__union_MetadataStream(struct soap *soap, const char *tag, struct __tt__union_MetadataStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __tt__union_MetadataStream **)soap_malloc(soap, sizeof(struct __tt__union_MetadataStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___tt__union_MetadataStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __tt__union_MetadataStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___tt__union_MetadataStream, sizeof(struct __tt__union_MetadataStream), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__tt__union_MetadataStream(struct soap *soap, struct __tt__union_MetadataStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__tt__union_MetadataStream);
	if (soap_out_PointerTo__tt__union_MetadataStream(soap, tag?tag:"-tt:union-MetadataStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __tt__union_MetadataStream ** SOAP_FMAC4 soap_get_PointerTo__tt__union_MetadataStream(struct soap *soap, struct __tt__union_MetadataStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__tt__union_MetadataStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataStreamExtension(struct soap *soap, struct tt__MetadataStreamExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataStreamExtension))
		soap_serialize_tt__MetadataStreamExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataStreamExtension(struct soap *soap, const char *tag, int id, struct tt__MetadataStreamExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataStreamExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataStreamExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataStreamExtension ** SOAP_FMAC4 soap_in_PointerTott__MetadataStreamExtension(struct soap *soap, const char *tag, struct tt__MetadataStreamExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataStreamExtension **)soap_malloc(soap, sizeof(struct tt__MetadataStreamExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataStreamExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataStreamExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataStreamExtension, sizeof(struct tt__MetadataStreamExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataStreamExtension(struct soap *soap, struct tt__MetadataStreamExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MetadataStreamExtension);
	if (soap_out_PointerTott__MetadataStreamExtension(soap, tag?tag:"tt:MetadataStreamExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataStreamExtension ** SOAP_FMAC4 soap_get_PointerTott__MetadataStreamExtension(struct soap *soap, struct tt__MetadataStreamExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataStreamExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventStream(struct soap *soap, struct tt__EventStream *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventStream))
		soap_serialize_tt__EventStream(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventStream(struct soap *soap, const char *tag, int id, struct tt__EventStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventStream);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EventStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EventStream ** SOAP_FMAC4 soap_in_PointerTott__EventStream(struct soap *soap, const char *tag, struct tt__EventStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EventStream **)soap_malloc(soap, sizeof(struct tt__EventStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EventStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EventStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventStream, sizeof(struct tt__EventStream), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventStream(struct soap *soap, struct tt__EventStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__EventStream);
	if (soap_out_PointerTott__EventStream(soap, tag?tag:"tt:EventStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventStream ** SOAP_FMAC4 soap_get_PointerTott__EventStream(struct soap *soap, struct tt__EventStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZStream(struct soap *soap, struct tt__PTZStream *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZStream))
		soap_serialize_tt__PTZStream(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZStream(struct soap *soap, const char *tag, int id, struct tt__PTZStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZStream);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZStream ** SOAP_FMAC4 soap_in_PointerTott__PTZStream(struct soap *soap, const char *tag, struct tt__PTZStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZStream **)soap_malloc(soap, sizeof(struct tt__PTZStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStream, sizeof(struct tt__PTZStream), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZStream(struct soap *soap, struct tt__PTZStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZStream);
	if (soap_out_PointerTott__PTZStream(soap, tag?tag:"tt:PTZStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStream ** SOAP_FMAC4 soap_get_PointerTott__PTZStream(struct soap *soap, struct tt__PTZStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoAnalyticsStream(struct soap *soap, struct tt__VideoAnalyticsStream *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoAnalyticsStream))
		soap_serialize_tt__VideoAnalyticsStream(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoAnalyticsStream(struct soap *soap, const char *tag, int id, struct tt__VideoAnalyticsStream *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoAnalyticsStream);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoAnalyticsStream(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStream ** SOAP_FMAC4 soap_in_PointerTott__VideoAnalyticsStream(struct soap *soap, const char *tag, struct tt__VideoAnalyticsStream **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoAnalyticsStream **)soap_malloc(soap, sizeof(struct tt__VideoAnalyticsStream *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoAnalyticsStream(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoAnalyticsStream **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoAnalyticsStream, sizeof(struct tt__VideoAnalyticsStream), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoAnalyticsStream(struct soap *soap, struct tt__VideoAnalyticsStream *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoAnalyticsStream);
	if (soap_out_PointerTott__VideoAnalyticsStream(soap, tag?tag:"tt:VideoAnalyticsStream", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAnalyticsStream ** SOAP_FMAC4 soap_get_PointerTott__VideoAnalyticsStream(struct soap *soap, struct tt__VideoAnalyticsStream **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoAnalyticsStream(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MotionExpression(struct soap *soap, struct tt__MotionExpression *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MotionExpression))
		soap_serialize_tt__MotionExpression(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MotionExpression(struct soap *soap, const char *tag, int id, struct tt__MotionExpression *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MotionExpression);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MotionExpression(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MotionExpression ** SOAP_FMAC4 soap_in_PointerTott__MotionExpression(struct soap *soap, const char *tag, struct tt__MotionExpression **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MotionExpression **)soap_malloc(soap, sizeof(struct tt__MotionExpression *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MotionExpression(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MotionExpression **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MotionExpression, sizeof(struct tt__MotionExpression), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MotionExpression(struct soap *soap, struct tt__MotionExpression *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MotionExpression);
	if (soap_out_PointerTott__MotionExpression(soap, tag?tag:"tt:MotionExpression", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MotionExpression ** SOAP_FMAC4 soap_get_PointerTott__MotionExpression(struct soap *soap, struct tt__MotionExpression **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MotionExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PolylineArray(struct soap *soap, struct tt__PolylineArray *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PolylineArray))
		soap_serialize_tt__PolylineArray(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PolylineArray(struct soap *soap, const char *tag, int id, struct tt__PolylineArray *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PolylineArray);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PolylineArray(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PolylineArray ** SOAP_FMAC4 soap_in_PointerTott__PolylineArray(struct soap *soap, const char *tag, struct tt__PolylineArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PolylineArray **)soap_malloc(soap, sizeof(struct tt__PolylineArray *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PolylineArray(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PolylineArray **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PolylineArray, sizeof(struct tt__PolylineArray), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PolylineArray(struct soap *soap, struct tt__PolylineArray *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PolylineArray);
	if (soap_out_PointerTott__PolylineArray(soap, tag?tag:"tt:PolylineArray", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PolylineArray ** SOAP_FMAC4 soap_get_PointerTott__PolylineArray(struct soap *soap, struct tt__PolylineArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PolylineArray(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PolylineArrayExtension(struct soap *soap, struct tt__PolylineArrayExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PolylineArrayExtension))
		soap_serialize_tt__PolylineArrayExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PolylineArrayExtension(struct soap *soap, const char *tag, int id, struct tt__PolylineArrayExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PolylineArrayExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PolylineArrayExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PolylineArrayExtension ** SOAP_FMAC4 soap_in_PointerTott__PolylineArrayExtension(struct soap *soap, const char *tag, struct tt__PolylineArrayExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PolylineArrayExtension **)soap_malloc(soap, sizeof(struct tt__PolylineArrayExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PolylineArrayExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PolylineArrayExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PolylineArrayExtension, sizeof(struct tt__PolylineArrayExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PolylineArrayExtension(struct soap *soap, struct tt__PolylineArrayExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PolylineArrayExtension);
	if (soap_out_PointerTott__PolylineArrayExtension(soap, tag?tag:"tt:PolylineArrayExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PolylineArrayExtension ** SOAP_FMAC4 soap_get_PointerTott__PolylineArrayExtension(struct soap *soap, struct tt__PolylineArrayExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PolylineArrayExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Polyline(struct soap *soap, struct tt__Polyline *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Polyline))
		soap_serialize_tt__Polyline(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Polyline(struct soap *soap, const char *tag, int id, struct tt__Polyline *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Polyline);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Polyline(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Polyline ** SOAP_FMAC4 soap_in_PointerTott__Polyline(struct soap *soap, const char *tag, struct tt__Polyline **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Polyline **)soap_malloc(soap, sizeof(struct tt__Polyline *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Polyline(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Polyline **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Polyline, sizeof(struct tt__Polyline), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Polyline(struct soap *soap, struct tt__Polyline *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Polyline);
	if (soap_out_PointerTott__Polyline(soap, tag?tag:"tt:Polyline", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Polyline ** SOAP_FMAC4 soap_get_PointerTott__Polyline(struct soap *soap, struct tt__Polyline **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Polyline(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, struct tt__SupportedAnalyticsModulesExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension))
		soap_serialize_tt__SupportedAnalyticsModulesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, int id, struct tt__SupportedAnalyticsModulesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SupportedAnalyticsModulesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModulesExtension ** SOAP_FMAC4 soap_in_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, const char *tag, struct tt__SupportedAnalyticsModulesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SupportedAnalyticsModulesExtension **)soap_malloc(soap, sizeof(struct tt__SupportedAnalyticsModulesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SupportedAnalyticsModulesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedAnalyticsModulesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedAnalyticsModulesExtension, sizeof(struct tt__SupportedAnalyticsModulesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, struct tt__SupportedAnalyticsModulesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SupportedAnalyticsModulesExtension);
	if (soap_out_PointerTott__SupportedAnalyticsModulesExtension(soap, tag?tag:"tt:SupportedAnalyticsModulesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedAnalyticsModulesExtension ** SOAP_FMAC4 soap_get_PointerTott__SupportedAnalyticsModulesExtension(struct soap *soap, struct tt__SupportedAnalyticsModulesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportedAnalyticsModulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportedRulesExtension(struct soap *soap, struct tt__SupportedRulesExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportedRulesExtension))
		soap_serialize_tt__SupportedRulesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportedRulesExtension(struct soap *soap, const char *tag, int id, struct tt__SupportedRulesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportedRulesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SupportedRulesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SupportedRulesExtension ** SOAP_FMAC4 soap_in_PointerTott__SupportedRulesExtension(struct soap *soap, const char *tag, struct tt__SupportedRulesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SupportedRulesExtension **)soap_malloc(soap, sizeof(struct tt__SupportedRulesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SupportedRulesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SupportedRulesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportedRulesExtension, sizeof(struct tt__SupportedRulesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportedRulesExtension(struct soap *soap, struct tt__SupportedRulesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SupportedRulesExtension);
	if (soap_out_PointerTott__SupportedRulesExtension(soap, tag?tag:"tt:SupportedRulesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportedRulesExtension ** SOAP_FMAC4 soap_get_PointerTott__SupportedRulesExtension(struct soap *soap, struct tt__SupportedRulesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportedRulesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ConfigDescription(struct soap *soap, struct tt__ConfigDescription *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ConfigDescription))
		soap_serialize_tt__ConfigDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ConfigDescription(struct soap *soap, const char *tag, int id, struct tt__ConfigDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ConfigDescription);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ConfigDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ConfigDescription ** SOAP_FMAC4 soap_in_PointerTott__ConfigDescription(struct soap *soap, const char *tag, struct tt__ConfigDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ConfigDescription **)soap_malloc(soap, sizeof(struct tt__ConfigDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ConfigDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ConfigDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ConfigDescription, sizeof(struct tt__ConfigDescription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ConfigDescription(struct soap *soap, struct tt__ConfigDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ConfigDescription);
	if (soap_out_PointerTott__ConfigDescription(soap, tag?tag:"tt:ConfigDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ConfigDescription ** SOAP_FMAC4 soap_get_PointerTott__ConfigDescription(struct soap *soap, struct tt__ConfigDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ConfigDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ConfigDescriptionExtension(struct soap *soap, struct tt__ConfigDescriptionExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ConfigDescriptionExtension))
		soap_serialize_tt__ConfigDescriptionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ConfigDescriptionExtension(struct soap *soap, const char *tag, int id, struct tt__ConfigDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ConfigDescriptionExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ConfigDescriptionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ConfigDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTott__ConfigDescriptionExtension(struct soap *soap, const char *tag, struct tt__ConfigDescriptionExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ConfigDescriptionExtension **)soap_malloc(soap, sizeof(struct tt__ConfigDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ConfigDescriptionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ConfigDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ConfigDescriptionExtension, sizeof(struct tt__ConfigDescriptionExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ConfigDescriptionExtension(struct soap *soap, struct tt__ConfigDescriptionExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ConfigDescriptionExtension);
	if (soap_out_PointerTott__ConfigDescriptionExtension(soap, tag?tag:"tt:ConfigDescriptionExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ConfigDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTott__ConfigDescriptionExtension(struct soap *soap, struct tt__ConfigDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ConfigDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, struct _tt__ConfigDescription_Messages *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ConfigDescription_Messages))
		soap_serialize__tt__ConfigDescription_Messages(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, const char *tag, int id, struct _tt__ConfigDescription_Messages *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ConfigDescription_Messages);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ConfigDescription_Messages(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ConfigDescription_Messages ** SOAP_FMAC4 soap_in_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, const char *tag, struct _tt__ConfigDescription_Messages **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ConfigDescription_Messages **)soap_malloc(soap, sizeof(struct _tt__ConfigDescription_Messages *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ConfigDescription_Messages(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ConfigDescription_Messages **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ConfigDescription_Messages, sizeof(struct _tt__ConfigDescription_Messages), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, struct _tt__ConfigDescription_Messages *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__ConfigDescription_Messages);
	if (soap_out_PointerTo_tt__ConfigDescription_Messages(soap, tag?tag:"tt:ConfigDescription-Messages", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ConfigDescription_Messages ** SOAP_FMAC4 soap_get_PointerTo_tt__ConfigDescription_Messages(struct soap *soap, struct _tt__ConfigDescription_Messages **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ConfigDescription_Messages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, struct tt__RuleEngineConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RuleEngineConfigurationExtension))
		soap_serialize_tt__RuleEngineConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__RuleEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RuleEngineConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RuleEngineConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RuleEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, const char *tag, struct tt__RuleEngineConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RuleEngineConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__RuleEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RuleEngineConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RuleEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RuleEngineConfigurationExtension, sizeof(struct tt__RuleEngineConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, struct tt__RuleEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RuleEngineConfigurationExtension);
	if (soap_out_PointerTott__RuleEngineConfigurationExtension(soap, tag?tag:"tt:RuleEngineConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RuleEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__RuleEngineConfigurationExtension(struct soap *soap, struct tt__RuleEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RuleEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsEngineConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension))
		soap_serialize_tt__AnalyticsEngineConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__AnalyticsEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsEngineConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, const char *tag, struct tt__AnalyticsEngineConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsEngineConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__AnalyticsEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsEngineConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineConfigurationExtension, sizeof(struct tt__AnalyticsEngineConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsEngineConfigurationExtension);
	if (soap_out_PointerTott__AnalyticsEngineConfigurationExtension(soap, tag?tag:"tt:AnalyticsEngineConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineConfigurationExtension(struct soap *soap, struct tt__AnalyticsEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Config(struct soap *soap, struct tt__Config *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Config))
		soap_serialize_tt__Config(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Config(struct soap *soap, const char *tag, int id, struct tt__Config *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Config);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Config(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Config ** SOAP_FMAC4 soap_in_PointerTott__Config(struct soap *soap, const char *tag, struct tt__Config **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Config **)soap_malloc(soap, sizeof(struct tt__Config *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Config(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Config **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Config, sizeof(struct tt__Config), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Config(struct soap *soap, struct tt__Config *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Config);
	if (soap_out_PointerTott__Config(soap, tag?tag:"tt:Config", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Config ** SOAP_FMAC4 soap_get_PointerTott__Config(struct soap *soap, struct tt__Config **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Config(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ObjectTreeExtension(struct soap *soap, struct tt__ObjectTreeExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ObjectTreeExtension))
		soap_serialize_tt__ObjectTreeExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ObjectTreeExtension(struct soap *soap, const char *tag, int id, struct tt__ObjectTreeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ObjectTreeExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ObjectTreeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ObjectTreeExtension ** SOAP_FMAC4 soap_in_PointerTott__ObjectTreeExtension(struct soap *soap, const char *tag, struct tt__ObjectTreeExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ObjectTreeExtension **)soap_malloc(soap, sizeof(struct tt__ObjectTreeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ObjectTreeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectTreeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ObjectTreeExtension, sizeof(struct tt__ObjectTreeExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ObjectTreeExtension(struct soap *soap, struct tt__ObjectTreeExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ObjectTreeExtension);
	if (soap_out_PointerTott__ObjectTreeExtension(soap, tag?tag:"tt:ObjectTreeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectTreeExtension ** SOAP_FMAC4 soap_get_PointerTott__ObjectTreeExtension(struct soap *soap, struct tt__ObjectTreeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ObjectTreeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Merge(struct soap *soap, struct tt__Merge *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Merge))
		soap_serialize_tt__Merge(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Merge(struct soap *soap, const char *tag, int id, struct tt__Merge *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Merge);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Merge(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Merge ** SOAP_FMAC4 soap_in_PointerTott__Merge(struct soap *soap, const char *tag, struct tt__Merge **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Merge **)soap_malloc(soap, sizeof(struct tt__Merge *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Merge(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Merge **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Merge, sizeof(struct tt__Merge), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Merge(struct soap *soap, struct tt__Merge *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Merge);
	if (soap_out_PointerTott__Merge(soap, tag?tag:"tt:Merge", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Merge ** SOAP_FMAC4 soap_get_PointerTott__Merge(struct soap *soap, struct tt__Merge **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Merge(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Split(struct soap *soap, struct tt__Split *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Split))
		soap_serialize_tt__Split(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Split(struct soap *soap, const char *tag, int id, struct tt__Split *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Split);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Split(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Split ** SOAP_FMAC4 soap_in_PointerTott__Split(struct soap *soap, const char *tag, struct tt__Split **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Split **)soap_malloc(soap, sizeof(struct tt__Split *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Split(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Split **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Split, sizeof(struct tt__Split), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Split(struct soap *soap, struct tt__Split *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Split);
	if (soap_out_PointerTott__Split(soap, tag?tag:"tt:Split", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Split ** SOAP_FMAC4 soap_get_PointerTott__Split(struct soap *soap, struct tt__Split **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Split(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Rename(struct soap *soap, struct tt__Rename *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Rename))
		soap_serialize_tt__Rename(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Rename(struct soap *soap, const char *tag, int id, struct tt__Rename *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Rename);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Rename(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Rename ** SOAP_FMAC4 soap_in_PointerTott__Rename(struct soap *soap, const char *tag, struct tt__Rename **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Rename **)soap_malloc(soap, sizeof(struct tt__Rename *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Rename(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Rename **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Rename, sizeof(struct tt__Rename), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Rename(struct soap *soap, struct tt__Rename *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Rename);
	if (soap_out_PointerTott__Rename(soap, tag?tag:"tt:Rename", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Rename ** SOAP_FMAC4 soap_get_PointerTott__Rename(struct soap *soap, struct tt__Rename **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Rename(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BehaviourExtension(struct soap *soap, struct tt__BehaviourExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BehaviourExtension))
		soap_serialize_tt__BehaviourExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BehaviourExtension(struct soap *soap, const char *tag, int id, struct tt__BehaviourExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BehaviourExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BehaviourExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__BehaviourExtension ** SOAP_FMAC4 soap_in_PointerTott__BehaviourExtension(struct soap *soap, const char *tag, struct tt__BehaviourExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__BehaviourExtension **)soap_malloc(soap, sizeof(struct tt__BehaviourExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BehaviourExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__BehaviourExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BehaviourExtension, sizeof(struct tt__BehaviourExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BehaviourExtension(struct soap *soap, struct tt__BehaviourExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__BehaviourExtension);
	if (soap_out_PointerTott__BehaviourExtension(soap, tag?tag:"tt:BehaviourExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BehaviourExtension ** SOAP_FMAC4 soap_get_PointerTott__BehaviourExtension(struct soap *soap, struct tt__BehaviourExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BehaviourExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__Behaviour_Idle(struct soap *soap, struct _tt__Behaviour_Idle *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__Behaviour_Idle))
		soap_serialize__tt__Behaviour_Idle(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__Behaviour_Idle(struct soap *soap, const char *tag, int id, struct _tt__Behaviour_Idle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__Behaviour_Idle);
	if (id < 0)
		return soap->error;
	return soap_out__tt__Behaviour_Idle(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__Behaviour_Idle ** SOAP_FMAC4 soap_in_PointerTo_tt__Behaviour_Idle(struct soap *soap, const char *tag, struct _tt__Behaviour_Idle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__Behaviour_Idle **)soap_malloc(soap, sizeof(struct _tt__Behaviour_Idle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__Behaviour_Idle(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__Behaviour_Idle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__Behaviour_Idle, sizeof(struct _tt__Behaviour_Idle), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__Behaviour_Idle(struct soap *soap, struct _tt__Behaviour_Idle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__Behaviour_Idle);
	if (soap_out_PointerTo_tt__Behaviour_Idle(soap, tag?tag:"tt:Behaviour-Idle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__Behaviour_Idle ** SOAP_FMAC4 soap_get_PointerTo_tt__Behaviour_Idle(struct soap *soap, struct _tt__Behaviour_Idle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__Behaviour_Idle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__Behaviour_Removed(struct soap *soap, struct _tt__Behaviour_Removed *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__Behaviour_Removed))
		soap_serialize__tt__Behaviour_Removed(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__Behaviour_Removed(struct soap *soap, const char *tag, int id, struct _tt__Behaviour_Removed *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__Behaviour_Removed);
	if (id < 0)
		return soap->error;
	return soap_out__tt__Behaviour_Removed(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__Behaviour_Removed ** SOAP_FMAC4 soap_in_PointerTo_tt__Behaviour_Removed(struct soap *soap, const char *tag, struct _tt__Behaviour_Removed **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__Behaviour_Removed **)soap_malloc(soap, sizeof(struct _tt__Behaviour_Removed *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__Behaviour_Removed(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__Behaviour_Removed **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__Behaviour_Removed, sizeof(struct _tt__Behaviour_Removed), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__Behaviour_Removed(struct soap *soap, struct _tt__Behaviour_Removed *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__Behaviour_Removed);
	if (soap_out_PointerTo_tt__Behaviour_Removed(soap, tag?tag:"tt:Behaviour-Removed", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__Behaviour_Removed ** SOAP_FMAC4 soap_get_PointerTo_tt__Behaviour_Removed(struct soap *soap, struct _tt__Behaviour_Removed **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__Behaviour_Removed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ObjectId(struct soap *soap, struct tt__ObjectId *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ObjectId))
		soap_serialize_tt__ObjectId(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ObjectId(struct soap *soap, const char *tag, int id, struct tt__ObjectId *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ObjectId);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ObjectId(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ObjectId ** SOAP_FMAC4 soap_in_PointerTott__ObjectId(struct soap *soap, const char *tag, struct tt__ObjectId **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ObjectId **)soap_malloc(soap, sizeof(struct tt__ObjectId *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ObjectId(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectId **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ObjectId, sizeof(struct tt__ObjectId), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ObjectId(struct soap *soap, struct tt__ObjectId *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ObjectId);
	if (soap_out_PointerTott__ObjectId(soap, tag?tag:"tt:ObjectId", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectId ** SOAP_FMAC4 soap_get_PointerTott__ObjectId(struct soap *soap, struct tt__ObjectId **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ObjectId(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FrameExtension2(struct soap *soap, struct tt__FrameExtension2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FrameExtension2))
		soap_serialize_tt__FrameExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FrameExtension2(struct soap *soap, const char *tag, int id, struct tt__FrameExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FrameExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FrameExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FrameExtension2 ** SOAP_FMAC4 soap_in_PointerTott__FrameExtension2(struct soap *soap, const char *tag, struct tt__FrameExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FrameExtension2 **)soap_malloc(soap, sizeof(struct tt__FrameExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FrameExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FrameExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FrameExtension2, sizeof(struct tt__FrameExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FrameExtension2(struct soap *soap, struct tt__FrameExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FrameExtension2);
	if (soap_out_PointerTott__FrameExtension2(soap, tag?tag:"tt:FrameExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FrameExtension2 ** SOAP_FMAC4 soap_get_PointerTott__FrameExtension2(struct soap *soap, struct tt__FrameExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FrameExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MotionInCells(struct soap *soap, struct tt__MotionInCells *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MotionInCells))
		soap_serialize_tt__MotionInCells(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MotionInCells(struct soap *soap, const char *tag, int id, struct tt__MotionInCells *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MotionInCells);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MotionInCells(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MotionInCells ** SOAP_FMAC4 soap_in_PointerTott__MotionInCells(struct soap *soap, const char *tag, struct tt__MotionInCells **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MotionInCells **)soap_malloc(soap, sizeof(struct tt__MotionInCells *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MotionInCells(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MotionInCells **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MotionInCells, sizeof(struct tt__MotionInCells), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MotionInCells(struct soap *soap, struct tt__MotionInCells *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MotionInCells);
	if (soap_out_PointerTott__MotionInCells(soap, tag?tag:"tt:MotionInCells", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MotionInCells ** SOAP_FMAC4 soap_get_PointerTott__MotionInCells(struct soap *soap, struct tt__MotionInCells **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MotionInCells(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FrameExtension(struct soap *soap, struct tt__FrameExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FrameExtension))
		soap_serialize_tt__FrameExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FrameExtension(struct soap *soap, const char *tag, int id, struct tt__FrameExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FrameExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FrameExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FrameExtension ** SOAP_FMAC4 soap_in_PointerTott__FrameExtension(struct soap *soap, const char *tag, struct tt__FrameExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FrameExtension **)soap_malloc(soap, sizeof(struct tt__FrameExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FrameExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FrameExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FrameExtension, sizeof(struct tt__FrameExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FrameExtension(struct soap *soap, struct tt__FrameExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FrameExtension);
	if (soap_out_PointerTott__FrameExtension(soap, tag?tag:"tt:FrameExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FrameExtension ** SOAP_FMAC4 soap_get_PointerTott__FrameExtension(struct soap *soap, struct tt__FrameExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FrameExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ObjectTree(struct soap *soap, struct tt__ObjectTree *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ObjectTree))
		soap_serialize_tt__ObjectTree(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ObjectTree(struct soap *soap, const char *tag, int id, struct tt__ObjectTree *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ObjectTree);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ObjectTree(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ObjectTree ** SOAP_FMAC4 soap_in_PointerTott__ObjectTree(struct soap *soap, const char *tag, struct tt__ObjectTree **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ObjectTree **)soap_malloc(soap, sizeof(struct tt__ObjectTree *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ObjectTree(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectTree **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ObjectTree, sizeof(struct tt__ObjectTree), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ObjectTree(struct soap *soap, struct tt__ObjectTree *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ObjectTree);
	if (soap_out_PointerTott__ObjectTree(soap, tag?tag:"tt:ObjectTree", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectTree ** SOAP_FMAC4 soap_get_PointerTott__ObjectTree(struct soap *soap, struct tt__ObjectTree **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ObjectTree(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Object(struct soap *soap, struct tt__Object *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Object))
		soap_serialize_tt__Object(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Object(struct soap *soap, const char *tag, int id, struct tt__Object *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Object);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Object(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Object ** SOAP_FMAC4 soap_in_PointerTott__Object(struct soap *soap, const char *tag, struct tt__Object **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Object **)soap_malloc(soap, sizeof(struct tt__Object *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Object(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Object **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Object, sizeof(struct tt__Object), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Object(struct soap *soap, struct tt__Object *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Object);
	if (soap_out_PointerTott__Object(soap, tag?tag:"tt:Object", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Object ** SOAP_FMAC4 soap_get_PointerTott__Object(struct soap *soap, struct tt__Object **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Object(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZStatus(struct soap *soap, struct tt__PTZStatus *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZStatus))
		soap_serialize_tt__PTZStatus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZStatus(struct soap *soap, const char *tag, int id, struct tt__PTZStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZStatus);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZStatus ** SOAP_FMAC4 soap_in_PointerTott__PTZStatus(struct soap *soap, const char *tag, struct tt__PTZStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZStatus **)soap_malloc(soap, sizeof(struct tt__PTZStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStatus, sizeof(struct tt__PTZStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZStatus(struct soap *soap, struct tt__PTZStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZStatus);
	if (soap_out_PointerTott__PTZStatus(soap, tag?tag:"tt:PTZStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStatus ** SOAP_FMAC4 soap_get_PointerTott__PTZStatus(struct soap *soap, struct tt__PTZStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TransformationExtension(struct soap *soap, struct tt__TransformationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TransformationExtension))
		soap_serialize_tt__TransformationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TransformationExtension(struct soap *soap, const char *tag, int id, struct tt__TransformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TransformationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TransformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TransformationExtension ** SOAP_FMAC4 soap_in_PointerTott__TransformationExtension(struct soap *soap, const char *tag, struct tt__TransformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TransformationExtension **)soap_malloc(soap, sizeof(struct tt__TransformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TransformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TransformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TransformationExtension, sizeof(struct tt__TransformationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TransformationExtension(struct soap *soap, struct tt__TransformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__TransformationExtension);
	if (soap_out_PointerTott__TransformationExtension(soap, tag?tag:"tt:TransformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TransformationExtension ** SOAP_FMAC4 soap_get_PointerTott__TransformationExtension(struct soap *soap, struct tt__TransformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TransformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ClassDescriptorExtension2(struct soap *soap, struct tt__ClassDescriptorExtension2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ClassDescriptorExtension2))
		soap_serialize_tt__ClassDescriptorExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ClassDescriptorExtension2(struct soap *soap, const char *tag, int id, struct tt__ClassDescriptorExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ClassDescriptorExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ClassDescriptorExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension2 ** SOAP_FMAC4 soap_in_PointerTott__ClassDescriptorExtension2(struct soap *soap, const char *tag, struct tt__ClassDescriptorExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ClassDescriptorExtension2 **)soap_malloc(soap, sizeof(struct tt__ClassDescriptorExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ClassDescriptorExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ClassDescriptorExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ClassDescriptorExtension2, sizeof(struct tt__ClassDescriptorExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ClassDescriptorExtension2(struct soap *soap, struct tt__ClassDescriptorExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ClassDescriptorExtension2);
	if (soap_out_PointerTott__ClassDescriptorExtension2(soap, tag?tag:"tt:ClassDescriptorExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension2 ** SOAP_FMAC4 soap_get_PointerTott__ClassDescriptorExtension2(struct soap *soap, struct tt__ClassDescriptorExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ClassDescriptorExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OtherType(struct soap *soap, struct tt__OtherType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OtherType))
		soap_serialize_tt__OtherType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OtherType(struct soap *soap, const char *tag, int id, struct tt__OtherType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OtherType);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OtherType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OtherType ** SOAP_FMAC4 soap_in_PointerTott__OtherType(struct soap *soap, const char *tag, struct tt__OtherType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OtherType **)soap_malloc(soap, sizeof(struct tt__OtherType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OtherType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OtherType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OtherType, sizeof(struct tt__OtherType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OtherType(struct soap *soap, struct tt__OtherType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__OtherType);
	if (soap_out_PointerTott__OtherType(soap, tag?tag:"tt:OtherType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OtherType ** SOAP_FMAC4 soap_get_PointerTott__OtherType(struct soap *soap, struct tt__OtherType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OtherType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ClassDescriptorExtension(struct soap *soap, struct tt__ClassDescriptorExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ClassDescriptorExtension))
		soap_serialize_tt__ClassDescriptorExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ClassDescriptorExtension(struct soap *soap, const char *tag, int id, struct tt__ClassDescriptorExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ClassDescriptorExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ClassDescriptorExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension ** SOAP_FMAC4 soap_in_PointerTott__ClassDescriptorExtension(struct soap *soap, const char *tag, struct tt__ClassDescriptorExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ClassDescriptorExtension **)soap_malloc(soap, sizeof(struct tt__ClassDescriptorExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ClassDescriptorExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ClassDescriptorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ClassDescriptorExtension, sizeof(struct tt__ClassDescriptorExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ClassDescriptorExtension(struct soap *soap, struct tt__ClassDescriptorExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ClassDescriptorExtension);
	if (soap_out_PointerTott__ClassDescriptorExtension(soap, tag?tag:"tt:ClassDescriptorExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ClassDescriptorExtension ** SOAP_FMAC4 soap_get_PointerTott__ClassDescriptorExtension(struct soap *soap, struct tt__ClassDescriptorExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ClassDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, struct _tt__ClassDescriptor_ClassCandidate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate))
		soap_serialize__tt__ClassDescriptor_ClassCandidate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, int id, struct _tt__ClassDescriptor_ClassCandidate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ClassDescriptor_ClassCandidate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ClassDescriptor_ClassCandidate ** SOAP_FMAC4 soap_in_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, const char *tag, struct _tt__ClassDescriptor_ClassCandidate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ClassDescriptor_ClassCandidate **)soap_malloc(soap, sizeof(struct _tt__ClassDescriptor_ClassCandidate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ClassDescriptor_ClassCandidate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ClassDescriptor_ClassCandidate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ClassDescriptor_ClassCandidate, sizeof(struct _tt__ClassDescriptor_ClassCandidate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, struct _tt__ClassDescriptor_ClassCandidate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__ClassDescriptor_ClassCandidate);
	if (soap_out_PointerTo_tt__ClassDescriptor_ClassCandidate(soap, tag?tag:"tt:ClassDescriptor-ClassCandidate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ClassDescriptor_ClassCandidate ** SOAP_FMAC4 soap_get_PointerTo_tt__ClassDescriptor_ClassCandidate(struct soap *soap, struct _tt__ClassDescriptor_ClassCandidate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ClassDescriptor_ClassCandidate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorDescriptorExtension(struct soap *soap, struct tt__ColorDescriptorExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorDescriptorExtension))
		soap_serialize_tt__ColorDescriptorExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorDescriptorExtension(struct soap *soap, const char *tag, int id, struct tt__ColorDescriptorExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorDescriptorExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ColorDescriptorExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ColorDescriptorExtension ** SOAP_FMAC4 soap_in_PointerTott__ColorDescriptorExtension(struct soap *soap, const char *tag, struct tt__ColorDescriptorExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ColorDescriptorExtension **)soap_malloc(soap, sizeof(struct tt__ColorDescriptorExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ColorDescriptorExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ColorDescriptorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorDescriptorExtension, sizeof(struct tt__ColorDescriptorExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorDescriptorExtension(struct soap *soap, struct tt__ColorDescriptorExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ColorDescriptorExtension);
	if (soap_out_PointerTott__ColorDescriptorExtension(soap, tag?tag:"tt:ColorDescriptorExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorDescriptorExtension ** SOAP_FMAC4 soap_get_PointerTott__ColorDescriptorExtension(struct soap *soap, struct tt__ColorDescriptorExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, struct _tt__ColorDescriptor_ColorCluster *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ColorDescriptor_ColorCluster))
		soap_serialize__tt__ColorDescriptor_ColorCluster(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, int id, struct _tt__ColorDescriptor_ColorCluster *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ColorDescriptor_ColorCluster);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ColorDescriptor_ColorCluster(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ColorDescriptor_ColorCluster ** SOAP_FMAC4 soap_in_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, const char *tag, struct _tt__ColorDescriptor_ColorCluster **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ColorDescriptor_ColorCluster **)soap_malloc(soap, sizeof(struct _tt__ColorDescriptor_ColorCluster *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ColorDescriptor_ColorCluster(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ColorDescriptor_ColorCluster **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ColorDescriptor_ColorCluster, sizeof(struct _tt__ColorDescriptor_ColorCluster), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, struct _tt__ColorDescriptor_ColorCluster *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__ColorDescriptor_ColorCluster);
	if (soap_out_PointerTo_tt__ColorDescriptor_ColorCluster(soap, tag?tag:"tt:ColorDescriptor-ColorCluster", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ColorDescriptor_ColorCluster ** SOAP_FMAC4 soap_get_PointerTo_tt__ColorDescriptor_ColorCluster(struct soap *soap, struct _tt__ColorDescriptor_ColorCluster **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ColorDescriptor_ColorCluster(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorCovariance(struct soap *soap, struct tt__ColorCovariance *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorCovariance))
		soap_serialize_tt__ColorCovariance(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorCovariance(struct soap *soap, const char *tag, int id, struct tt__ColorCovariance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorCovariance);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ColorCovariance(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ColorCovariance ** SOAP_FMAC4 soap_in_PointerTott__ColorCovariance(struct soap *soap, const char *tag, struct tt__ColorCovariance **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ColorCovariance **)soap_malloc(soap, sizeof(struct tt__ColorCovariance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ColorCovariance(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ColorCovariance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorCovariance, sizeof(struct tt__ColorCovariance), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorCovariance(struct soap *soap, struct tt__ColorCovariance *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ColorCovariance);
	if (soap_out_PointerTott__ColorCovariance(soap, tag?tag:"tt:ColorCovariance", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorCovariance ** SOAP_FMAC4 soap_get_PointerTott__ColorCovariance(struct soap *soap, struct tt__ColorCovariance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorCovariance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Color(struct soap *soap, struct tt__Color *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Color))
		soap_serialize_tt__Color(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Color(struct soap *soap, const char *tag, int id, struct tt__Color *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Color);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Color(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Color ** SOAP_FMAC4 soap_in_PointerTott__Color(struct soap *soap, const char *tag, struct tt__Color **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Color **)soap_malloc(soap, sizeof(struct tt__Color *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Color(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Color **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Color, sizeof(struct tt__Color), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Color(struct soap *soap, struct tt__Color *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Color);
	if (soap_out_PointerTott__Color(soap, tag?tag:"tt:Color", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Color ** SOAP_FMAC4 soap_get_PointerTott__Color(struct soap *soap, struct tt__Color **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Color(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ShapeDescriptorExtension(struct soap *soap, struct tt__ShapeDescriptorExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ShapeDescriptorExtension))
		soap_serialize_tt__ShapeDescriptorExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ShapeDescriptorExtension(struct soap *soap, const char *tag, int id, struct tt__ShapeDescriptorExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ShapeDescriptorExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ShapeDescriptorExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ShapeDescriptorExtension ** SOAP_FMAC4 soap_in_PointerTott__ShapeDescriptorExtension(struct soap *soap, const char *tag, struct tt__ShapeDescriptorExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ShapeDescriptorExtension **)soap_malloc(soap, sizeof(struct tt__ShapeDescriptorExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ShapeDescriptorExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ShapeDescriptorExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ShapeDescriptorExtension, sizeof(struct tt__ShapeDescriptorExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ShapeDescriptorExtension(struct soap *soap, struct tt__ShapeDescriptorExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ShapeDescriptorExtension);
	if (soap_out_PointerTott__ShapeDescriptorExtension(soap, tag?tag:"tt:ShapeDescriptorExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ShapeDescriptorExtension ** SOAP_FMAC4 soap_get_PointerTott__ShapeDescriptorExtension(struct soap *soap, struct tt__ShapeDescriptorExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ShapeDescriptorExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Polygon(struct soap *soap, struct tt__Polygon *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Polygon))
		soap_serialize_tt__Polygon(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Polygon(struct soap *soap, const char *tag, int id, struct tt__Polygon *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Polygon);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Polygon(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Polygon ** SOAP_FMAC4 soap_in_PointerTott__Polygon(struct soap *soap, const char *tag, struct tt__Polygon **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Polygon **)soap_malloc(soap, sizeof(struct tt__Polygon *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Polygon(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Polygon **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Polygon, sizeof(struct tt__Polygon), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Polygon(struct soap *soap, struct tt__Polygon *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Polygon);
	if (soap_out_PointerTott__Polygon(soap, tag?tag:"tt:Polygon", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Polygon ** SOAP_FMAC4 soap_get_PointerTott__Polygon(struct soap *soap, struct tt__Polygon **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Polygon(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AppearanceExtension(struct soap *soap, struct tt__AppearanceExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AppearanceExtension))
		soap_serialize_tt__AppearanceExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AppearanceExtension(struct soap *soap, const char *tag, int id, struct tt__AppearanceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AppearanceExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AppearanceExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AppearanceExtension ** SOAP_FMAC4 soap_in_PointerTott__AppearanceExtension(struct soap *soap, const char *tag, struct tt__AppearanceExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AppearanceExtension **)soap_malloc(soap, sizeof(struct tt__AppearanceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AppearanceExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AppearanceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AppearanceExtension, sizeof(struct tt__AppearanceExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AppearanceExtension(struct soap *soap, struct tt__AppearanceExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AppearanceExtension);
	if (soap_out_PointerTott__AppearanceExtension(soap, tag?tag:"tt:AppearanceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AppearanceExtension ** SOAP_FMAC4 soap_get_PointerTott__AppearanceExtension(struct soap *soap, struct tt__AppearanceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AppearanceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ClassDescriptor(struct soap *soap, struct tt__ClassDescriptor *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ClassDescriptor))
		soap_serialize_tt__ClassDescriptor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ClassDescriptor(struct soap *soap, const char *tag, int id, struct tt__ClassDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ClassDescriptor);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ClassDescriptor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ClassDescriptor ** SOAP_FMAC4 soap_in_PointerTott__ClassDescriptor(struct soap *soap, const char *tag, struct tt__ClassDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ClassDescriptor **)soap_malloc(soap, sizeof(struct tt__ClassDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ClassDescriptor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ClassDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ClassDescriptor, sizeof(struct tt__ClassDescriptor), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ClassDescriptor(struct soap *soap, struct tt__ClassDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ClassDescriptor);
	if (soap_out_PointerTott__ClassDescriptor(soap, tag?tag:"tt:ClassDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ClassDescriptor ** SOAP_FMAC4 soap_get_PointerTott__ClassDescriptor(struct soap *soap, struct tt__ClassDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ClassDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ColorDescriptor(struct soap *soap, struct tt__ColorDescriptor *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ColorDescriptor))
		soap_serialize_tt__ColorDescriptor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ColorDescriptor(struct soap *soap, const char *tag, int id, struct tt__ColorDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ColorDescriptor);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ColorDescriptor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ColorDescriptor ** SOAP_FMAC4 soap_in_PointerTott__ColorDescriptor(struct soap *soap, const char *tag, struct tt__ColorDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ColorDescriptor **)soap_malloc(soap, sizeof(struct tt__ColorDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ColorDescriptor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ColorDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ColorDescriptor, sizeof(struct tt__ColorDescriptor), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ColorDescriptor(struct soap *soap, struct tt__ColorDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ColorDescriptor);
	if (soap_out_PointerTott__ColorDescriptor(soap, tag?tag:"tt:ColorDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ColorDescriptor ** SOAP_FMAC4 soap_get_PointerTott__ColorDescriptor(struct soap *soap, struct tt__ColorDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ColorDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ShapeDescriptor(struct soap *soap, struct tt__ShapeDescriptor *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ShapeDescriptor))
		soap_serialize_tt__ShapeDescriptor(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ShapeDescriptor(struct soap *soap, const char *tag, int id, struct tt__ShapeDescriptor *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ShapeDescriptor);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ShapeDescriptor(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ShapeDescriptor ** SOAP_FMAC4 soap_in_PointerTott__ShapeDescriptor(struct soap *soap, const char *tag, struct tt__ShapeDescriptor **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ShapeDescriptor **)soap_malloc(soap, sizeof(struct tt__ShapeDescriptor *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ShapeDescriptor(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ShapeDescriptor **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ShapeDescriptor, sizeof(struct tt__ShapeDescriptor), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ShapeDescriptor(struct soap *soap, struct tt__ShapeDescriptor *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ShapeDescriptor);
	if (soap_out_PointerTott__ShapeDescriptor(soap, tag?tag:"tt:ShapeDescriptor", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ShapeDescriptor ** SOAP_FMAC4 soap_get_PointerTott__ShapeDescriptor(struct soap *soap, struct tt__ShapeDescriptor **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ShapeDescriptor(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Transformation(struct soap *soap, struct tt__Transformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Transformation))
		soap_serialize_tt__Transformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Transformation(struct soap *soap, const char *tag, int id, struct tt__Transformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Transformation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Transformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Transformation ** SOAP_FMAC4 soap_in_PointerTott__Transformation(struct soap *soap, const char *tag, struct tt__Transformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Transformation **)soap_malloc(soap, sizeof(struct tt__Transformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Transformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Transformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Transformation, sizeof(struct tt__Transformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Transformation(struct soap *soap, struct tt__Transformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Transformation);
	if (soap_out_PointerTott__Transformation(soap, tag?tag:"tt:Transformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Transformation ** SOAP_FMAC4 soap_get_PointerTott__Transformation(struct soap *soap, struct tt__Transformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Transformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector(struct soap *soap, struct tt__Vector *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector))
		soap_serialize_tt__Vector(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector(struct soap *soap, const char *tag, int id, struct tt__Vector *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Vector(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Vector ** SOAP_FMAC4 soap_in_PointerTott__Vector(struct soap *soap, const char *tag, struct tt__Vector **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Vector **)soap_malloc(soap, sizeof(struct tt__Vector *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Vector(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Vector **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector, sizeof(struct tt__Vector), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector(struct soap *soap, struct tt__Vector *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Vector);
	if (soap_out_PointerTott__Vector(soap, tag?tag:"tt:Vector", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector ** SOAP_FMAC4 soap_get_PointerTott__Vector(struct soap *soap, struct tt__Vector **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListDescriptionExtension))
		soap_serialize_tt__ItemListDescriptionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListDescriptionExtension(struct soap *soap, const char *tag, int id, struct tt__ItemListDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListDescriptionExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemListDescriptionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTott__ItemListDescriptionExtension(struct soap *soap, const char *tag, struct tt__ItemListDescriptionExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ItemListDescriptionExtension **)soap_malloc(soap, sizeof(struct tt__ItemListDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ItemListDescriptionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListDescriptionExtension, sizeof(struct tt__ItemListDescriptionExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ItemListDescriptionExtension);
	if (soap_out_PointerTott__ItemListDescriptionExtension(soap, tag?tag:"tt:ItemListDescriptionExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTott__ItemListDescriptionExtension(struct soap *soap, struct tt__ItemListDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription))
		soap_serialize__tt__ItemListDescription_ElementItemDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, int id, struct _tt__ItemListDescription_ElementItemDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemListDescription_ElementItemDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, const char *tag, struct _tt__ItemListDescription_ElementItemDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemListDescription_ElementItemDescription **)soap_malloc(soap, sizeof(struct _tt__ItemListDescription_ElementItemDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemListDescription_ElementItemDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemListDescription_ElementItemDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemListDescription_ElementItemDescription, sizeof(struct _tt__ItemListDescription_ElementItemDescription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__ItemListDescription_ElementItemDescription);
	if (soap_out_PointerTo_tt__ItemListDescription_ElementItemDescription(soap, tag?tag:"tt:ItemListDescription-ElementItemDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemListDescription_ElementItemDescription ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemListDescription_ElementItemDescription(struct soap *soap, struct _tt__ItemListDescription_ElementItemDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemListDescription_ElementItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription))
		soap_serialize__tt__ItemListDescription_SimpleItemDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, int id, struct _tt__ItemListDescription_SimpleItemDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemListDescription_SimpleItemDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, const char *tag, struct _tt__ItemListDescription_SimpleItemDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemListDescription_SimpleItemDescription **)soap_malloc(soap, sizeof(struct _tt__ItemListDescription_SimpleItemDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemListDescription_SimpleItemDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemListDescription_SimpleItemDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemListDescription_SimpleItemDescription, sizeof(struct _tt__ItemListDescription_SimpleItemDescription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__ItemListDescription_SimpleItemDescription);
	if (soap_out_PointerTo_tt__ItemListDescription_SimpleItemDescription(soap, tag?tag:"tt:ItemListDescription-SimpleItemDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemListDescription_SimpleItemDescription ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemListDescription_SimpleItemDescription(struct soap *soap, struct _tt__ItemListDescription_SimpleItemDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemListDescription_SimpleItemDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MessageDescriptionExtension))
		soap_serialize_tt__MessageDescriptionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MessageDescriptionExtension(struct soap *soap, const char *tag, int id, struct tt__MessageDescriptionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MessageDescriptionExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MessageDescriptionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension ** SOAP_FMAC4 soap_in_PointerTott__MessageDescriptionExtension(struct soap *soap, const char *tag, struct tt__MessageDescriptionExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MessageDescriptionExtension **)soap_malloc(soap, sizeof(struct tt__MessageDescriptionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MessageDescriptionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MessageDescriptionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MessageDescriptionExtension, sizeof(struct tt__MessageDescriptionExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MessageDescriptionExtension);
	if (soap_out_PointerTott__MessageDescriptionExtension(soap, tag?tag:"tt:MessageDescriptionExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MessageDescriptionExtension ** SOAP_FMAC4 soap_get_PointerTott__MessageDescriptionExtension(struct soap *soap, struct tt__MessageDescriptionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MessageDescriptionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListExtension))
		soap_serialize_tt__ItemListExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListExtension(struct soap *soap, const char *tag, int id, struct tt__ItemListExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemListExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemListExtension ** SOAP_FMAC4 soap_in_PointerTott__ItemListExtension(struct soap *soap, const char *tag, struct tt__ItemListExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ItemListExtension **)soap_malloc(soap, sizeof(struct tt__ItemListExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ItemListExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListExtension, sizeof(struct tt__ItemListExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListExtension(struct soap *soap, struct tt__ItemListExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ItemListExtension);
	if (soap_out_PointerTott__ItemListExtension(soap, tag?tag:"tt:ItemListExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListExtension ** SOAP_FMAC4 soap_get_PointerTott__ItemListExtension(struct soap *soap, struct tt__ItemListExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemList_ElementItem))
		soap_serialize__tt__ItemList_ElementItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemList_ElementItem(struct soap *soap, const char *tag, int id, struct _tt__ItemList_ElementItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemList_ElementItem);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemList_ElementItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemList_ElementItem(struct soap *soap, const char *tag, struct _tt__ItemList_ElementItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemList_ElementItem **)soap_malloc(soap, sizeof(struct _tt__ItemList_ElementItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemList_ElementItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemList_ElementItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemList_ElementItem, sizeof(struct _tt__ItemList_ElementItem), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__ItemList_ElementItem);
	if (soap_out_PointerTo_tt__ItemList_ElementItem(soap, tag?tag:"tt:ItemList-ElementItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_ElementItem ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemList_ElementItem(struct soap *soap, struct _tt__ItemList_ElementItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemList_ElementItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__ItemList_SimpleItem))
		soap_serialize__tt__ItemList_SimpleItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, int id, struct _tt__ItemList_SimpleItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__ItemList_SimpleItem);
	if (id < 0)
		return soap->error;
	return soap_out__tt__ItemList_SimpleItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem ** SOAP_FMAC4 soap_in_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, const char *tag, struct _tt__ItemList_SimpleItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__ItemList_SimpleItem **)soap_malloc(soap, sizeof(struct _tt__ItemList_SimpleItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__ItemList_SimpleItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__ItemList_SimpleItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__ItemList_SimpleItem, sizeof(struct _tt__ItemList_SimpleItem), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__ItemList_SimpleItem);
	if (soap_out_PointerTo_tt__ItemList_SimpleItem(soap, tag?tag:"tt:ItemList-SimpleItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__ItemList_SimpleItem ** SOAP_FMAC4 soap_get_PointerTo_tt__ItemList_SimpleItem(struct soap *soap, struct _tt__ItemList_SimpleItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__ItemList_SimpleItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusOptions20Extension(struct soap *soap, struct tt__FocusOptions20Extension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusOptions20Extension))
		soap_serialize_tt__FocusOptions20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusOptions20Extension(struct soap *soap, const char *tag, int id, struct tt__FocusOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusOptions20Extension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusOptions20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusOptions20Extension(struct soap *soap, const char *tag, struct tt__FocusOptions20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusOptions20Extension **)soap_malloc(soap, sizeof(struct tt__FocusOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusOptions20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusOptions20Extension, sizeof(struct tt__FocusOptions20Extension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusOptions20Extension(struct soap *soap, struct tt__FocusOptions20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusOptions20Extension);
	if (soap_out_PointerTott__FocusOptions20Extension(soap, tag?tag:"tt:FocusOptions20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusOptions20Extension(struct soap *soap, struct tt__FocusOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, struct tt__WhiteBalanceOptions20Extension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension))
		soap_serialize_tt__WhiteBalanceOptions20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, int id, struct tt__WhiteBalanceOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalanceOptions20Extension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WhiteBalanceOptions20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, const char *tag, struct tt__WhiteBalanceOptions20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WhiteBalanceOptions20Extension **)soap_malloc(soap, sizeof(struct tt__WhiteBalanceOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WhiteBalanceOptions20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalanceOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceOptions20Extension, sizeof(struct tt__WhiteBalanceOptions20Extension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, struct tt__WhiteBalanceOptions20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WhiteBalanceOptions20Extension);
	if (soap_out_PointerTott__WhiteBalanceOptions20Extension(soap, tag?tag:"tt:WhiteBalanceOptions20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalanceOptions20Extension(struct soap *soap, struct tt__WhiteBalanceOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalanceOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusConfiguration20Extension))
		soap_serialize_tt__FocusConfiguration20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration20Extension(struct soap *soap, const char *tag, int id, struct tt__FocusConfiguration20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusConfiguration20Extension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusConfiguration20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration20Extension(struct soap *soap, const char *tag, struct tt__FocusConfiguration20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusConfiguration20Extension **)soap_malloc(soap, sizeof(struct tt__FocusConfiguration20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusConfiguration20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusConfiguration20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration20Extension, sizeof(struct tt__FocusConfiguration20Extension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusConfiguration20Extension);
	if (soap_out_PointerTott__FocusConfiguration20Extension(soap, tag?tag:"tt:FocusConfiguration20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusConfiguration20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration20Extension(struct soap *soap, struct tt__FocusConfiguration20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusConfiguration20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalance20Extension))
		soap_serialize_tt__WhiteBalance20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance20Extension(struct soap *soap, const char *tag, int id, struct tt__WhiteBalance20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalance20Extension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WhiteBalance20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance20Extension(struct soap *soap, const char *tag, struct tt__WhiteBalance20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WhiteBalance20Extension **)soap_malloc(soap, sizeof(struct tt__WhiteBalance20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WhiteBalance20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalance20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance20Extension, sizeof(struct tt__WhiteBalance20Extension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WhiteBalance20Extension);
	if (soap_out_PointerTott__WhiteBalance20Extension(soap, tag?tag:"tt:WhiteBalance20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalance20Extension ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance20Extension(struct soap *soap, struct tt__WhiteBalance20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalance20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelativeFocusOptions20(struct soap *soap, struct tt__RelativeFocusOptions20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelativeFocusOptions20))
		soap_serialize_tt__RelativeFocusOptions20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelativeFocusOptions20(struct soap *soap, const char *tag, int id, struct tt__RelativeFocusOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelativeFocusOptions20);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RelativeFocusOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions20 ** SOAP_FMAC4 soap_in_PointerTott__RelativeFocusOptions20(struct soap *soap, const char *tag, struct tt__RelativeFocusOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RelativeFocusOptions20 **)soap_malloc(soap, sizeof(struct tt__RelativeFocusOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RelativeFocusOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RelativeFocusOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelativeFocusOptions20, sizeof(struct tt__RelativeFocusOptions20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelativeFocusOptions20(struct soap *soap, struct tt__RelativeFocusOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RelativeFocusOptions20);
	if (soap_out_PointerTott__RelativeFocusOptions20(soap, tag?tag:"tt:RelativeFocusOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions20 ** SOAP_FMAC4 soap_get_PointerTott__RelativeFocusOptions20(struct soap *soap, struct tt__RelativeFocusOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelativeFocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensationMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensationMode(struct soap *soap, const char *tag, int id, enum tt__BacklightCompensationMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensationMode);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BacklightCompensationMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__BacklightCompensationMode ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensationMode(struct soap *soap, const char *tag, enum tt__BacklightCompensationMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__BacklightCompensationMode **)soap_malloc(soap, sizeof(enum tt__BacklightCompensationMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BacklightCompensationMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__BacklightCompensationMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensationMode, sizeof(enum tt__BacklightCompensationMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__BacklightCompensationMode);
	if (soap_out_PointerTott__BacklightCompensationMode(soap, tag?tag:"tt:BacklightCompensationMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__BacklightCompensationMode ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensationMode(struct soap *soap, enum tt__BacklightCompensationMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, struct tt__ImageStabilizationOptionsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension))
		soap_serialize_tt__ImageStabilizationOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__ImageStabilizationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilizationOptionsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImageStabilizationOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImageStabilizationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, const char *tag, struct tt__ImageStabilizationOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImageStabilizationOptionsExtension **)soap_malloc(soap, sizeof(struct tt__ImageStabilizationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImageStabilizationOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImageStabilizationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationOptionsExtension, sizeof(struct tt__ImageStabilizationOptionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, struct tt__ImageStabilizationOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImageStabilizationOptionsExtension);
	if (soap_out_PointerTott__ImageStabilizationOptionsExtension(soap, tag?tag:"tt:ImageStabilizationOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImageStabilizationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilizationOptionsExtension(struct soap *soap, struct tt__ImageStabilizationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilizationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilizationMode(struct soap *soap, enum tt__ImageStabilizationMode *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilizationMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilizationMode(struct soap *soap, const char *tag, int id, enum tt__ImageStabilizationMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilizationMode);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImageStabilizationMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__ImageStabilizationMode ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilizationMode(struct soap *soap, const char *tag, enum tt__ImageStabilizationMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__ImageStabilizationMode **)soap_malloc(soap, sizeof(enum tt__ImageStabilizationMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImageStabilizationMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__ImageStabilizationMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationMode, sizeof(enum tt__ImageStabilizationMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilizationMode(struct soap *soap, enum tt__ImageStabilizationMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImageStabilizationMode);
	if (soap_out_PointerTott__ImageStabilizationMode(soap, tag?tag:"tt:ImageStabilizationMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ImageStabilizationMode ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilizationMode(struct soap *soap, enum tt__ImageStabilizationMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilizationMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension2(struct soap *soap, struct tt__ImagingOptions20Extension2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20Extension2))
		soap_serialize_tt__ImagingOptions20Extension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension2(struct soap *soap, const char *tag, int id, struct tt__ImagingOptions20Extension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20Extension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingOptions20Extension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension2 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension2(struct soap *soap, const char *tag, struct tt__ImagingOptions20Extension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingOptions20Extension2 **)soap_malloc(soap, sizeof(struct tt__ImagingOptions20Extension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingOptions20Extension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20Extension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension2, sizeof(struct tt__ImagingOptions20Extension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension2(struct soap *soap, struct tt__ImagingOptions20Extension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingOptions20Extension2);
	if (soap_out_PointerTott__ImagingOptions20Extension2(soap, tag?tag:"tt:ImagingOptions20Extension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension2 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension2(struct soap *soap, struct tt__ImagingOptions20Extension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20Extension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilizationOptions(struct soap *soap, struct tt__ImageStabilizationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilizationOptions))
		soap_serialize_tt__ImageStabilizationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilizationOptions(struct soap *soap, const char *tag, int id, struct tt__ImageStabilizationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilizationOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImageStabilizationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImageStabilizationOptions ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilizationOptions(struct soap *soap, const char *tag, struct tt__ImageStabilizationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImageStabilizationOptions **)soap_malloc(soap, sizeof(struct tt__ImageStabilizationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImageStabilizationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImageStabilizationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationOptions, sizeof(struct tt__ImageStabilizationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilizationOptions(struct soap *soap, struct tt__ImageStabilizationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImageStabilizationOptions);
	if (soap_out_PointerTott__ImageStabilizationOptions(soap, tag?tag:"tt:ImageStabilizationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImageStabilizationOptions ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilizationOptions(struct soap *soap, struct tt__ImageStabilizationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilizationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20Extension(struct soap *soap, struct tt__ImagingOptions20Extension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20Extension))
		soap_serialize_tt__ImagingOptions20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20Extension(struct soap *soap, const char *tag, int id, struct tt__ImagingOptions20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20Extension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingOptions20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20Extension(struct soap *soap, const char *tag, struct tt__ImagingOptions20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingOptions20Extension **)soap_malloc(soap, sizeof(struct tt__ImagingOptions20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingOptions20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20Extension, sizeof(struct tt__ImagingOptions20Extension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20Extension(struct soap *soap, struct tt__ImagingOptions20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingOptions20Extension);
	if (soap_out_PointerTott__ImagingOptions20Extension(soap, tag?tag:"tt:ImagingOptions20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20Extension ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20Extension(struct soap *soap, struct tt__ImagingOptions20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalanceOptions20(struct soap *soap, struct tt__WhiteBalanceOptions20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalanceOptions20))
		soap_serialize_tt__WhiteBalanceOptions20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalanceOptions20(struct soap *soap, const char *tag, int id, struct tt__WhiteBalanceOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalanceOptions20);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WhiteBalanceOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20 ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalanceOptions20(struct soap *soap, const char *tag, struct tt__WhiteBalanceOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WhiteBalanceOptions20 **)soap_malloc(soap, sizeof(struct tt__WhiteBalanceOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WhiteBalanceOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalanceOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceOptions20, sizeof(struct tt__WhiteBalanceOptions20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalanceOptions20(struct soap *soap, struct tt__WhiteBalanceOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WhiteBalanceOptions20);
	if (soap_out_PointerTott__WhiteBalanceOptions20(soap, tag?tag:"tt:WhiteBalanceOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions20 ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalanceOptions20(struct soap *soap, struct tt__WhiteBalanceOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalanceOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRangeOptions20(struct soap *soap, struct tt__WideDynamicRangeOptions20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicRangeOptions20))
		soap_serialize_tt__WideDynamicRangeOptions20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRangeOptions20(struct soap *soap, const char *tag, int id, struct tt__WideDynamicRangeOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicRangeOptions20);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WideDynamicRangeOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions20 ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRangeOptions20(struct soap *soap, const char *tag, struct tt__WideDynamicRangeOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WideDynamicRangeOptions20 **)soap_malloc(soap, sizeof(struct tt__WideDynamicRangeOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WideDynamicRangeOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WideDynamicRangeOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRangeOptions20, sizeof(struct tt__WideDynamicRangeOptions20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRangeOptions20(struct soap *soap, struct tt__WideDynamicRangeOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WideDynamicRangeOptions20);
	if (soap_out_PointerTott__WideDynamicRangeOptions20(soap, tag?tag:"tt:WideDynamicRangeOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions20 ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRangeOptions20(struct soap *soap, struct tt__WideDynamicRangeOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicRangeOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusOptions20(struct soap *soap, struct tt__FocusOptions20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusOptions20))
		soap_serialize_tt__FocusOptions20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusOptions20(struct soap *soap, const char *tag, int id, struct tt__FocusOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusOptions20);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusOptions20 ** SOAP_FMAC4 soap_in_PointerTott__FocusOptions20(struct soap *soap, const char *tag, struct tt__FocusOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusOptions20 **)soap_malloc(soap, sizeof(struct tt__FocusOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusOptions20, sizeof(struct tt__FocusOptions20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusOptions20(struct soap *soap, struct tt__FocusOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusOptions20);
	if (soap_out_PointerTott__FocusOptions20(soap, tag?tag:"tt:FocusOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusOptions20 ** SOAP_FMAC4 soap_get_PointerTott__FocusOptions20(struct soap *soap, struct tt__FocusOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ExposureOptions20(struct soap *soap, struct tt__ExposureOptions20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ExposureOptions20))
		soap_serialize_tt__ExposureOptions20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ExposureOptions20(struct soap *soap, const char *tag, int id, struct tt__ExposureOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ExposureOptions20);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ExposureOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ExposureOptions20 ** SOAP_FMAC4 soap_in_PointerTott__ExposureOptions20(struct soap *soap, const char *tag, struct tt__ExposureOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ExposureOptions20 **)soap_malloc(soap, sizeof(struct tt__ExposureOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ExposureOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ExposureOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposureOptions20, sizeof(struct tt__ExposureOptions20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ExposureOptions20(struct soap *soap, struct tt__ExposureOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ExposureOptions20);
	if (soap_out_PointerTott__ExposureOptions20(soap, tag?tag:"tt:ExposureOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ExposureOptions20 ** SOAP_FMAC4 soap_get_PointerTott__ExposureOptions20(struct soap *soap, struct tt__ExposureOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ExposureOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensationOptions20(struct soap *soap, struct tt__BacklightCompensationOptions20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensationOptions20))
		soap_serialize_tt__BacklightCompensationOptions20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensationOptions20(struct soap *soap, const char *tag, int id, struct tt__BacklightCompensationOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensationOptions20);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BacklightCompensationOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions20 ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensationOptions20(struct soap *soap, const char *tag, struct tt__BacklightCompensationOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__BacklightCompensationOptions20 **)soap_malloc(soap, sizeof(struct tt__BacklightCompensationOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BacklightCompensationOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__BacklightCompensationOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensationOptions20, sizeof(struct tt__BacklightCompensationOptions20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensationOptions20(struct soap *soap, struct tt__BacklightCompensationOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__BacklightCompensationOptions20);
	if (soap_out_PointerTott__BacklightCompensationOptions20(soap, tag?tag:"tt:BacklightCompensationOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions20 ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensationOptions20(struct soap *soap, struct tt__BacklightCompensationOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensationOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilizationExtension(struct soap *soap, struct tt__ImageStabilizationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilizationExtension))
		soap_serialize_tt__ImageStabilizationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilizationExtension(struct soap *soap, const char *tag, int id, struct tt__ImageStabilizationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilizationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImageStabilizationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImageStabilizationExtension ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilizationExtension(struct soap *soap, const char *tag, struct tt__ImageStabilizationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImageStabilizationExtension **)soap_malloc(soap, sizeof(struct tt__ImageStabilizationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImageStabilizationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImageStabilizationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilizationExtension, sizeof(struct tt__ImageStabilizationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilizationExtension(struct soap *soap, struct tt__ImageStabilizationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImageStabilizationExtension);
	if (soap_out_PointerTott__ImageStabilizationExtension(soap, tag?tag:"tt:ImageStabilizationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImageStabilizationExtension ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilizationExtension(struct soap *soap, struct tt__ImageStabilizationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilizationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension202(struct soap *soap, struct tt__ImagingSettingsExtension202 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension202))
		soap_serialize_tt__ImagingSettingsExtension202(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension202(struct soap *soap, const char *tag, int id, struct tt__ImagingSettingsExtension202 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension202);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingSettingsExtension202(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension202 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension202(struct soap *soap, const char *tag, struct tt__ImagingSettingsExtension202 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingSettingsExtension202 **)soap_malloc(soap, sizeof(struct tt__ImagingSettingsExtension202 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingSettingsExtension202(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettingsExtension202 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension202, sizeof(struct tt__ImagingSettingsExtension202), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension202(struct soap *soap, struct tt__ImagingSettingsExtension202 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingSettingsExtension202);
	if (soap_out_PointerTott__ImagingSettingsExtension202(soap, tag?tag:"tt:ImagingSettingsExtension202", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension202 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension202(struct soap *soap, struct tt__ImagingSettingsExtension202 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension202(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImageStabilization(struct soap *soap, struct tt__ImageStabilization *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImageStabilization))
		soap_serialize_tt__ImageStabilization(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImageStabilization(struct soap *soap, const char *tag, int id, struct tt__ImageStabilization *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImageStabilization);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImageStabilization(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImageStabilization ** SOAP_FMAC4 soap_in_PointerTott__ImageStabilization(struct soap *soap, const char *tag, struct tt__ImageStabilization **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImageStabilization **)soap_malloc(soap, sizeof(struct tt__ImageStabilization *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImageStabilization(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImageStabilization **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImageStabilization, sizeof(struct tt__ImageStabilization), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImageStabilization(struct soap *soap, struct tt__ImageStabilization *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImageStabilization);
	if (soap_out_PointerTott__ImageStabilization(soap, tag?tag:"tt:ImageStabilization", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImageStabilization ** SOAP_FMAC4 soap_get_PointerTott__ImageStabilization(struct soap *soap, struct tt__ImageStabilization **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImageStabilization(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension20(struct soap *soap, struct tt__ImagingSettingsExtension20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension20))
		soap_serialize_tt__ImagingSettingsExtension20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension20(struct soap *soap, const char *tag, int id, struct tt__ImagingSettingsExtension20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension20);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingSettingsExtension20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension20(struct soap *soap, const char *tag, struct tt__ImagingSettingsExtension20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingSettingsExtension20 **)soap_malloc(soap, sizeof(struct tt__ImagingSettingsExtension20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingSettingsExtension20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettingsExtension20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension20, sizeof(struct tt__ImagingSettingsExtension20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension20(struct soap *soap, struct tt__ImagingSettingsExtension20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingSettingsExtension20);
	if (soap_out_PointerTott__ImagingSettingsExtension20(soap, tag?tag:"tt:ImagingSettingsExtension20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension20(struct soap *soap, struct tt__ImagingSettingsExtension20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance20(struct soap *soap, struct tt__WhiteBalance20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalance20))
		soap_serialize_tt__WhiteBalance20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance20(struct soap *soap, const char *tag, int id, struct tt__WhiteBalance20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalance20);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WhiteBalance20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WhiteBalance20 ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance20(struct soap *soap, const char *tag, struct tt__WhiteBalance20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WhiteBalance20 **)soap_malloc(soap, sizeof(struct tt__WhiteBalance20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WhiteBalance20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalance20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance20, sizeof(struct tt__WhiteBalance20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance20(struct soap *soap, struct tt__WhiteBalance20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WhiteBalance20);
	if (soap_out_PointerTott__WhiteBalance20(soap, tag?tag:"tt:WhiteBalance20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalance20 ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance20(struct soap *soap, struct tt__WhiteBalance20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalance20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRange20(struct soap *soap, struct tt__WideDynamicRange20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicRange20))
		soap_serialize_tt__WideDynamicRange20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRange20(struct soap *soap, const char *tag, int id, struct tt__WideDynamicRange20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicRange20);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WideDynamicRange20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WideDynamicRange20 ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRange20(struct soap *soap, const char *tag, struct tt__WideDynamicRange20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WideDynamicRange20 **)soap_malloc(soap, sizeof(struct tt__WideDynamicRange20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WideDynamicRange20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WideDynamicRange20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRange20, sizeof(struct tt__WideDynamicRange20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRange20(struct soap *soap, struct tt__WideDynamicRange20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WideDynamicRange20);
	if (soap_out_PointerTott__WideDynamicRange20(soap, tag?tag:"tt:WideDynamicRange20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WideDynamicRange20 ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRange20(struct soap *soap, struct tt__WideDynamicRange20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicRange20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration20(struct soap *soap, struct tt__FocusConfiguration20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusConfiguration20))
		soap_serialize_tt__FocusConfiguration20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration20(struct soap *soap, const char *tag, int id, struct tt__FocusConfiguration20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusConfiguration20);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusConfiguration20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusConfiguration20 ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration20(struct soap *soap, const char *tag, struct tt__FocusConfiguration20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusConfiguration20 **)soap_malloc(soap, sizeof(struct tt__FocusConfiguration20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusConfiguration20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusConfiguration20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration20, sizeof(struct tt__FocusConfiguration20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration20(struct soap *soap, struct tt__FocusConfiguration20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusConfiguration20);
	if (soap_out_PointerTott__FocusConfiguration20(soap, tag?tag:"tt:FocusConfiguration20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusConfiguration20 ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration20(struct soap *soap, struct tt__FocusConfiguration20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusConfiguration20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Exposure20(struct soap *soap, struct tt__Exposure20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Exposure20))
		soap_serialize_tt__Exposure20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Exposure20(struct soap *soap, const char *tag, int id, struct tt__Exposure20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Exposure20);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Exposure20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Exposure20 ** SOAP_FMAC4 soap_in_PointerTott__Exposure20(struct soap *soap, const char *tag, struct tt__Exposure20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Exposure20 **)soap_malloc(soap, sizeof(struct tt__Exposure20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Exposure20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Exposure20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Exposure20, sizeof(struct tt__Exposure20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Exposure20(struct soap *soap, struct tt__Exposure20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Exposure20);
	if (soap_out_PointerTott__Exposure20(soap, tag?tag:"tt:Exposure20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Exposure20 ** SOAP_FMAC4 soap_get_PointerTott__Exposure20(struct soap *soap, struct tt__Exposure20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Exposure20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensation20(struct soap *soap, struct tt__BacklightCompensation20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensation20))
		soap_serialize_tt__BacklightCompensation20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensation20(struct soap *soap, const char *tag, int id, struct tt__BacklightCompensation20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensation20);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BacklightCompensation20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__BacklightCompensation20 ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensation20(struct soap *soap, const char *tag, struct tt__BacklightCompensation20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__BacklightCompensation20 **)soap_malloc(soap, sizeof(struct tt__BacklightCompensation20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BacklightCompensation20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__BacklightCompensation20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensation20, sizeof(struct tt__BacklightCompensation20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensation20(struct soap *soap, struct tt__BacklightCompensation20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__BacklightCompensation20);
	if (soap_out_PointerTott__BacklightCompensation20(soap, tag?tag:"tt:BacklightCompensation20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BacklightCompensation20 ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensation20(struct soap *soap, struct tt__BacklightCompensation20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensation20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusStatus20Extension(struct soap *soap, struct tt__FocusStatus20Extension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusStatus20Extension))
		soap_serialize_tt__FocusStatus20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusStatus20Extension(struct soap *soap, const char *tag, int id, struct tt__FocusStatus20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusStatus20Extension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusStatus20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusStatus20Extension ** SOAP_FMAC4 soap_in_PointerTott__FocusStatus20Extension(struct soap *soap, const char *tag, struct tt__FocusStatus20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusStatus20Extension **)soap_malloc(soap, sizeof(struct tt__FocusStatus20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusStatus20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusStatus20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusStatus20Extension, sizeof(struct tt__FocusStatus20Extension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusStatus20Extension(struct soap *soap, struct tt__FocusStatus20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusStatus20Extension);
	if (soap_out_PointerTott__FocusStatus20Extension(soap, tag?tag:"tt:FocusStatus20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusStatus20Extension ** SOAP_FMAC4 soap_get_PointerTott__FocusStatus20Extension(struct soap *soap, struct tt__FocusStatus20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingStatus20Extension(struct soap *soap, struct tt__ImagingStatus20Extension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingStatus20Extension))
		soap_serialize_tt__ImagingStatus20Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingStatus20Extension(struct soap *soap, const char *tag, int id, struct tt__ImagingStatus20Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingStatus20Extension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingStatus20Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingStatus20Extension ** SOAP_FMAC4 soap_in_PointerTott__ImagingStatus20Extension(struct soap *soap, const char *tag, struct tt__ImagingStatus20Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingStatus20Extension **)soap_malloc(soap, sizeof(struct tt__ImagingStatus20Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingStatus20Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingStatus20Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingStatus20Extension, sizeof(struct tt__ImagingStatus20Extension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingStatus20Extension(struct soap *soap, struct tt__ImagingStatus20Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingStatus20Extension);
	if (soap_out_PointerTott__ImagingStatus20Extension(soap, tag?tag:"tt:ImagingStatus20Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingStatus20Extension ** SOAP_FMAC4 soap_get_PointerTott__ImagingStatus20Extension(struct soap *soap, struct tt__ImagingStatus20Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingStatus20Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusStatus20(struct soap *soap, struct tt__FocusStatus20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusStatus20))
		soap_serialize_tt__FocusStatus20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusStatus20(struct soap *soap, const char *tag, int id, struct tt__FocusStatus20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusStatus20);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusStatus20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusStatus20 ** SOAP_FMAC4 soap_in_PointerTott__FocusStatus20(struct soap *soap, const char *tag, struct tt__FocusStatus20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusStatus20 **)soap_malloc(soap, sizeof(struct tt__FocusStatus20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusStatus20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusStatus20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusStatus20, sizeof(struct tt__FocusStatus20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusStatus20(struct soap *soap, struct tt__FocusStatus20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusStatus20);
	if (soap_out_PointerTott__FocusStatus20(soap, tag?tag:"tt:FocusStatus20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusStatus20 ** SOAP_FMAC4 soap_get_PointerTott__FocusStatus20(struct soap *soap, struct tt__FocusStatus20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ContinuousFocusOptions(struct soap *soap, struct tt__ContinuousFocusOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ContinuousFocusOptions))
		soap_serialize_tt__ContinuousFocusOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ContinuousFocusOptions(struct soap *soap, const char *tag, int id, struct tt__ContinuousFocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ContinuousFocusOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ContinuousFocusOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ContinuousFocusOptions ** SOAP_FMAC4 soap_in_PointerTott__ContinuousFocusOptions(struct soap *soap, const char *tag, struct tt__ContinuousFocusOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ContinuousFocusOptions **)soap_malloc(soap, sizeof(struct tt__ContinuousFocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ContinuousFocusOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ContinuousFocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ContinuousFocusOptions, sizeof(struct tt__ContinuousFocusOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ContinuousFocusOptions(struct soap *soap, struct tt__ContinuousFocusOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ContinuousFocusOptions);
	if (soap_out_PointerTott__ContinuousFocusOptions(soap, tag?tag:"tt:ContinuousFocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ContinuousFocusOptions ** SOAP_FMAC4 soap_get_PointerTott__ContinuousFocusOptions(struct soap *soap, struct tt__ContinuousFocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ContinuousFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelativeFocusOptions(struct soap *soap, struct tt__RelativeFocusOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelativeFocusOptions))
		soap_serialize_tt__RelativeFocusOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelativeFocusOptions(struct soap *soap, const char *tag, int id, struct tt__RelativeFocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelativeFocusOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RelativeFocusOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions ** SOAP_FMAC4 soap_in_PointerTott__RelativeFocusOptions(struct soap *soap, const char *tag, struct tt__RelativeFocusOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RelativeFocusOptions **)soap_malloc(soap, sizeof(struct tt__RelativeFocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RelativeFocusOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RelativeFocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelativeFocusOptions, sizeof(struct tt__RelativeFocusOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelativeFocusOptions(struct soap *soap, struct tt__RelativeFocusOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RelativeFocusOptions);
	if (soap_out_PointerTott__RelativeFocusOptions(soap, tag?tag:"tt:RelativeFocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelativeFocusOptions ** SOAP_FMAC4 soap_get_PointerTott__RelativeFocusOptions(struct soap *soap, struct tt__RelativeFocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelativeFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AbsoluteFocusOptions(struct soap *soap, struct tt__AbsoluteFocusOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AbsoluteFocusOptions))
		soap_serialize_tt__AbsoluteFocusOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AbsoluteFocusOptions(struct soap *soap, const char *tag, int id, struct tt__AbsoluteFocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AbsoluteFocusOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AbsoluteFocusOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AbsoluteFocusOptions ** SOAP_FMAC4 soap_in_PointerTott__AbsoluteFocusOptions(struct soap *soap, const char *tag, struct tt__AbsoluteFocusOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AbsoluteFocusOptions **)soap_malloc(soap, sizeof(struct tt__AbsoluteFocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AbsoluteFocusOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AbsoluteFocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AbsoluteFocusOptions, sizeof(struct tt__AbsoluteFocusOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AbsoluteFocusOptions(struct soap *soap, struct tt__AbsoluteFocusOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AbsoluteFocusOptions);
	if (soap_out_PointerTott__AbsoluteFocusOptions(soap, tag?tag:"tt:AbsoluteFocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AbsoluteFocusOptions ** SOAP_FMAC4 soap_get_PointerTott__AbsoluteFocusOptions(struct soap *soap, struct tt__AbsoluteFocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AbsoluteFocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ContinuousFocus(struct soap *soap, struct tt__ContinuousFocus *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ContinuousFocus))
		soap_serialize_tt__ContinuousFocus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ContinuousFocus(struct soap *soap, const char *tag, int id, struct tt__ContinuousFocus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ContinuousFocus);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ContinuousFocus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ContinuousFocus ** SOAP_FMAC4 soap_in_PointerTott__ContinuousFocus(struct soap *soap, const char *tag, struct tt__ContinuousFocus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ContinuousFocus **)soap_malloc(soap, sizeof(struct tt__ContinuousFocus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ContinuousFocus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ContinuousFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ContinuousFocus, sizeof(struct tt__ContinuousFocus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ContinuousFocus(struct soap *soap, struct tt__ContinuousFocus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ContinuousFocus);
	if (soap_out_PointerTott__ContinuousFocus(soap, tag?tag:"tt:ContinuousFocus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ContinuousFocus ** SOAP_FMAC4 soap_get_PointerTott__ContinuousFocus(struct soap *soap, struct tt__ContinuousFocus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ContinuousFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelativeFocus(struct soap *soap, struct tt__RelativeFocus *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelativeFocus))
		soap_serialize_tt__RelativeFocus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelativeFocus(struct soap *soap, const char *tag, int id, struct tt__RelativeFocus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelativeFocus);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RelativeFocus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RelativeFocus ** SOAP_FMAC4 soap_in_PointerTott__RelativeFocus(struct soap *soap, const char *tag, struct tt__RelativeFocus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RelativeFocus **)soap_malloc(soap, sizeof(struct tt__RelativeFocus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RelativeFocus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RelativeFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelativeFocus, sizeof(struct tt__RelativeFocus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelativeFocus(struct soap *soap, struct tt__RelativeFocus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RelativeFocus);
	if (soap_out_PointerTott__RelativeFocus(soap, tag?tag:"tt:RelativeFocus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelativeFocus ** SOAP_FMAC4 soap_get_PointerTott__RelativeFocus(struct soap *soap, struct tt__RelativeFocus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelativeFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AbsoluteFocus(struct soap *soap, struct tt__AbsoluteFocus *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AbsoluteFocus))
		soap_serialize_tt__AbsoluteFocus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AbsoluteFocus(struct soap *soap, const char *tag, int id, struct tt__AbsoluteFocus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AbsoluteFocus);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AbsoluteFocus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AbsoluteFocus ** SOAP_FMAC4 soap_in_PointerTott__AbsoluteFocus(struct soap *soap, const char *tag, struct tt__AbsoluteFocus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AbsoluteFocus **)soap_malloc(soap, sizeof(struct tt__AbsoluteFocus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AbsoluteFocus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AbsoluteFocus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AbsoluteFocus, sizeof(struct tt__AbsoluteFocus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AbsoluteFocus(struct soap *soap, struct tt__AbsoluteFocus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AbsoluteFocus);
	if (soap_out_PointerTott__AbsoluteFocus(soap, tag?tag:"tt:AbsoluteFocus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AbsoluteFocus ** SOAP_FMAC4 soap_get_PointerTott__AbsoluteFocus(struct soap *soap, struct tt__AbsoluteFocus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AbsoluteFocus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalanceMode(struct soap *soap, enum tt__WhiteBalanceMode *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalanceMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalanceMode(struct soap *soap, const char *tag, int id, enum tt__WhiteBalanceMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalanceMode);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WhiteBalanceMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__WhiteBalanceMode ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalanceMode(struct soap *soap, const char *tag, enum tt__WhiteBalanceMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__WhiteBalanceMode **)soap_malloc(soap, sizeof(enum tt__WhiteBalanceMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WhiteBalanceMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__WhiteBalanceMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceMode, sizeof(enum tt__WhiteBalanceMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalanceMode(struct soap *soap, enum tt__WhiteBalanceMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WhiteBalanceMode);
	if (soap_out_PointerTott__WhiteBalanceMode(soap, tag?tag:"tt:WhiteBalanceMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__WhiteBalanceMode ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalanceMode(struct soap *soap, enum tt__WhiteBalanceMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalanceMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ExposurePriority(struct soap *soap, enum tt__ExposurePriority *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__ExposurePriority);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ExposurePriority(struct soap *soap, const char *tag, int id, enum tt__ExposurePriority *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ExposurePriority);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ExposurePriority(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__ExposurePriority ** SOAP_FMAC4 soap_in_PointerTott__ExposurePriority(struct soap *soap, const char *tag, enum tt__ExposurePriority **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__ExposurePriority **)soap_malloc(soap, sizeof(enum tt__ExposurePriority *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ExposurePriority(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__ExposurePriority **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposurePriority, sizeof(enum tt__ExposurePriority), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ExposurePriority(struct soap *soap, enum tt__ExposurePriority *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ExposurePriority);
	if (soap_out_PointerTott__ExposurePriority(soap, tag?tag:"tt:ExposurePriority", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ExposurePriority ** SOAP_FMAC4 soap_get_PointerTott__ExposurePriority(struct soap *soap, enum tt__ExposurePriority **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ExposurePriority(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ExposureMode(struct soap *soap, enum tt__ExposureMode *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__ExposureMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ExposureMode(struct soap *soap, const char *tag, int id, enum tt__ExposureMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ExposureMode);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ExposureMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__ExposureMode ** SOAP_FMAC4 soap_in_PointerTott__ExposureMode(struct soap *soap, const char *tag, enum tt__ExposureMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__ExposureMode **)soap_malloc(soap, sizeof(enum tt__ExposureMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ExposureMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__ExposureMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposureMode, sizeof(enum tt__ExposureMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ExposureMode(struct soap *soap, enum tt__ExposureMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ExposureMode);
	if (soap_out_PointerTott__ExposureMode(soap, tag?tag:"tt:ExposureMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ExposureMode ** SOAP_FMAC4 soap_get_PointerTott__ExposureMode(struct soap *soap, enum tt__ExposureMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ExposureMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AutoFocusMode(struct soap *soap, enum tt__AutoFocusMode *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__AutoFocusMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AutoFocusMode(struct soap *soap, const char *tag, int id, enum tt__AutoFocusMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AutoFocusMode);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AutoFocusMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__AutoFocusMode ** SOAP_FMAC4 soap_in_PointerTott__AutoFocusMode(struct soap *soap, const char *tag, enum tt__AutoFocusMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__AutoFocusMode **)soap_malloc(soap, sizeof(enum tt__AutoFocusMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AutoFocusMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__AutoFocusMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AutoFocusMode, sizeof(enum tt__AutoFocusMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AutoFocusMode(struct soap *soap, enum tt__AutoFocusMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AutoFocusMode);
	if (soap_out_PointerTott__AutoFocusMode(soap, tag?tag:"tt:AutoFocusMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__AutoFocusMode ** SOAP_FMAC4 soap_get_PointerTott__AutoFocusMode(struct soap *soap, enum tt__AutoFocusMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AutoFocusMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicMode(struct soap *soap, enum tt__WideDynamicMode *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicMode(struct soap *soap, const char *tag, int id, enum tt__WideDynamicMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicMode);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WideDynamicMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__WideDynamicMode ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicMode(struct soap *soap, const char *tag, enum tt__WideDynamicMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__WideDynamicMode **)soap_malloc(soap, sizeof(enum tt__WideDynamicMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WideDynamicMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__WideDynamicMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicMode, sizeof(enum tt__WideDynamicMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicMode(struct soap *soap, enum tt__WideDynamicMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WideDynamicMode);
	if (soap_out_PointerTott__WideDynamicMode(soap, tag?tag:"tt:WideDynamicMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__WideDynamicMode ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicMode(struct soap *soap, enum tt__WideDynamicMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalanceOptions(struct soap *soap, struct tt__WhiteBalanceOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalanceOptions))
		soap_serialize_tt__WhiteBalanceOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalanceOptions(struct soap *soap, const char *tag, int id, struct tt__WhiteBalanceOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalanceOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WhiteBalanceOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalanceOptions(struct soap *soap, const char *tag, struct tt__WhiteBalanceOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WhiteBalanceOptions **)soap_malloc(soap, sizeof(struct tt__WhiteBalanceOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WhiteBalanceOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalanceOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalanceOptions, sizeof(struct tt__WhiteBalanceOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalanceOptions(struct soap *soap, struct tt__WhiteBalanceOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WhiteBalanceOptions);
	if (soap_out_PointerTott__WhiteBalanceOptions(soap, tag?tag:"tt:WhiteBalanceOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalanceOptions ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalanceOptions(struct soap *soap, struct tt__WhiteBalanceOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalanceOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRangeOptions(struct soap *soap, struct tt__WideDynamicRangeOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicRangeOptions))
		soap_serialize_tt__WideDynamicRangeOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRangeOptions(struct soap *soap, const char *tag, int id, struct tt__WideDynamicRangeOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicRangeOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WideDynamicRangeOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRangeOptions(struct soap *soap, const char *tag, struct tt__WideDynamicRangeOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WideDynamicRangeOptions **)soap_malloc(soap, sizeof(struct tt__WideDynamicRangeOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WideDynamicRangeOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WideDynamicRangeOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRangeOptions, sizeof(struct tt__WideDynamicRangeOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRangeOptions(struct soap *soap, struct tt__WideDynamicRangeOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WideDynamicRangeOptions);
	if (soap_out_PointerTott__WideDynamicRangeOptions(soap, tag?tag:"tt:WideDynamicRangeOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WideDynamicRangeOptions ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRangeOptions(struct soap *soap, struct tt__WideDynamicRangeOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicRangeOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusOptions(struct soap *soap, struct tt__FocusOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusOptions))
		soap_serialize_tt__FocusOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusOptions(struct soap *soap, const char *tag, int id, struct tt__FocusOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusOptions ** SOAP_FMAC4 soap_in_PointerTott__FocusOptions(struct soap *soap, const char *tag, struct tt__FocusOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusOptions **)soap_malloc(soap, sizeof(struct tt__FocusOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusOptions, sizeof(struct tt__FocusOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusOptions(struct soap *soap, struct tt__FocusOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusOptions);
	if (soap_out_PointerTott__FocusOptions(soap, tag?tag:"tt:FocusOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusOptions ** SOAP_FMAC4 soap_get_PointerTott__FocusOptions(struct soap *soap, struct tt__FocusOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ExposureOptions(struct soap *soap, struct tt__ExposureOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ExposureOptions))
		soap_serialize_tt__ExposureOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ExposureOptions(struct soap *soap, const char *tag, int id, struct tt__ExposureOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ExposureOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ExposureOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ExposureOptions ** SOAP_FMAC4 soap_in_PointerTott__ExposureOptions(struct soap *soap, const char *tag, struct tt__ExposureOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ExposureOptions **)soap_malloc(soap, sizeof(struct tt__ExposureOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ExposureOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ExposureOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ExposureOptions, sizeof(struct tt__ExposureOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ExposureOptions(struct soap *soap, struct tt__ExposureOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ExposureOptions);
	if (soap_out_PointerTott__ExposureOptions(soap, tag?tag:"tt:ExposureOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ExposureOptions ** SOAP_FMAC4 soap_get_PointerTott__ExposureOptions(struct soap *soap, struct tt__ExposureOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ExposureOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensationOptions(struct soap *soap, struct tt__BacklightCompensationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensationOptions))
		soap_serialize_tt__BacklightCompensationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensationOptions(struct soap *soap, const char *tag, int id, struct tt__BacklightCompensationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensationOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BacklightCompensationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensationOptions(struct soap *soap, const char *tag, struct tt__BacklightCompensationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__BacklightCompensationOptions **)soap_malloc(soap, sizeof(struct tt__BacklightCompensationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BacklightCompensationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__BacklightCompensationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensationOptions, sizeof(struct tt__BacklightCompensationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensationOptions(struct soap *soap, struct tt__BacklightCompensationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__BacklightCompensationOptions);
	if (soap_out_PointerTott__BacklightCompensationOptions(soap, tag?tag:"tt:BacklightCompensationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BacklightCompensationOptions ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensationOptions(struct soap *soap, struct tt__BacklightCompensationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Rectangle(struct soap *soap, struct tt__Rectangle *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Rectangle))
		soap_serialize_tt__Rectangle(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Rectangle(struct soap *soap, const char *tag, int id, struct tt__Rectangle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Rectangle);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Rectangle(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Rectangle ** SOAP_FMAC4 soap_in_PointerTott__Rectangle(struct soap *soap, const char *tag, struct tt__Rectangle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Rectangle **)soap_malloc(soap, sizeof(struct tt__Rectangle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Rectangle(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Rectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Rectangle, sizeof(struct tt__Rectangle), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Rectangle(struct soap *soap, struct tt__Rectangle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Rectangle);
	if (soap_out_PointerTott__Rectangle(soap, tag?tag:"tt:Rectangle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Rectangle ** SOAP_FMAC4 soap_get_PointerTott__Rectangle(struct soap *soap, struct tt__Rectangle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Rectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettingsExtension(struct soap *soap, struct tt__ImagingSettingsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettingsExtension))
		soap_serialize_tt__ImagingSettingsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettingsExtension(struct soap *soap, const char *tag, int id, struct tt__ImagingSettingsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettingsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingSettingsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettingsExtension(struct soap *soap, const char *tag, struct tt__ImagingSettingsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingSettingsExtension **)soap_malloc(soap, sizeof(struct tt__ImagingSettingsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingSettingsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettingsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettingsExtension, sizeof(struct tt__ImagingSettingsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettingsExtension(struct soap *soap, struct tt__ImagingSettingsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingSettingsExtension);
	if (soap_out_PointerTott__ImagingSettingsExtension(soap, tag?tag:"tt:ImagingSettingsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettingsExtension ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettingsExtension(struct soap *soap, struct tt__ImagingSettingsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettingsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WhiteBalance(struct soap *soap, struct tt__WhiteBalance *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WhiteBalance))
		soap_serialize_tt__WhiteBalance(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WhiteBalance(struct soap *soap, const char *tag, int id, struct tt__WhiteBalance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WhiteBalance);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WhiteBalance(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WhiteBalance ** SOAP_FMAC4 soap_in_PointerTott__WhiteBalance(struct soap *soap, const char *tag, struct tt__WhiteBalance **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WhiteBalance **)soap_malloc(soap, sizeof(struct tt__WhiteBalance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WhiteBalance(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WhiteBalance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WhiteBalance, sizeof(struct tt__WhiteBalance), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WhiteBalance(struct soap *soap, struct tt__WhiteBalance *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WhiteBalance);
	if (soap_out_PointerTott__WhiteBalance(soap, tag?tag:"tt:WhiteBalance", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WhiteBalance ** SOAP_FMAC4 soap_get_PointerTott__WhiteBalance(struct soap *soap, struct tt__WhiteBalance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WhiteBalance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__WideDynamicRange(struct soap *soap, struct tt__WideDynamicRange *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__WideDynamicRange))
		soap_serialize_tt__WideDynamicRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__WideDynamicRange(struct soap *soap, const char *tag, int id, struct tt__WideDynamicRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__WideDynamicRange);
	if (id < 0)
		return soap->error;
	return soap_out_tt__WideDynamicRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__WideDynamicRange ** SOAP_FMAC4 soap_in_PointerTott__WideDynamicRange(struct soap *soap, const char *tag, struct tt__WideDynamicRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__WideDynamicRange **)soap_malloc(soap, sizeof(struct tt__WideDynamicRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__WideDynamicRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__WideDynamicRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__WideDynamicRange, sizeof(struct tt__WideDynamicRange), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__WideDynamicRange(struct soap *soap, struct tt__WideDynamicRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__WideDynamicRange);
	if (soap_out_PointerTott__WideDynamicRange(soap, tag?tag:"tt:WideDynamicRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__WideDynamicRange ** SOAP_FMAC4 soap_get_PointerTott__WideDynamicRange(struct soap *soap, struct tt__WideDynamicRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__WideDynamicRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__IrCutFilterMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IrCutFilterMode(struct soap *soap, const char *tag, int id, enum tt__IrCutFilterMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IrCutFilterMode);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IrCutFilterMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__IrCutFilterMode ** SOAP_FMAC4 soap_in_PointerTott__IrCutFilterMode(struct soap *soap, const char *tag, enum tt__IrCutFilterMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__IrCutFilterMode **)soap_malloc(soap, sizeof(enum tt__IrCutFilterMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IrCutFilterMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__IrCutFilterMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IrCutFilterMode, sizeof(enum tt__IrCutFilterMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IrCutFilterMode);
	if (soap_out_PointerTott__IrCutFilterMode(soap, tag?tag:"tt:IrCutFilterMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IrCutFilterMode ** SOAP_FMAC4 soap_get_PointerTott__IrCutFilterMode(struct soap *soap, enum tt__IrCutFilterMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IrCutFilterMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusConfiguration(struct soap *soap, struct tt__FocusConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusConfiguration))
		soap_serialize_tt__FocusConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusConfiguration(struct soap *soap, const char *tag, int id, struct tt__FocusConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusConfiguration ** SOAP_FMAC4 soap_in_PointerTott__FocusConfiguration(struct soap *soap, const char *tag, struct tt__FocusConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusConfiguration **)soap_malloc(soap, sizeof(struct tt__FocusConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusConfiguration, sizeof(struct tt__FocusConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusConfiguration(struct soap *soap, struct tt__FocusConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusConfiguration);
	if (soap_out_PointerTott__FocusConfiguration(soap, tag?tag:"tt:FocusConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusConfiguration ** SOAP_FMAC4 soap_get_PointerTott__FocusConfiguration(struct soap *soap, struct tt__FocusConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Exposure(struct soap *soap, struct tt__Exposure *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Exposure))
		soap_serialize_tt__Exposure(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Exposure(struct soap *soap, const char *tag, int id, struct tt__Exposure *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Exposure);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Exposure(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Exposure ** SOAP_FMAC4 soap_in_PointerTott__Exposure(struct soap *soap, const char *tag, struct tt__Exposure **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Exposure **)soap_malloc(soap, sizeof(struct tt__Exposure *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Exposure(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Exposure **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Exposure, sizeof(struct tt__Exposure), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Exposure(struct soap *soap, struct tt__Exposure *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Exposure);
	if (soap_out_PointerTott__Exposure(soap, tag?tag:"tt:Exposure", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Exposure ** SOAP_FMAC4 soap_get_PointerTott__Exposure(struct soap *soap, struct tt__Exposure **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Exposure(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BacklightCompensation(struct soap *soap, struct tt__BacklightCompensation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BacklightCompensation))
		soap_serialize_tt__BacklightCompensation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BacklightCompensation(struct soap *soap, const char *tag, int id, struct tt__BacklightCompensation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BacklightCompensation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BacklightCompensation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__BacklightCompensation ** SOAP_FMAC4 soap_in_PointerTott__BacklightCompensation(struct soap *soap, const char *tag, struct tt__BacklightCompensation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__BacklightCompensation **)soap_malloc(soap, sizeof(struct tt__BacklightCompensation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BacklightCompensation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__BacklightCompensation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BacklightCompensation, sizeof(struct tt__BacklightCompensation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BacklightCompensation(struct soap *soap, struct tt__BacklightCompensation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__BacklightCompensation);
	if (soap_out_PointerTott__BacklightCompensation(soap, tag?tag:"tt:BacklightCompensation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BacklightCompensation ** SOAP_FMAC4 soap_get_PointerTott__BacklightCompensation(struct soap *soap, struct tt__BacklightCompensation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BacklightCompensation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusStatus(struct soap *soap, struct tt__FocusStatus *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusStatus))
		soap_serialize_tt__FocusStatus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusStatus(struct soap *soap, const char *tag, int id, struct tt__FocusStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusStatus);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusStatus ** SOAP_FMAC4 soap_in_PointerTott__FocusStatus(struct soap *soap, const char *tag, struct tt__FocusStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusStatus **)soap_malloc(soap, sizeof(struct tt__FocusStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusStatus, sizeof(struct tt__FocusStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusStatus(struct soap *soap, struct tt__FocusStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusStatus);
	if (soap_out_PointerTott__FocusStatus(soap, tag?tag:"tt:FocusStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusStatus ** SOAP_FMAC4 soap_get_PointerTott__FocusStatus(struct soap *soap, struct tt__FocusStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, struct tt__PTZPresetTourStartingConditionOptionsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension))
		soap_serialize_tt__PTZPresetTourStartingConditionOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourStartingConditionOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourStartingConditionOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourStartingConditionOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourStartingConditionOptionsExtension **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourStartingConditionOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourStartingConditionOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStartingConditionOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptionsExtension, sizeof(struct tt__PTZPresetTourStartingConditionOptionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, struct tt__PTZPresetTourStartingConditionOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionOptionsExtension);
	if (soap_out_PointerTott__PTZPresetTourStartingConditionOptionsExtension(soap, tag?tag:"tt:PTZPresetTourStartingConditionOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourStartingConditionOptionsExtension(struct soap *soap, struct tt__PTZPresetTourStartingConditionOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourStartingConditionOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, struct tt__PTZPresetTourPresetDetailOptionsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension))
		soap_serialize_tt__PTZPresetTourPresetDetailOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourPresetDetailOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourPresetDetailOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetailOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourPresetDetailOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourPresetDetailOptionsExtension **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourPresetDetailOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourPresetDetailOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourPresetDetailOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptionsExtension, sizeof(struct tt__PTZPresetTourPresetDetailOptionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, struct tt__PTZPresetTourPresetDetailOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourPresetDetailOptionsExtension);
	if (soap_out_PointerTott__PTZPresetTourPresetDetailOptionsExtension(soap, tag?tag:"tt:PTZPresetTourPresetDetailOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetailOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourPresetDetailOptionsExtension(struct soap *soap, struct tt__PTZPresetTourPresetDetailOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourPresetDetailOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourPresetDetailOptions(struct soap *soap, struct tt__PTZPresetTourPresetDetailOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions))
		soap_serialize_tt__PTZPresetTourPresetDetailOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourPresetDetailOptions(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourPresetDetailOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourPresetDetailOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetailOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourPresetDetailOptions(struct soap *soap, const char *tag, struct tt__PTZPresetTourPresetDetailOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourPresetDetailOptions **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourPresetDetailOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourPresetDetailOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourPresetDetailOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourPresetDetailOptions, sizeof(struct tt__PTZPresetTourPresetDetailOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourPresetDetailOptions(struct soap *soap, struct tt__PTZPresetTourPresetDetailOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourPresetDetailOptions);
	if (soap_out_PointerTott__PTZPresetTourPresetDetailOptions(soap, tag?tag:"tt:PTZPresetTourPresetDetailOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetailOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourPresetDetailOptions(struct soap *soap, struct tt__PTZPresetTourPresetDetailOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourPresetDetailOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourSpotOptions(struct soap *soap, struct tt__PTZPresetTourSpotOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourSpotOptions))
		soap_serialize_tt__PTZPresetTourSpotOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourSpotOptions(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourSpotOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourSpotOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourSpotOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpotOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourSpotOptions(struct soap *soap, const char *tag, struct tt__PTZPresetTourSpotOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourSpotOptions **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourSpotOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourSpotOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourSpotOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSpotOptions, sizeof(struct tt__PTZPresetTourSpotOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourSpotOptions(struct soap *soap, struct tt__PTZPresetTourSpotOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourSpotOptions);
	if (soap_out_PointerTott__PTZPresetTourSpotOptions(soap, tag?tag:"tt:PTZPresetTourSpotOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpotOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourSpotOptions(struct soap *soap, struct tt__PTZPresetTourSpotOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourSpotOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourStartingConditionOptions(struct soap *soap, struct tt__PTZPresetTourStartingConditionOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions))
		soap_serialize_tt__PTZPresetTourStartingConditionOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourStartingConditionOptions(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourStartingConditionOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourStartingConditionOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourStartingConditionOptions(struct soap *soap, const char *tag, struct tt__PTZPresetTourStartingConditionOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourStartingConditionOptions **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourStartingConditionOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourStartingConditionOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStartingConditionOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStartingConditionOptions, sizeof(struct tt__PTZPresetTourStartingConditionOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourStartingConditionOptions(struct soap *soap, struct tt__PTZPresetTourStartingConditionOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionOptions);
	if (soap_out_PointerTott__PTZPresetTourStartingConditionOptions(soap, tag?tag:"tt:PTZPresetTourStartingConditionOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourStartingConditionOptions(struct soap *soap, struct tt__PTZPresetTourStartingConditionOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourStartingConditionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourStartingConditionExtension(struct soap *soap, struct tt__PTZPresetTourStartingConditionExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension))
		soap_serialize_tt__PTZPresetTourStartingConditionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourStartingConditionExtension(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourStartingConditionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourStartingConditionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourStartingConditionExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourStartingConditionExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourStartingConditionExtension **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourStartingConditionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourStartingConditionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStartingConditionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStartingConditionExtension, sizeof(struct tt__PTZPresetTourStartingConditionExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourStartingConditionExtension(struct soap *soap, struct tt__PTZPresetTourStartingConditionExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourStartingConditionExtension);
	if (soap_out_PointerTott__PTZPresetTourStartingConditionExtension(soap, tag?tag:"tt:PTZPresetTourStartingConditionExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingConditionExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourStartingConditionExtension(struct soap *soap, struct tt__PTZPresetTourStartingConditionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourStartingConditionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourDirection(struct soap *soap, enum tt__PTZPresetTourDirection *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourDirection);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourDirection(struct soap *soap, const char *tag, int id, enum tt__PTZPresetTourDirection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourDirection);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourDirection(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__PTZPresetTourDirection ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourDirection(struct soap *soap, const char *tag, enum tt__PTZPresetTourDirection **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__PTZPresetTourDirection **)soap_malloc(soap, sizeof(enum tt__PTZPresetTourDirection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourDirection(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__PTZPresetTourDirection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourDirection, sizeof(enum tt__PTZPresetTourDirection), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourDirection(struct soap *soap, enum tt__PTZPresetTourDirection *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourDirection);
	if (soap_out_PointerTott__PTZPresetTourDirection(soap, tag?tag:"tt:PTZPresetTourDirection", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PTZPresetTourDirection ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourDirection(struct soap *soap, enum tt__PTZPresetTourDirection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourDirection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourStatusExtension(struct soap *soap, struct tt__PTZPresetTourStatusExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourStatusExtension))
		soap_serialize_tt__PTZPresetTourStatusExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourStatusExtension(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourStatusExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourStatusExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourStatusExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourStatusExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourStatusExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourStatusExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourStatusExtension **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourStatusExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourStatusExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStatusExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStatusExtension, sizeof(struct tt__PTZPresetTourStatusExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourStatusExtension(struct soap *soap, struct tt__PTZPresetTourStatusExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourStatusExtension);
	if (soap_out_PointerTott__PTZPresetTourStatusExtension(soap, tag?tag:"tt:PTZPresetTourStatusExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStatusExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourStatusExtension(struct soap *soap, struct tt__PTZPresetTourStatusExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourStatusExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourTypeExtension(struct soap *soap, struct tt__PTZPresetTourTypeExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourTypeExtension))
		soap_serialize_tt__PTZPresetTourTypeExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourTypeExtension(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourTypeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourTypeExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourTypeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourTypeExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourTypeExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourTypeExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourTypeExtension **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourTypeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourTypeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourTypeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourTypeExtension, sizeof(struct tt__PTZPresetTourTypeExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourTypeExtension(struct soap *soap, struct tt__PTZPresetTourTypeExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourTypeExtension);
	if (soap_out_PointerTott__PTZPresetTourTypeExtension(soap, tag?tag:"tt:PTZPresetTourTypeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourTypeExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourTypeExtension(struct soap *soap, struct tt__PTZPresetTourTypeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourTypeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourSpotExtension(struct soap *soap, struct tt__PTZPresetTourSpotExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourSpotExtension))
		soap_serialize_tt__PTZPresetTourSpotExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourSpotExtension(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourSpotExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourSpotExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourSpotExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpotExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourSpotExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourSpotExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourSpotExtension **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourSpotExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourSpotExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourSpotExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSpotExtension, sizeof(struct tt__PTZPresetTourSpotExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourSpotExtension(struct soap *soap, struct tt__PTZPresetTourSpotExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourSpotExtension);
	if (soap_out_PointerTott__PTZPresetTourSpotExtension(soap, tag?tag:"tt:PTZPresetTourSpotExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpotExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourSpotExtension(struct soap *soap, struct tt__PTZPresetTourSpotExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourSpotExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZSpeed(struct soap *soap, struct tt__PTZSpeed *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZSpeed))
		soap_serialize_tt__PTZSpeed(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZSpeed(struct soap *soap, const char *tag, int id, struct tt__PTZSpeed *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZSpeed);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZSpeed(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZSpeed ** SOAP_FMAC4 soap_in_PointerTott__PTZSpeed(struct soap *soap, const char *tag, struct tt__PTZSpeed **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZSpeed **)soap_malloc(soap, sizeof(struct tt__PTZSpeed *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZSpeed(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZSpeed **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZSpeed, sizeof(struct tt__PTZSpeed), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZSpeed(struct soap *soap, struct tt__PTZSpeed *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZSpeed);
	if (soap_out_PointerTott__PTZSpeed(soap, tag?tag:"tt:PTZSpeed", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZSpeed ** SOAP_FMAC4 soap_get_PointerTott__PTZSpeed(struct soap *soap, struct tt__PTZSpeed **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZSpeed(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourPresetDetail(struct soap *soap, struct tt__PTZPresetTourPresetDetail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourPresetDetail))
		soap_serialize_tt__PTZPresetTourPresetDetail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourPresetDetail(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourPresetDetail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourPresetDetail);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourPresetDetail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetail ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourPresetDetail(struct soap *soap, const char *tag, struct tt__PTZPresetTourPresetDetail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourPresetDetail **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourPresetDetail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourPresetDetail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourPresetDetail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourPresetDetail, sizeof(struct tt__PTZPresetTourPresetDetail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourPresetDetail(struct soap *soap, struct tt__PTZPresetTourPresetDetail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourPresetDetail);
	if (soap_out_PointerTott__PTZPresetTourPresetDetail(soap, tag?tag:"tt:PTZPresetTourPresetDetail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourPresetDetail ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourPresetDetail(struct soap *soap, struct tt__PTZPresetTourPresetDetail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourPresetDetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourExtension(struct soap *soap, struct tt__PTZPresetTourExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourExtension))
		soap_serialize_tt__PTZPresetTourExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourExtension(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourExtension **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourExtension, sizeof(struct tt__PTZPresetTourExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourExtension(struct soap *soap, struct tt__PTZPresetTourExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourExtension);
	if (soap_out_PointerTott__PTZPresetTourExtension(soap, tag?tag:"tt:PTZPresetTourExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourExtension(struct soap *soap, struct tt__PTZPresetTourExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourSpot(struct soap *soap, struct tt__PTZPresetTourSpot *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourSpot))
		soap_serialize_tt__PTZPresetTourSpot(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourSpot(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourSpot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourSpot);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourSpot(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpot ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourSpot(struct soap *soap, const char *tag, struct tt__PTZPresetTourSpot **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourSpot **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourSpot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourSpot(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourSpot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSpot, sizeof(struct tt__PTZPresetTourSpot), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourSpot(struct soap *soap, struct tt__PTZPresetTourSpot *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourSpot);
	if (soap_out_PointerTott__PTZPresetTourSpot(soap, tag?tag:"tt:PTZPresetTourSpot", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourSpot ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourSpot(struct soap *soap, struct tt__PTZPresetTourSpot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourSpot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourStartingCondition(struct soap *soap, struct tt__PTZPresetTourStartingCondition *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourStartingCondition))
		soap_serialize_tt__PTZPresetTourStartingCondition(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourStartingCondition(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourStartingCondition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourStartingCondition);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourStartingCondition(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingCondition ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourStartingCondition(struct soap *soap, const char *tag, struct tt__PTZPresetTourStartingCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourStartingCondition **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourStartingCondition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourStartingCondition(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStartingCondition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStartingCondition, sizeof(struct tt__PTZPresetTourStartingCondition), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourStartingCondition(struct soap *soap, struct tt__PTZPresetTourStartingCondition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourStartingCondition);
	if (soap_out_PointerTott__PTZPresetTourStartingCondition(soap, tag?tag:"tt:PTZPresetTourStartingCondition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStartingCondition ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourStartingCondition(struct soap *soap, struct tt__PTZPresetTourStartingCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourStartingCondition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourStatus(struct soap *soap, struct tt__PTZPresetTourStatus *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourStatus))
		soap_serialize_tt__PTZPresetTourStatus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourStatus(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourStatus);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourStatus ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourStatus(struct soap *soap, const char *tag, struct tt__PTZPresetTourStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourStatus **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourStatus, sizeof(struct tt__PTZPresetTourStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourStatus(struct soap *soap, struct tt__PTZPresetTourStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourStatus);
	if (soap_out_PointerTott__PTZPresetTourStatus(soap, tag?tag:"tt:PTZPresetTourStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourStatus ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourStatus(struct soap *soap, struct tt__PTZPresetTourStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MoveStatus(struct soap *soap, enum tt__MoveStatus *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__MoveStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MoveStatus(struct soap *soap, const char *tag, int id, enum tt__MoveStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MoveStatus);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MoveStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__MoveStatus ** SOAP_FMAC4 soap_in_PointerTott__MoveStatus(struct soap *soap, const char *tag, enum tt__MoveStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__MoveStatus **)soap_malloc(soap, sizeof(enum tt__MoveStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MoveStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__MoveStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MoveStatus, sizeof(enum tt__MoveStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MoveStatus(struct soap *soap, enum tt__MoveStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MoveStatus);
	if (soap_out_PointerTott__MoveStatus(soap, tag?tag:"tt:MoveStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__MoveStatus ** SOAP_FMAC4 soap_get_PointerTott__MoveStatus(struct soap *soap, enum tt__MoveStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZMoveStatus(struct soap *soap, struct tt__PTZMoveStatus *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZMoveStatus))
		soap_serialize_tt__PTZMoveStatus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZMoveStatus(struct soap *soap, const char *tag, int id, struct tt__PTZMoveStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZMoveStatus);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZMoveStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZMoveStatus ** SOAP_FMAC4 soap_in_PointerTott__PTZMoveStatus(struct soap *soap, const char *tag, struct tt__PTZMoveStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZMoveStatus **)soap_malloc(soap, sizeof(struct tt__PTZMoveStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZMoveStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZMoveStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZMoveStatus, sizeof(struct tt__PTZMoveStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZMoveStatus(struct soap *soap, struct tt__PTZMoveStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZMoveStatus);
	if (soap_out_PointerTott__PTZMoveStatus(soap, tag?tag:"tt:PTZMoveStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZMoveStatus ** SOAP_FMAC4 soap_get_PointerTott__PTZMoveStatus(struct soap *soap, struct tt__PTZMoveStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZMoveStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZVector(struct soap *soap, struct tt__PTZVector *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZVector))
		soap_serialize_tt__PTZVector(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZVector(struct soap *soap, const char *tag, int id, struct tt__PTZVector *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZVector);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZVector(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZVector ** SOAP_FMAC4 soap_in_PointerTott__PTZVector(struct soap *soap, const char *tag, struct tt__PTZVector **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZVector **)soap_malloc(soap, sizeof(struct tt__PTZVector *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZVector(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZVector **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZVector, sizeof(struct tt__PTZVector), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZVector(struct soap *soap, struct tt__PTZVector *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZVector);
	if (soap_out_PointerTott__PTZVector(soap, tag?tag:"tt:PTZVector", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZVector ** SOAP_FMAC4 soap_get_PointerTott__PTZVector(struct soap *soap, struct tt__PTZVector **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZVector(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector1D(struct soap *soap, struct tt__Vector1D *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector1D))
		soap_serialize_tt__Vector1D(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector1D(struct soap *soap, const char *tag, int id, struct tt__Vector1D *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector1D);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Vector1D(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Vector1D ** SOAP_FMAC4 soap_in_PointerTott__Vector1D(struct soap *soap, const char *tag, struct tt__Vector1D **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Vector1D **)soap_malloc(soap, sizeof(struct tt__Vector1D *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Vector1D(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Vector1D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector1D, sizeof(struct tt__Vector1D), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector1D(struct soap *soap, struct tt__Vector1D *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Vector1D);
	if (soap_out_PointerTott__Vector1D(soap, tag?tag:"tt:Vector1D", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector1D ** SOAP_FMAC4 soap_get_PointerTott__Vector1D(struct soap *soap, struct tt__Vector1D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector1D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Vector2D(struct soap *soap, struct tt__Vector2D *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Vector2D))
		soap_serialize_tt__Vector2D(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Vector2D(struct soap *soap, const char *tag, int id, struct tt__Vector2D *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Vector2D);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Vector2D(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Vector2D ** SOAP_FMAC4 soap_in_PointerTott__Vector2D(struct soap *soap, const char *tag, struct tt__Vector2D **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Vector2D **)soap_malloc(soap, sizeof(struct tt__Vector2D *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Vector2D(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Vector2D **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Vector2D, sizeof(struct tt__Vector2D), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Vector2D(struct soap *soap, struct tt__Vector2D *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Vector2D);
	if (soap_out_PointerTott__Vector2D(soap, tag?tag:"tt:Vector2D", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Vector2D ** SOAP_FMAC4 soap_get_PointerTott__Vector2D(struct soap *soap, struct tt__Vector2D **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Vector2D(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FloatRange(struct soap *soap, struct tt__FloatRange *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FloatRange))
		soap_serialize_tt__FloatRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FloatRange(struct soap *soap, const char *tag, int id, struct tt__FloatRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FloatRange);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FloatRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FloatRange ** SOAP_FMAC4 soap_in_PointerTott__FloatRange(struct soap *soap, const char *tag, struct tt__FloatRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FloatRange **)soap_malloc(soap, sizeof(struct tt__FloatRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FloatRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FloatRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FloatRange, sizeof(struct tt__FloatRange), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FloatRange(struct soap *soap, struct tt__FloatRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FloatRange);
	if (soap_out_PointerTott__FloatRange(soap, tag?tag:"tt:FloatRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FloatRange ** SOAP_FMAC4 soap_get_PointerTott__FloatRange(struct soap *soap, struct tt__FloatRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZSpacesExtension(struct soap *soap, struct tt__PTZSpacesExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZSpacesExtension))
		soap_serialize_tt__PTZSpacesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZSpacesExtension(struct soap *soap, const char *tag, int id, struct tt__PTZSpacesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZSpacesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZSpacesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZSpacesExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZSpacesExtension(struct soap *soap, const char *tag, struct tt__PTZSpacesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZSpacesExtension **)soap_malloc(soap, sizeof(struct tt__PTZSpacesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZSpacesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZSpacesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZSpacesExtension, sizeof(struct tt__PTZSpacesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZSpacesExtension(struct soap *soap, struct tt__PTZSpacesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZSpacesExtension);
	if (soap_out_PointerTott__PTZSpacesExtension(soap, tag?tag:"tt:PTZSpacesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZSpacesExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZSpacesExtension(struct soap *soap, struct tt__PTZSpacesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZSpacesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Space1DDescription(struct soap *soap, struct tt__Space1DDescription *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Space1DDescription))
		soap_serialize_tt__Space1DDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Space1DDescription(struct soap *soap, const char *tag, int id, struct tt__Space1DDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Space1DDescription);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Space1DDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Space1DDescription ** SOAP_FMAC4 soap_in_PointerTott__Space1DDescription(struct soap *soap, const char *tag, struct tt__Space1DDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Space1DDescription **)soap_malloc(soap, sizeof(struct tt__Space1DDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Space1DDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Space1DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Space1DDescription, sizeof(struct tt__Space1DDescription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Space1DDescription(struct soap *soap, struct tt__Space1DDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Space1DDescription);
	if (soap_out_PointerTott__Space1DDescription(soap, tag?tag:"tt:Space1DDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Space1DDescription ** SOAP_FMAC4 soap_get_PointerTott__Space1DDescription(struct soap *soap, struct tt__Space1DDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Space1DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Space2DDescription(struct soap *soap, struct tt__Space2DDescription *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Space2DDescription))
		soap_serialize_tt__Space2DDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Space2DDescription(struct soap *soap, const char *tag, int id, struct tt__Space2DDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Space2DDescription);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Space2DDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Space2DDescription ** SOAP_FMAC4 soap_in_PointerTott__Space2DDescription(struct soap *soap, const char *tag, struct tt__Space2DDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Space2DDescription **)soap_malloc(soap, sizeof(struct tt__Space2DDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Space2DDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Space2DDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Space2DDescription, sizeof(struct tt__Space2DDescription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Space2DDescription(struct soap *soap, struct tt__Space2DDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Space2DDescription);
	if (soap_out_PointerTott__Space2DDescription(soap, tag?tag:"tt:Space2DDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Space2DDescription ** SOAP_FMAC4 soap_get_PointerTott__Space2DDescription(struct soap *soap, struct tt__Space2DDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Space2DDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReverseOptionsExtension(struct soap *soap, struct tt__ReverseOptionsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReverseOptionsExtension))
		soap_serialize_tt__ReverseOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReverseOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__ReverseOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReverseOptionsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReverseOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ReverseOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__ReverseOptionsExtension(struct soap *soap, const char *tag, struct tt__ReverseOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ReverseOptionsExtension **)soap_malloc(soap, sizeof(struct tt__ReverseOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReverseOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ReverseOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReverseOptionsExtension, sizeof(struct tt__ReverseOptionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReverseOptionsExtension(struct soap *soap, struct tt__ReverseOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ReverseOptionsExtension);
	if (soap_out_PointerTott__ReverseOptionsExtension(soap, tag?tag:"tt:ReverseOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReverseOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__ReverseOptionsExtension(struct soap *soap, struct tt__ReverseOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReverseOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReverseMode(struct soap *soap, enum tt__ReverseMode *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__ReverseMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReverseMode(struct soap *soap, const char *tag, int id, enum tt__ReverseMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReverseMode);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReverseMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__ReverseMode ** SOAP_FMAC4 soap_in_PointerTott__ReverseMode(struct soap *soap, const char *tag, enum tt__ReverseMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__ReverseMode **)soap_malloc(soap, sizeof(enum tt__ReverseMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReverseMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__ReverseMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReverseMode, sizeof(enum tt__ReverseMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReverseMode(struct soap *soap, enum tt__ReverseMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ReverseMode);
	if (soap_out_PointerTott__ReverseMode(soap, tag?tag:"tt:ReverseMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__ReverseMode ** SOAP_FMAC4 soap_get_PointerTott__ReverseMode(struct soap *soap, enum tt__ReverseMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReverseMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EFlipOptionsExtension(struct soap *soap, struct tt__EFlipOptionsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EFlipOptionsExtension))
		soap_serialize_tt__EFlipOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EFlipOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__EFlipOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EFlipOptionsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EFlipOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EFlipOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__EFlipOptionsExtension(struct soap *soap, const char *tag, struct tt__EFlipOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EFlipOptionsExtension **)soap_malloc(soap, sizeof(struct tt__EFlipOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EFlipOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EFlipOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EFlipOptionsExtension, sizeof(struct tt__EFlipOptionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EFlipOptionsExtension(struct soap *soap, struct tt__EFlipOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__EFlipOptionsExtension);
	if (soap_out_PointerTott__EFlipOptionsExtension(soap, tag?tag:"tt:EFlipOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EFlipOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__EFlipOptionsExtension(struct soap *soap, struct tt__EFlipOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EFlipOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EFlipMode(struct soap *soap, enum tt__EFlipMode *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__EFlipMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EFlipMode(struct soap *soap, const char *tag, int id, enum tt__EFlipMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EFlipMode);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EFlipMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__EFlipMode ** SOAP_FMAC4 soap_in_PointerTott__EFlipMode(struct soap *soap, const char *tag, enum tt__EFlipMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__EFlipMode **)soap_malloc(soap, sizeof(enum tt__EFlipMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EFlipMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__EFlipMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EFlipMode, sizeof(enum tt__EFlipMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EFlipMode(struct soap *soap, enum tt__EFlipMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__EFlipMode);
	if (soap_out_PointerTott__EFlipMode(soap, tag?tag:"tt:EFlipMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__EFlipMode ** SOAP_FMAC4 soap_get_PointerTott__EFlipMode(struct soap *soap, enum tt__EFlipMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EFlipMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTControlDirectionOptionsExtension(struct soap *soap, struct tt__PTControlDirectionOptionsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTControlDirectionOptionsExtension))
		soap_serialize_tt__PTControlDirectionOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTControlDirectionOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__PTControlDirectionOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTControlDirectionOptionsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTControlDirectionOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTControlDirectionOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__PTControlDirectionOptionsExtension(struct soap *soap, const char *tag, struct tt__PTControlDirectionOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTControlDirectionOptionsExtension **)soap_malloc(soap, sizeof(struct tt__PTControlDirectionOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTControlDirectionOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTControlDirectionOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirectionOptionsExtension, sizeof(struct tt__PTControlDirectionOptionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTControlDirectionOptionsExtension(struct soap *soap, struct tt__PTControlDirectionOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTControlDirectionOptionsExtension);
	if (soap_out_PointerTott__PTControlDirectionOptionsExtension(soap, tag?tag:"tt:PTControlDirectionOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTControlDirectionOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__PTControlDirectionOptionsExtension(struct soap *soap, struct tt__PTControlDirectionOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTControlDirectionOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReverseOptions(struct soap *soap, struct tt__ReverseOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReverseOptions))
		soap_serialize_tt__ReverseOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReverseOptions(struct soap *soap, const char *tag, int id, struct tt__ReverseOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReverseOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReverseOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ReverseOptions ** SOAP_FMAC4 soap_in_PointerTott__ReverseOptions(struct soap *soap, const char *tag, struct tt__ReverseOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ReverseOptions **)soap_malloc(soap, sizeof(struct tt__ReverseOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReverseOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ReverseOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReverseOptions, sizeof(struct tt__ReverseOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReverseOptions(struct soap *soap, struct tt__ReverseOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ReverseOptions);
	if (soap_out_PointerTott__ReverseOptions(soap, tag?tag:"tt:ReverseOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReverseOptions ** SOAP_FMAC4 soap_get_PointerTott__ReverseOptions(struct soap *soap, struct tt__ReverseOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReverseOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EFlipOptions(struct soap *soap, struct tt__EFlipOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EFlipOptions))
		soap_serialize_tt__EFlipOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EFlipOptions(struct soap *soap, const char *tag, int id, struct tt__EFlipOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EFlipOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EFlipOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EFlipOptions ** SOAP_FMAC4 soap_in_PointerTott__EFlipOptions(struct soap *soap, const char *tag, struct tt__EFlipOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EFlipOptions **)soap_malloc(soap, sizeof(struct tt__EFlipOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EFlipOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EFlipOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EFlipOptions, sizeof(struct tt__EFlipOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EFlipOptions(struct soap *soap, struct tt__EFlipOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__EFlipOptions);
	if (soap_out_PointerTott__EFlipOptions(soap, tag?tag:"tt:EFlipOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EFlipOptions ** SOAP_FMAC4 soap_get_PointerTott__EFlipOptions(struct soap *soap, struct tt__EFlipOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EFlipOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationOptions2(struct soap *soap, struct tt__PTZConfigurationOptions2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationOptions2))
		soap_serialize_tt__PTZConfigurationOptions2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationOptions2(struct soap *soap, const char *tag, int id, struct tt__PTZConfigurationOptions2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationOptions2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZConfigurationOptions2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions2 ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationOptions2(struct soap *soap, const char *tag, struct tt__PTZConfigurationOptions2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZConfigurationOptions2 **)soap_malloc(soap, sizeof(struct tt__PTZConfigurationOptions2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZConfigurationOptions2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationOptions2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationOptions2, sizeof(struct tt__PTZConfigurationOptions2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationOptions2(struct soap *soap, struct tt__PTZConfigurationOptions2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZConfigurationOptions2);
	if (soap_out_PointerTott__PTZConfigurationOptions2(soap, tag?tag:"tt:PTZConfigurationOptions2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions2 ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationOptions2(struct soap *soap, struct tt__PTZConfigurationOptions2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationOptions2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTControlDirectionOptions(struct soap *soap, struct tt__PTControlDirectionOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTControlDirectionOptions))
		soap_serialize_tt__PTControlDirectionOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTControlDirectionOptions(struct soap *soap, const char *tag, int id, struct tt__PTControlDirectionOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTControlDirectionOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTControlDirectionOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTControlDirectionOptions ** SOAP_FMAC4 soap_in_PointerTott__PTControlDirectionOptions(struct soap *soap, const char *tag, struct tt__PTControlDirectionOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTControlDirectionOptions **)soap_malloc(soap, sizeof(struct tt__PTControlDirectionOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTControlDirectionOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTControlDirectionOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirectionOptions, sizeof(struct tt__PTControlDirectionOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTControlDirectionOptions(struct soap *soap, struct tt__PTControlDirectionOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTControlDirectionOptions);
	if (soap_out_PointerTott__PTControlDirectionOptions(soap, tag?tag:"tt:PTControlDirectionOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTControlDirectionOptions ** SOAP_FMAC4 soap_get_PointerTott__PTControlDirectionOptions(struct soap *soap, struct tt__PTControlDirectionOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTControlDirectionOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DurationRange(struct soap *soap, struct tt__DurationRange *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DurationRange))
		soap_serialize_tt__DurationRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DurationRange(struct soap *soap, const char *tag, int id, struct tt__DurationRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DurationRange);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DurationRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DurationRange ** SOAP_FMAC4 soap_in_PointerTott__DurationRange(struct soap *soap, const char *tag, struct tt__DurationRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DurationRange **)soap_malloc(soap, sizeof(struct tt__DurationRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DurationRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DurationRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DurationRange, sizeof(struct tt__DurationRange), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DurationRange(struct soap *soap, struct tt__DurationRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DurationRange);
	if (soap_out_PointerTott__DurationRange(soap, tag?tag:"tt:DurationRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DurationRange ** SOAP_FMAC4 soap_get_PointerTott__DurationRange(struct soap *soap, struct tt__DurationRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DurationRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZSpaces(struct soap *soap, struct tt__PTZSpaces *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZSpaces))
		soap_serialize_tt__PTZSpaces(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZSpaces(struct soap *soap, const char *tag, int id, struct tt__PTZSpaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZSpaces);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZSpaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZSpaces ** SOAP_FMAC4 soap_in_PointerTott__PTZSpaces(struct soap *soap, const char *tag, struct tt__PTZSpaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZSpaces **)soap_malloc(soap, sizeof(struct tt__PTZSpaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZSpaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZSpaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZSpaces, sizeof(struct tt__PTZSpaces), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZSpaces(struct soap *soap, struct tt__PTZSpaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZSpaces);
	if (soap_out_PointerTott__PTZSpaces(soap, tag?tag:"tt:PTZSpaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZSpaces ** SOAP_FMAC4 soap_get_PointerTott__PTZSpaces(struct soap *soap, struct tt__PTZSpaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZSpaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTControlDirectionExtension(struct soap *soap, struct tt__PTControlDirectionExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTControlDirectionExtension))
		soap_serialize_tt__PTControlDirectionExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTControlDirectionExtension(struct soap *soap, const char *tag, int id, struct tt__PTControlDirectionExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTControlDirectionExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTControlDirectionExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTControlDirectionExtension ** SOAP_FMAC4 soap_in_PointerTott__PTControlDirectionExtension(struct soap *soap, const char *tag, struct tt__PTControlDirectionExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTControlDirectionExtension **)soap_malloc(soap, sizeof(struct tt__PTControlDirectionExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTControlDirectionExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTControlDirectionExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirectionExtension, sizeof(struct tt__PTControlDirectionExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTControlDirectionExtension(struct soap *soap, struct tt__PTControlDirectionExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTControlDirectionExtension);
	if (soap_out_PointerTott__PTControlDirectionExtension(soap, tag?tag:"tt:PTControlDirectionExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTControlDirectionExtension ** SOAP_FMAC4 soap_get_PointerTott__PTControlDirectionExtension(struct soap *soap, struct tt__PTControlDirectionExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTControlDirectionExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Reverse(struct soap *soap, struct tt__Reverse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Reverse))
		soap_serialize_tt__Reverse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Reverse(struct soap *soap, const char *tag, int id, struct tt__Reverse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Reverse);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Reverse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Reverse ** SOAP_FMAC4 soap_in_PointerTott__Reverse(struct soap *soap, const char *tag, struct tt__Reverse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Reverse **)soap_malloc(soap, sizeof(struct tt__Reverse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Reverse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Reverse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Reverse, sizeof(struct tt__Reverse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Reverse(struct soap *soap, struct tt__Reverse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Reverse);
	if (soap_out_PointerTott__Reverse(soap, tag?tag:"tt:Reverse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Reverse ** SOAP_FMAC4 soap_get_PointerTott__Reverse(struct soap *soap, struct tt__Reverse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Reverse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EFlip(struct soap *soap, struct tt__EFlip *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EFlip))
		soap_serialize_tt__EFlip(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EFlip(struct soap *soap, const char *tag, int id, struct tt__EFlip *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EFlip);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EFlip(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EFlip ** SOAP_FMAC4 soap_in_PointerTott__EFlip(struct soap *soap, const char *tag, struct tt__EFlip **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EFlip **)soap_malloc(soap, sizeof(struct tt__EFlip *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EFlip(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EFlip **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EFlip, sizeof(struct tt__EFlip), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EFlip(struct soap *soap, struct tt__EFlip *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__EFlip);
	if (soap_out_PointerTott__EFlip(soap, tag?tag:"tt:EFlip", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EFlip ** SOAP_FMAC4 soap_get_PointerTott__EFlip(struct soap *soap, struct tt__EFlip **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EFlip(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationExtension2(struct soap *soap, struct tt__PTZConfigurationExtension2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationExtension2))
		soap_serialize_tt__PTZConfigurationExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationExtension2(struct soap *soap, const char *tag, int id, struct tt__PTZConfigurationExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZConfigurationExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationExtension2(struct soap *soap, const char *tag, struct tt__PTZConfigurationExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZConfigurationExtension2 **)soap_malloc(soap, sizeof(struct tt__PTZConfigurationExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZConfigurationExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationExtension2, sizeof(struct tt__PTZConfigurationExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationExtension2(struct soap *soap, struct tt__PTZConfigurationExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZConfigurationExtension2);
	if (soap_out_PointerTott__PTZConfigurationExtension2(soap, tag?tag:"tt:PTZConfigurationExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationExtension2(struct soap *soap, struct tt__PTZConfigurationExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTControlDirection(struct soap *soap, struct tt__PTControlDirection *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTControlDirection))
		soap_serialize_tt__PTControlDirection(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTControlDirection(struct soap *soap, const char *tag, int id, struct tt__PTControlDirection *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTControlDirection);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTControlDirection(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTControlDirection ** SOAP_FMAC4 soap_in_PointerTott__PTControlDirection(struct soap *soap, const char *tag, struct tt__PTControlDirection **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTControlDirection **)soap_malloc(soap, sizeof(struct tt__PTControlDirection *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTControlDirection(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTControlDirection **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTControlDirection, sizeof(struct tt__PTControlDirection), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTControlDirection(struct soap *soap, struct tt__PTControlDirection *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTControlDirection);
	if (soap_out_PointerTott__PTControlDirection(soap, tag?tag:"tt:PTControlDirection", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTControlDirection ** SOAP_FMAC4 soap_get_PointerTott__PTControlDirection(struct soap *soap, struct tt__PTControlDirection **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTControlDirection(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourSupportedExtension(struct soap *soap, struct tt__PTZPresetTourSupportedExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourSupportedExtension))
		soap_serialize_tt__PTZPresetTourSupportedExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourSupportedExtension(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourSupportedExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourSupportedExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourSupportedExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourSupportedExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourSupportedExtension(struct soap *soap, const char *tag, struct tt__PTZPresetTourSupportedExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourSupportedExtension **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourSupportedExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourSupportedExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourSupportedExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSupportedExtension, sizeof(struct tt__PTZPresetTourSupportedExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourSupportedExtension(struct soap *soap, struct tt__PTZPresetTourSupportedExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourSupportedExtension);
	if (soap_out_PointerTott__PTZPresetTourSupportedExtension(soap, tag?tag:"tt:PTZPresetTourSupportedExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourSupportedExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourSupportedExtension(struct soap *soap, struct tt__PTZPresetTourSupportedExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourSupportedExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourOperation(struct soap *soap, enum tt__PTZPresetTourOperation *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourOperation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourOperation(struct soap *soap, const char *tag, int id, enum tt__PTZPresetTourOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourOperation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourOperation(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__PTZPresetTourOperation ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourOperation(struct soap *soap, const char *tag, enum tt__PTZPresetTourOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__PTZPresetTourOperation **)soap_malloc(soap, sizeof(enum tt__PTZPresetTourOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourOperation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__PTZPresetTourOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourOperation, sizeof(enum tt__PTZPresetTourOperation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourOperation(struct soap *soap, enum tt__PTZPresetTourOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourOperation);
	if (soap_out_PointerTott__PTZPresetTourOperation(soap, tag?tag:"tt:PTZPresetTourOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PTZPresetTourOperation ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourOperation(struct soap *soap, enum tt__PTZPresetTourOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZNodeExtension2(struct soap *soap, struct tt__PTZNodeExtension2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZNodeExtension2))
		soap_serialize_tt__PTZNodeExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZNodeExtension2(struct soap *soap, const char *tag, int id, struct tt__PTZNodeExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZNodeExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZNodeExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZNodeExtension2 ** SOAP_FMAC4 soap_in_PointerTott__PTZNodeExtension2(struct soap *soap, const char *tag, struct tt__PTZNodeExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZNodeExtension2 **)soap_malloc(soap, sizeof(struct tt__PTZNodeExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZNodeExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZNodeExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZNodeExtension2, sizeof(struct tt__PTZNodeExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZNodeExtension2(struct soap *soap, struct tt__PTZNodeExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZNodeExtension2);
	if (soap_out_PointerTott__PTZNodeExtension2(soap, tag?tag:"tt:PTZNodeExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZNodeExtension2 ** SOAP_FMAC4 soap_get_PointerTott__PTZNodeExtension2(struct soap *soap, struct tt__PTZNodeExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZNodeExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourSupported(struct soap *soap, struct tt__PTZPresetTourSupported *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourSupported))
		soap_serialize_tt__PTZPresetTourSupported(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourSupported(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourSupported *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourSupported);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourSupported(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourSupported ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourSupported(struct soap *soap, const char *tag, struct tt__PTZPresetTourSupported **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourSupported **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourSupported *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourSupported(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourSupported **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourSupported, sizeof(struct tt__PTZPresetTourSupported), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourSupported(struct soap *soap, struct tt__PTZPresetTourSupported *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourSupported);
	if (soap_out_PointerTott__PTZPresetTourSupported(soap, tag?tag:"tt:PTZPresetTourSupported", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourSupported ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourSupported(struct soap *soap, struct tt__PTZPresetTourSupported **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourSupported(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EapMethodExtension(struct soap *soap, struct tt__EapMethodExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EapMethodExtension))
		soap_serialize_tt__EapMethodExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EapMethodExtension(struct soap *soap, const char *tag, int id, struct tt__EapMethodExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EapMethodExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EapMethodExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EapMethodExtension ** SOAP_FMAC4 soap_in_PointerTott__EapMethodExtension(struct soap *soap, const char *tag, struct tt__EapMethodExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EapMethodExtension **)soap_malloc(soap, sizeof(struct tt__EapMethodExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EapMethodExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EapMethodExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EapMethodExtension, sizeof(struct tt__EapMethodExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EapMethodExtension(struct soap *soap, struct tt__EapMethodExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__EapMethodExtension);
	if (soap_out_PointerTott__EapMethodExtension(soap, tag?tag:"tt:EapMethodExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EapMethodExtension ** SOAP_FMAC4 soap_get_PointerTott__EapMethodExtension(struct soap *soap, struct tt__EapMethodExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EapMethodExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TLSConfiguration(struct soap *soap, struct tt__TLSConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TLSConfiguration))
		soap_serialize_tt__TLSConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TLSConfiguration(struct soap *soap, const char *tag, int id, struct tt__TLSConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TLSConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TLSConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TLSConfiguration ** SOAP_FMAC4 soap_in_PointerTott__TLSConfiguration(struct soap *soap, const char *tag, struct tt__TLSConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TLSConfiguration **)soap_malloc(soap, sizeof(struct tt__TLSConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TLSConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TLSConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TLSConfiguration, sizeof(struct tt__TLSConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TLSConfiguration(struct soap *soap, struct tt__TLSConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__TLSConfiguration);
	if (soap_out_PointerTott__TLSConfiguration(soap, tag?tag:"tt:TLSConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TLSConfiguration ** SOAP_FMAC4 soap_get_PointerTott__TLSConfiguration(struct soap *soap, struct tt__TLSConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TLSConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot1XConfigurationExtension(struct soap *soap, struct tt__Dot1XConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot1XConfigurationExtension))
		soap_serialize_tt__Dot1XConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot1XConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__Dot1XConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot1XConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot1XConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot1XConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__Dot1XConfigurationExtension(struct soap *soap, const char *tag, struct tt__Dot1XConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot1XConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__Dot1XConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot1XConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot1XConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot1XConfigurationExtension, sizeof(struct tt__Dot1XConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot1XConfigurationExtension(struct soap *soap, struct tt__Dot1XConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot1XConfigurationExtension);
	if (soap_out_PointerTott__Dot1XConfigurationExtension(soap, tag?tag:"tt:Dot1XConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot1XConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__Dot1XConfigurationExtension(struct soap *soap, struct tt__Dot1XConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot1XConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EAPMethodConfiguration(struct soap *soap, struct tt__EAPMethodConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EAPMethodConfiguration))
		soap_serialize_tt__EAPMethodConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EAPMethodConfiguration(struct soap *soap, const char *tag, int id, struct tt__EAPMethodConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EAPMethodConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EAPMethodConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EAPMethodConfiguration ** SOAP_FMAC4 soap_in_PointerTott__EAPMethodConfiguration(struct soap *soap, const char *tag, struct tt__EAPMethodConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EAPMethodConfiguration **)soap_malloc(soap, sizeof(struct tt__EAPMethodConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EAPMethodConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EAPMethodConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EAPMethodConfiguration, sizeof(struct tt__EAPMethodConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EAPMethodConfiguration(struct soap *soap, struct tt__EAPMethodConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__EAPMethodConfiguration);
	if (soap_out_PointerTott__EAPMethodConfiguration(soap, tag?tag:"tt:EAPMethodConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EAPMethodConfiguration ** SOAP_FMAC4 soap_get_PointerTott__EAPMethodConfiguration(struct soap *soap, struct tt__EAPMethodConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EAPMethodConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateInformationExtension(struct soap *soap, struct tt__CertificateInformationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateInformationExtension))
		soap_serialize_tt__CertificateInformationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateInformationExtension(struct soap *soap, const char *tag, int id, struct tt__CertificateInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateInformationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CertificateInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CertificateInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__CertificateInformationExtension(struct soap *soap, const char *tag, struct tt__CertificateInformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CertificateInformationExtension **)soap_malloc(soap, sizeof(struct tt__CertificateInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CertificateInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateInformationExtension, sizeof(struct tt__CertificateInformationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateInformationExtension(struct soap *soap, struct tt__CertificateInformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__CertificateInformationExtension);
	if (soap_out_PointerTott__CertificateInformationExtension(soap, tag?tag:"tt:CertificateInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__CertificateInformationExtension(struct soap *soap, struct tt__CertificateInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DateTimeRange(struct soap *soap, struct tt__DateTimeRange *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DateTimeRange))
		soap_serialize_tt__DateTimeRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DateTimeRange(struct soap *soap, const char *tag, int id, struct tt__DateTimeRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DateTimeRange);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DateTimeRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DateTimeRange ** SOAP_FMAC4 soap_in_PointerTott__DateTimeRange(struct soap *soap, const char *tag, struct tt__DateTimeRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DateTimeRange **)soap_malloc(soap, sizeof(struct tt__DateTimeRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DateTimeRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DateTimeRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DateTimeRange, sizeof(struct tt__DateTimeRange), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DateTimeRange(struct soap *soap, struct tt__DateTimeRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DateTimeRange);
	if (soap_out_PointerTott__DateTimeRange(soap, tag?tag:"tt:DateTimeRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DateTimeRange ** SOAP_FMAC4 soap_get_PointerTott__DateTimeRange(struct soap *soap, struct tt__DateTimeRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DateTimeRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateUsage(struct soap *soap, struct tt__CertificateUsage *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateUsage))
		soap_serialize_tt__CertificateUsage(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateUsage(struct soap *soap, const char *tag, int id, struct tt__CertificateUsage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateUsage);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CertificateUsage(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CertificateUsage ** SOAP_FMAC4 soap_in_PointerTott__CertificateUsage(struct soap *soap, const char *tag, struct tt__CertificateUsage **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CertificateUsage **)soap_malloc(soap, sizeof(struct tt__CertificateUsage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CertificateUsage(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateUsage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateUsage, sizeof(struct tt__CertificateUsage), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateUsage(struct soap *soap, struct tt__CertificateUsage *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__CertificateUsage);
	if (soap_out_PointerTott__CertificateUsage(soap, tag?tag:"tt:CertificateUsage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateUsage ** SOAP_FMAC4 soap_get_PointerTott__CertificateUsage(struct soap *soap, struct tt__CertificateUsage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateUsage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BinaryData(struct soap *soap, struct tt__BinaryData *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BinaryData))
		soap_serialize_tt__BinaryData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BinaryData(struct soap *soap, const char *tag, int id, struct tt__BinaryData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BinaryData);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BinaryData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__BinaryData ** SOAP_FMAC4 soap_in_PointerTott__BinaryData(struct soap *soap, const char *tag, struct tt__BinaryData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__BinaryData **)soap_malloc(soap, sizeof(struct tt__BinaryData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BinaryData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__BinaryData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BinaryData, sizeof(struct tt__BinaryData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BinaryData(struct soap *soap, struct tt__BinaryData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__BinaryData);
	if (soap_out_PointerTott__BinaryData(soap, tag?tag:"tt:BinaryData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BinaryData ** SOAP_FMAC4 soap_get_PointerTott__BinaryData(struct soap *soap, struct tt__BinaryData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BinaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateGenerationParametersExtension(struct soap *soap, struct tt__CertificateGenerationParametersExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateGenerationParametersExtension))
		soap_serialize_tt__CertificateGenerationParametersExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, int id, struct tt__CertificateGenerationParametersExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateGenerationParametersExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CertificateGenerationParametersExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CertificateGenerationParametersExtension ** SOAP_FMAC4 soap_in_PointerTott__CertificateGenerationParametersExtension(struct soap *soap, const char *tag, struct tt__CertificateGenerationParametersExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CertificateGenerationParametersExtension **)soap_malloc(soap, sizeof(struct tt__CertificateGenerationParametersExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CertificateGenerationParametersExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateGenerationParametersExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateGenerationParametersExtension, sizeof(struct tt__CertificateGenerationParametersExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateGenerationParametersExtension(struct soap *soap, struct tt__CertificateGenerationParametersExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__CertificateGenerationParametersExtension);
	if (soap_out_PointerTott__CertificateGenerationParametersExtension(soap, tag?tag:"tt:CertificateGenerationParametersExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateGenerationParametersExtension ** SOAP_FMAC4 soap_get_PointerTott__CertificateGenerationParametersExtension(struct soap *soap, struct tt__CertificateGenerationParametersExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateGenerationParametersExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__UserExtension(struct soap *soap, struct tt__UserExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__UserExtension))
		soap_serialize_tt__UserExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__UserExtension(struct soap *soap, const char *tag, int id, struct tt__UserExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__UserExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__UserExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__UserExtension ** SOAP_FMAC4 soap_in_PointerTott__UserExtension(struct soap *soap, const char *tag, struct tt__UserExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__UserExtension **)soap_malloc(soap, sizeof(struct tt__UserExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__UserExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__UserExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__UserExtension, sizeof(struct tt__UserExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__UserExtension(struct soap *soap, struct tt__UserExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__UserExtension);
	if (soap_out_PointerTott__UserExtension(soap, tag?tag:"tt:UserExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__UserExtension ** SOAP_FMAC4 soap_get_PointerTott__UserExtension(struct soap *soap, struct tt__UserExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__UserExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Date(struct soap *soap, struct tt__Date *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Date))
		soap_serialize_tt__Date(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Date(struct soap *soap, const char *tag, int id, struct tt__Date *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Date);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Date(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Date ** SOAP_FMAC4 soap_in_PointerTott__Date(struct soap *soap, const char *tag, struct tt__Date **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Date **)soap_malloc(soap, sizeof(struct tt__Date *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Date(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Date **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Date, sizeof(struct tt__Date), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Date(struct soap *soap, struct tt__Date *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Date);
	if (soap_out_PointerTott__Date(soap, tag?tag:"tt:Date", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Date ** SOAP_FMAC4 soap_get_PointerTott__Date(struct soap *soap, struct tt__Date **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Date(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Time(struct soap *soap, struct tt__Time *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Time))
		soap_serialize_tt__Time(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Time(struct soap *soap, const char *tag, int id, struct tt__Time *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Time);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Time(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Time ** SOAP_FMAC4 soap_in_PointerTott__Time(struct soap *soap, const char *tag, struct tt__Time **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Time **)soap_malloc(soap, sizeof(struct tt__Time *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Time(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Time **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Time, sizeof(struct tt__Time), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Time(struct soap *soap, struct tt__Time *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Time);
	if (soap_out_PointerTott__Time(soap, tag?tag:"tt:Time", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Time ** SOAP_FMAC4 soap_get_PointerTott__Time(struct soap *soap, struct tt__Time **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Time(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemDateTimeExtension(struct soap *soap, struct tt__SystemDateTimeExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemDateTimeExtension))
		soap_serialize_tt__SystemDateTimeExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemDateTimeExtension(struct soap *soap, const char *tag, int id, struct tt__SystemDateTimeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemDateTimeExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemDateTimeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemDateTimeExtension ** SOAP_FMAC4 soap_in_PointerTott__SystemDateTimeExtension(struct soap *soap, const char *tag, struct tt__SystemDateTimeExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemDateTimeExtension **)soap_malloc(soap, sizeof(struct tt__SystemDateTimeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemDateTimeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemDateTimeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemDateTimeExtension, sizeof(struct tt__SystemDateTimeExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemDateTimeExtension(struct soap *soap, struct tt__SystemDateTimeExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SystemDateTimeExtension);
	if (soap_out_PointerTott__SystemDateTimeExtension(soap, tag?tag:"tt:SystemDateTimeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemDateTimeExtension ** SOAP_FMAC4 soap_get_PointerTott__SystemDateTimeExtension(struct soap *soap, struct tt__SystemDateTimeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemDateTimeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DateTime(struct soap *soap, struct tt__DateTime *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DateTime))
		soap_serialize_tt__DateTime(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DateTime(struct soap *soap, const char *tag, int id, struct tt__DateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DateTime);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DateTime ** SOAP_FMAC4 soap_in_PointerTott__DateTime(struct soap *soap, const char *tag, struct tt__DateTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DateTime **)soap_malloc(soap, sizeof(struct tt__DateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DateTime, sizeof(struct tt__DateTime), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DateTime(struct soap *soap, struct tt__DateTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DateTime);
	if (soap_out_PointerTott__DateTime(soap, tag?tag:"tt:DateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DateTime ** SOAP_FMAC4 soap_get_PointerTott__DateTime(struct soap *soap, struct tt__DateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TimeZone(struct soap *soap, struct tt__TimeZone *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TimeZone))
		soap_serialize_tt__TimeZone(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TimeZone(struct soap *soap, const char *tag, int id, struct tt__TimeZone *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TimeZone);
	if (id < 0)
		return soap->error;
	return soap_out_tt__TimeZone(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__TimeZone ** SOAP_FMAC4 soap_in_PointerTott__TimeZone(struct soap *soap, const char *tag, struct tt__TimeZone **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__TimeZone **)soap_malloc(soap, sizeof(struct tt__TimeZone *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__TimeZone(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__TimeZone **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TimeZone, sizeof(struct tt__TimeZone), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TimeZone(struct soap *soap, struct tt__TimeZone *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__TimeZone);
	if (soap_out_PointerTott__TimeZone(soap, tag?tag:"tt:TimeZone", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__TimeZone ** SOAP_FMAC4 soap_get_PointerTott__TimeZone(struct soap *soap, struct tt__TimeZone **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TimeZone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemLogUri(struct soap *soap, struct tt__SystemLogUri *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemLogUri))
		soap_serialize_tt__SystemLogUri(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemLogUri(struct soap *soap, const char *tag, int id, struct tt__SystemLogUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemLogUri);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemLogUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemLogUri ** SOAP_FMAC4 soap_in_PointerTott__SystemLogUri(struct soap *soap, const char *tag, struct tt__SystemLogUri **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemLogUri **)soap_malloc(soap, sizeof(struct tt__SystemLogUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemLogUri(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemLogUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemLogUri, sizeof(struct tt__SystemLogUri), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemLogUri(struct soap *soap, struct tt__SystemLogUri *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SystemLogUri);
	if (soap_out_PointerTott__SystemLogUri(soap, tag?tag:"tt:SystemLogUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemLogUri ** SOAP_FMAC4 soap_get_PointerTott__SystemLogUri(struct soap *soap, struct tt__SystemLogUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemLogUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AttachmentData(struct soap *soap, struct tt__AttachmentData *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AttachmentData))
		soap_serialize_tt__AttachmentData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AttachmentData(struct soap *soap, const char *tag, int id, struct tt__AttachmentData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AttachmentData);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AttachmentData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AttachmentData ** SOAP_FMAC4 soap_in_PointerTott__AttachmentData(struct soap *soap, const char *tag, struct tt__AttachmentData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AttachmentData **)soap_malloc(soap, sizeof(struct tt__AttachmentData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AttachmentData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AttachmentData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AttachmentData, sizeof(struct tt__AttachmentData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AttachmentData(struct soap *soap, struct tt__AttachmentData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AttachmentData);
	if (soap_out_PointerTott__AttachmentData(soap, tag?tag:"tt:AttachmentData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AttachmentData ** SOAP_FMAC4 soap_get_PointerTott__AttachmentData(struct soap *soap, struct tt__AttachmentData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AttachmentData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsDeviceExtension(struct soap *soap, struct tt__AnalyticsDeviceExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsDeviceExtension))
		soap_serialize_tt__AnalyticsDeviceExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsDeviceExtension(struct soap *soap, const char *tag, int id, struct tt__AnalyticsDeviceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsDeviceExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsDeviceExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsDeviceExtension(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsDeviceExtension **)soap_malloc(soap, sizeof(struct tt__AnalyticsDeviceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsDeviceExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceExtension, sizeof(struct tt__AnalyticsDeviceExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsDeviceExtension(struct soap *soap, struct tt__AnalyticsDeviceExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsDeviceExtension);
	if (soap_out_PointerTott__AnalyticsDeviceExtension(soap, tag?tag:"tt:AnalyticsDeviceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsDeviceExtension(struct soap *soap, struct tt__AnalyticsDeviceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsDeviceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, struct tt__SystemCapabilitiesExtension2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemCapabilitiesExtension2))
		soap_serialize_tt__SystemCapabilitiesExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, int id, struct tt__SystemCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemCapabilitiesExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemCapabilitiesExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__SystemCapabilitiesExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemCapabilitiesExtension2 **)soap_malloc(soap, sizeof(struct tt__SystemCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemCapabilitiesExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilitiesExtension2, sizeof(struct tt__SystemCapabilitiesExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, struct tt__SystemCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SystemCapabilitiesExtension2);
	if (soap_out_PointerTott__SystemCapabilitiesExtension2(soap, tag?tag:"tt:SystemCapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__SystemCapabilitiesExtension2(struct soap *soap, struct tt__SystemCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemCapabilitiesExtension(struct soap *soap, struct tt__SystemCapabilitiesExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemCapabilitiesExtension))
		soap_serialize_tt__SystemCapabilitiesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__SystemCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__SystemCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__SystemCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__SystemCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilitiesExtension, sizeof(struct tt__SystemCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemCapabilitiesExtension(struct soap *soap, struct tt__SystemCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SystemCapabilitiesExtension);
	if (soap_out_PointerTott__SystemCapabilitiesExtension(soap, tag?tag:"tt:SystemCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__SystemCapabilitiesExtension(struct soap *soap, struct tt__SystemCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__OnvifVersion(struct soap *soap, struct tt__OnvifVersion *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__OnvifVersion))
		soap_serialize_tt__OnvifVersion(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__OnvifVersion(struct soap *soap, const char *tag, int id, struct tt__OnvifVersion *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__OnvifVersion);
	if (id < 0)
		return soap->error;
	return soap_out_tt__OnvifVersion(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__OnvifVersion ** SOAP_FMAC4 soap_in_PointerTott__OnvifVersion(struct soap *soap, const char *tag, struct tt__OnvifVersion **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__OnvifVersion **)soap_malloc(soap, sizeof(struct tt__OnvifVersion *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__OnvifVersion(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__OnvifVersion **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__OnvifVersion, sizeof(struct tt__OnvifVersion), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__OnvifVersion(struct soap *soap, struct tt__OnvifVersion *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__OnvifVersion);
	if (soap_out_PointerTott__OnvifVersion(soap, tag?tag:"tt:OnvifVersion", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__OnvifVersion ** SOAP_FMAC4 soap_get_PointerTott__OnvifVersion(struct soap *soap, struct tt__OnvifVersion **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__OnvifVersion(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, struct tt__SecurityCapabilitiesExtension2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2))
		soap_serialize_tt__SecurityCapabilitiesExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, int id, struct tt__SecurityCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SecurityCapabilitiesExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SecurityCapabilitiesExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__SecurityCapabilitiesExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SecurityCapabilitiesExtension2 **)soap_malloc(soap, sizeof(struct tt__SecurityCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SecurityCapabilitiesExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SecurityCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilitiesExtension2, sizeof(struct tt__SecurityCapabilitiesExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, struct tt__SecurityCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension2);
	if (soap_out_PointerTott__SecurityCapabilitiesExtension2(soap, tag?tag:"tt:SecurityCapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__SecurityCapabilitiesExtension2(struct soap *soap, struct tt__SecurityCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SecurityCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, struct tt__SecurityCapabilitiesExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SecurityCapabilitiesExtension))
		soap_serialize_tt__SecurityCapabilitiesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__SecurityCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SecurityCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SecurityCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__SecurityCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SecurityCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__SecurityCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SecurityCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SecurityCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilitiesExtension, sizeof(struct tt__SecurityCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, struct tt__SecurityCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SecurityCapabilitiesExtension);
	if (soap_out_PointerTott__SecurityCapabilitiesExtension(soap, tag?tag:"tt:SecurityCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__SecurityCapabilitiesExtension(struct soap *soap, struct tt__SecurityCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SecurityCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, struct tt__NetworkCapabilitiesExtension2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2))
		soap_serialize_tt__NetworkCapabilitiesExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, int id, struct tt__NetworkCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkCapabilitiesExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkCapabilitiesExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__NetworkCapabilitiesExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkCapabilitiesExtension2 **)soap_malloc(soap, sizeof(struct tt__NetworkCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkCapabilitiesExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilitiesExtension2, sizeof(struct tt__NetworkCapabilitiesExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, struct tt__NetworkCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension2);
	if (soap_out_PointerTott__NetworkCapabilitiesExtension2(soap, tag?tag:"tt:NetworkCapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__NetworkCapabilitiesExtension2(struct soap *soap, struct tt__NetworkCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, struct tt__NetworkCapabilitiesExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkCapabilitiesExtension))
		soap_serialize_tt__NetworkCapabilitiesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__NetworkCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__NetworkCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__NetworkCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilitiesExtension, sizeof(struct tt__NetworkCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, struct tt__NetworkCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkCapabilitiesExtension);
	if (soap_out_PointerTott__NetworkCapabilitiesExtension(soap, tag?tag:"tt:NetworkCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkCapabilitiesExtension(struct soap *soap, struct tt__NetworkCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct tt__RealTimeStreamingCapabilitiesExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension))
		soap_serialize_tt__RealTimeStreamingCapabilitiesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__RealTimeStreamingCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__RealTimeStreamingCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RealTimeStreamingCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__RealTimeStreamingCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RealTimeStreamingCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RealTimeStreamingCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RealTimeStreamingCapabilitiesExtension, sizeof(struct tt__RealTimeStreamingCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct tt__RealTimeStreamingCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RealTimeStreamingCapabilitiesExtension);
	if (soap_out_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, tag?tag:"tt:RealTimeStreamingCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__RealTimeStreamingCapabilitiesExtension(struct soap *soap, struct tt__RealTimeStreamingCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RealTimeStreamingCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileCapabilities))
		soap_serialize_tt__ProfileCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileCapabilities(struct soap *soap, const char *tag, int id, struct tt__ProfileCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ProfileCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ProfileCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ProfileCapabilities(struct soap *soap, const char *tag, struct tt__ProfileCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ProfileCapabilities **)soap_malloc(soap, sizeof(struct tt__ProfileCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ProfileCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileCapabilities, sizeof(struct tt__ProfileCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ProfileCapabilities);
	if (soap_out_PointerTott__ProfileCapabilities(soap, tag?tag:"tt:ProfileCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ProfileCapabilities(struct soap *soap, struct tt__ProfileCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaCapabilitiesExtension))
		soap_serialize_tt__MediaCapabilitiesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__MediaCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MediaCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MediaCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__MediaCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__MediaCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MediaCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__MediaCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MediaCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MediaCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaCapabilitiesExtension, sizeof(struct tt__MediaCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MediaCapabilitiesExtension);
	if (soap_out_PointerTott__MediaCapabilitiesExtension(soap, tag?tag:"tt:MediaCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__MediaCapabilitiesExtension(struct soap *soap, struct tt__MediaCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RealTimeStreamingCapabilities))
		soap_serialize_tt__RealTimeStreamingCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, int id, struct tt__RealTimeStreamingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RealTimeStreamingCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RealTimeStreamingCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, const char *tag, struct tt__RealTimeStreamingCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RealTimeStreamingCapabilities **)soap_malloc(soap, sizeof(struct tt__RealTimeStreamingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RealTimeStreamingCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RealTimeStreamingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RealTimeStreamingCapabilities, sizeof(struct tt__RealTimeStreamingCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RealTimeStreamingCapabilities);
	if (soap_out_PointerTott__RealTimeStreamingCapabilities(soap, tag?tag:"tt:RealTimeStreamingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RealTimeStreamingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__RealTimeStreamingCapabilities(struct soap *soap, struct tt__RealTimeStreamingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RealTimeStreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IOCapabilitiesExtension2(struct soap *soap, struct tt__IOCapabilitiesExtension2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IOCapabilitiesExtension2))
		soap_serialize_tt__IOCapabilitiesExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IOCapabilitiesExtension2(struct soap *soap, const char *tag, int id, struct tt__IOCapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IOCapabilitiesExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IOCapabilitiesExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__IOCapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__IOCapabilitiesExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IOCapabilitiesExtension2 **)soap_malloc(soap, sizeof(struct tt__IOCapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IOCapabilitiesExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IOCapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilitiesExtension2, sizeof(struct tt__IOCapabilitiesExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IOCapabilitiesExtension2(struct soap *soap, struct tt__IOCapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IOCapabilitiesExtension2);
	if (soap_out_PointerTott__IOCapabilitiesExtension2(soap, tag?tag:"tt:IOCapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__IOCapabilitiesExtension2(struct soap *soap, struct tt__IOCapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IOCapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AuxiliaryData(struct soap *soap, char **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AuxiliaryData))
		soap_serialize_tt__AuxiliaryData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AuxiliaryData(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AuxiliaryData);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AuxiliaryData(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTott__AuxiliaryData(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AuxiliaryData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AuxiliaryData, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AuxiliaryData(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AuxiliaryData);
	if (soap_out_PointerTott__AuxiliaryData(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTott__AuxiliaryData(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AuxiliaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IOCapabilitiesExtension(struct soap *soap, struct tt__IOCapabilitiesExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IOCapabilitiesExtension))
		soap_serialize_tt__IOCapabilitiesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IOCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__IOCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IOCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IOCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__IOCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__IOCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IOCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__IOCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IOCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IOCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilitiesExtension, sizeof(struct tt__IOCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IOCapabilitiesExtension(struct soap *soap, struct tt__IOCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IOCapabilitiesExtension);
	if (soap_out_PointerTott__IOCapabilitiesExtension(soap, tag?tag:"tt:IOCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IOCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__IOCapabilitiesExtension(struct soap *soap, struct tt__IOCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IOCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, struct tt__DeviceCapabilitiesExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceCapabilitiesExtension))
		soap_serialize_tt__DeviceCapabilitiesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__DeviceCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DeviceCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DeviceCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, const char *tag, struct tt__DeviceCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DeviceCapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__DeviceCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DeviceCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DeviceCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceCapabilitiesExtension, sizeof(struct tt__DeviceCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, struct tt__DeviceCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DeviceCapabilitiesExtension);
	if (soap_out_PointerTott__DeviceCapabilitiesExtension(soap, tag?tag:"tt:DeviceCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__DeviceCapabilitiesExtension(struct soap *soap, struct tt__DeviceCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SecurityCapabilities(struct soap *soap, struct tt__SecurityCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SecurityCapabilities))
		soap_serialize_tt__SecurityCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SecurityCapabilities(struct soap *soap, const char *tag, int id, struct tt__SecurityCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SecurityCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SecurityCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SecurityCapabilities ** SOAP_FMAC4 soap_in_PointerTott__SecurityCapabilities(struct soap *soap, const char *tag, struct tt__SecurityCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SecurityCapabilities **)soap_malloc(soap, sizeof(struct tt__SecurityCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SecurityCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SecurityCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SecurityCapabilities, sizeof(struct tt__SecurityCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SecurityCapabilities(struct soap *soap, struct tt__SecurityCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SecurityCapabilities);
	if (soap_out_PointerTott__SecurityCapabilities(soap, tag?tag:"tt:SecurityCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SecurityCapabilities ** SOAP_FMAC4 soap_get_PointerTott__SecurityCapabilities(struct soap *soap, struct tt__SecurityCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IOCapabilities(struct soap *soap, struct tt__IOCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IOCapabilities))
		soap_serialize_tt__IOCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IOCapabilities(struct soap *soap, const char *tag, int id, struct tt__IOCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IOCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IOCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IOCapabilities ** SOAP_FMAC4 soap_in_PointerTott__IOCapabilities(struct soap *soap, const char *tag, struct tt__IOCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IOCapabilities **)soap_malloc(soap, sizeof(struct tt__IOCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IOCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IOCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IOCapabilities, sizeof(struct tt__IOCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IOCapabilities(struct soap *soap, struct tt__IOCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IOCapabilities);
	if (soap_out_PointerTott__IOCapabilities(soap, tag?tag:"tt:IOCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IOCapabilities ** SOAP_FMAC4 soap_get_PointerTott__IOCapabilities(struct soap *soap, struct tt__IOCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemCapabilities))
		soap_serialize_tt__SystemCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemCapabilities(struct soap *soap, const char *tag, int id, struct tt__SystemCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemCapabilities ** SOAP_FMAC4 soap_in_PointerTott__SystemCapabilities(struct soap *soap, const char *tag, struct tt__SystemCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemCapabilities **)soap_malloc(soap, sizeof(struct tt__SystemCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemCapabilities, sizeof(struct tt__SystemCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SystemCapabilities);
	if (soap_out_PointerTott__SystemCapabilities(soap, tag?tag:"tt:SystemCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemCapabilities ** SOAP_FMAC4 soap_get_PointerTott__SystemCapabilities(struct soap *soap, struct tt__SystemCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkCapabilities(struct soap *soap, struct tt__NetworkCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkCapabilities))
		soap_serialize_tt__NetworkCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkCapabilities(struct soap *soap, const char *tag, int id, struct tt__NetworkCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkCapabilities ** SOAP_FMAC4 soap_in_PointerTott__NetworkCapabilities(struct soap *soap, const char *tag, struct tt__NetworkCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkCapabilities **)soap_malloc(soap, sizeof(struct tt__NetworkCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkCapabilities, sizeof(struct tt__NetworkCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkCapabilities(struct soap *soap, struct tt__NetworkCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkCapabilities);
	if (soap_out_PointerTott__NetworkCapabilities(soap, tag?tag:"tt:NetworkCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkCapabilities ** SOAP_FMAC4 soap_get_PointerTott__NetworkCapabilities(struct soap *soap, struct tt__NetworkCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CapabilitiesExtension2(struct soap *soap, struct tt__CapabilitiesExtension2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CapabilitiesExtension2))
		soap_serialize_tt__CapabilitiesExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CapabilitiesExtension2(struct soap *soap, const char *tag, int id, struct tt__CapabilitiesExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CapabilitiesExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CapabilitiesExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension2 ** SOAP_FMAC4 soap_in_PointerTott__CapabilitiesExtension2(struct soap *soap, const char *tag, struct tt__CapabilitiesExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CapabilitiesExtension2 **)soap_malloc(soap, sizeof(struct tt__CapabilitiesExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CapabilitiesExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CapabilitiesExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CapabilitiesExtension2, sizeof(struct tt__CapabilitiesExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CapabilitiesExtension2(struct soap *soap, struct tt__CapabilitiesExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__CapabilitiesExtension2);
	if (soap_out_PointerTott__CapabilitiesExtension2(soap, tag?tag:"tt:CapabilitiesExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension2 ** SOAP_FMAC4 soap_get_PointerTott__CapabilitiesExtension2(struct soap *soap, struct tt__CapabilitiesExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CapabilitiesExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, struct tt__AnalyticsDeviceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities))
		soap_serialize_tt__AnalyticsDeviceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, const char *tag, int id, struct tt__AnalyticsDeviceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsDeviceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsDeviceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceCapabilities ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsDeviceCapabilities **)soap_malloc(soap, sizeof(struct tt__AnalyticsDeviceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsDeviceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceCapabilities, sizeof(struct tt__AnalyticsDeviceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, struct tt__AnalyticsDeviceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsDeviceCapabilities);
	if (soap_out_PointerTott__AnalyticsDeviceCapabilities(soap, tag?tag:"tt:AnalyticsDeviceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceCapabilities ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsDeviceCapabilities(struct soap *soap, struct tt__AnalyticsDeviceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsDeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReceiverCapabilities(struct soap *soap, struct tt__ReceiverCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReceiverCapabilities))
		soap_serialize_tt__ReceiverCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReceiverCapabilities(struct soap *soap, const char *tag, int id, struct tt__ReceiverCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReceiverCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReceiverCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ReceiverCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ReceiverCapabilities(struct soap *soap, const char *tag, struct tt__ReceiverCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ReceiverCapabilities **)soap_malloc(soap, sizeof(struct tt__ReceiverCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReceiverCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ReceiverCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReceiverCapabilities, sizeof(struct tt__ReceiverCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReceiverCapabilities(struct soap *soap, struct tt__ReceiverCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ReceiverCapabilities);
	if (soap_out_PointerTott__ReceiverCapabilities(soap, tag?tag:"tt:ReceiverCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReceiverCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ReceiverCapabilities(struct soap *soap, struct tt__ReceiverCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReceiverCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReplayCapabilities(struct soap *soap, struct tt__ReplayCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReplayCapabilities))
		soap_serialize_tt__ReplayCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReplayCapabilities(struct soap *soap, const char *tag, int id, struct tt__ReplayCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReplayCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReplayCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ReplayCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ReplayCapabilities(struct soap *soap, const char *tag, struct tt__ReplayCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ReplayCapabilities **)soap_malloc(soap, sizeof(struct tt__ReplayCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReplayCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ReplayCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReplayCapabilities, sizeof(struct tt__ReplayCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReplayCapabilities(struct soap *soap, struct tt__ReplayCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ReplayCapabilities);
	if (soap_out_PointerTott__ReplayCapabilities(soap, tag?tag:"tt:ReplayCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReplayCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ReplayCapabilities(struct soap *soap, struct tt__ReplayCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SearchCapabilities(struct soap *soap, struct tt__SearchCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SearchCapabilities))
		soap_serialize_tt__SearchCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SearchCapabilities(struct soap *soap, const char *tag, int id, struct tt__SearchCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SearchCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SearchCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SearchCapabilities ** SOAP_FMAC4 soap_in_PointerTott__SearchCapabilities(struct soap *soap, const char *tag, struct tt__SearchCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SearchCapabilities **)soap_malloc(soap, sizeof(struct tt__SearchCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SearchCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SearchCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SearchCapabilities, sizeof(struct tt__SearchCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SearchCapabilities(struct soap *soap, struct tt__SearchCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SearchCapabilities);
	if (soap_out_PointerTott__SearchCapabilities(soap, tag?tag:"tt:SearchCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SearchCapabilities ** SOAP_FMAC4 soap_get_PointerTott__SearchCapabilities(struct soap *soap, struct tt__SearchCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SearchCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingCapabilities(struct soap *soap, struct tt__RecordingCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingCapabilities))
		soap_serialize_tt__RecordingCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingCapabilities(struct soap *soap, const char *tag, int id, struct tt__RecordingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__RecordingCapabilities(struct soap *soap, const char *tag, struct tt__RecordingCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingCapabilities **)soap_malloc(soap, sizeof(struct tt__RecordingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingCapabilities, sizeof(struct tt__RecordingCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingCapabilities(struct soap *soap, struct tt__RecordingCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingCapabilities);
	if (soap_out_PointerTott__RecordingCapabilities(soap, tag?tag:"tt:RecordingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__RecordingCapabilities(struct soap *soap, struct tt__RecordingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DisplayCapabilities(struct soap *soap, struct tt__DisplayCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DisplayCapabilities))
		soap_serialize_tt__DisplayCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DisplayCapabilities(struct soap *soap, const char *tag, int id, struct tt__DisplayCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DisplayCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DisplayCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DisplayCapabilities ** SOAP_FMAC4 soap_in_PointerTott__DisplayCapabilities(struct soap *soap, const char *tag, struct tt__DisplayCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DisplayCapabilities **)soap_malloc(soap, sizeof(struct tt__DisplayCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DisplayCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DisplayCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DisplayCapabilities, sizeof(struct tt__DisplayCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DisplayCapabilities(struct soap *soap, struct tt__DisplayCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DisplayCapabilities);
	if (soap_out_PointerTott__DisplayCapabilities(soap, tag?tag:"tt:DisplayCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DisplayCapabilities ** SOAP_FMAC4 soap_get_PointerTott__DisplayCapabilities(struct soap *soap, struct tt__DisplayCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DisplayCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceIOCapabilities(struct soap *soap, struct tt__DeviceIOCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceIOCapabilities))
		soap_serialize_tt__DeviceIOCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceIOCapabilities(struct soap *soap, const char *tag, int id, struct tt__DeviceIOCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceIOCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DeviceIOCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DeviceIOCapabilities ** SOAP_FMAC4 soap_in_PointerTott__DeviceIOCapabilities(struct soap *soap, const char *tag, struct tt__DeviceIOCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DeviceIOCapabilities **)soap_malloc(soap, sizeof(struct tt__DeviceIOCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DeviceIOCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DeviceIOCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceIOCapabilities, sizeof(struct tt__DeviceIOCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceIOCapabilities(struct soap *soap, struct tt__DeviceIOCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DeviceIOCapabilities);
	if (soap_out_PointerTott__DeviceIOCapabilities(soap, tag?tag:"tt:DeviceIOCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceIOCapabilities ** SOAP_FMAC4 soap_get_PointerTott__DeviceIOCapabilities(struct soap *soap, struct tt__DeviceIOCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceIOCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CapabilitiesExtension(struct soap *soap, struct tt__CapabilitiesExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CapabilitiesExtension))
		soap_serialize_tt__CapabilitiesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CapabilitiesExtension(struct soap *soap, const char *tag, int id, struct tt__CapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTott__CapabilitiesExtension(struct soap *soap, const char *tag, struct tt__CapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CapabilitiesExtension **)soap_malloc(soap, sizeof(struct tt__CapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CapabilitiesExtension, sizeof(struct tt__CapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CapabilitiesExtension(struct soap *soap, struct tt__CapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__CapabilitiesExtension);
	if (soap_out_PointerTott__CapabilitiesExtension(soap, tag?tag:"tt:CapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTott__CapabilitiesExtension(struct soap *soap, struct tt__CapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZCapabilities))
		soap_serialize_tt__PTZCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZCapabilities(struct soap *soap, const char *tag, int id, struct tt__PTZCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZCapabilities ** SOAP_FMAC4 soap_in_PointerTott__PTZCapabilities(struct soap *soap, const char *tag, struct tt__PTZCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZCapabilities **)soap_malloc(soap, sizeof(struct tt__PTZCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZCapabilities, sizeof(struct tt__PTZCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZCapabilities);
	if (soap_out_PointerTott__PTZCapabilities(soap, tag?tag:"tt:PTZCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZCapabilities ** SOAP_FMAC4 soap_get_PointerTott__PTZCapabilities(struct soap *soap, struct tt__PTZCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaCapabilities))
		soap_serialize_tt__MediaCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaCapabilities(struct soap *soap, const char *tag, int id, struct tt__MediaCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MediaCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MediaCapabilities ** SOAP_FMAC4 soap_in_PointerTott__MediaCapabilities(struct soap *soap, const char *tag, struct tt__MediaCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MediaCapabilities **)soap_malloc(soap, sizeof(struct tt__MediaCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MediaCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MediaCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaCapabilities, sizeof(struct tt__MediaCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MediaCapabilities);
	if (soap_out_PointerTott__MediaCapabilities(soap, tag?tag:"tt:MediaCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaCapabilities ** SOAP_FMAC4 soap_get_PointerTott__MediaCapabilities(struct soap *soap, struct tt__MediaCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingCapabilities(struct soap *soap, struct tt__ImagingCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingCapabilities))
		soap_serialize_tt__ImagingCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingCapabilities(struct soap *soap, const char *tag, int id, struct tt__ImagingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__ImagingCapabilities(struct soap *soap, const char *tag, struct tt__ImagingCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingCapabilities **)soap_malloc(soap, sizeof(struct tt__ImagingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingCapabilities, sizeof(struct tt__ImagingCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingCapabilities(struct soap *soap, struct tt__ImagingCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingCapabilities);
	if (soap_out_PointerTott__ImagingCapabilities(soap, tag?tag:"tt:ImagingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__ImagingCapabilities(struct soap *soap, struct tt__ImagingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventCapabilities(struct soap *soap, struct tt__EventCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventCapabilities))
		soap_serialize_tt__EventCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventCapabilities(struct soap *soap, const char *tag, int id, struct tt__EventCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EventCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EventCapabilities ** SOAP_FMAC4 soap_in_PointerTott__EventCapabilities(struct soap *soap, const char *tag, struct tt__EventCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EventCapabilities **)soap_malloc(soap, sizeof(struct tt__EventCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EventCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EventCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventCapabilities, sizeof(struct tt__EventCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventCapabilities(struct soap *soap, struct tt__EventCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__EventCapabilities);
	if (soap_out_PointerTott__EventCapabilities(soap, tag?tag:"tt:EventCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventCapabilities ** SOAP_FMAC4 soap_get_PointerTott__EventCapabilities(struct soap *soap, struct tt__EventCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DeviceCapabilities))
		soap_serialize_tt__DeviceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DeviceCapabilities(struct soap *soap, const char *tag, int id, struct tt__DeviceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DeviceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DeviceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DeviceCapabilities ** SOAP_FMAC4 soap_in_PointerTott__DeviceCapabilities(struct soap *soap, const char *tag, struct tt__DeviceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DeviceCapabilities **)soap_malloc(soap, sizeof(struct tt__DeviceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DeviceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DeviceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DeviceCapabilities, sizeof(struct tt__DeviceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DeviceCapabilities);
	if (soap_out_PointerTott__DeviceCapabilities(soap, tag?tag:"tt:DeviceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DeviceCapabilities ** SOAP_FMAC4 soap_get_PointerTott__DeviceCapabilities(struct soap *soap, struct tt__DeviceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DeviceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsCapabilities(struct soap *soap, struct tt__AnalyticsCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsCapabilities))
		soap_serialize_tt__AnalyticsCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsCapabilities(struct soap *soap, const char *tag, int id, struct tt__AnalyticsCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsCapabilities ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsCapabilities(struct soap *soap, const char *tag, struct tt__AnalyticsCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsCapabilities **)soap_malloc(soap, sizeof(struct tt__AnalyticsCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsCapabilities, sizeof(struct tt__AnalyticsCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsCapabilities(struct soap *soap, struct tt__AnalyticsCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsCapabilities);
	if (soap_out_PointerTott__AnalyticsCapabilities(soap, tag?tag:"tt:AnalyticsCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsCapabilities ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsCapabilities(struct soap *soap, struct tt__AnalyticsCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, struct tt__Dot11AvailableNetworksExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension))
		soap_serialize_tt__Dot11AvailableNetworksExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, const char *tag, int id, struct tt__Dot11AvailableNetworksExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11AvailableNetworksExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11AvailableNetworksExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworksExtension ** SOAP_FMAC4 soap_in_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, const char *tag, struct tt__Dot11AvailableNetworksExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11AvailableNetworksExtension **)soap_malloc(soap, sizeof(struct tt__Dot11AvailableNetworksExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11AvailableNetworksExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11AvailableNetworksExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11AvailableNetworksExtension, sizeof(struct tt__Dot11AvailableNetworksExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, struct tt__Dot11AvailableNetworksExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11AvailableNetworksExtension);
	if (soap_out_PointerTott__Dot11AvailableNetworksExtension(soap, tag?tag:"tt:Dot11AvailableNetworksExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworksExtension ** SOAP_FMAC4 soap_get_PointerTott__Dot11AvailableNetworksExtension(struct soap *soap, struct tt__Dot11AvailableNetworksExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11AvailableNetworksExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11AuthAndMangementSuite(struct soap *soap, enum tt__Dot11AuthAndMangementSuite *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__Dot11AuthAndMangementSuite);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11AuthAndMangementSuite(struct soap *soap, const char *tag, int id, enum tt__Dot11AuthAndMangementSuite *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11AuthAndMangementSuite);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11AuthAndMangementSuite(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__Dot11AuthAndMangementSuite ** SOAP_FMAC4 soap_in_PointerTott__Dot11AuthAndMangementSuite(struct soap *soap, const char *tag, enum tt__Dot11AuthAndMangementSuite **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__Dot11AuthAndMangementSuite **)soap_malloc(soap, sizeof(enum tt__Dot11AuthAndMangementSuite *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11AuthAndMangementSuite(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__Dot11AuthAndMangementSuite **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11AuthAndMangementSuite, sizeof(enum tt__Dot11AuthAndMangementSuite), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11AuthAndMangementSuite(struct soap *soap, enum tt__Dot11AuthAndMangementSuite *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11AuthAndMangementSuite);
	if (soap_out_PointerTott__Dot11AuthAndMangementSuite(soap, tag?tag:"tt:Dot11AuthAndMangementSuite", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11AuthAndMangementSuite ** SOAP_FMAC4 soap_get_PointerTott__Dot11AuthAndMangementSuite(struct soap *soap, enum tt__Dot11AuthAndMangementSuite **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11AuthAndMangementSuite(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11SignalStrength(struct soap *soap, enum tt__Dot11SignalStrength *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__Dot11SignalStrength);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11SignalStrength(struct soap *soap, const char *tag, int id, enum tt__Dot11SignalStrength *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11SignalStrength);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11SignalStrength(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__Dot11SignalStrength ** SOAP_FMAC4 soap_in_PointerTott__Dot11SignalStrength(struct soap *soap, const char *tag, enum tt__Dot11SignalStrength **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__Dot11SignalStrength **)soap_malloc(soap, sizeof(enum tt__Dot11SignalStrength *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11SignalStrength(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__Dot11SignalStrength **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11SignalStrength, sizeof(enum tt__Dot11SignalStrength), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11SignalStrength(struct soap *soap, enum tt__Dot11SignalStrength *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11SignalStrength);
	if (soap_out_PointerTott__Dot11SignalStrength(soap, tag?tag:"tt:Dot11SignalStrength", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11SignalStrength ** SOAP_FMAC4 soap_get_PointerTott__Dot11SignalStrength(struct soap *soap, enum tt__Dot11SignalStrength **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11SignalStrength(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11PSKSetExtension(struct soap *soap, struct tt__Dot11PSKSetExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11PSKSetExtension))
		soap_serialize_tt__Dot11PSKSetExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11PSKSetExtension(struct soap *soap, const char *tag, int id, struct tt__Dot11PSKSetExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11PSKSetExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11PSKSetExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11PSKSetExtension ** SOAP_FMAC4 soap_in_PointerTott__Dot11PSKSetExtension(struct soap *soap, const char *tag, struct tt__Dot11PSKSetExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11PSKSetExtension **)soap_malloc(soap, sizeof(struct tt__Dot11PSKSetExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11PSKSetExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11PSKSetExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11PSKSetExtension, sizeof(struct tt__Dot11PSKSetExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11PSKSetExtension(struct soap *soap, struct tt__Dot11PSKSetExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11PSKSetExtension);
	if (soap_out_PointerTott__Dot11PSKSetExtension(soap, tag?tag:"tt:Dot11PSKSetExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11PSKSetExtension ** SOAP_FMAC4 soap_get_PointerTott__Dot11PSKSetExtension(struct soap *soap, struct tt__Dot11PSKSetExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11PSKSetExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11PSK(struct soap *soap, struct xsd__hexBinary *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_tt__Dot11PSK(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11PSK(struct soap *soap, const char *tag, int id, struct xsd__hexBinary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_tt__Dot11PSK);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11PSK(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xsd__hexBinary ** SOAP_FMAC4 soap_in_PointerTott__Dot11PSK(struct soap *soap, const char *tag, struct xsd__hexBinary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xsd__hexBinary **)soap_malloc(soap, sizeof(struct xsd__hexBinary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11PSK(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xsd__hexBinary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11PSK, sizeof(struct xsd__hexBinary), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11PSK(struct soap *soap, struct xsd__hexBinary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11PSK);
	if (soap_out_PointerTott__Dot11PSK(soap, tag?tag:"tt:Dot11PSK", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__hexBinary ** SOAP_FMAC4 soap_get_PointerTott__Dot11PSK(struct soap *soap, struct xsd__hexBinary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11PSK(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, struct tt__Dot11SecurityConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension))
		soap_serialize_tt__Dot11SecurityConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__Dot11SecurityConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11SecurityConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, const char *tag, struct tt__Dot11SecurityConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11SecurityConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__Dot11SecurityConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11SecurityConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11SecurityConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11SecurityConfigurationExtension, sizeof(struct tt__Dot11SecurityConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, struct tt__Dot11SecurityConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11SecurityConfigurationExtension);
	if (soap_out_PointerTott__Dot11SecurityConfigurationExtension(soap, tag?tag:"tt:Dot11SecurityConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__Dot11SecurityConfigurationExtension(struct soap *soap, struct tt__Dot11SecurityConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11SecurityConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11PSKSet(struct soap *soap, struct tt__Dot11PSKSet *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11PSKSet))
		soap_serialize_tt__Dot11PSKSet(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11PSKSet(struct soap *soap, const char *tag, int id, struct tt__Dot11PSKSet *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11PSKSet);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11PSKSet(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11PSKSet ** SOAP_FMAC4 soap_in_PointerTott__Dot11PSKSet(struct soap *soap, const char *tag, struct tt__Dot11PSKSet **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11PSKSet **)soap_malloc(soap, sizeof(struct tt__Dot11PSKSet *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11PSKSet(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11PSKSet **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11PSKSet, sizeof(struct tt__Dot11PSKSet), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11PSKSet(struct soap *soap, struct tt__Dot11PSKSet *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11PSKSet);
	if (soap_out_PointerTott__Dot11PSKSet(soap, tag?tag:"tt:Dot11PSKSet", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11PSKSet ** SOAP_FMAC4 soap_get_PointerTott__Dot11PSKSet(struct soap *soap, struct tt__Dot11PSKSet **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11PSKSet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Cipher(struct soap *soap, enum tt__Dot11Cipher *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Cipher);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Cipher(struct soap *soap, const char *tag, int id, enum tt__Dot11Cipher *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Cipher);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11Cipher(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__Dot11Cipher ** SOAP_FMAC4 soap_in_PointerTott__Dot11Cipher(struct soap *soap, const char *tag, enum tt__Dot11Cipher **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__Dot11Cipher **)soap_malloc(soap, sizeof(enum tt__Dot11Cipher *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11Cipher(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__Dot11Cipher **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Cipher, sizeof(enum tt__Dot11Cipher), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Cipher(struct soap *soap, enum tt__Dot11Cipher *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11Cipher);
	if (soap_out_PointerTott__Dot11Cipher(soap, tag?tag:"tt:Dot11Cipher", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Dot11Cipher ** SOAP_FMAC4 soap_get_PointerTott__Dot11Cipher(struct soap *soap, enum tt__Dot11Cipher **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Cipher(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11SecurityConfiguration(struct soap *soap, struct tt__Dot11SecurityConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11SecurityConfiguration))
		soap_serialize_tt__Dot11SecurityConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11SecurityConfiguration(struct soap *soap, const char *tag, int id, struct tt__Dot11SecurityConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11SecurityConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11SecurityConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfiguration ** SOAP_FMAC4 soap_in_PointerTott__Dot11SecurityConfiguration(struct soap *soap, const char *tag, struct tt__Dot11SecurityConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11SecurityConfiguration **)soap_malloc(soap, sizeof(struct tt__Dot11SecurityConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11SecurityConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11SecurityConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11SecurityConfiguration, sizeof(struct tt__Dot11SecurityConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11SecurityConfiguration(struct soap *soap, struct tt__Dot11SecurityConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11SecurityConfiguration);
	if (soap_out_PointerTott__Dot11SecurityConfiguration(soap, tag?tag:"tt:Dot11SecurityConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11SecurityConfiguration ** SOAP_FMAC4 soap_get_PointerTott__Dot11SecurityConfiguration(struct soap *soap, struct tt__Dot11SecurityConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11SecurityConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddressFilterExtension(struct soap *soap, struct tt__IPAddressFilterExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddressFilterExtension))
		soap_serialize_tt__IPAddressFilterExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddressFilterExtension(struct soap *soap, const char *tag, int id, struct tt__IPAddressFilterExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddressFilterExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPAddressFilterExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPAddressFilterExtension ** SOAP_FMAC4 soap_in_PointerTott__IPAddressFilterExtension(struct soap *soap, const char *tag, struct tt__IPAddressFilterExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPAddressFilterExtension **)soap_malloc(soap, sizeof(struct tt__IPAddressFilterExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPAddressFilterExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPAddressFilterExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddressFilterExtension, sizeof(struct tt__IPAddressFilterExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddressFilterExtension(struct soap *soap, struct tt__IPAddressFilterExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPAddressFilterExtension);
	if (soap_out_PointerTott__IPAddressFilterExtension(soap, tag?tag:"tt:IPAddressFilterExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddressFilterExtension ** SOAP_FMAC4 soap_get_PointerTott__IPAddressFilterExtension(struct soap *soap, struct tt__IPAddressFilterExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddressFilterExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, struct tt__NetworkZeroConfigurationExtension2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2))
		soap_serialize_tt__NetworkZeroConfigurationExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, const char *tag, int id, struct tt__NetworkZeroConfigurationExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkZeroConfigurationExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkZeroConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, const char *tag, struct tt__NetworkZeroConfigurationExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkZeroConfigurationExtension2 **)soap_malloc(soap, sizeof(struct tt__NetworkZeroConfigurationExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkZeroConfigurationExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkZeroConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension2, sizeof(struct tt__NetworkZeroConfigurationExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, struct tt__NetworkZeroConfigurationExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension2);
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension2(soap, tag?tag:"tt:NetworkZeroConfigurationExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkZeroConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__NetworkZeroConfigurationExtension2(struct soap *soap, struct tt__NetworkZeroConfigurationExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkZeroConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkZeroConfiguration(struct soap *soap, struct tt__NetworkZeroConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkZeroConfiguration))
		soap_serialize_tt__NetworkZeroConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkZeroConfiguration(struct soap *soap, const char *tag, int id, struct tt__NetworkZeroConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkZeroConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkZeroConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkZeroConfiguration ** SOAP_FMAC4 soap_in_PointerTott__NetworkZeroConfiguration(struct soap *soap, const char *tag, struct tt__NetworkZeroConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkZeroConfiguration **)soap_malloc(soap, sizeof(struct tt__NetworkZeroConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkZeroConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkZeroConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkZeroConfiguration, sizeof(struct tt__NetworkZeroConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkZeroConfiguration(struct soap *soap, struct tt__NetworkZeroConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkZeroConfiguration);
	if (soap_out_PointerTott__NetworkZeroConfiguration(soap, tag?tag:"tt:NetworkZeroConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkZeroConfiguration ** SOAP_FMAC4 soap_get_PointerTott__NetworkZeroConfiguration(struct soap *soap, struct tt__NetworkZeroConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, struct tt__NetworkZeroConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension))
		soap_serialize_tt__NetworkZeroConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__NetworkZeroConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkZeroConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkZeroConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkZeroConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, const char *tag, struct tt__NetworkZeroConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkZeroConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__NetworkZeroConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkZeroConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkZeroConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkZeroConfigurationExtension, sizeof(struct tt__NetworkZeroConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, struct tt__NetworkZeroConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkZeroConfigurationExtension);
	if (soap_out_PointerTott__NetworkZeroConfigurationExtension(soap, tag?tag:"tt:NetworkZeroConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkZeroConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkZeroConfigurationExtension(struct soap *soap, struct tt__NetworkZeroConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkZeroConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6Address(struct soap *soap, char **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6Address))
		soap_serialize_tt__IPv6Address(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6Address(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6Address);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTott__IPv6Address(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6Address, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6Address(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6Address);
	if (soap_out_PointerTott__IPv6Address(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTott__IPv6Address(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4Address(struct soap *soap, char **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4Address))
		soap_serialize_tt__IPv4Address(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4Address(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4Address);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv4Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTott__IPv4Address(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv4Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4Address, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4Address(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv4Address);
	if (soap_out_PointerTott__IPv4Address(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTott__IPv4Address(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__IPv6DHCPConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6DHCPConfiguration(struct soap *soap, const char *tag, int id, enum tt__IPv6DHCPConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6DHCPConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6DHCPConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration ** SOAP_FMAC4 soap_in_PointerTott__IPv6DHCPConfiguration(struct soap *soap, const char *tag, enum tt__IPv6DHCPConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__IPv6DHCPConfiguration **)soap_malloc(soap, sizeof(enum tt__IPv6DHCPConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6DHCPConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__IPv6DHCPConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6DHCPConfiguration, sizeof(enum tt__IPv6DHCPConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6DHCPConfiguration);
	if (soap_out_PointerTott__IPv6DHCPConfiguration(soap, tag?tag:"tt:IPv6DHCPConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__IPv6DHCPConfiguration ** SOAP_FMAC4 soap_get_PointerTott__IPv6DHCPConfiguration(struct soap *soap, enum tt__IPv6DHCPConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6DHCPConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2))
		soap_serialize_tt__NetworkInterfaceSetConfigurationExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceSetConfigurationExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfigurationExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceSetConfigurationExtension2 **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceSetConfigurationExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceSetConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension2, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension2);
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, tag?tag:"tt:NetworkInterfaceSetConfigurationExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceSetConfigurationExtension2(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension))
		soap_serialize_tt__NetworkInterfaceSetConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceSetConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceSetConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceSetConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceSetConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfigurationExtension, sizeof(struct tt__NetworkInterfaceSetConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceSetConfigurationExtension);
	if (soap_out_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, tag?tag:"tt:NetworkInterfaceSetConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceSetConfigurationExtension(struct soap *soap, struct tt__NetworkInterfaceSetConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceSetConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv6NetworkInterfaceSetConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration))
		soap_serialize_tt__IPv6NetworkInterfaceSetConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, struct tt__IPv6NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__IPv6NetworkInterfaceSetConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPv6NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(struct tt__IPv6NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6NetworkInterfaceSetConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPv6NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv6NetworkInterfaceSetConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv6NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6NetworkInterfaceSetConfiguration);
	if (soap_out_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, tag?tag:"tt:IPv6NetworkInterfaceSetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTott__IPv6NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv6NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv4NetworkInterfaceSetConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration))
		soap_serialize_tt__IPv4NetworkInterfaceSetConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, struct tt__IPv4NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__IPv4NetworkInterfaceSetConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPv4NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(struct tt__IPv4NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv4NetworkInterfaceSetConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPv4NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4NetworkInterfaceSetConfiguration, sizeof(struct tt__IPv4NetworkInterfaceSetConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv4NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv4NetworkInterfaceSetConfiguration);
	if (soap_out_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, tag?tag:"tt:IPv4NetworkInterfaceSetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTott__IPv4NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__IPv4NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DynamicDNSInformationExtension(struct soap *soap, struct tt__DynamicDNSInformationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DynamicDNSInformationExtension))
		soap_serialize_tt__DynamicDNSInformationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DynamicDNSInformationExtension(struct soap *soap, const char *tag, int id, struct tt__DynamicDNSInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DynamicDNSInformationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DynamicDNSInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DynamicDNSInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__DynamicDNSInformationExtension(struct soap *soap, const char *tag, struct tt__DynamicDNSInformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DynamicDNSInformationExtension **)soap_malloc(soap, sizeof(struct tt__DynamicDNSInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DynamicDNSInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DynamicDNSInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DynamicDNSInformationExtension, sizeof(struct tt__DynamicDNSInformationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DynamicDNSInformationExtension(struct soap *soap, struct tt__DynamicDNSInformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DynamicDNSInformationExtension);
	if (soap_out_PointerTott__DynamicDNSInformationExtension(soap, tag?tag:"tt:DynamicDNSInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DynamicDNSInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__DynamicDNSInformationExtension(struct soap *soap, struct tt__DynamicDNSInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DynamicDNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__duration(struct soap *soap, LONG64 *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__duration(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__duration);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__duration(soap, tag, id, *a, type);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_in_PointerToxsd__duration(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (LONG64 **)soap_malloc(soap, sizeof(LONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__duration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__duration, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__duration(struct soap *soap, LONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__duration);
	if (soap_out_PointerToxsd__duration(soap, tag?tag:"xsd:duration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 LONG64 ** SOAP_FMAC4 soap_get_PointerToxsd__duration(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__duration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NTPInformationExtension(struct soap *soap, struct tt__NTPInformationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NTPInformationExtension))
		soap_serialize_tt__NTPInformationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NTPInformationExtension(struct soap *soap, const char *tag, int id, struct tt__NTPInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NTPInformationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NTPInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NTPInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__NTPInformationExtension(struct soap *soap, const char *tag, struct tt__NTPInformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NTPInformationExtension **)soap_malloc(soap, sizeof(struct tt__NTPInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NTPInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NTPInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NTPInformationExtension, sizeof(struct tt__NTPInformationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NTPInformationExtension(struct soap *soap, struct tt__NTPInformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NTPInformationExtension);
	if (soap_out_PointerTott__NTPInformationExtension(soap, tag?tag:"tt:NTPInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NTPInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__NTPInformationExtension(struct soap *soap, struct tt__NTPInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NTPInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkHost(struct soap *soap, struct tt__NetworkHost *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkHost))
		soap_serialize_tt__NetworkHost(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkHost(struct soap *soap, const char *tag, int id, struct tt__NetworkHost *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkHost);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkHost(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkHost ** SOAP_FMAC4 soap_in_PointerTott__NetworkHost(struct soap *soap, const char *tag, struct tt__NetworkHost **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkHost **)soap_malloc(soap, sizeof(struct tt__NetworkHost *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkHost(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkHost **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkHost, sizeof(struct tt__NetworkHost), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkHost(struct soap *soap, struct tt__NetworkHost *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkHost);
	if (soap_out_PointerTott__NetworkHost(soap, tag?tag:"tt:NetworkHost", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkHost ** SOAP_FMAC4 soap_get_PointerTott__NetworkHost(struct soap *soap, struct tt__NetworkHost **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkHost(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DNSInformationExtension(struct soap *soap, struct tt__DNSInformationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DNSInformationExtension))
		soap_serialize_tt__DNSInformationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DNSInformationExtension(struct soap *soap, const char *tag, int id, struct tt__DNSInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DNSInformationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DNSInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DNSInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__DNSInformationExtension(struct soap *soap, const char *tag, struct tt__DNSInformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DNSInformationExtension **)soap_malloc(soap, sizeof(struct tt__DNSInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DNSInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DNSInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DNSInformationExtension, sizeof(struct tt__DNSInformationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DNSInformationExtension(struct soap *soap, struct tt__DNSInformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DNSInformationExtension);
	if (soap_out_PointerTott__DNSInformationExtension(soap, tag?tag:"tt:DNSInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DNSInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__DNSInformationExtension(struct soap *soap, struct tt__DNSInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DNSInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__token(struct soap *soap, char **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__token))
		soap_serialize_xsd__token(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__token(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__token);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__token(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerToxsd__token(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__token(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__token, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__token(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__token);
	if (soap_out_PointerToxsd__token(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToxsd__token(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__HostnameInformationExtension(struct soap *soap, struct tt__HostnameInformationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__HostnameInformationExtension))
		soap_serialize_tt__HostnameInformationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__HostnameInformationExtension(struct soap *soap, const char *tag, int id, struct tt__HostnameInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__HostnameInformationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__HostnameInformationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__HostnameInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__HostnameInformationExtension(struct soap *soap, const char *tag, struct tt__HostnameInformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__HostnameInformationExtension **)soap_malloc(soap, sizeof(struct tt__HostnameInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__HostnameInformationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__HostnameInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__HostnameInformationExtension, sizeof(struct tt__HostnameInformationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__HostnameInformationExtension(struct soap *soap, struct tt__HostnameInformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__HostnameInformationExtension);
	if (soap_out_PointerTott__HostnameInformationExtension(soap, tag?tag:"tt:HostnameInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__HostnameInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__HostnameInformationExtension(struct soap *soap, struct tt__HostnameInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__HostnameInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkHostExtension(struct soap *soap, struct tt__NetworkHostExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkHostExtension))
		soap_serialize_tt__NetworkHostExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkHostExtension(struct soap *soap, const char *tag, int id, struct tt__NetworkHostExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkHostExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkHostExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkHostExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkHostExtension(struct soap *soap, const char *tag, struct tt__NetworkHostExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkHostExtension **)soap_malloc(soap, sizeof(struct tt__NetworkHostExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkHostExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkHostExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkHostExtension, sizeof(struct tt__NetworkHostExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkHostExtension(struct soap *soap, struct tt__NetworkHostExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkHostExtension);
	if (soap_out_PointerTott__NetworkHostExtension(soap, tag?tag:"tt:NetworkHostExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkHostExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkHostExtension(struct soap *soap, struct tt__NetworkHostExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkHostExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkProtocolExtension(struct soap *soap, struct tt__NetworkProtocolExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkProtocolExtension))
		soap_serialize_tt__NetworkProtocolExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkProtocolExtension(struct soap *soap, const char *tag, int id, struct tt__NetworkProtocolExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkProtocolExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkProtocolExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkProtocolExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkProtocolExtension(struct soap *soap, const char *tag, struct tt__NetworkProtocolExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkProtocolExtension **)soap_malloc(soap, sizeof(struct tt__NetworkProtocolExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkProtocolExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkProtocolExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkProtocolExtension, sizeof(struct tt__NetworkProtocolExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkProtocolExtension(struct soap *soap, struct tt__NetworkProtocolExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkProtocolExtension);
	if (soap_out_PointerTott__NetworkProtocolExtension(soap, tag?tag:"tt:NetworkProtocolExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkProtocolExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkProtocolExtension(struct soap *soap, struct tt__NetworkProtocolExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkProtocolExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6ConfigurationExtension(struct soap *soap, struct tt__IPv6ConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6ConfigurationExtension))
		soap_serialize_tt__IPv6ConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6ConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__IPv6ConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6ConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6ConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv6ConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__IPv6ConfigurationExtension(struct soap *soap, const char *tag, struct tt__IPv6ConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPv6ConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__IPv6ConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6ConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPv6ConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6ConfigurationExtension, sizeof(struct tt__IPv6ConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6ConfigurationExtension(struct soap *soap, struct tt__IPv6ConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6ConfigurationExtension);
	if (soap_out_PointerTott__IPv6ConfigurationExtension(soap, tag?tag:"tt:IPv6ConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6ConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__IPv6ConfigurationExtension(struct soap *soap, struct tt__IPv6ConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6ConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PrefixedIPv6Address(struct soap *soap, struct tt__PrefixedIPv6Address *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PrefixedIPv6Address))
		soap_serialize_tt__PrefixedIPv6Address(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, int id, struct tt__PrefixedIPv6Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PrefixedIPv6Address);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PrefixedIPv6Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PrefixedIPv6Address ** SOAP_FMAC4 soap_in_PointerTott__PrefixedIPv6Address(struct soap *soap, const char *tag, struct tt__PrefixedIPv6Address **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PrefixedIPv6Address **)soap_malloc(soap, sizeof(struct tt__PrefixedIPv6Address *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PrefixedIPv6Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PrefixedIPv6Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PrefixedIPv6Address, sizeof(struct tt__PrefixedIPv6Address), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PrefixedIPv6Address(struct soap *soap, struct tt__PrefixedIPv6Address *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PrefixedIPv6Address);
	if (soap_out_PointerTott__PrefixedIPv6Address(soap, tag?tag:"tt:PrefixedIPv6Address", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PrefixedIPv6Address ** SOAP_FMAC4 soap_get_PointerTott__PrefixedIPv6Address(struct soap *soap, struct tt__PrefixedIPv6Address **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PrefixedIPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PrefixedIPv4Address(struct soap *soap, struct tt__PrefixedIPv4Address *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PrefixedIPv4Address))
		soap_serialize_tt__PrefixedIPv4Address(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, int id, struct tt__PrefixedIPv4Address *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PrefixedIPv4Address);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PrefixedIPv4Address(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PrefixedIPv4Address ** SOAP_FMAC4 soap_in_PointerTott__PrefixedIPv4Address(struct soap *soap, const char *tag, struct tt__PrefixedIPv4Address **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PrefixedIPv4Address **)soap_malloc(soap, sizeof(struct tt__PrefixedIPv4Address *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PrefixedIPv4Address(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PrefixedIPv4Address **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PrefixedIPv4Address, sizeof(struct tt__PrefixedIPv4Address), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PrefixedIPv4Address(struct soap *soap, struct tt__PrefixedIPv4Address *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PrefixedIPv4Address);
	if (soap_out_PointerTott__PrefixedIPv4Address(soap, tag?tag:"tt:PrefixedIPv4Address", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PrefixedIPv4Address ** SOAP_FMAC4 soap_get_PointerTott__PrefixedIPv4Address(struct soap *soap, struct tt__PrefixedIPv4Address **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PrefixedIPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4Configuration(struct soap *soap, struct tt__IPv4Configuration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4Configuration))
		soap_serialize_tt__IPv4Configuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4Configuration(struct soap *soap, const char *tag, int id, struct tt__IPv4Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4Configuration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv4Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv4Configuration ** SOAP_FMAC4 soap_in_PointerTott__IPv4Configuration(struct soap *soap, const char *tag, struct tt__IPv4Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPv4Configuration **)soap_malloc(soap, sizeof(struct tt__IPv4Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv4Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPv4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4Configuration, sizeof(struct tt__IPv4Configuration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4Configuration(struct soap *soap, struct tt__IPv4Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv4Configuration);
	if (soap_out_PointerTott__IPv4Configuration(soap, tag?tag:"tt:IPv4Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4Configuration ** SOAP_FMAC4 soap_get_PointerTott__IPv4Configuration(struct soap *soap, struct tt__IPv4Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6Configuration(struct soap *soap, struct tt__IPv6Configuration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6Configuration))
		soap_serialize_tt__IPv6Configuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6Configuration(struct soap *soap, const char *tag, int id, struct tt__IPv6Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6Configuration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv6Configuration ** SOAP_FMAC4 soap_in_PointerTott__IPv6Configuration(struct soap *soap, const char *tag, struct tt__IPv6Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPv6Configuration **)soap_malloc(soap, sizeof(struct tt__IPv6Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPv6Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6Configuration, sizeof(struct tt__IPv6Configuration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6Configuration(struct soap *soap, struct tt__IPv6Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6Configuration);
	if (soap_out_PointerTott__IPv6Configuration(soap, tag?tag:"tt:IPv6Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6Configuration ** SOAP_FMAC4 soap_get_PointerTott__IPv6Configuration(struct soap *soap, struct tt__IPv6Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, struct tt__NetworkInterfaceConnectionSetting *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting))
		soap_serialize_tt__NetworkInterfaceConnectionSetting(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceConnectionSetting *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceConnectionSetting(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceConnectionSetting ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, const char *tag, struct tt__NetworkInterfaceConnectionSetting **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceConnectionSetting **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceConnectionSetting *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceConnectionSetting(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceConnectionSetting **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceConnectionSetting, sizeof(struct tt__NetworkInterfaceConnectionSetting), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, struct tt__NetworkInterfaceConnectionSetting *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceConnectionSetting);
	if (soap_out_PointerTott__NetworkInterfaceConnectionSetting(soap, tag?tag:"tt:NetworkInterfaceConnectionSetting", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceConnectionSetting ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceConnectionSetting(struct soap *soap, struct tt__NetworkInterfaceConnectionSetting **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceConnectionSetting(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceExtension2(struct soap *soap, struct tt__NetworkInterfaceExtension2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceExtension2))
		soap_serialize_tt__NetworkInterfaceExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceExtension2(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension2 ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceExtension2(struct soap *soap, const char *tag, struct tt__NetworkInterfaceExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceExtension2 **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceExtension2, sizeof(struct tt__NetworkInterfaceExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceExtension2(struct soap *soap, struct tt__NetworkInterfaceExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceExtension2);
	if (soap_out_PointerTott__NetworkInterfaceExtension2(soap, tag?tag:"tt:NetworkInterfaceExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension2 ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceExtension2(struct soap *soap, struct tt__NetworkInterfaceExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Configuration(struct soap *soap, struct tt__Dot11Configuration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Configuration))
		soap_serialize_tt__Dot11Configuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Configuration(struct soap *soap, const char *tag, int id, struct tt__Dot11Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Configuration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11Configuration ** SOAP_FMAC4 soap_in_PointerTott__Dot11Configuration(struct soap *soap, const char *tag, struct tt__Dot11Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11Configuration **)soap_malloc(soap, sizeof(struct tt__Dot11Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Configuration, sizeof(struct tt__Dot11Configuration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Configuration(struct soap *soap, struct tt__Dot11Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11Configuration);
	if (soap_out_PointerTott__Dot11Configuration(soap, tag?tag:"tt:Dot11Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Configuration ** SOAP_FMAC4 soap_get_PointerTott__Dot11Configuration(struct soap *soap, struct tt__Dot11Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot3Configuration(struct soap *soap, struct tt__Dot3Configuration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot3Configuration))
		soap_serialize_tt__Dot3Configuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot3Configuration(struct soap *soap, const char *tag, int id, struct tt__Dot3Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot3Configuration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot3Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot3Configuration ** SOAP_FMAC4 soap_in_PointerTott__Dot3Configuration(struct soap *soap, const char *tag, struct tt__Dot3Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot3Configuration **)soap_malloc(soap, sizeof(struct tt__Dot3Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot3Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot3Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot3Configuration, sizeof(struct tt__Dot3Configuration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot3Configuration(struct soap *soap, struct tt__Dot3Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot3Configuration);
	if (soap_out_PointerTott__Dot3Configuration(soap, tag?tag:"tt:Dot3Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot3Configuration ** SOAP_FMAC4 soap_get_PointerTott__Dot3Configuration(struct soap *soap, struct tt__Dot3Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot3Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Transport(struct soap *soap, struct tt__Transport *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Transport))
		soap_serialize_tt__Transport(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Transport(struct soap *soap, const char *tag, int id, struct tt__Transport *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Transport);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Transport(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Transport ** SOAP_FMAC4 soap_in_PointerTott__Transport(struct soap *soap, const char *tag, struct tt__Transport **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Transport **)soap_malloc(soap, sizeof(struct tt__Transport *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Transport(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Transport **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Transport, sizeof(struct tt__Transport), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Transport(struct soap *soap, struct tt__Transport *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Transport);
	if (soap_out_PointerTott__Transport(soap, tag?tag:"tt:Transport", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Transport ** SOAP_FMAC4 soap_get_PointerTott__Transport(struct soap *soap, struct tt__Transport **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Transport(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddress(struct soap *soap, struct tt__IPAddress *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddress))
		soap_serialize_tt__IPAddress(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddress(struct soap *soap, const char *tag, int id, struct tt__IPAddress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddress);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPAddress(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPAddress ** SOAP_FMAC4 soap_in_PointerTott__IPAddress(struct soap *soap, const char *tag, struct tt__IPAddress **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPAddress **)soap_malloc(soap, sizeof(struct tt__IPAddress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPAddress(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddress, sizeof(struct tt__IPAddress), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddress(struct soap *soap, struct tt__IPAddress *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPAddress);
	if (soap_out_PointerTott__IPAddress(soap, tag?tag:"tt:IPAddress", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddress ** SOAP_FMAC4 soap_get_PointerTott__IPAddress(struct soap *soap, struct tt__IPAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__AudioDecoderConfigurationOptionsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension))
		soap_serialize_tt__AudioDecoderConfigurationOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__AudioDecoderConfigurationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioDecoderConfigurationOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__AudioDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, struct tt__AudioDecoderConfigurationOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioDecoderConfigurationOptionsExtension **)soap_malloc(soap, sizeof(struct tt__AudioDecoderConfigurationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioDecoderConfigurationOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioDecoderConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioDecoderConfigurationOptionsExtension, sizeof(struct tt__AudioDecoderConfigurationOptionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__AudioDecoderConfigurationOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioDecoderConfigurationOptionsExtension);
	if (soap_out_PointerTott__AudioDecoderConfigurationOptionsExtension(soap, tag?tag:"tt:AudioDecoderConfigurationOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioDecoderConfigurationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__AudioDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__AudioDecoderConfigurationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioDecoderConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__G726DecOptions(struct soap *soap, struct tt__G726DecOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__G726DecOptions))
		soap_serialize_tt__G726DecOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__G726DecOptions(struct soap *soap, const char *tag, int id, struct tt__G726DecOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__G726DecOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__G726DecOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__G726DecOptions ** SOAP_FMAC4 soap_in_PointerTott__G726DecOptions(struct soap *soap, const char *tag, struct tt__G726DecOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__G726DecOptions **)soap_malloc(soap, sizeof(struct tt__G726DecOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__G726DecOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__G726DecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__G726DecOptions, sizeof(struct tt__G726DecOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__G726DecOptions(struct soap *soap, struct tt__G726DecOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__G726DecOptions);
	if (soap_out_PointerTott__G726DecOptions(soap, tag?tag:"tt:G726DecOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__G726DecOptions ** SOAP_FMAC4 soap_get_PointerTott__G726DecOptions(struct soap *soap, struct tt__G726DecOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__G726DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__G711DecOptions(struct soap *soap, struct tt__G711DecOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__G711DecOptions))
		soap_serialize_tt__G711DecOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__G711DecOptions(struct soap *soap, const char *tag, int id, struct tt__G711DecOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__G711DecOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__G711DecOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__G711DecOptions ** SOAP_FMAC4 soap_in_PointerTott__G711DecOptions(struct soap *soap, const char *tag, struct tt__G711DecOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__G711DecOptions **)soap_malloc(soap, sizeof(struct tt__G711DecOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__G711DecOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__G711DecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__G711DecOptions, sizeof(struct tt__G711DecOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__G711DecOptions(struct soap *soap, struct tt__G711DecOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__G711DecOptions);
	if (soap_out_PointerTott__G711DecOptions(soap, tag?tag:"tt:G711DecOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__G711DecOptions ** SOAP_FMAC4 soap_get_PointerTott__G711DecOptions(struct soap *soap, struct tt__G711DecOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__G711DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AACDecOptions(struct soap *soap, struct tt__AACDecOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AACDecOptions))
		soap_serialize_tt__AACDecOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AACDecOptions(struct soap *soap, const char *tag, int id, struct tt__AACDecOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AACDecOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AACDecOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AACDecOptions ** SOAP_FMAC4 soap_in_PointerTott__AACDecOptions(struct soap *soap, const char *tag, struct tt__AACDecOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AACDecOptions **)soap_malloc(soap, sizeof(struct tt__AACDecOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AACDecOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AACDecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AACDecOptions, sizeof(struct tt__AACDecOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AACDecOptions(struct soap *soap, struct tt__AACDecOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AACDecOptions);
	if (soap_out_PointerTott__AACDecOptions(soap, tag?tag:"tt:AACDecOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AACDecOptions ** SOAP_FMAC4 soap_get_PointerTott__AACDecOptions(struct soap *soap, struct tt__AACDecOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AACDecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__VideoDecoderConfigurationOptionsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension))
		soap_serialize_tt__VideoDecoderConfigurationOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__VideoDecoderConfigurationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoDecoderConfigurationOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoDecoderConfigurationOptionsExtension(struct soap *soap, const char *tag, struct tt__VideoDecoderConfigurationOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoDecoderConfigurationOptionsExtension **)soap_malloc(soap, sizeof(struct tt__VideoDecoderConfigurationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoDecoderConfigurationOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoDecoderConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoDecoderConfigurationOptionsExtension, sizeof(struct tt__VideoDecoderConfigurationOptionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__VideoDecoderConfigurationOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoDecoderConfigurationOptionsExtension);
	if (soap_out_PointerTott__VideoDecoderConfigurationOptionsExtension(soap, tag?tag:"tt:VideoDecoderConfigurationOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoDecoderConfigurationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoDecoderConfigurationOptionsExtension(struct soap *soap, struct tt__VideoDecoderConfigurationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoDecoderConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4DecOptions(struct soap *soap, struct tt__Mpeg4DecOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4DecOptions))
		soap_serialize_tt__Mpeg4DecOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4DecOptions(struct soap *soap, const char *tag, int id, struct tt__Mpeg4DecOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4DecOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Mpeg4DecOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Mpeg4DecOptions ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4DecOptions(struct soap *soap, const char *tag, struct tt__Mpeg4DecOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Mpeg4DecOptions **)soap_malloc(soap, sizeof(struct tt__Mpeg4DecOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Mpeg4DecOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Mpeg4DecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4DecOptions, sizeof(struct tt__Mpeg4DecOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4DecOptions(struct soap *soap, struct tt__Mpeg4DecOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Mpeg4DecOptions);
	if (soap_out_PointerTott__Mpeg4DecOptions(soap, tag?tag:"tt:Mpeg4DecOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4DecOptions ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4DecOptions(struct soap *soap, struct tt__Mpeg4DecOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264DecOptions(struct soap *soap, struct tt__H264DecOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264DecOptions))
		soap_serialize_tt__H264DecOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264DecOptions(struct soap *soap, const char *tag, int id, struct tt__H264DecOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264DecOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__H264DecOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__H264DecOptions ** SOAP_FMAC4 soap_in_PointerTott__H264DecOptions(struct soap *soap, const char *tag, struct tt__H264DecOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__H264DecOptions **)soap_malloc(soap, sizeof(struct tt__H264DecOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__H264DecOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__H264DecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264DecOptions, sizeof(struct tt__H264DecOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264DecOptions(struct soap *soap, struct tt__H264DecOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__H264DecOptions);
	if (soap_out_PointerTott__H264DecOptions(soap, tag?tag:"tt:H264DecOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264DecOptions ** SOAP_FMAC4 soap_get_PointerTott__H264DecOptions(struct soap *soap, struct tt__H264DecOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264DecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__JpegDecOptions(struct soap *soap, struct tt__JpegDecOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__JpegDecOptions))
		soap_serialize_tt__JpegDecOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__JpegDecOptions(struct soap *soap, const char *tag, int id, struct tt__JpegDecOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__JpegDecOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__JpegDecOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__JpegDecOptions ** SOAP_FMAC4 soap_in_PointerTott__JpegDecOptions(struct soap *soap, const char *tag, struct tt__JpegDecOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__JpegDecOptions **)soap_malloc(soap, sizeof(struct tt__JpegDecOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__JpegDecOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__JpegDecOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__JpegDecOptions, sizeof(struct tt__JpegDecOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__JpegDecOptions(struct soap *soap, struct tt__JpegDecOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__JpegDecOptions);
	if (soap_out_PointerTott__JpegDecOptions(soap, tag?tag:"tt:JpegDecOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegDecOptions ** SOAP_FMAC4 soap_get_PointerTott__JpegDecOptions(struct soap *soap, struct tt__JpegDecOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__JpegDecOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZStatusFilterOptionsExtension(struct soap *soap, struct tt__PTZStatusFilterOptionsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension))
		soap_serialize_tt__PTZStatusFilterOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZStatusFilterOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__PTZStatusFilterOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZStatusFilterOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZStatusFilterOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZStatusFilterOptionsExtension(struct soap *soap, const char *tag, struct tt__PTZStatusFilterOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZStatusFilterOptionsExtension **)soap_malloc(soap, sizeof(struct tt__PTZStatusFilterOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZStatusFilterOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStatusFilterOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStatusFilterOptionsExtension, sizeof(struct tt__PTZStatusFilterOptionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZStatusFilterOptionsExtension(struct soap *soap, struct tt__PTZStatusFilterOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZStatusFilterOptionsExtension);
	if (soap_out_PointerTott__PTZStatusFilterOptionsExtension(soap, tag?tag:"tt:PTZStatusFilterOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStatusFilterOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZStatusFilterOptionsExtension(struct soap *soap, struct tt__PTZStatusFilterOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZStatusFilterOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZStatusFilterOptions(struct soap *soap, struct tt__PTZStatusFilterOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZStatusFilterOptions))
		soap_serialize_tt__PTZStatusFilterOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZStatusFilterOptions(struct soap *soap, const char *tag, int id, struct tt__PTZStatusFilterOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZStatusFilterOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZStatusFilterOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZStatusFilterOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZStatusFilterOptions(struct soap *soap, const char *tag, struct tt__PTZStatusFilterOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZStatusFilterOptions **)soap_malloc(soap, sizeof(struct tt__PTZStatusFilterOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZStatusFilterOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZStatusFilterOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZStatusFilterOptions, sizeof(struct tt__PTZStatusFilterOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZStatusFilterOptions(struct soap *soap, struct tt__PTZStatusFilterOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZStatusFilterOptions);
	if (soap_out_PointerTott__PTZStatusFilterOptions(soap, tag?tag:"tt:PTZStatusFilterOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZStatusFilterOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZStatusFilterOptions(struct soap *soap, struct tt__PTZStatusFilterOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZStatusFilterOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, struct _tt__EventSubscription_SubscriptionPolicy *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy))
		soap_serialize__tt__EventSubscription_SubscriptionPolicy(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, struct _tt__EventSubscription_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy);
	if (id < 0)
		return soap->error;
	return soap_out__tt__EventSubscription_SubscriptionPolicy(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tt__EventSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, struct _tt__EventSubscription_SubscriptionPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tt__EventSubscription_SubscriptionPolicy **)soap_malloc(soap, sizeof(struct _tt__EventSubscription_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tt__EventSubscription_SubscriptionPolicy(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tt__EventSubscription_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tt__EventSubscription_SubscriptionPolicy, sizeof(struct _tt__EventSubscription_SubscriptionPolicy), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, struct _tt__EventSubscription_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tt__EventSubscription_SubscriptionPolicy);
	if (soap_out_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, tag?tag:"tt:EventSubscription-SubscriptionPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tt__EventSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_tt__EventSubscription_SubscriptionPolicy(struct soap *soap, struct _tt__EventSubscription_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tt__EventSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__FilterType(struct soap *soap, struct wsnt__FilterType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__FilterType))
		soap_serialize_wsnt__FilterType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__FilterType(struct soap *soap, const char *tag, int id, struct wsnt__FilterType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__FilterType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__FilterType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__FilterType ** SOAP_FMAC4 soap_in_PointerTowsnt__FilterType(struct soap *soap, const char *tag, struct wsnt__FilterType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__FilterType **)soap_malloc(soap, sizeof(struct wsnt__FilterType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__FilterType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__FilterType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__FilterType, sizeof(struct wsnt__FilterType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__FilterType(struct soap *soap, struct wsnt__FilterType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__FilterType);
	if (soap_out_PointerTowsnt__FilterType(soap, tag?tag:"wsnt:FilterType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__FilterType ** SOAP_FMAC4 soap_get_PointerTowsnt__FilterType(struct soap *soap, struct wsnt__FilterType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__FilterType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, struct tt__AudioEncoderConfigurationOption *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioEncoderConfigurationOption))
		soap_serialize_tt__AudioEncoderConfigurationOption(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, int id, struct tt__AudioEncoderConfigurationOption *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioEncoderConfigurationOption);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioEncoderConfigurationOption(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOption ** SOAP_FMAC4 soap_in_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, struct tt__AudioEncoderConfigurationOption **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioEncoderConfigurationOption **)soap_malloc(soap, sizeof(struct tt__AudioEncoderConfigurationOption *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioEncoderConfigurationOption(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioEncoderConfigurationOption **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoderConfigurationOption, sizeof(struct tt__AudioEncoderConfigurationOption), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, struct tt__AudioEncoderConfigurationOption *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioEncoderConfigurationOption);
	if (soap_out_PointerTott__AudioEncoderConfigurationOption(soap, tag?tag:"tt:AudioEncoderConfigurationOption", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoderConfigurationOption ** SOAP_FMAC4 soap_get_PointerTott__AudioEncoderConfigurationOption(struct soap *soap, struct tt__AudioEncoderConfigurationOption **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioEncoderConfigurationOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSourceOptionsExtension(struct soap *soap, struct tt__AudioSourceOptionsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSourceOptionsExtension))
		soap_serialize_tt__AudioSourceOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSourceOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__AudioSourceOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSourceOptionsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioSourceOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioSourceOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__AudioSourceOptionsExtension(struct soap *soap, const char *tag, struct tt__AudioSourceOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioSourceOptionsExtension **)soap_malloc(soap, sizeof(struct tt__AudioSourceOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioSourceOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioSourceOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSourceOptionsExtension, sizeof(struct tt__AudioSourceOptionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSourceOptionsExtension(struct soap *soap, struct tt__AudioSourceOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioSourceOptionsExtension);
	if (soap_out_PointerTott__AudioSourceOptionsExtension(soap, tag?tag:"tt:AudioSourceOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSourceOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__AudioSourceOptionsExtension(struct soap *soap, struct tt__AudioSourceOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSourceOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Profile(struct soap *soap, enum tt__H264Profile *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__H264Profile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Profile(struct soap *soap, const char *tag, int id, enum tt__H264Profile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Profile);
	if (id < 0)
		return soap->error;
	return soap_out_tt__H264Profile(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__H264Profile ** SOAP_FMAC4 soap_in_PointerTott__H264Profile(struct soap *soap, const char *tag, enum tt__H264Profile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__H264Profile **)soap_malloc(soap, sizeof(enum tt__H264Profile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__H264Profile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__H264Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Profile, sizeof(enum tt__H264Profile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Profile(struct soap *soap, enum tt__H264Profile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__H264Profile);
	if (soap_out_PointerTott__H264Profile(soap, tag?tag:"tt:H264Profile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__H264Profile ** SOAP_FMAC4 soap_get_PointerTott__H264Profile(struct soap *soap, enum tt__H264Profile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Profile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Profile(struct soap *soap, const char *tag, int id, enum tt__Mpeg4Profile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Profile);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Mpeg4Profile(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__Mpeg4Profile ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Profile(struct soap *soap, const char *tag, enum tt__Mpeg4Profile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__Mpeg4Profile **)soap_malloc(soap, sizeof(enum tt__Mpeg4Profile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Mpeg4Profile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__Mpeg4Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Profile, sizeof(enum tt__Mpeg4Profile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Mpeg4Profile);
	if (soap_out_PointerTott__Mpeg4Profile(soap, tag?tag:"tt:Mpeg4Profile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__Mpeg4Profile ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Profile(struct soap *soap, enum tt__Mpeg4Profile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoResolution(struct soap *soap, struct tt__VideoResolution *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoResolution))
		soap_serialize_tt__VideoResolution(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoResolution(struct soap *soap, const char *tag, int id, struct tt__VideoResolution *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoResolution);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoResolution(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoResolution ** SOAP_FMAC4 soap_in_PointerTott__VideoResolution(struct soap *soap, const char *tag, struct tt__VideoResolution **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoResolution **)soap_malloc(soap, sizeof(struct tt__VideoResolution *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoResolution(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoResolution **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoResolution, sizeof(struct tt__VideoResolution), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoResolution(struct soap *soap, struct tt__VideoResolution *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoResolution);
	if (soap_out_PointerTott__VideoResolution(soap, tag?tag:"tt:VideoResolution", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoResolution ** SOAP_FMAC4 soap_get_PointerTott__VideoResolution(struct soap *soap, struct tt__VideoResolution **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoResolution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2))
		soap_serialize_tt__VideoEncoderOptionsExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, int id, struct tt__VideoEncoderOptionsExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderOptionsExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoEncoderOptionsExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, struct tt__VideoEncoderOptionsExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoEncoderOptionsExtension2 **)soap_malloc(soap, sizeof(struct tt__VideoEncoderOptionsExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoEncoderOptionsExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderOptionsExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, sizeof(struct tt__VideoEncoderOptionsExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension2);
	if (soap_out_PointerTott__VideoEncoderOptionsExtension2(soap, tag?tag:"tt:VideoEncoderOptionsExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderOptionsExtension2(struct soap *soap, struct tt__VideoEncoderOptionsExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Options2(struct soap *soap, struct tt__H264Options2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Options2))
		soap_serialize_tt__H264Options2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Options2(struct soap *soap, const char *tag, int id, struct tt__H264Options2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Options2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__H264Options2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__H264Options2 ** SOAP_FMAC4 soap_in_PointerTott__H264Options2(struct soap *soap, const char *tag, struct tt__H264Options2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__H264Options2 **)soap_malloc(soap, sizeof(struct tt__H264Options2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__H264Options2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__H264Options2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Options2, sizeof(struct tt__H264Options2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Options2(struct soap *soap, struct tt__H264Options2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__H264Options2);
	if (soap_out_PointerTott__H264Options2(soap, tag?tag:"tt:H264Options2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Options2 ** SOAP_FMAC4 soap_get_PointerTott__H264Options2(struct soap *soap, struct tt__H264Options2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Options2))
		soap_serialize_tt__Mpeg4Options2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Options2(struct soap *soap, const char *tag, int id, struct tt__Mpeg4Options2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Options2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Mpeg4Options2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Mpeg4Options2 ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Options2(struct soap *soap, const char *tag, struct tt__Mpeg4Options2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Mpeg4Options2 **)soap_malloc(soap, sizeof(struct tt__Mpeg4Options2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Mpeg4Options2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Options2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Options2, sizeof(struct tt__Mpeg4Options2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Mpeg4Options2);
	if (soap_out_PointerTott__Mpeg4Options2(soap, tag?tag:"tt:Mpeg4Options2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Options2 ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Options2(struct soap *soap, struct tt__Mpeg4Options2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__JpegOptions2))
		soap_serialize_tt__JpegOptions2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__JpegOptions2(struct soap *soap, const char *tag, int id, struct tt__JpegOptions2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__JpegOptions2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__JpegOptions2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__JpegOptions2 ** SOAP_FMAC4 soap_in_PointerTott__JpegOptions2(struct soap *soap, const char *tag, struct tt__JpegOptions2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__JpegOptions2 **)soap_malloc(soap, sizeof(struct tt__JpegOptions2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__JpegOptions2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__JpegOptions2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__JpegOptions2, sizeof(struct tt__JpegOptions2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__JpegOptions2);
	if (soap_out_PointerTott__JpegOptions2(soap, tag?tag:"tt:JpegOptions2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegOptions2 ** SOAP_FMAC4 soap_get_PointerTott__JpegOptions2(struct soap *soap, struct tt__JpegOptions2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__JpegOptions2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderOptionsExtension))
		soap_serialize_tt__VideoEncoderOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__VideoEncoderOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderOptionsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoEncoderOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, struct tt__VideoEncoderOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoEncoderOptionsExtension **)soap_malloc(soap, sizeof(struct tt__VideoEncoderOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoEncoderOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(struct tt__VideoEncoderOptionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoEncoderOptionsExtension);
	if (soap_out_PointerTott__VideoEncoderOptionsExtension(soap, tag?tag:"tt:VideoEncoderOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderOptionsExtension(struct soap *soap, struct tt__VideoEncoderOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Options(struct soap *soap, struct tt__H264Options *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Options))
		soap_serialize_tt__H264Options(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Options(struct soap *soap, const char *tag, int id, struct tt__H264Options *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Options);
	if (id < 0)
		return soap->error;
	return soap_out_tt__H264Options(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__H264Options ** SOAP_FMAC4 soap_in_PointerTott__H264Options(struct soap *soap, const char *tag, struct tt__H264Options **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__H264Options **)soap_malloc(soap, sizeof(struct tt__H264Options *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__H264Options(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__H264Options **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Options, sizeof(struct tt__H264Options), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Options(struct soap *soap, struct tt__H264Options *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__H264Options);
	if (soap_out_PointerTott__H264Options(soap, tag?tag:"tt:H264Options", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Options ** SOAP_FMAC4 soap_get_PointerTott__H264Options(struct soap *soap, struct tt__H264Options **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Options))
		soap_serialize_tt__Mpeg4Options(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Options(struct soap *soap, const char *tag, int id, struct tt__Mpeg4Options *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Options);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Mpeg4Options(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Mpeg4Options ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Options(struct soap *soap, const char *tag, struct tt__Mpeg4Options **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Mpeg4Options **)soap_malloc(soap, sizeof(struct tt__Mpeg4Options *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Mpeg4Options(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Options **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Options, sizeof(struct tt__Mpeg4Options), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Mpeg4Options);
	if (soap_out_PointerTott__Mpeg4Options(soap, tag?tag:"tt:Mpeg4Options", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Options ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Options(struct soap *soap, struct tt__Mpeg4Options **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__JpegOptions(struct soap *soap, struct tt__JpegOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__JpegOptions))
		soap_serialize_tt__JpegOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__JpegOptions(struct soap *soap, const char *tag, int id, struct tt__JpegOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__JpegOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__JpegOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__JpegOptions ** SOAP_FMAC4 soap_in_PointerTott__JpegOptions(struct soap *soap, const char *tag, struct tt__JpegOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__JpegOptions **)soap_malloc(soap, sizeof(struct tt__JpegOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__JpegOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__JpegOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__JpegOptions, sizeof(struct tt__JpegOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__JpegOptions(struct soap *soap, struct tt__JpegOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__JpegOptions);
	if (soap_out_PointerTott__JpegOptions(soap, tag?tag:"tt:JpegOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__JpegOptions ** SOAP_FMAC4 soap_get_PointerTott__JpegOptions(struct soap *soap, struct tt__JpegOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__JpegOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RotateOptionsExtension(struct soap *soap, struct tt__RotateOptionsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RotateOptionsExtension))
		soap_serialize_tt__RotateOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RotateOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__RotateOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RotateOptionsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RotateOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RotateOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__RotateOptionsExtension(struct soap *soap, const char *tag, struct tt__RotateOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RotateOptionsExtension **)soap_malloc(soap, sizeof(struct tt__RotateOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RotateOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RotateOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateOptionsExtension, sizeof(struct tt__RotateOptionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RotateOptionsExtension(struct soap *soap, struct tt__RotateOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RotateOptionsExtension);
	if (soap_out_PointerTott__RotateOptionsExtension(soap, tag?tag:"tt:RotateOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RotateOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__RotateOptionsExtension(struct soap *soap, struct tt__RotateOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RotateOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntList(struct soap *soap, struct tt__IntList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntList))
		soap_serialize_tt__IntList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntList(struct soap *soap, const char *tag, int id, struct tt__IntList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntList);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IntList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IntList ** SOAP_FMAC4 soap_in_PointerTott__IntList(struct soap *soap, const char *tag, struct tt__IntList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IntList **)soap_malloc(soap, sizeof(struct tt__IntList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IntList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IntList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntList, sizeof(struct tt__IntList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntList(struct soap *soap, struct tt__IntList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IntList);
	if (soap_out_PointerTott__IntList(soap, tag?tag:"tt:IntList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntList ** SOAP_FMAC4 soap_get_PointerTott__IntList(struct soap *soap, struct tt__IntList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RotateMode(struct soap *soap, enum tt__RotateMode *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__RotateMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RotateMode(struct soap *soap, const char *tag, int id, enum tt__RotateMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RotateMode);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RotateMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__RotateMode ** SOAP_FMAC4 soap_in_PointerTott__RotateMode(struct soap *soap, const char *tag, enum tt__RotateMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__RotateMode **)soap_malloc(soap, sizeof(enum tt__RotateMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RotateMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__RotateMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateMode, sizeof(enum tt__RotateMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RotateMode(struct soap *soap, enum tt__RotateMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RotateMode);
	if (soap_out_PointerTott__RotateMode(soap, tag?tag:"tt:RotateMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__RotateMode ** SOAP_FMAC4 soap_get_PointerTott__RotateMode(struct soap *soap, enum tt__RotateMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RotateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2))
		soap_serialize_tt__VideoSourceConfigurationOptionsExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfigurationOptionsExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceConfigurationOptionsExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationOptionsExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceConfigurationOptionsExtension2 **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfigurationOptionsExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceConfigurationOptionsExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationOptionsExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, sizeof(struct tt__VideoSourceConfigurationOptionsExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoSourceConfigurationOptionsExtension2);
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, tag?tag:"tt:VideoSourceConfigurationOptionsExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationOptionsExtension2(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RotateOptions(struct soap *soap, struct tt__RotateOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RotateOptions))
		soap_serialize_tt__RotateOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RotateOptions(struct soap *soap, const char *tag, int id, struct tt__RotateOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RotateOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RotateOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RotateOptions ** SOAP_FMAC4 soap_in_PointerTott__RotateOptions(struct soap *soap, const char *tag, struct tt__RotateOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RotateOptions **)soap_malloc(soap, sizeof(struct tt__RotateOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RotateOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RotateOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateOptions, sizeof(struct tt__RotateOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RotateOptions(struct soap *soap, struct tt__RotateOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RotateOptions);
	if (soap_out_PointerTott__RotateOptions(soap, tag?tag:"tt:RotateOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RotateOptions ** SOAP_FMAC4 soap_get_PointerTott__RotateOptions(struct soap *soap, struct tt__RotateOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RotateOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension))
		soap_serialize_tt__VideoSourceConfigurationOptionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfigurationOptionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceConfigurationOptionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationOptionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceConfigurationOptionsExtension **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfigurationOptionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceConfigurationOptionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationOptionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, sizeof(struct tt__VideoSourceConfigurationOptionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoSourceConfigurationOptionsExtension);
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension(soap, tag?tag:"tt:VideoSourceConfigurationOptionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptionsExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationOptionsExtension(struct soap *soap, struct tt__VideoSourceConfigurationOptionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRectangleRange(struct soap *soap, struct tt__IntRectangleRange *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRectangleRange))
		soap_serialize_tt__IntRectangleRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRectangleRange(struct soap *soap, const char *tag, int id, struct tt__IntRectangleRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRectangleRange);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IntRectangleRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IntRectangleRange ** SOAP_FMAC4 soap_in_PointerTott__IntRectangleRange(struct soap *soap, const char *tag, struct tt__IntRectangleRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IntRectangleRange **)soap_malloc(soap, sizeof(struct tt__IntRectangleRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IntRectangleRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IntRectangleRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRectangleRange, sizeof(struct tt__IntRectangleRange), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRectangleRange(struct soap *soap, struct tt__IntRectangleRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IntRectangleRange);
	if (soap_out_PointerTott__IntRectangleRange(soap, tag?tag:"tt:IntRectangleRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRectangleRange ** SOAP_FMAC4 soap_get_PointerTott__IntRectangleRange(struct soap *soap, struct tt__IntRectangleRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRectangleRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RotateExtension(struct soap *soap, struct tt__RotateExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RotateExtension))
		soap_serialize_tt__RotateExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RotateExtension(struct soap *soap, const char *tag, int id, struct tt__RotateExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RotateExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RotateExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RotateExtension ** SOAP_FMAC4 soap_in_PointerTott__RotateExtension(struct soap *soap, const char *tag, struct tt__RotateExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RotateExtension **)soap_malloc(soap, sizeof(struct tt__RotateExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RotateExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RotateExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RotateExtension, sizeof(struct tt__RotateExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RotateExtension(struct soap *soap, struct tt__RotateExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RotateExtension);
	if (soap_out_PointerTott__RotateExtension(soap, tag?tag:"tt:RotateExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RotateExtension ** SOAP_FMAC4 soap_get_PointerTott__RotateExtension(struct soap *soap, struct tt__RotateExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RotateExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, struct tt__VideoSourceConfigurationExtension2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2))
		soap_serialize_tt__VideoSourceConfigurationExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfigurationExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceConfigurationExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceConfigurationExtension2 **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfigurationExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceConfigurationExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, sizeof(struct tt__VideoSourceConfigurationExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, struct tt__VideoSourceConfigurationExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension2);
	if (soap_out_PointerTott__VideoSourceConfigurationExtension2(soap, tag?tag:"tt:VideoSourceConfigurationExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationExtension2(struct soap *soap, struct tt__VideoSourceConfigurationExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Rotate(struct soap *soap, struct tt__Rotate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Rotate))
		soap_serialize_tt__Rotate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Rotate(struct soap *soap, const char *tag, int id, struct tt__Rotate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Rotate);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Rotate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Rotate ** SOAP_FMAC4 soap_in_PointerTott__Rotate(struct soap *soap, const char *tag, struct tt__Rotate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Rotate **)soap_malloc(soap, sizeof(struct tt__Rotate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Rotate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Rotate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Rotate, sizeof(struct tt__Rotate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Rotate(struct soap *soap, struct tt__Rotate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Rotate);
	if (soap_out_PointerTott__Rotate(soap, tag?tag:"tt:Rotate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Rotate ** SOAP_FMAC4 soap_get_PointerTott__Rotate(struct soap *soap, struct tt__Rotate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Rotate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileExtension2(struct soap *soap, struct tt__ProfileExtension2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileExtension2))
		soap_serialize_tt__ProfileExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileExtension2(struct soap *soap, const char *tag, int id, struct tt__ProfileExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ProfileExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ProfileExtension2 ** SOAP_FMAC4 soap_in_PointerTott__ProfileExtension2(struct soap *soap, const char *tag, struct tt__ProfileExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ProfileExtension2 **)soap_malloc(soap, sizeof(struct tt__ProfileExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ProfileExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileExtension2, sizeof(struct tt__ProfileExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileExtension2(struct soap *soap, struct tt__ProfileExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ProfileExtension2);
	if (soap_out_PointerTott__ProfileExtension2(soap, tag?tag:"tt:ProfileExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileExtension2 ** SOAP_FMAC4 soap_get_PointerTott__ProfileExtension2(struct soap *soap, struct tt__ProfileExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioDecoderConfiguration(struct soap *soap, struct tt__AudioDecoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioDecoderConfiguration))
		soap_serialize_tt__AudioDecoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioDecoderConfiguration(struct soap *soap, const char *tag, int id, struct tt__AudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioDecoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioDecoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioDecoderConfiguration(struct soap *soap, const char *tag, struct tt__AudioDecoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioDecoderConfiguration **)soap_malloc(soap, sizeof(struct tt__AudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioDecoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioDecoderConfiguration, sizeof(struct tt__AudioDecoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioDecoderConfiguration(struct soap *soap, struct tt__AudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioDecoderConfiguration);
	if (soap_out_PointerTott__AudioDecoderConfiguration(soap, tag?tag:"tt:AudioDecoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioDecoderConfiguration(struct soap *soap, struct tt__AudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioOutputConfiguration))
		soap_serialize_tt__AudioOutputConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioOutputConfiguration(struct soap *soap, const char *tag, int id, struct tt__AudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioOutputConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioOutputConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioOutputConfiguration(struct soap *soap, const char *tag, struct tt__AudioOutputConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioOutputConfiguration **)soap_malloc(soap, sizeof(struct tt__AudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioOutputConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioOutputConfiguration, sizeof(struct tt__AudioOutputConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioOutputConfiguration);
	if (soap_out_PointerTott__AudioOutputConfiguration(soap, tag?tag:"tt:AudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioOutputConfiguration(struct soap *soap, struct tt__AudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ProfileExtension(struct soap *soap, struct tt__ProfileExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ProfileExtension))
		soap_serialize_tt__ProfileExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ProfileExtension(struct soap *soap, const char *tag, int id, struct tt__ProfileExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ProfileExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ProfileExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ProfileExtension ** SOAP_FMAC4 soap_in_PointerTott__ProfileExtension(struct soap *soap, const char *tag, struct tt__ProfileExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ProfileExtension **)soap_malloc(soap, sizeof(struct tt__ProfileExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ProfileExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ProfileExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ProfileExtension, sizeof(struct tt__ProfileExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ProfileExtension(struct soap *soap, struct tt__ProfileExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ProfileExtension);
	if (soap_out_PointerTott__ProfileExtension(soap, tag?tag:"tt:ProfileExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ProfileExtension ** SOAP_FMAC4 soap_get_PointerTott__ProfileExtension(struct soap *soap, struct tt__ProfileExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ProfileExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfiguration(struct soap *soap, struct tt__MetadataConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfiguration))
		soap_serialize_tt__MetadataConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfiguration(struct soap *soap, const char *tag, int id, struct tt__MetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfiguration(struct soap *soap, const char *tag, struct tt__MetadataConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataConfiguration **)soap_malloc(soap, sizeof(struct tt__MetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfiguration, sizeof(struct tt__MetadataConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfiguration(struct soap *soap, struct tt__MetadataConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MetadataConfiguration);
	if (soap_out_PointerTott__MetadataConfiguration(soap, tag?tag:"tt:MetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfiguration(struct soap *soap, struct tt__MetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfiguration(struct soap *soap, struct tt__PTZConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfiguration))
		soap_serialize_tt__PTZConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfiguration(struct soap *soap, const char *tag, int id, struct tt__PTZConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZConfiguration ** SOAP_FMAC4 soap_in_PointerTott__PTZConfiguration(struct soap *soap, const char *tag, struct tt__PTZConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZConfiguration **)soap_malloc(soap, sizeof(struct tt__PTZConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfiguration, sizeof(struct tt__PTZConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfiguration(struct soap *soap, struct tt__PTZConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZConfiguration);
	if (soap_out_PointerTott__PTZConfiguration(soap, tag?tag:"tt:PTZConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfiguration ** SOAP_FMAC4 soap_get_PointerTott__PTZConfiguration(struct soap *soap, struct tt__PTZConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, struct tt__VideoAnalyticsConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoAnalyticsConfiguration))
		soap_serialize_tt__VideoAnalyticsConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, struct tt__VideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoAnalyticsConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoAnalyticsConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct tt__VideoAnalyticsConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(struct tt__VideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoAnalyticsConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoAnalyticsConfiguration, sizeof(struct tt__VideoAnalyticsConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, struct tt__VideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoAnalyticsConfiguration);
	if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, tag?tag:"tt:VideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoAnalyticsConfiguration(struct soap *soap, struct tt__VideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioEncoderConfiguration(struct soap *soap, struct tt__AudioEncoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioEncoderConfiguration))
		soap_serialize_tt__AudioEncoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioEncoderConfiguration(struct soap *soap, const char *tag, int id, struct tt__AudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioEncoderConfiguration(struct soap *soap, const char *tag, struct tt__AudioEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioEncoderConfiguration **)soap_malloc(soap, sizeof(struct tt__AudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(struct tt__AudioEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioEncoderConfiguration(struct soap *soap, struct tt__AudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioEncoderConfiguration);
	if (soap_out_PointerTott__AudioEncoderConfiguration(soap, tag?tag:"tt:AudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioEncoderConfiguration(struct soap *soap, struct tt__AudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderConfiguration))
		soap_serialize_tt__VideoEncoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, struct tt__VideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, struct tt__VideoEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoEncoderConfiguration **)soap_malloc(soap, sizeof(struct tt__VideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(struct tt__VideoEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoEncoderConfiguration);
	if (soap_out_PointerTott__VideoEncoderConfiguration(soap, tag?tag:"tt:VideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderConfiguration(struct soap *soap, struct tt__VideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSourceConfiguration))
		soap_serialize_tt__AudioSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, struct tt__AudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AudioSourceConfiguration(struct soap *soap, const char *tag, struct tt__AudioSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioSourceConfiguration **)soap_malloc(soap, sizeof(struct tt__AudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(struct tt__AudioSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioSourceConfiguration);
	if (soap_out_PointerTott__AudioSourceConfiguration(soap, tag?tag:"tt:AudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AudioSourceConfiguration(struct soap *soap, struct tt__AudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfiguration))
		soap_serialize_tt__VideoSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfiguration(struct soap *soap, const char *tag, struct tt__VideoSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceConfiguration **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(struct tt__VideoSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoSourceConfiguration);
	if (soap_out_PointerTott__VideoSourceConfiguration(soap, tag?tag:"tt:VideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfiguration(struct soap *soap, struct tt__VideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceExtension2(struct soap *soap, struct tt__VideoSourceExtension2 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceExtension2))
		soap_serialize_tt__VideoSourceExtension2(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceExtension2(struct soap *soap, const char *tag, int id, struct tt__VideoSourceExtension2 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceExtension2);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceExtension2(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceExtension2 ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceExtension2(struct soap *soap, const char *tag, struct tt__VideoSourceExtension2 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceExtension2 **)soap_malloc(soap, sizeof(struct tt__VideoSourceExtension2 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceExtension2(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceExtension2 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceExtension2, sizeof(struct tt__VideoSourceExtension2), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceExtension2(struct soap *soap, struct tt__VideoSourceExtension2 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoSourceExtension2);
	if (soap_out_PointerTott__VideoSourceExtension2(soap, tag?tag:"tt:VideoSourceExtension2", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceExtension2 ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceExtension2(struct soap *soap, struct tt__VideoSourceExtension2 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettings20(struct soap *soap, struct tt__ImagingSettings20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettings20))
		soap_serialize_tt__ImagingSettings20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettings20(struct soap *soap, const char *tag, int id, struct tt__ImagingSettings20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettings20);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingSettings20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingSettings20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettings20(struct soap *soap, const char *tag, struct tt__ImagingSettings20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingSettings20 **)soap_malloc(soap, sizeof(struct tt__ImagingSettings20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingSettings20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettings20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettings20, sizeof(struct tt__ImagingSettings20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettings20(struct soap *soap, struct tt__ImagingSettings20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingSettings20);
	if (soap_out_PointerTott__ImagingSettings20(soap, tag?tag:"tt:ImagingSettings20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettings20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettings20(struct soap *soap, struct tt__ImagingSettings20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettings20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTofloat(struct soap *soap, float *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_float);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTofloat(struct soap *soap, const char *tag, int id, float *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_float);
	if (id < 0)
		return soap->error;
	return soap_out_float(soap, tag, id, *a, type);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_in_PointerTofloat(struct soap *soap, const char *tag, float **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (float **)soap_malloc(soap, sizeof(float *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_float(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (float **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_float, sizeof(float), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTofloat(struct soap *soap, float *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTofloat);
	if (soap_out_PointerTofloat(soap, tag?tag:"float", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 float ** SOAP_FMAC4 soap_get_PointerTofloat(struct soap *soap, float **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTofloat(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRange(struct soap *soap, struct tt__IntRange *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRange))
		soap_serialize_tt__IntRange(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRange(struct soap *soap, const char *tag, int id, struct tt__IntRange *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRange);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IntRange(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IntRange ** SOAP_FMAC4 soap_in_PointerTott__IntRange(struct soap *soap, const char *tag, struct tt__IntRange **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IntRange **)soap_malloc(soap, sizeof(struct tt__IntRange *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IntRange(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IntRange **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRange, sizeof(struct tt__IntRange), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRange(struct soap *soap, struct tt__IntRange *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IntRange);
	if (soap_out_PointerTott__IntRange(soap, tag?tag:"tt:IntRange", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRange ** SOAP_FMAC4 soap_get_PointerTott__IntRange(struct soap *soap, struct tt__IntRange **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ActionTrigger(struct soap *soap, struct ns1__ActionTrigger *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ActionTrigger))
		soap_serialize_ns1__ActionTrigger(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ActionTrigger(struct soap *soap, const char *tag, int id, struct ns1__ActionTrigger *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ActionTrigger);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ActionTrigger(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ActionTrigger ** SOAP_FMAC4 soap_in_PointerTons1__ActionTrigger(struct soap *soap, const char *tag, struct ns1__ActionTrigger **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ActionTrigger **)soap_malloc(soap, sizeof(struct ns1__ActionTrigger *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ActionTrigger(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ActionTrigger **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionTrigger, sizeof(struct ns1__ActionTrigger), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ActionTrigger(struct soap *soap, struct ns1__ActionTrigger *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ActionTrigger);
	if (soap_out_PointerTons1__ActionTrigger(soap, tag?tag:"ns1:ActionTrigger", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ActionTrigger ** SOAP_FMAC4 soap_get_PointerTons1__ActionTrigger(struct soap *soap, struct ns1__ActionTrigger **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ActionTrigger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ActionEngineCapabilities(struct soap *soap, struct ns1__ActionEngineCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ActionEngineCapabilities))
		soap_serialize_ns1__ActionEngineCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ActionEngineCapabilities(struct soap *soap, const char *tag, int id, struct ns1__ActionEngineCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ActionEngineCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ActionEngineCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ActionEngineCapabilities ** SOAP_FMAC4 soap_in_PointerTons1__ActionEngineCapabilities(struct soap *soap, const char *tag, struct ns1__ActionEngineCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ActionEngineCapabilities **)soap_malloc(soap, sizeof(struct ns1__ActionEngineCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ActionEngineCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ActionEngineCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionEngineCapabilities, sizeof(struct ns1__ActionEngineCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ActionEngineCapabilities(struct soap *soap, struct ns1__ActionEngineCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ActionEngineCapabilities);
	if (soap_out_PointerTons1__ActionEngineCapabilities(soap, tag?tag:"ns1:ActionEngineCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ActionEngineCapabilities ** SOAP_FMAC4 soap_get_PointerTons1__ActionEngineCapabilities(struct soap *soap, struct ns1__ActionEngineCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ActionEngineCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__Action(struct soap *soap, struct ns1__Action *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__Action))
		soap_serialize_ns1__Action(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__Action(struct soap *soap, const char *tag, int id, struct ns1__Action *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__Action);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__Action(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__Action ** SOAP_FMAC4 soap_in_PointerTons1__Action(struct soap *soap, const char *tag, struct ns1__Action **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__Action **)soap_malloc(soap, sizeof(struct ns1__Action *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__Action(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__Action **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__Action, sizeof(struct ns1__Action), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__Action(struct soap *soap, struct ns1__Action *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__Action);
	if (soap_out_PointerTons1__Action(soap, tag?tag:"ns1:Action", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Action ** SOAP_FMAC4 soap_get_PointerTons1__Action(struct soap *soap, struct ns1__Action **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__Action(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SupportedActions(struct soap *soap, struct ns1__SupportedActions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SupportedActions))
		soap_serialize_ns1__SupportedActions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SupportedActions(struct soap *soap, const char *tag, int id, struct ns1__SupportedActions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SupportedActions);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SupportedActions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SupportedActions ** SOAP_FMAC4 soap_in_PointerTons1__SupportedActions(struct soap *soap, const char *tag, struct ns1__SupportedActions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SupportedActions **)soap_malloc(soap, sizeof(struct ns1__SupportedActions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SupportedActions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SupportedActions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SupportedActions, sizeof(struct ns1__SupportedActions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SupportedActions(struct soap *soap, struct ns1__SupportedActions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SupportedActions);
	if (soap_out_PointerTons1__SupportedActions(soap, tag?tag:"ns1:SupportedActions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SupportedActions ** SOAP_FMAC4 soap_get_PointerTons1__SupportedActions(struct soap *soap, struct ns1__SupportedActions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SupportedActions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TriggeredRecordingConfiguration(struct soap *soap, struct ns1__TriggeredRecordingConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TriggeredRecordingConfiguration))
		soap_serialize_ns1__TriggeredRecordingConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TriggeredRecordingConfiguration(struct soap *soap, const char *tag, int id, struct ns1__TriggeredRecordingConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TriggeredRecordingConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__TriggeredRecordingConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__TriggeredRecordingConfiguration ** SOAP_FMAC4 soap_in_PointerTons1__TriggeredRecordingConfiguration(struct soap *soap, const char *tag, struct ns1__TriggeredRecordingConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__TriggeredRecordingConfiguration **)soap_malloc(soap, sizeof(struct ns1__TriggeredRecordingConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__TriggeredRecordingConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__TriggeredRecordingConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TriggeredRecordingConfiguration, sizeof(struct ns1__TriggeredRecordingConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TriggeredRecordingConfiguration(struct soap *soap, struct ns1__TriggeredRecordingConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TriggeredRecordingConfiguration);
	if (soap_out_PointerTons1__TriggeredRecordingConfiguration(soap, tag?tag:"ns1:TriggeredRecordingConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__TriggeredRecordingConfiguration ** SOAP_FMAC4 soap_get_PointerTons1__TriggeredRecordingConfiguration(struct soap *soap, struct ns1__TriggeredRecordingConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TriggeredRecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FtpFileNameConfigurations(struct soap *soap, struct ns1__FtpFileNameConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FtpFileNameConfigurations))
		soap_serialize_ns1__FtpFileNameConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FtpFileNameConfigurations(struct soap *soap, const char *tag, int id, struct ns1__FtpFileNameConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FtpFileNameConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__FtpFileNameConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__FtpFileNameConfigurations ** SOAP_FMAC4 soap_in_PointerTons1__FtpFileNameConfigurations(struct soap *soap, const char *tag, struct ns1__FtpFileNameConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__FtpFileNameConfigurations **)soap_malloc(soap, sizeof(struct ns1__FtpFileNameConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__FtpFileNameConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__FtpFileNameConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpFileNameConfigurations, sizeof(struct ns1__FtpFileNameConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FtpFileNameConfigurations(struct soap *soap, struct ns1__FtpFileNameConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__FtpFileNameConfigurations);
	if (soap_out_PointerTons1__FtpFileNameConfigurations(soap, tag?tag:"ns1:FtpFileNameConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__FtpFileNameConfigurations ** SOAP_FMAC4 soap_get_PointerTons1__FtpFileNameConfigurations(struct soap *soap, struct ns1__FtpFileNameConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FtpFileNameConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FtpContentConfigurationUploadFile(struct soap *soap, struct ns1__FtpContentConfigurationUploadFile *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FtpContentConfigurationUploadFile))
		soap_serialize_ns1__FtpContentConfigurationUploadFile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FtpContentConfigurationUploadFile(struct soap *soap, const char *tag, int id, struct ns1__FtpContentConfigurationUploadFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FtpContentConfigurationUploadFile);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__FtpContentConfigurationUploadFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__FtpContentConfigurationUploadFile ** SOAP_FMAC4 soap_in_PointerTons1__FtpContentConfigurationUploadFile(struct soap *soap, const char *tag, struct ns1__FtpContentConfigurationUploadFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__FtpContentConfigurationUploadFile **)soap_malloc(soap, sizeof(struct ns1__FtpContentConfigurationUploadFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__FtpContentConfigurationUploadFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__FtpContentConfigurationUploadFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpContentConfigurationUploadFile, sizeof(struct ns1__FtpContentConfigurationUploadFile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FtpContentConfigurationUploadFile(struct soap *soap, struct ns1__FtpContentConfigurationUploadFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__FtpContentConfigurationUploadFile);
	if (soap_out_PointerTons1__FtpContentConfigurationUploadFile(soap, tag?tag:"ns1:FtpContentConfigurationUploadFile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__FtpContentConfigurationUploadFile ** SOAP_FMAC4 soap_get_PointerTons1__FtpContentConfigurationUploadFile(struct soap *soap, struct ns1__FtpContentConfigurationUploadFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FtpContentConfigurationUploadFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FtpContentConfigurationUploadImages(struct soap *soap, struct ns1__FtpContentConfigurationUploadImages *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FtpContentConfigurationUploadImages))
		soap_serialize_ns1__FtpContentConfigurationUploadImages(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FtpContentConfigurationUploadImages(struct soap *soap, const char *tag, int id, struct ns1__FtpContentConfigurationUploadImages *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FtpContentConfigurationUploadImages);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__FtpContentConfigurationUploadImages(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__FtpContentConfigurationUploadImages ** SOAP_FMAC4 soap_in_PointerTons1__FtpContentConfigurationUploadImages(struct soap *soap, const char *tag, struct ns1__FtpContentConfigurationUploadImages **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__FtpContentConfigurationUploadImages **)soap_malloc(soap, sizeof(struct ns1__FtpContentConfigurationUploadImages *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__FtpContentConfigurationUploadImages(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__FtpContentConfigurationUploadImages **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpContentConfigurationUploadImages, sizeof(struct ns1__FtpContentConfigurationUploadImages), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FtpContentConfigurationUploadImages(struct soap *soap, struct ns1__FtpContentConfigurationUploadImages *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__FtpContentConfigurationUploadImages);
	if (soap_out_PointerTons1__FtpContentConfigurationUploadImages(soap, tag?tag:"ns1:FtpContentConfigurationUploadImages", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__FtpContentConfigurationUploadImages ** SOAP_FMAC4 soap_get_PointerTons1__FtpContentConfigurationUploadImages(struct soap *soap, struct ns1__FtpContentConfigurationUploadImages **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FtpContentConfigurationUploadImages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FtpContentConfiguration(struct soap *soap, struct ns1__FtpContentConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FtpContentConfiguration))
		soap_serialize_ns1__FtpContentConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FtpContentConfiguration(struct soap *soap, const char *tag, int id, struct ns1__FtpContentConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FtpContentConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__FtpContentConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__FtpContentConfiguration ** SOAP_FMAC4 soap_in_PointerTons1__FtpContentConfiguration(struct soap *soap, const char *tag, struct ns1__FtpContentConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__FtpContentConfiguration **)soap_malloc(soap, sizeof(struct ns1__FtpContentConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__FtpContentConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__FtpContentConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpContentConfiguration, sizeof(struct ns1__FtpContentConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FtpContentConfiguration(struct soap *soap, struct ns1__FtpContentConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__FtpContentConfiguration);
	if (soap_out_PointerTons1__FtpContentConfiguration(soap, tag?tag:"ns1:FtpContentConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__FtpContentConfiguration ** SOAP_FMAC4 soap_get_PointerTons1__FtpContentConfiguration(struct soap *soap, struct ns1__FtpContentConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FtpContentConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FtpAuthenticationConfigurationExtension(struct soap *soap, struct ns1__FtpAuthenticationConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FtpAuthenticationConfigurationExtension))
		soap_serialize_ns1__FtpAuthenticationConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FtpAuthenticationConfigurationExtension(struct soap *soap, const char *tag, int id, struct ns1__FtpAuthenticationConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FtpAuthenticationConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__FtpAuthenticationConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__FtpAuthenticationConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTons1__FtpAuthenticationConfigurationExtension(struct soap *soap, const char *tag, struct ns1__FtpAuthenticationConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__FtpAuthenticationConfigurationExtension **)soap_malloc(soap, sizeof(struct ns1__FtpAuthenticationConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__FtpAuthenticationConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__FtpAuthenticationConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpAuthenticationConfigurationExtension, sizeof(struct ns1__FtpAuthenticationConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FtpAuthenticationConfigurationExtension(struct soap *soap, struct ns1__FtpAuthenticationConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__FtpAuthenticationConfigurationExtension);
	if (soap_out_PointerTons1__FtpAuthenticationConfigurationExtension(soap, tag?tag:"ns1:FtpAuthenticationConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__FtpAuthenticationConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTons1__FtpAuthenticationConfigurationExtension(struct soap *soap, struct ns1__FtpAuthenticationConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FtpAuthenticationConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FtpDestinationConfigurationExtension(struct soap *soap, struct ns1__FtpDestinationConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FtpDestinationConfigurationExtension))
		soap_serialize_ns1__FtpDestinationConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FtpDestinationConfigurationExtension(struct soap *soap, const char *tag, int id, struct ns1__FtpDestinationConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FtpDestinationConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__FtpDestinationConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__FtpDestinationConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTons1__FtpDestinationConfigurationExtension(struct soap *soap, const char *tag, struct ns1__FtpDestinationConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__FtpDestinationConfigurationExtension **)soap_malloc(soap, sizeof(struct ns1__FtpDestinationConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__FtpDestinationConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__FtpDestinationConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpDestinationConfigurationExtension, sizeof(struct ns1__FtpDestinationConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FtpDestinationConfigurationExtension(struct soap *soap, struct ns1__FtpDestinationConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__FtpDestinationConfigurationExtension);
	if (soap_out_PointerTons1__FtpDestinationConfigurationExtension(soap, tag?tag:"ns1:FtpDestinationConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__FtpDestinationConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTons1__FtpDestinationConfigurationExtension(struct soap *soap, struct ns1__FtpDestinationConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FtpDestinationConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FtpAuthenticationConfiguration(struct soap *soap, struct ns1__FtpAuthenticationConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FtpAuthenticationConfiguration))
		soap_serialize_ns1__FtpAuthenticationConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FtpAuthenticationConfiguration(struct soap *soap, const char *tag, int id, struct ns1__FtpAuthenticationConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FtpAuthenticationConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__FtpAuthenticationConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__FtpAuthenticationConfiguration ** SOAP_FMAC4 soap_in_PointerTons1__FtpAuthenticationConfiguration(struct soap *soap, const char *tag, struct ns1__FtpAuthenticationConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__FtpAuthenticationConfiguration **)soap_malloc(soap, sizeof(struct ns1__FtpAuthenticationConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__FtpAuthenticationConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__FtpAuthenticationConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpAuthenticationConfiguration, sizeof(struct ns1__FtpAuthenticationConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FtpAuthenticationConfiguration(struct soap *soap, struct ns1__FtpAuthenticationConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__FtpAuthenticationConfiguration);
	if (soap_out_PointerTons1__FtpAuthenticationConfiguration(soap, tag?tag:"ns1:FtpAuthenticationConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__FtpAuthenticationConfiguration ** SOAP_FMAC4 soap_get_PointerTons1__FtpAuthenticationConfiguration(struct soap *soap, struct ns1__FtpAuthenticationConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FtpAuthenticationConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FtpHostAddress(struct soap *soap, struct ns1__FtpHostAddress *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FtpHostAddress))
		soap_serialize_ns1__FtpHostAddress(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FtpHostAddress(struct soap *soap, const char *tag, int id, struct ns1__FtpHostAddress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FtpHostAddress);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__FtpHostAddress(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__FtpHostAddress ** SOAP_FMAC4 soap_in_PointerTons1__FtpHostAddress(struct soap *soap, const char *tag, struct ns1__FtpHostAddress **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__FtpHostAddress **)soap_malloc(soap, sizeof(struct ns1__FtpHostAddress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__FtpHostAddress(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__FtpHostAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpHostAddress, sizeof(struct ns1__FtpHostAddress), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FtpHostAddress(struct soap *soap, struct ns1__FtpHostAddress *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__FtpHostAddress);
	if (soap_out_PointerTons1__FtpHostAddress(soap, tag?tag:"ns1:FtpHostAddress", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__FtpHostAddress ** SOAP_FMAC4 soap_get_PointerTons1__FtpHostAddress(struct soap *soap, struct ns1__FtpHostAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FtpHostAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FtpHostConfigurationsExtension(struct soap *soap, struct ns1__FtpHostConfigurationsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FtpHostConfigurationsExtension))
		soap_serialize_ns1__FtpHostConfigurationsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FtpHostConfigurationsExtension(struct soap *soap, const char *tag, int id, struct ns1__FtpHostConfigurationsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FtpHostConfigurationsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__FtpHostConfigurationsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__FtpHostConfigurationsExtension ** SOAP_FMAC4 soap_in_PointerTons1__FtpHostConfigurationsExtension(struct soap *soap, const char *tag, struct ns1__FtpHostConfigurationsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__FtpHostConfigurationsExtension **)soap_malloc(soap, sizeof(struct ns1__FtpHostConfigurationsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__FtpHostConfigurationsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__FtpHostConfigurationsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpHostConfigurationsExtension, sizeof(struct ns1__FtpHostConfigurationsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FtpHostConfigurationsExtension(struct soap *soap, struct ns1__FtpHostConfigurationsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__FtpHostConfigurationsExtension);
	if (soap_out_PointerTons1__FtpHostConfigurationsExtension(soap, tag?tag:"ns1:FtpHostConfigurationsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__FtpHostConfigurationsExtension ** SOAP_FMAC4 soap_get_PointerTons1__FtpHostConfigurationsExtension(struct soap *soap, struct ns1__FtpHostConfigurationsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FtpHostConfigurationsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FtpDestinationConfiguration(struct soap *soap, struct ns1__FtpDestinationConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__FtpDestinationConfiguration))
		soap_serialize_ns1__FtpDestinationConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FtpDestinationConfiguration(struct soap *soap, const char *tag, int id, struct ns1__FtpDestinationConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FtpDestinationConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__FtpDestinationConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__FtpDestinationConfiguration ** SOAP_FMAC4 soap_in_PointerTons1__FtpDestinationConfiguration(struct soap *soap, const char *tag, struct ns1__FtpDestinationConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__FtpDestinationConfiguration **)soap_malloc(soap, sizeof(struct ns1__FtpDestinationConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__FtpDestinationConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__FtpDestinationConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FtpDestinationConfiguration, sizeof(struct ns1__FtpDestinationConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FtpDestinationConfiguration(struct soap *soap, struct ns1__FtpDestinationConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__FtpDestinationConfiguration);
	if (soap_out_PointerTons1__FtpDestinationConfiguration(soap, tag?tag:"ns1:FtpDestinationConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__FtpDestinationConfiguration ** SOAP_FMAC4 soap_get_PointerTons1__FtpDestinationConfiguration(struct soap *soap, struct ns1__FtpDestinationConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FtpDestinationConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PostBodyConfiguration(struct soap *soap, struct ns1__PostBodyConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PostBodyConfiguration))
		soap_serialize_ns1__PostBodyConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PostBodyConfiguration(struct soap *soap, const char *tag, int id, struct ns1__PostBodyConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PostBodyConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__PostBodyConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__PostBodyConfiguration ** SOAP_FMAC4 soap_in_PointerTons1__PostBodyConfiguration(struct soap *soap, const char *tag, struct ns1__PostBodyConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__PostBodyConfiguration **)soap_malloc(soap, sizeof(struct ns1__PostBodyConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__PostBodyConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__PostBodyConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PostBodyConfiguration, sizeof(struct ns1__PostBodyConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PostBodyConfiguration(struct soap *soap, struct ns1__PostBodyConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PostBodyConfiguration);
	if (soap_out_PointerTons1__PostBodyConfiguration(soap, tag?tag:"ns1:PostBodyConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__PostBodyConfiguration ** SOAP_FMAC4 soap_get_PointerTons1__PostBodyConfiguration(struct soap *soap, struct ns1__PostBodyConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PostBodyConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MediaSource(struct soap *soap, struct ns1__MediaSource *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MediaSource))
		soap_serialize_ns1__MediaSource(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MediaSource(struct soap *soap, const char *tag, int id, struct ns1__MediaSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MediaSource);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__MediaSource(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__MediaSource ** SOAP_FMAC4 soap_in_PointerTons1__MediaSource(struct soap *soap, const char *tag, struct ns1__MediaSource **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__MediaSource **)soap_malloc(soap, sizeof(struct ns1__MediaSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__MediaSource(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__MediaSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MediaSource, sizeof(struct ns1__MediaSource), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MediaSource(struct soap *soap, struct ns1__MediaSource *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MediaSource);
	if (soap_out_PointerTons1__MediaSource(soap, tag?tag:"ns1:MediaSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__MediaSource ** SOAP_FMAC4 soap_get_PointerTons1__MediaSource(struct soap *soap, struct ns1__MediaSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MediaSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HttpAuthenticationConfigurationExtension(struct soap *soap, struct ns1__HttpAuthenticationConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HttpAuthenticationConfigurationExtension))
		soap_serialize_ns1__HttpAuthenticationConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HttpAuthenticationConfigurationExtension(struct soap *soap, const char *tag, int id, struct ns1__HttpAuthenticationConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HttpAuthenticationConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__HttpAuthenticationConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__HttpAuthenticationConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTons1__HttpAuthenticationConfigurationExtension(struct soap *soap, const char *tag, struct ns1__HttpAuthenticationConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__HttpAuthenticationConfigurationExtension **)soap_malloc(soap, sizeof(struct ns1__HttpAuthenticationConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__HttpAuthenticationConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__HttpAuthenticationConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HttpAuthenticationConfigurationExtension, sizeof(struct ns1__HttpAuthenticationConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HttpAuthenticationConfigurationExtension(struct soap *soap, struct ns1__HttpAuthenticationConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HttpAuthenticationConfigurationExtension);
	if (soap_out_PointerTons1__HttpAuthenticationConfigurationExtension(soap, tag?tag:"ns1:HttpAuthenticationConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__HttpAuthenticationConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTons1__HttpAuthenticationConfigurationExtension(struct soap *soap, struct ns1__HttpAuthenticationConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HttpAuthenticationConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HttpDestinationConfigurationExtension(struct soap *soap, struct ns1__HttpDestinationConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HttpDestinationConfigurationExtension))
		soap_serialize_ns1__HttpDestinationConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HttpDestinationConfigurationExtension(struct soap *soap, const char *tag, int id, struct ns1__HttpDestinationConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HttpDestinationConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__HttpDestinationConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__HttpDestinationConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTons1__HttpDestinationConfigurationExtension(struct soap *soap, const char *tag, struct ns1__HttpDestinationConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__HttpDestinationConfigurationExtension **)soap_malloc(soap, sizeof(struct ns1__HttpDestinationConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__HttpDestinationConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__HttpDestinationConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HttpDestinationConfigurationExtension, sizeof(struct ns1__HttpDestinationConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HttpDestinationConfigurationExtension(struct soap *soap, struct ns1__HttpDestinationConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HttpDestinationConfigurationExtension);
	if (soap_out_PointerTons1__HttpDestinationConfigurationExtension(soap, tag?tag:"ns1:HttpDestinationConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__HttpDestinationConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTons1__HttpDestinationConfigurationExtension(struct soap *soap, struct ns1__HttpDestinationConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HttpDestinationConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HttpAuthenticationConfiguration(struct soap *soap, struct ns1__HttpAuthenticationConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HttpAuthenticationConfiguration))
		soap_serialize_ns1__HttpAuthenticationConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HttpAuthenticationConfiguration(struct soap *soap, const char *tag, int id, struct ns1__HttpAuthenticationConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HttpAuthenticationConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__HttpAuthenticationConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__HttpAuthenticationConfiguration ** SOAP_FMAC4 soap_in_PointerTons1__HttpAuthenticationConfiguration(struct soap *soap, const char *tag, struct ns1__HttpAuthenticationConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__HttpAuthenticationConfiguration **)soap_malloc(soap, sizeof(struct ns1__HttpAuthenticationConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__HttpAuthenticationConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__HttpAuthenticationConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HttpAuthenticationConfiguration, sizeof(struct ns1__HttpAuthenticationConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HttpAuthenticationConfiguration(struct soap *soap, struct ns1__HttpAuthenticationConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HttpAuthenticationConfiguration);
	if (soap_out_PointerTons1__HttpAuthenticationConfiguration(soap, tag?tag:"ns1:HttpAuthenticationConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__HttpAuthenticationConfiguration ** SOAP_FMAC4 soap_get_PointerTons1__HttpAuthenticationConfiguration(struct soap *soap, struct ns1__HttpAuthenticationConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HttpAuthenticationConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HttpHostAddress(struct soap *soap, struct ns1__HttpHostAddress *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HttpHostAddress))
		soap_serialize_ns1__HttpHostAddress(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HttpHostAddress(struct soap *soap, const char *tag, int id, struct ns1__HttpHostAddress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HttpHostAddress);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__HttpHostAddress(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__HttpHostAddress ** SOAP_FMAC4 soap_in_PointerTons1__HttpHostAddress(struct soap *soap, const char *tag, struct ns1__HttpHostAddress **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__HttpHostAddress **)soap_malloc(soap, sizeof(struct ns1__HttpHostAddress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__HttpHostAddress(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__HttpHostAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HttpHostAddress, sizeof(struct ns1__HttpHostAddress), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HttpHostAddress(struct soap *soap, struct ns1__HttpHostAddress *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HttpHostAddress);
	if (soap_out_PointerTons1__HttpHostAddress(soap, tag?tag:"ns1:HttpHostAddress", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__HttpHostAddress ** SOAP_FMAC4 soap_get_PointerTons1__HttpHostAddress(struct soap *soap, struct ns1__HttpHostAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HttpHostAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HttpHostConfigurationsExtension(struct soap *soap, struct ns1__HttpHostConfigurationsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HttpHostConfigurationsExtension))
		soap_serialize_ns1__HttpHostConfigurationsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HttpHostConfigurationsExtension(struct soap *soap, const char *tag, int id, struct ns1__HttpHostConfigurationsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HttpHostConfigurationsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__HttpHostConfigurationsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__HttpHostConfigurationsExtension ** SOAP_FMAC4 soap_in_PointerTons1__HttpHostConfigurationsExtension(struct soap *soap, const char *tag, struct ns1__HttpHostConfigurationsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__HttpHostConfigurationsExtension **)soap_malloc(soap, sizeof(struct ns1__HttpHostConfigurationsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__HttpHostConfigurationsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__HttpHostConfigurationsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HttpHostConfigurationsExtension, sizeof(struct ns1__HttpHostConfigurationsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HttpHostConfigurationsExtension(struct soap *soap, struct ns1__HttpHostConfigurationsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HttpHostConfigurationsExtension);
	if (soap_out_PointerTons1__HttpHostConfigurationsExtension(soap, tag?tag:"ns1:HttpHostConfigurationsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__HttpHostConfigurationsExtension ** SOAP_FMAC4 soap_get_PointerTons1__HttpHostConfigurationsExtension(struct soap *soap, struct ns1__HttpHostConfigurationsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HttpHostConfigurationsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HttpDestinationConfiguration(struct soap *soap, struct ns1__HttpDestinationConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HttpDestinationConfiguration))
		soap_serialize_ns1__HttpDestinationConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HttpDestinationConfiguration(struct soap *soap, const char *tag, int id, struct ns1__HttpDestinationConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HttpDestinationConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__HttpDestinationConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__HttpDestinationConfiguration ** SOAP_FMAC4 soap_in_PointerTons1__HttpDestinationConfiguration(struct soap *soap, const char *tag, struct ns1__HttpDestinationConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__HttpDestinationConfiguration **)soap_malloc(soap, sizeof(struct ns1__HttpDestinationConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__HttpDestinationConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__HttpDestinationConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HttpDestinationConfiguration, sizeof(struct ns1__HttpDestinationConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HttpDestinationConfiguration(struct soap *soap, struct ns1__HttpDestinationConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HttpDestinationConfiguration);
	if (soap_out_PointerTons1__HttpDestinationConfiguration(soap, tag?tag:"ns1:HttpDestinationConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__HttpDestinationConfiguration ** SOAP_FMAC4 soap_get_PointerTons1__HttpDestinationConfiguration(struct soap *soap, struct ns1__HttpDestinationConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HttpDestinationConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__boolean(struct soap *soap, const char *tag, int id, enum xsd__boolean *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__boolean);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__boolean(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_in_PointerToxsd__boolean(struct soap *soap, const char *tag, enum xsd__boolean **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum xsd__boolean **)soap_malloc(soap, sizeof(enum xsd__boolean *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__boolean(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum xsd__boolean **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__boolean, sizeof(enum xsd__boolean), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__boolean);
	if (soap_out_PointerToxsd__boolean(soap, tag?tag:"xsd:boolean", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum xsd__boolean ** SOAP_FMAC4 soap_get_PointerToxsd__boolean(struct soap *soap, enum xsd__boolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EMailAttachmentConfigurationExtension(struct soap *soap, struct ns1__EMailAttachmentConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__EMailAttachmentConfigurationExtension))
		soap_serialize_ns1__EMailAttachmentConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EMailAttachmentConfigurationExtension(struct soap *soap, const char *tag, int id, struct ns1__EMailAttachmentConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__EMailAttachmentConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__EMailAttachmentConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__EMailAttachmentConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTons1__EMailAttachmentConfigurationExtension(struct soap *soap, const char *tag, struct ns1__EMailAttachmentConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__EMailAttachmentConfigurationExtension **)soap_malloc(soap, sizeof(struct ns1__EMailAttachmentConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__EMailAttachmentConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__EMailAttachmentConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EMailAttachmentConfigurationExtension, sizeof(struct ns1__EMailAttachmentConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EMailAttachmentConfigurationExtension(struct soap *soap, struct ns1__EMailAttachmentConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__EMailAttachmentConfigurationExtension);
	if (soap_out_PointerTons1__EMailAttachmentConfigurationExtension(soap, tag?tag:"ns1:EMailAttachmentConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__EMailAttachmentConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTons1__EMailAttachmentConfigurationExtension(struct soap *soap, struct ns1__EMailAttachmentConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EMailAttachmentConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__FileSuffixType(struct soap *soap, enum ns1__FileSuffixType *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_ns1__FileSuffixType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__FileSuffixType(struct soap *soap, const char *tag, int id, enum ns1__FileSuffixType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__FileSuffixType);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__FileSuffixType(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum ns1__FileSuffixType ** SOAP_FMAC4 soap_in_PointerTons1__FileSuffixType(struct soap *soap, const char *tag, enum ns1__FileSuffixType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum ns1__FileSuffixType **)soap_malloc(soap, sizeof(enum ns1__FileSuffixType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__FileSuffixType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum ns1__FileSuffixType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__FileSuffixType, sizeof(enum ns1__FileSuffixType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__FileSuffixType(struct soap *soap, enum ns1__FileSuffixType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__FileSuffixType);
	if (soap_out_PointerTons1__FileSuffixType(soap, tag?tag:"ns1:FileSuffixType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum ns1__FileSuffixType ** SOAP_FMAC4 soap_get_PointerTons1__FileSuffixType(struct soap *soap, enum ns1__FileSuffixType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__FileSuffixType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EMailReceiverConfigurationExtension(struct soap *soap, struct ns1__EMailReceiverConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__EMailReceiverConfigurationExtension))
		soap_serialize_ns1__EMailReceiverConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EMailReceiverConfigurationExtension(struct soap *soap, const char *tag, int id, struct ns1__EMailReceiverConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__EMailReceiverConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__EMailReceiverConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__EMailReceiverConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTons1__EMailReceiverConfigurationExtension(struct soap *soap, const char *tag, struct ns1__EMailReceiverConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__EMailReceiverConfigurationExtension **)soap_malloc(soap, sizeof(struct ns1__EMailReceiverConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__EMailReceiverConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__EMailReceiverConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EMailReceiverConfigurationExtension, sizeof(struct ns1__EMailReceiverConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EMailReceiverConfigurationExtension(struct soap *soap, struct ns1__EMailReceiverConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__EMailReceiverConfigurationExtension);
	if (soap_out_PointerTons1__EMailReceiverConfigurationExtension(soap, tag?tag:"ns1:EMailReceiverConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__EMailReceiverConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTons1__EMailReceiverConfigurationExtension(struct soap *soap, struct ns1__EMailReceiverConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EMailReceiverConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostring);
	if (soap_out_PointerTostring(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UserCredentials(struct soap *soap, struct ns1__UserCredentials *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UserCredentials))
		soap_serialize_ns1__UserCredentials(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UserCredentials(struct soap *soap, const char *tag, int id, struct ns1__UserCredentials *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UserCredentials);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__UserCredentials(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__UserCredentials ** SOAP_FMAC4 soap_in_PointerTons1__UserCredentials(struct soap *soap, const char *tag, struct ns1__UserCredentials **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__UserCredentials **)soap_malloc(soap, sizeof(struct ns1__UserCredentials *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__UserCredentials(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__UserCredentials **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UserCredentials, sizeof(struct ns1__UserCredentials), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UserCredentials(struct soap *soap, struct ns1__UserCredentials *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UserCredentials);
	if (soap_out_PointerTons1__UserCredentials(soap, tag?tag:"ns1:UserCredentials", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__UserCredentials ** SOAP_FMAC4 soap_get_PointerTons1__UserCredentials(struct soap *soap, struct ns1__UserCredentials **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UserCredentials(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UserCredentialsExtension(struct soap *soap, struct ns1__UserCredentialsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UserCredentialsExtension))
		soap_serialize_ns1__UserCredentialsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UserCredentialsExtension(struct soap *soap, const char *tag, int id, struct ns1__UserCredentialsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UserCredentialsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__UserCredentialsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__UserCredentialsExtension ** SOAP_FMAC4 soap_in_PointerTons1__UserCredentialsExtension(struct soap *soap, const char *tag, struct ns1__UserCredentialsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__UserCredentialsExtension **)soap_malloc(soap, sizeof(struct ns1__UserCredentialsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__UserCredentialsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__UserCredentialsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UserCredentialsExtension, sizeof(struct ns1__UserCredentialsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UserCredentialsExtension(struct soap *soap, struct ns1__UserCredentialsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UserCredentialsExtension);
	if (soap_out_PointerTons1__UserCredentialsExtension(soap, tag?tag:"ns1:UserCredentialsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__UserCredentialsExtension ** SOAP_FMAC4 soap_get_PointerTons1__UserCredentialsExtension(struct soap *soap, struct ns1__UserCredentialsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UserCredentialsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__base64Binary(struct soap *soap, struct xsd__base64Binary *const*a)
{
#ifndef WITH_NOIDREF
	if (*a)
		soap_serialize_xsd__base64Binary(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__base64Binary(struct soap *soap, const char *tag, int id, struct xsd__base64Binary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_xsd__base64Binary);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__base64Binary(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xsd__base64Binary ** SOAP_FMAC4 soap_in_PointerToxsd__base64Binary(struct soap *soap, const char *tag, struct xsd__base64Binary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xsd__base64Binary **)soap_malloc(soap, sizeof(struct xsd__base64Binary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__base64Binary(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xsd__base64Binary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__base64Binary, sizeof(struct xsd__base64Binary), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__base64Binary(struct soap *soap, struct xsd__base64Binary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__base64Binary);
	if (soap_out_PointerToxsd__base64Binary(soap, tag?tag:"xsd:base64Binary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xsd__base64Binary ** SOAP_FMAC4 soap_get_PointerToxsd__base64Binary(struct soap *soap, struct xsd__base64Binary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__base64Binary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HostAddress(struct soap *soap, struct ns1__HostAddress *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HostAddress))
		soap_serialize_ns1__HostAddress(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HostAddress(struct soap *soap, const char *tag, int id, struct ns1__HostAddress *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HostAddress);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__HostAddress(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__HostAddress ** SOAP_FMAC4 soap_in_PointerTons1__HostAddress(struct soap *soap, const char *tag, struct ns1__HostAddress **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__HostAddress **)soap_malloc(soap, sizeof(struct ns1__HostAddress *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__HostAddress(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__HostAddress **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HostAddress, sizeof(struct ns1__HostAddress), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HostAddress(struct soap *soap, struct ns1__HostAddress *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HostAddress);
	if (soap_out_PointerTons1__HostAddress(soap, tag?tag:"ns1:HostAddress", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__HostAddress ** SOAP_FMAC4 soap_get_PointerTons1__HostAddress(struct soap *soap, struct ns1__HostAddress **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HostAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AuthenticationConfig(struct soap *soap, struct ns1__AuthenticationConfig *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AuthenticationConfig))
		soap_serialize_ns1__AuthenticationConfig(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AuthenticationConfig(struct soap *soap, const char *tag, int id, struct ns1__AuthenticationConfig *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AuthenticationConfig);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__AuthenticationConfig(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__AuthenticationConfig ** SOAP_FMAC4 soap_in_PointerTons1__AuthenticationConfig(struct soap *soap, const char *tag, struct ns1__AuthenticationConfig **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__AuthenticationConfig **)soap_malloc(soap, sizeof(struct ns1__AuthenticationConfig *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__AuthenticationConfig(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__AuthenticationConfig **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AuthenticationConfig, sizeof(struct ns1__AuthenticationConfig), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AuthenticationConfig(struct soap *soap, struct ns1__AuthenticationConfig *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AuthenticationConfig);
	if (soap_out_PointerTons1__AuthenticationConfig(soap, tag?tag:"ns1:AuthenticationConfig", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__AuthenticationConfig ** SOAP_FMAC4 soap_get_PointerTons1__AuthenticationConfig(struct soap *soap, struct ns1__AuthenticationConfig **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AuthenticationConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__POPConfig(struct soap *soap, struct ns1__POPConfig *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__POPConfig))
		soap_serialize_ns1__POPConfig(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__POPConfig(struct soap *soap, const char *tag, int id, struct ns1__POPConfig *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__POPConfig);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__POPConfig(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__POPConfig ** SOAP_FMAC4 soap_in_PointerTons1__POPConfig(struct soap *soap, const char *tag, struct ns1__POPConfig **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__POPConfig **)soap_malloc(soap, sizeof(struct ns1__POPConfig *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__POPConfig(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__POPConfig **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__POPConfig, sizeof(struct ns1__POPConfig), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__POPConfig(struct soap *soap, struct ns1__POPConfig *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__POPConfig);
	if (soap_out_PointerTons1__POPConfig(soap, tag?tag:"ns1:POPConfig", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__POPConfig ** SOAP_FMAC4 soap_get_PointerTons1__POPConfig(struct soap *soap, struct ns1__POPConfig **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__POPConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SMTPConfig(struct soap *soap, struct ns1__SMTPConfig *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SMTPConfig))
		soap_serialize_ns1__SMTPConfig(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SMTPConfig(struct soap *soap, const char *tag, int id, struct ns1__SMTPConfig *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SMTPConfig);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SMTPConfig(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SMTPConfig ** SOAP_FMAC4 soap_in_PointerTons1__SMTPConfig(struct soap *soap, const char *tag, struct ns1__SMTPConfig **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SMTPConfig **)soap_malloc(soap, sizeof(struct ns1__SMTPConfig *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SMTPConfig(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SMTPConfig **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SMTPConfig, sizeof(struct ns1__SMTPConfig), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SMTPConfig(struct soap *soap, struct ns1__SMTPConfig *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SMTPConfig);
	if (soap_out_PointerTons1__SMTPConfig(soap, tag?tag:"ns1:SMTPConfig", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SMTPConfig ** SOAP_FMAC4 soap_get_PointerTons1__SMTPConfig(struct soap *soap, struct ns1__SMTPConfig **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SMTPConfig(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ActionTriggerConfiguration(struct soap *soap, struct ns1__ActionTriggerConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ActionTriggerConfiguration))
		soap_serialize_ns1__ActionTriggerConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ActionTriggerConfiguration(struct soap *soap, const char *tag, int id, struct ns1__ActionTriggerConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ActionTriggerConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ActionTriggerConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ActionTriggerConfiguration ** SOAP_FMAC4 soap_in_PointerTons1__ActionTriggerConfiguration(struct soap *soap, const char *tag, struct ns1__ActionTriggerConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ActionTriggerConfiguration **)soap_malloc(soap, sizeof(struct ns1__ActionTriggerConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ActionTriggerConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ActionTriggerConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionTriggerConfiguration, sizeof(struct ns1__ActionTriggerConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ActionTriggerConfiguration(struct soap *soap, struct ns1__ActionTriggerConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ActionTriggerConfiguration);
	if (soap_out_PointerTons1__ActionTriggerConfiguration(soap, tag?tag:"ns1:ActionTriggerConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ActionTriggerConfiguration ** SOAP_FMAC4 soap_get_PointerTons1__ActionTriggerConfiguration(struct soap *soap, struct ns1__ActionTriggerConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ActionTriggerConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ActionTriggerConfigurationExtension(struct soap *soap, struct ns1__ActionTriggerConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ActionTriggerConfigurationExtension))
		soap_serialize_ns1__ActionTriggerConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ActionTriggerConfigurationExtension(struct soap *soap, const char *tag, int id, struct ns1__ActionTriggerConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ActionTriggerConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ActionTriggerConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ActionTriggerConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTons1__ActionTriggerConfigurationExtension(struct soap *soap, const char *tag, struct ns1__ActionTriggerConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ActionTriggerConfigurationExtension **)soap_malloc(soap, sizeof(struct ns1__ActionTriggerConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ActionTriggerConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ActionTriggerConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionTriggerConfigurationExtension, sizeof(struct ns1__ActionTriggerConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ActionTriggerConfigurationExtension(struct soap *soap, struct ns1__ActionTriggerConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ActionTriggerConfigurationExtension);
	if (soap_out_PointerTons1__ActionTriggerConfigurationExtension(soap, tag?tag:"ns1:ActionTriggerConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ActionTriggerConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTons1__ActionTriggerConfigurationExtension(struct soap *soap, struct ns1__ActionTriggerConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ActionTriggerConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReferenceToken(struct soap *soap, char **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReferenceToken))
		soap_serialize_tt__ReferenceToken(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReferenceToken(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReferenceToken);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReferenceToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTott__ReferenceToken(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReferenceToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReferenceToken, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReferenceToken(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ReferenceToken);
	if (soap_out_PointerTott__ReferenceToken(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTott__ReferenceToken(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__QueryExpressionType(struct soap *soap, struct wsnt__QueryExpressionType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__QueryExpressionType))
		soap_serialize_wsnt__QueryExpressionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__QueryExpressionType(struct soap *soap, const char *tag, int id, struct wsnt__QueryExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__QueryExpressionType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__QueryExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__QueryExpressionType ** SOAP_FMAC4 soap_in_PointerTowsnt__QueryExpressionType(struct soap *soap, const char *tag, struct wsnt__QueryExpressionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__QueryExpressionType **)soap_malloc(soap, sizeof(struct wsnt__QueryExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__QueryExpressionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__QueryExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__QueryExpressionType, sizeof(struct wsnt__QueryExpressionType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__QueryExpressionType(struct soap *soap, struct wsnt__QueryExpressionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__QueryExpressionType);
	if (soap_out_PointerTowsnt__QueryExpressionType(soap, tag?tag:"wsnt:QueryExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__QueryExpressionType ** SOAP_FMAC4 soap_get_PointerTowsnt__QueryExpressionType(struct soap *soap, struct wsnt__QueryExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__TopicExpressionType))
		soap_serialize_wsnt__TopicExpressionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, struct wsnt__TopicExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__TopicExpressionType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__TopicExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType ** SOAP_FMAC4 soap_in_PointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, struct wsnt__TopicExpressionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__TopicExpressionType **)soap_malloc(soap, sizeof(struct wsnt__TopicExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__TopicExpressionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__TopicExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(struct wsnt__TopicExpressionType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__TopicExpressionType);
	if (soap_out_PointerTowsnt__TopicExpressionType(soap, tag?tag:"wsnt:TopicExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicExpressionType ** SOAP_FMAC4 soap_get_PointerTowsnt__TopicExpressionType(struct soap *soap, struct wsnt__TopicExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ActionConfiguration(struct soap *soap, struct ns1__ActionConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ActionConfiguration))
		soap_serialize_ns1__ActionConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ActionConfiguration(struct soap *soap, const char *tag, int id, struct ns1__ActionConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ActionConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ActionConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ActionConfiguration ** SOAP_FMAC4 soap_in_PointerTons1__ActionConfiguration(struct soap *soap, const char *tag, struct ns1__ActionConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ActionConfiguration **)soap_malloc(soap, sizeof(struct ns1__ActionConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ActionConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ActionConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionConfiguration, sizeof(struct ns1__ActionConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ActionConfiguration(struct soap *soap, struct ns1__ActionConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ActionConfiguration);
	if (soap_out_PointerTons1__ActionConfiguration(soap, tag?tag:"ns1:ActionConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ActionConfiguration ** SOAP_FMAC4 soap_get_PointerTons1__ActionConfiguration(struct soap *soap, struct ns1__ActionConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ActionConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemList(struct soap *soap, struct tt__ItemList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemList))
		soap_serialize_tt__ItemList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemList(struct soap *soap, const char *tag, int id, struct tt__ItemList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemList);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemList ** SOAP_FMAC4 soap_in_PointerTott__ItemList(struct soap *soap, const char *tag, struct tt__ItemList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ItemList **)soap_malloc(soap, sizeof(struct tt__ItemList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ItemList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ItemList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemList, sizeof(struct tt__ItemList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemList(struct soap *soap, struct tt__ItemList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ItemList);
	if (soap_out_PointerTott__ItemList(soap, tag?tag:"tt:ItemList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemList ** SOAP_FMAC4 soap_get_PointerTott__ItemList(struct soap *soap, struct tt__ItemList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ActionEngineCapabilitiesExtension(struct soap *soap, struct ns1__ActionEngineCapabilitiesExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ActionEngineCapabilitiesExtension))
		soap_serialize_ns1__ActionEngineCapabilitiesExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ActionEngineCapabilitiesExtension(struct soap *soap, const char *tag, int id, struct ns1__ActionEngineCapabilitiesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ActionEngineCapabilitiesExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ActionEngineCapabilitiesExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ActionEngineCapabilitiesExtension ** SOAP_FMAC4 soap_in_PointerTons1__ActionEngineCapabilitiesExtension(struct soap *soap, const char *tag, struct ns1__ActionEngineCapabilitiesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ActionEngineCapabilitiesExtension **)soap_malloc(soap, sizeof(struct ns1__ActionEngineCapabilitiesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ActionEngineCapabilitiesExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ActionEngineCapabilitiesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionEngineCapabilitiesExtension, sizeof(struct ns1__ActionEngineCapabilitiesExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ActionEngineCapabilitiesExtension(struct soap *soap, struct ns1__ActionEngineCapabilitiesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ActionEngineCapabilitiesExtension);
	if (soap_out_PointerTons1__ActionEngineCapabilitiesExtension(soap, tag?tag:"ns1:ActionEngineCapabilitiesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ActionEngineCapabilitiesExtension ** SOAP_FMAC4 soap_get_PointerTons1__ActionEngineCapabilitiesExtension(struct soap *soap, struct ns1__ActionEngineCapabilitiesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ActionEngineCapabilitiesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ActionTypeLimits(struct soap *soap, struct ns1__ActionTypeLimits *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ActionTypeLimits))
		soap_serialize_ns1__ActionTypeLimits(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ActionTypeLimits(struct soap *soap, const char *tag, int id, struct ns1__ActionTypeLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ActionTypeLimits);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ActionTypeLimits(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ActionTypeLimits ** SOAP_FMAC4 soap_in_PointerTons1__ActionTypeLimits(struct soap *soap, const char *tag, struct ns1__ActionTypeLimits **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ActionTypeLimits **)soap_malloc(soap, sizeof(struct ns1__ActionTypeLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ActionTypeLimits(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ActionTypeLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionTypeLimits, sizeof(struct ns1__ActionTypeLimits), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ActionTypeLimits(struct soap *soap, struct ns1__ActionTypeLimits *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ActionTypeLimits);
	if (soap_out_PointerTons1__ActionTypeLimits(soap, tag?tag:"ns1:ActionTypeLimits", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ActionTypeLimits ** SOAP_FMAC4 soap_get_PointerTons1__ActionTypeLimits(struct soap *soap, struct ns1__ActionTypeLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ActionTypeLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SupportedActionsExtension(struct soap *soap, struct ns1__SupportedActionsExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SupportedActionsExtension))
		soap_serialize_ns1__SupportedActionsExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SupportedActionsExtension(struct soap *soap, const char *tag, int id, struct ns1__SupportedActionsExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SupportedActionsExtension);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__SupportedActionsExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__SupportedActionsExtension ** SOAP_FMAC4 soap_in_PointerTons1__SupportedActionsExtension(struct soap *soap, const char *tag, struct ns1__SupportedActionsExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__SupportedActionsExtension **)soap_malloc(soap, sizeof(struct ns1__SupportedActionsExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__SupportedActionsExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__SupportedActionsExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SupportedActionsExtension, sizeof(struct ns1__SupportedActionsExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SupportedActionsExtension(struct soap *soap, struct ns1__SupportedActionsExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SupportedActionsExtension);
	if (soap_out_PointerTons1__SupportedActionsExtension(soap, tag?tag:"ns1:SupportedActionsExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SupportedActionsExtension ** SOAP_FMAC4 soap_get_PointerTons1__SupportedActionsExtension(struct soap *soap, struct ns1__SupportedActionsExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SupportedActionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ActionConfigDescription(struct soap *soap, struct ns1__ActionConfigDescription *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ActionConfigDescription))
		soap_serialize_ns1__ActionConfigDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ActionConfigDescription(struct soap *soap, const char *tag, int id, struct ns1__ActionConfigDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ActionConfigDescription);
	if (id < 0)
		return soap->error;
	return soap_out_ns1__ActionConfigDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ns1__ActionConfigDescription ** SOAP_FMAC4 soap_in_PointerTons1__ActionConfigDescription(struct soap *soap, const char *tag, struct ns1__ActionConfigDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ns1__ActionConfigDescription **)soap_malloc(soap, sizeof(struct ns1__ActionConfigDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ns1__ActionConfigDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ns1__ActionConfigDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ActionConfigDescription, sizeof(struct ns1__ActionConfigDescription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ActionConfigDescription(struct soap *soap, struct ns1__ActionConfigDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ActionConfigDescription);
	if (soap_out_PointerTons1__ActionConfigDescription(soap, tag?tag:"ns1:ActionConfigDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ActionConfigDescription ** SOAP_FMAC4 soap_get_PointerTons1__ActionConfigDescription(struct soap *soap, struct ns1__ActionConfigDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ActionConfigDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__anyURI(struct soap *soap, char **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI))
		soap_serialize_xsd__anyURI(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__anyURI(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__anyURI);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__anyURI(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerToxsd__anyURI(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__anyURI(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__anyURI, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__anyURI(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__anyURI);
	if (soap_out_PointerToxsd__anyURI(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerToxsd__anyURI(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ItemListDescription(struct soap *soap, struct tt__ItemListDescription *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ItemListDescription))
		soap_serialize_tt__ItemListDescription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ItemListDescription(struct soap *soap, const char *tag, int id, struct tt__ItemListDescription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ItemListDescription);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ItemListDescription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ItemListDescription ** SOAP_FMAC4 soap_in_PointerTott__ItemListDescription(struct soap *soap, const char *tag, struct tt__ItemListDescription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ItemListDescription **)soap_malloc(soap, sizeof(struct tt__ItemListDescription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ItemListDescription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ItemListDescription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ItemListDescription, sizeof(struct tt__ItemListDescription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ItemListDescription(struct soap *soap, struct tt__ItemListDescription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ItemListDescription);
	if (soap_out_PointerTott__ItemListDescription(soap, tag?tag:"tt:ItemListDescription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ItemListDescription ** SOAP_FMAC4 soap_get_PointerTott__ItemListDescription(struct soap *soap, struct tt__ItemListDescription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ItemListDescription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobReference(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobReference(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__RecordingJobReference);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__RecordingJobReference(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__RecordingJobReference, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobReference(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingJobReference);
	if (soap_out_tt__RecordingJobReference(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__RecordingJobReference(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__JobToken(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__JobToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__JobToken(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__JobToken);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__JobToken(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__JobToken, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__JobToken(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__JobToken);
	if (soap_out_tt__JobToken(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__JobToken(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__JobToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TrackReference(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__TrackReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TrackReference(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__TrackReference);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__TrackReference(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__TrackReference, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TrackReference(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__TrackReference);
	if (soap_out_tt__TrackReference(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__TrackReference(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TrackReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingReference(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__RecordingReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingReference(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__RecordingReference);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__RecordingReference(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__RecordingReference, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingReference(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingReference);
	if (soap_out_tt__RecordingReference(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__RecordingReference(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReceiverReference(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__ReceiverReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReceiverReference(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__ReceiverReference);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__ReceiverReference(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__ReceiverReference, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReceiverReference(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ReceiverReference);
	if (soap_out_tt__ReceiverReference(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__ReceiverReference(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReceiverReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__SimpleTopicExpression(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_wstop__SimpleTopicExpression);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__SimpleTopicExpression(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wstop__SimpleTopicExpression);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wstop__SimpleTopicExpression(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_wstop__SimpleTopicExpression, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__SimpleTopicExpression(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wstop__SimpleTopicExpression);
	if (soap_out_wstop__SimpleTopicExpression(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wstop__SimpleTopicExpression(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__SimpleTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__ConcreteTopicExpression(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_wstop__ConcreteTopicExpression);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__ConcreteTopicExpression(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wstop__ConcreteTopicExpression);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wstop__ConcreteTopicExpression(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_wstop__ConcreteTopicExpression, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__ConcreteTopicExpression(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wstop__ConcreteTopicExpression);
	if (soap_out_wstop__ConcreteTopicExpression(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wstop__ConcreteTopicExpression(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__ConcreteTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wstop__FullTopicExpression(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_wstop__FullTopicExpression);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wstop__FullTopicExpression(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wstop__FullTopicExpression);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wstop__FullTopicExpression(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_wstop__FullTopicExpression, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wstop__FullTopicExpression(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wstop__FullTopicExpression);
	if (soap_out_wstop__FullTopicExpression(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wstop__FullTopicExpression(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wstop__FullTopicExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobState(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobState(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__RecordingJobState);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__RecordingJobState(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__RecordingJobState, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobState(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingJobState);
	if (soap_out_tt__RecordingJobState(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__RecordingJobState(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__RecordingJobMode(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RecordingJobMode(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__RecordingJobMode);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__RecordingJobMode(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__RecordingJobMode, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__RecordingJobMode(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__RecordingJobMode);
	if (soap_out_tt__RecordingJobMode(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__RecordingJobMode(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RecordingJobMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__XPathExpression(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__XPathExpression);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__XPathExpression(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__XPathExpression);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__XPathExpression(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__XPathExpression, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__XPathExpression(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__XPathExpression);
	if (soap_out_tt__XPathExpression(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__XPathExpression(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__XPathExpression(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Description(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__Description);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Description(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__Description);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__Description(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__Description, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Description(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Description);
	if (soap_out_tt__Description(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__Description(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__TopicNamespaceLocation(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__TopicNamespaceLocation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__TopicNamespaceLocation(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__TopicNamespaceLocation);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__TopicNamespaceLocation(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__TopicNamespaceLocation, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__TopicNamespaceLocation(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__TopicNamespaceLocation);
	if (soap_out_tt__TopicNamespaceLocation(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__TopicNamespaceLocation(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__TopicNamespaceLocation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__AuxiliaryData(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__AuxiliaryData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AuxiliaryData(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__AuxiliaryData);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__AuxiliaryData(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__AuxiliaryData, 1, 0, 128);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__AuxiliaryData(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__AuxiliaryData);
	if (soap_out_tt__AuxiliaryData(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__AuxiliaryData(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AuxiliaryData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Dot11PSKPassphrase(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__Dot11PSKPassphrase);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Dot11PSKPassphrase(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__Dot11PSKPassphrase);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__Dot11PSKPassphrase(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__Dot11PSKPassphrase, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Dot11PSKPassphrase(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Dot11PSKPassphrase);
	if (soap_out_tt__Dot11PSKPassphrase(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__Dot11PSKPassphrase(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Dot11PSKPassphrase(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Domain(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__Domain);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Domain(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__Domain);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__Domain(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__Domain, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Domain(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Domain);
	if (soap_out_tt__Domain(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__Domain(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Domain(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__DNSName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__DNSName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DNSName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__DNSName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__DNSName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__DNSName, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__DNSName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__DNSName);
	if (soap_out_tt__DNSName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__DNSName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DNSName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__HwAddress(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__HwAddress);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__HwAddress(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__HwAddress);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__HwAddress(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__HwAddress, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__HwAddress(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__HwAddress);
	if (soap_out_tt__HwAddress(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__HwAddress(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__HwAddress(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv6Address(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__IPv6Address);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv6Address(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__IPv6Address);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__IPv6Address(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__IPv6Address, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv6Address(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv6Address);
	if (soap_out_tt__IPv6Address(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__IPv6Address(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv6Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IPv4Address(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__IPv4Address);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IPv4Address(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__IPv4Address);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__IPv4Address(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__IPv4Address, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IPv4Address(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IPv4Address);
	if (soap_out_tt__IPv4Address(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__IPv4Address(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IPv4Address(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__NetworkInterfaceConfigPriority(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceConfigPriority);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__NetworkInterfaceConfigPriority(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__NetworkInterfaceConfigPriority);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__NetworkInterfaceConfigPriority(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__NetworkInterfaceConfigPriority, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__NetworkInterfaceConfigPriority(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__NetworkInterfaceConfigPriority);
	if (soap_out_tt__NetworkInterfaceConfigPriority(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__NetworkInterfaceConfigPriority(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__NetworkInterfaceConfigPriority(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__Name(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__Name);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Name(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__Name);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__Name(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__Name, 1, 0, 64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__Name(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__Name);
	if (soap_out_tt__Name(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__Name(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Name(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__ReferenceToken(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__ReferenceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ReferenceToken(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__ReferenceToken);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__ReferenceToken(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__ReferenceToken, 1, 0, 64);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__ReferenceToken(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__ReferenceToken);
	if (soap_out_tt__ReferenceToken(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__ReferenceToken(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ReferenceToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trc__EncodingTypes(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_trc__EncodingTypes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trc__EncodingTypes(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_trc__EncodingTypes);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_trc__EncodingTypes(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_trc__EncodingTypes, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trc__EncodingTypes(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trc__EncodingTypes);
	if (soap_out_trc__EncodingTypes(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_trc__EncodingTypes(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_trc__EncodingTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tds__EAPMethodTypes(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tds__EAPMethodTypes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tds__EAPMethodTypes(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tds__EAPMethodTypes);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tds__EAPMethodTypes(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tds__EAPMethodTypes, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tds__EAPMethodTypes(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tds__EAPMethodTypes);
	if (soap_out_tds__EAPMethodTypes(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tds__EAPMethodTypes(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tds__EAPMethodTypes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tmd__DelayTimes(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tmd__DelayTimes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tmd__DelayTimes(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tmd__DelayTimes);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tmd__DelayTimes(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tmd__DelayTimes, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tmd__DelayTimes(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tmd__DelayTimes);
	if (soap_out_tmd__DelayTimes(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tmd__DelayTimes(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tmd__DelayTimes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsnt__AbsoluteOrRelativeTimeType);
	if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsnt__AbsoluteOrRelativeTimeType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__StringAttrList(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__StringAttrList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__StringAttrList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__StringAttrList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__StringAttrList(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__StringAttrList, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__StringAttrList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__StringAttrList);
	if (soap_out_tt__StringAttrList(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__StringAttrList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__StringAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__FloatAttrList(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__FloatAttrList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatAttrList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__FloatAttrList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__FloatAttrList(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__FloatAttrList, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__FloatAttrList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__FloatAttrList);
	if (soap_out_tt__FloatAttrList(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__FloatAttrList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__IntAttrList(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__IntAttrList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntAttrList(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_tt__IntAttrList);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_tt__IntAttrList(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_tt__IntAttrList, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__IntAttrList(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__IntAttrList);
	if (soap_out_tt__IntAttrList(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_tt__IntAttrList(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntAttrList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__token(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__token);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__token(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__token);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__token(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__token, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__token(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__token);
	if (soap_out_xsd__token(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__token(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__token(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__positiveInteger(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__positiveInteger);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__positiveInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__positiveInteger);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__positiveInteger(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__positiveInteger, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__positiveInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__positiveInteger);
	if (soap_out_xsd__positiveInteger(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__positiveInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__positiveInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__nonNegativeInteger(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__nonNegativeInteger);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__nonNegativeInteger(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__nonNegativeInteger);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__nonNegativeInteger(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__nonNegativeInteger, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__nonNegativeInteger(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__nonNegativeInteger);
	if (soap_out_xsd__nonNegativeInteger(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__nonNegativeInteger(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__nonNegativeInteger(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__integer);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__integer);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__integer(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__integer, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__integer);
	if (soap_out_xsd__integer(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anyURI(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__anyURI);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anyURI(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anyURI);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anyURI(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anyURI, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anyURI(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anyURI);
	if (soap_out_xsd__anyURI(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anyURI(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anyURI(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__anySimpleType(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__anySimpleType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__anySimpleType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__anySimpleType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__anySimpleType(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__anySimpleType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__anySimpleType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__anySimpleType);
	if (soap_out_xsd__anySimpleType(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__anySimpleType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__anySimpleType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__NCName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_xsd__NCName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__NCName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__NCName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_xsd__NCName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__NCName, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__NCName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__NCName);
	if (soap_out_xsd__NCName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_xsd__NCName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__NCName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Header))
		soap_serialize_SOAP_ENV__Header(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Header(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Header *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Header);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Header(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Header **)soap_malloc(soap, sizeof(struct SOAP_ENV__Header *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Header(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Header);
	if (soap_out_PointerToSOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_chan__ChannelInstanceType))
		soap_serialize_chan__ChannelInstanceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, int id, struct chan__ChannelInstanceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_chan__ChannelInstanceType);
	if (id < 0)
		return soap->error;
	return soap_out_chan__ChannelInstanceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_in_PointerTochan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct chan__ChannelInstanceType **)soap_malloc(soap, sizeof(struct chan__ChannelInstanceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_chan__ChannelInstanceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct chan__ChannelInstanceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTochan__ChannelInstanceType);
	if (soap_out_PointerTochan__ChannelInstanceType(soap, tag?tag:"chan:ChannelInstanceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType ** SOAP_FMAC4 soap_get_PointerTochan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTochan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__FaultTo))
		soap_serialize__wsa5__FaultTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__FaultTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__FaultTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__FaultTo, sizeof(struct wsa5__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__FaultTo);
	if (soap_out_PointerTo_wsa5__FaultTo(soap, tag?tag:"wsa5:FaultTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__FaultTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__ReplyTo))
		soap_serialize__wsa5__ReplyTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__ReplyTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__ReplyTo(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__ReplyTo, sizeof(struct wsa5__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__ReplyTo);
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, tag?tag:"wsa5:ReplyTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__ReplyTo(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__From))
		soap_serialize__wsa5__From(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__From(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__From);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__From(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__From, sizeof(struct wsa5__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__From);
	if (soap_out_PointerTo_wsa5__From(soap, tag?tag:"wsa5:From", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__From(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa5__RelatesTo))
		soap_serialize__wsa5__RelatesTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa5__RelatesToType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa5__RelatesTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa5__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_in_PointerTo_wsa5__RelatesTo(struct soap *soap, const char *tag, struct wsa5__RelatesToType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__RelatesToType **)soap_malloc(soap, sizeof(struct wsa5__RelatesToType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa5__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__RelatesToType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa5__RelatesTo, sizeof(struct wsa5__RelatesToType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa5__RelatesTo);
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, tag?tag:"wsa5:RelatesTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType ** SOAP_FMAC4 soap_get_PointerTo_wsa5__RelatesTo(struct soap *soap, struct wsa5__RelatesToType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa5__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsa5__ProblemHeaderQName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__wsa5__ProblemHeaderQName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsa5__ProblemHeaderQName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__wsa5__ProblemHeaderQName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__wsa5__ProblemHeaderQName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__wsa5__ProblemHeaderQName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsa5__ProblemHeaderQName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsa5__ProblemHeaderQName);
	if (soap_out__wsa5__ProblemHeaderQName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__wsa5__ProblemHeaderQName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__wsa5__ProblemHeaderQName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__MetadataType))
		soap_serialize_wsa5__MetadataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, int id, struct wsa5__MetadataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__MetadataType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__MetadataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_in_PointerTowsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__MetadataType **)soap_malloc(soap, sizeof(struct wsa5__MetadataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__MetadataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa5__MetadataType);
	if (soap_out_PointerTowsa5__MetadataType(soap, tag?tag:"wsa5:MetadataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType ** SOAP_FMAC4 soap_get_PointerTowsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__ReferenceParametersType))
		soap_serialize_wsa5__ReferenceParametersType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa5__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__ReferenceParametersType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa5__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa5__ReferenceParametersType);
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, tag?tag:"wsa5:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__FaultCodesOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__FaultCodesOpenEnumType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__FaultCodesOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__FaultCodesOpenEnumType);
	if (soap_out_wsa5__FaultCodesOpenEnumType(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__FaultCodesOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__FaultCodesOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsa5__RelationshipTypeOpenEnum(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelationshipTypeOpenEnum);
	if (soap_out_wsa5__RelationshipTypeOpenEnum(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsa5__RelationshipTypeOpenEnum(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelationshipTypeOpenEnum(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedByte(struct soap *soap, unsigned char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_unsignedByte);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedByte(struct soap *soap, const char *tag, int id, unsigned char *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedByte);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedByte(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_in_PointerTounsignedByte(struct soap *soap, const char *tag, unsigned char **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned char **)soap_malloc(soap, sizeof(unsigned char *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedByte(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned char **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedByte, sizeof(unsigned char), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedByte(struct soap *soap, unsigned char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedByte);
	if (soap_out_PointerTounsignedByte(soap, tag?tag:"unsignedByte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned char ** SOAP_FMAC4 soap_get_PointerTounsignedByte(struct soap *soap, unsigned char **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedByte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ResolveMatchesType))
		soap_serialize_wsdd__ResolveMatchesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ResolveMatchesType(struct soap *soap, const char *tag, int id, struct wsdd__ResolveMatchesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ResolveMatchesType);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ResolveMatchesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType ** SOAP_FMAC4 soap_in_PointerTowsdd__ResolveMatchesType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ResolveMatchesType **)soap_malloc(soap, sizeof(struct wsdd__ResolveMatchesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ResolveMatchesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ResolveMatchesType, sizeof(struct wsdd__ResolveMatchesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsdd__ResolveMatchesType);
	if (soap_out_PointerTowsdd__ResolveMatchesType(soap, tag?tag:"wsdd:ResolveMatchesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType ** SOAP_FMAC4 soap_get_PointerTowsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ResolveMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ResolveType))
		soap_serialize_wsdd__ResolveType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ResolveType(struct soap *soap, const char *tag, int id, struct wsdd__ResolveType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ResolveType);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ResolveType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ResolveType ** SOAP_FMAC4 soap_in_PointerTowsdd__ResolveType(struct soap *soap, const char *tag, struct wsdd__ResolveType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ResolveType **)soap_malloc(soap, sizeof(struct wsdd__ResolveType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ResolveType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ResolveType, sizeof(struct wsdd__ResolveType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsdd__ResolveType);
	if (soap_out_PointerTowsdd__ResolveType(soap, tag?tag:"wsdd:ResolveType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveType ** SOAP_FMAC4 soap_get_PointerTowsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ResolveType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ProbeMatchesType))
		soap_serialize_wsdd__ProbeMatchesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ProbeMatchesType(struct soap *soap, const char *tag, int id, struct wsdd__ProbeMatchesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ProbeMatchesType);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ProbeMatchesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType ** SOAP_FMAC4 soap_in_PointerTowsdd__ProbeMatchesType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ProbeMatchesType **)soap_malloc(soap, sizeof(struct wsdd__ProbeMatchesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ProbeMatchesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ProbeMatchesType, sizeof(struct wsdd__ProbeMatchesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsdd__ProbeMatchesType);
	if (soap_out_PointerTowsdd__ProbeMatchesType(soap, tag?tag:"wsdd:ProbeMatchesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType ** SOAP_FMAC4 soap_get_PointerTowsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ProbeMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ProbeType))
		soap_serialize_wsdd__ProbeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ProbeType(struct soap *soap, const char *tag, int id, struct wsdd__ProbeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ProbeType);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ProbeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ProbeType ** SOAP_FMAC4 soap_in_PointerTowsdd__ProbeType(struct soap *soap, const char *tag, struct wsdd__ProbeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ProbeType **)soap_malloc(soap, sizeof(struct wsdd__ProbeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ProbeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ProbeType, sizeof(struct wsdd__ProbeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsdd__ProbeType);
	if (soap_out_PointerTowsdd__ProbeType(soap, tag?tag:"wsdd:ProbeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeType ** SOAP_FMAC4 soap_get_PointerTowsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ProbeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ByeType(struct soap *soap, struct wsdd__ByeType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ByeType))
		soap_serialize_wsdd__ByeType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ByeType(struct soap *soap, const char *tag, int id, struct wsdd__ByeType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ByeType);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ByeType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ByeType ** SOAP_FMAC4 soap_in_PointerTowsdd__ByeType(struct soap *soap, const char *tag, struct wsdd__ByeType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ByeType **)soap_malloc(soap, sizeof(struct wsdd__ByeType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ByeType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ByeType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ByeType, sizeof(struct wsdd__ByeType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ByeType(struct soap *soap, struct wsdd__ByeType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsdd__ByeType);
	if (soap_out_PointerTowsdd__ByeType(soap, tag?tag:"wsdd:ByeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ByeType ** SOAP_FMAC4 soap_get_PointerTowsdd__ByeType(struct soap *soap, struct wsdd__ByeType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ByeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__HelloType(struct soap *soap, struct wsdd__HelloType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__HelloType))
		soap_serialize_wsdd__HelloType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__HelloType(struct soap *soap, const char *tag, int id, struct wsdd__HelloType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__HelloType);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__HelloType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__HelloType ** SOAP_FMAC4 soap_in_PointerTowsdd__HelloType(struct soap *soap, const char *tag, struct wsdd__HelloType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__HelloType **)soap_malloc(soap, sizeof(struct wsdd__HelloType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__HelloType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__HelloType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__HelloType, sizeof(struct wsdd__HelloType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__HelloType(struct soap *soap, struct wsdd__HelloType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsdd__HelloType);
	if (soap_out_PointerTowsdd__HelloType(soap, tag?tag:"wsdd:HelloType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__HelloType ** SOAP_FMAC4 soap_get_PointerTowsdd__HelloType(struct soap *soap, struct wsdd__HelloType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__HelloType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__AppSequenceType))
		soap_serialize_wsdd__AppSequenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__AppSequenceType(struct soap *soap, const char *tag, int id, struct wsdd__AppSequenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__AppSequenceType);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__AppSequenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__AppSequenceType ** SOAP_FMAC4 soap_in_PointerTowsdd__AppSequenceType(struct soap *soap, const char *tag, struct wsdd__AppSequenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__AppSequenceType **)soap_malloc(soap, sizeof(struct wsdd__AppSequenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__AppSequenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__AppSequenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__AppSequenceType, sizeof(struct wsdd__AppSequenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsdd__AppSequenceType);
	if (soap_out_PointerTowsdd__AppSequenceType(soap, tag?tag:"wsdd:AppSequenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__AppSequenceType ** SOAP_FMAC4 soap_get_PointerTowsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__AppSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__SigType(struct soap *soap, struct wsdd__SigType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__SigType))
		soap_serialize_wsdd__SigType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__SigType(struct soap *soap, const char *tag, int id, struct wsdd__SigType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__SigType);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__SigType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__SigType ** SOAP_FMAC4 soap_in_PointerTowsdd__SigType(struct soap *soap, const char *tag, struct wsdd__SigType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__SigType **)soap_malloc(soap, sizeof(struct wsdd__SigType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__SigType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__SigType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__SigType, sizeof(struct wsdd__SigType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__SigType(struct soap *soap, struct wsdd__SigType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsdd__SigType);
	if (soap_out_PointerTowsdd__SigType(soap, tag?tag:"wsdd:SigType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__SigType ** SOAP_FMAC4 soap_get_PointerTowsdd__SigType(struct soap *soap, struct wsdd__SigType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__SigType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ResolveMatchType))
		soap_serialize_wsdd__ResolveMatchType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ResolveMatchType(struct soap *soap, const char *tag, int id, struct wsdd__ResolveMatchType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ResolveMatchType);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ResolveMatchType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType ** SOAP_FMAC4 soap_in_PointerTowsdd__ResolveMatchType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ResolveMatchType **)soap_malloc(soap, sizeof(struct wsdd__ResolveMatchType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ResolveMatchType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ResolveMatchType, sizeof(struct wsdd__ResolveMatchType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsdd__ResolveMatchType);
	if (soap_out_PointerTowsdd__ResolveMatchType(soap, tag?tag:"wsdd:ResolveMatchType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType ** SOAP_FMAC4 soap_get_PointerTowsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ResolveMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ProbeMatchType))
		soap_serialize_wsdd__ProbeMatchType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ProbeMatchType(struct soap *soap, const char *tag, int id, struct wsdd__ProbeMatchType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ProbeMatchType);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ProbeMatchType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType ** SOAP_FMAC4 soap_in_PointerTowsdd__ProbeMatchType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ProbeMatchType **)soap_malloc(soap, sizeof(struct wsdd__ProbeMatchType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ProbeMatchType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ProbeMatchType, sizeof(struct wsdd__ProbeMatchType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsdd__ProbeMatchType);
	if (soap_out_PointerTowsdd__ProbeMatchType(soap, tag?tag:"wsdd:ProbeMatchType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType ** SOAP_FMAC4 soap_get_PointerTowsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ProbeMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedInt(struct soap *soap, unsigned int *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedInt(struct soap *soap, const char *tag, int id, unsigned int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedInt);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedInt(soap, tag, id, *a, type);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_in_PointerTounsignedInt(struct soap *soap, const char *tag, unsigned int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (unsigned int **)soap_malloc(soap, sizeof(unsigned int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedInt(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (unsigned int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedInt, sizeof(unsigned int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedInt(struct soap *soap, unsigned int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedInt);
	if (soap_out_PointerTounsignedInt(soap, tag?tag:"unsignedInt", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 unsigned int ** SOAP_FMAC4 soap_get_PointerTounsignedInt(struct soap *soap, unsigned int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedInt(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsdd__ScopesType))
		soap_serialize_wsdd__ScopesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsdd__ScopesType(struct soap *soap, const char *tag, int id, struct wsdd__ScopesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsdd__ScopesType);
	if (id < 0)
		return soap->error;
	return soap_out_wsdd__ScopesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsdd__ScopesType ** SOAP_FMAC4 soap_in_PointerTowsdd__ScopesType(struct soap *soap, const char *tag, struct wsdd__ScopesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsdd__ScopesType **)soap_malloc(soap, sizeof(struct wsdd__ScopesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsdd__ScopesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsdd__ScopesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsdd__ScopesType, sizeof(struct wsdd__ScopesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsdd__ScopesType);
	if (soap_out_PointerTowsdd__ScopesType(soap, tag?tag:"wsdd:ScopesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ScopesType ** SOAP_FMAC4 soap_get_PointerTowsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsdd__ScopesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__FaultCodeOpenType(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_wsdd__FaultCodeOpenType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__FaultCodeOpenType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsdd__FaultCodeOpenType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsdd__FaultCodeOpenType(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_wsdd__FaultCodeOpenType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__FaultCodeOpenType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsdd__FaultCodeOpenType);
	if (soap_out_wsdd__FaultCodeOpenType(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsdd__FaultCodeOpenType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__FaultCodeOpenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__UriListType(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_wsdd__UriListType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__UriListType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsdd__UriListType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsdd__UriListType(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_wsdd__UriListType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__UriListType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsdd__UriListType);
	if (soap_out_wsdd__UriListType(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsdd__UriListType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__UriListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__QNameListType(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_wsdd__QNameListType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__QNameListType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsdd__QNameListType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsdd__QNameListType(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_wsdd__QNameListType, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__QNameListType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsdd__QNameListType);
	if (soap_out_wsdd__QNameListType(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsdd__QNameListType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__QNameListType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__FaultTo))
		soap_serialize__wsa__FaultTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__FaultTo(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__FaultTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__FaultTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__FaultTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__FaultTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__FaultTo, sizeof(struct wsa__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__FaultTo);
	if (soap_out_PointerTo_wsa__FaultTo(soap, tag?tag:"wsa:FaultTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__FaultTo(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__FaultTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__ReplyTo))
		soap_serialize__wsa__ReplyTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__ReplyTo(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__ReplyTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__ReplyTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__ReplyTo(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__ReplyTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__ReplyTo, sizeof(struct wsa__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__ReplyTo);
	if (soap_out_PointerTo_wsa__ReplyTo(soap, tag?tag:"wsa:ReplyTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__ReplyTo(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__ReplyTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__From))
		soap_serialize__wsa__From(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__From(struct soap *soap, const char *tag, int id, struct wsa__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__From);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__From(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTo_wsa__From(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__From(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__From, sizeof(struct wsa__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__From);
	if (soap_out_PointerTo_wsa__From(soap, tag?tag:"wsa:From", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTo_wsa__From(struct soap *soap, struct wsa__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__From(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__Relationship *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsa__RelatesTo))
		soap_serialize__wsa__RelatesTo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsa__RelatesTo(struct soap *soap, const char *tag, int id, struct wsa__Relationship *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsa__RelatesTo);
	if (id < 0)
		return soap->error;
	return soap_out__wsa__RelatesTo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__Relationship ** SOAP_FMAC4 soap_in_PointerTo_wsa__RelatesTo(struct soap *soap, const char *tag, struct wsa__Relationship **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__Relationship **)soap_malloc(soap, sizeof(struct wsa__Relationship *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsa__RelatesTo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__Relationship **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsa__RelatesTo, sizeof(struct wsa__Relationship), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__Relationship *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsa__RelatesTo);
	if (soap_out_PointerTo_wsa__RelatesTo(soap, tag?tag:"wsa:RelatesTo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__Relationship ** SOAP_FMAC4 soap_get_PointerTo_wsa__RelatesTo(struct soap *soap, struct wsa__Relationship **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsa__RelatesTo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ServiceNameType))
		soap_serialize_wsa__ServiceNameType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ServiceNameType(struct soap *soap, const char *tag, int id, struct wsa__ServiceNameType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ServiceNameType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ServiceNameType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ServiceNameType ** SOAP_FMAC4 soap_in_PointerTowsa__ServiceNameType(struct soap *soap, const char *tag, struct wsa__ServiceNameType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__ServiceNameType **)soap_malloc(soap, sizeof(struct wsa__ServiceNameType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa__ServiceNameType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__ServiceNameType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ServiceNameType, sizeof(struct wsa__ServiceNameType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa__ServiceNameType);
	if (soap_out_PointerTowsa__ServiceNameType(soap, tag?tag:"wsa:ServiceNameType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ServiceNameType ** SOAP_FMAC4 soap_get_PointerTowsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_QName(struct soap *soap, char **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__QName))
		soap_serialize__QName(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_QName(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__QName);
	if (id < 0)
		return soap->error;
	return soap_out__QName(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTo_QName(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__QName(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__QName, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_QName(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_QName);
	if (soap_out_PointerTo_QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTo_QName(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ReferenceParametersType))
		soap_serialize_wsa__ReferenceParametersType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, struct wsa__ReferenceParametersType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ReferenceParametersType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ReferenceParametersType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType ** SOAP_FMAC4 soap_in_PointerTowsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__ReferenceParametersType **)soap_malloc(soap, sizeof(struct wsa__ReferenceParametersType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa__ReferenceParametersType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferenceParametersType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa__ReferenceParametersType);
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, tag?tag:"wsa:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType ** SOAP_FMAC4 soap_get_PointerTowsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa__ReferencePropertiesType))
		soap_serialize_wsa__ReferencePropertiesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa__ReferencePropertiesType(struct soap *soap, const char *tag, int id, struct wsa__ReferencePropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa__ReferencePropertiesType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa__ReferencePropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType ** SOAP_FMAC4 soap_in_PointerTowsa__ReferencePropertiesType(struct soap *soap, const char *tag, struct wsa__ReferencePropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa__ReferencePropertiesType **)soap_malloc(soap, sizeof(struct wsa__ReferencePropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa__ReferencePropertiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferencePropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa__ReferencePropertiesType);
	if (soap_out_PointerTowsa__ReferencePropertiesType(soap, tag?tag:"wsa:ReferencePropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType ** SOAP_FMAC4 soap_get_PointerTowsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Security))
		soap_serialize__wsse__Security(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Security(struct soap *soap, const char *tag, int id, struct _wsse__Security *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Security);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Security(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_in_PointerTo_wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Security **)soap_malloc(soap, sizeof(struct _wsse__Security *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Security(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Security);
	if (soap_out_PointerTo_wsse__Security(soap, tag?tag:"wsse:Security", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security ** SOAP_FMAC4 soap_get_PointerTo_wsse__Security(struct soap *soap, struct _wsse__Security **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureType))
		soap_serialize_ds__SignatureType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureType(struct soap *soap, const char *tag, int id, struct ds__SignatureType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_in_PointerTods__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureType **)soap_malloc(soap, sizeof(struct ds__SignatureType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureType);
	if (soap_out_PointerTods__SignatureType(soap, tag?tag:"ds:SignatureType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType ** SOAP_FMAC4 soap_get_PointerTods__SignatureType(struct soap *soap, struct ds__SignatureType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsc__SecurityContextTokenType))
		soap_serialize_wsc__SecurityContextTokenType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsc__SecurityContextTokenType(struct soap *soap, const char *tag, int id, struct wsc__SecurityContextTokenType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsc__SecurityContextTokenType);
	if (id < 0)
		return soap->error;
	return soap_out_wsc__SecurityContextTokenType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType ** SOAP_FMAC4 soap_in_PointerTowsc__SecurityContextTokenType(struct soap *soap, const char *tag, struct wsc__SecurityContextTokenType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsc__SecurityContextTokenType **)soap_malloc(soap, sizeof(struct wsc__SecurityContextTokenType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsc__SecurityContextTokenType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsc__SecurityContextTokenType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsc__SecurityContextTokenType);
	if (soap_out_PointerTowsc__SecurityContextTokenType(soap, tag?tag:"wsc:SecurityContextTokenType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType ** SOAP_FMAC4 soap_get_PointerTowsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsc__SecurityContextTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptedKeyType))
		soap_serialize_xenc__EncryptedKeyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptedKeyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptedKeyType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptedKeyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptedKeyType **)soap_malloc(soap, sizeof(struct xenc__EncryptedKeyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptedKeyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__EncryptedKeyType);
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, tag?tag:"xenc:EncryptedKeyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__BinarySecurityToken))
		soap_serialize__wsse__BinarySecurityToken(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, struct _wsse__BinarySecurityToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__BinarySecurityToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__BinarySecurityToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__BinarySecurityToken **)soap_malloc(soap, sizeof(struct _wsse__BinarySecurityToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__BinarySecurityToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__BinarySecurityToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__BinarySecurityToken);
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, tag?tag:"wsse:BinarySecurityToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__UsernameToken))
		soap_serialize__wsse__UsernameToken(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, int id, struct _wsse__UsernameToken *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__UsernameToken);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__UsernameToken(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_in_PointerTo_wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__UsernameToken **)soap_malloc(soap, sizeof(struct _wsse__UsernameToken *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__UsernameToken(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__UsernameToken);
	if (soap_out_PointerTo_wsse__UsernameToken(soap, tag?tag:"wsse:UsernameToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken ** SOAP_FMAC4 soap_get_PointerTo_wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsu__Timestamp))
		soap_serialize__wsu__Timestamp(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, int id, struct _wsu__Timestamp *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsu__Timestamp);
	if (id < 0)
		return soap->error;
	return soap_out__wsu__Timestamp(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_in_PointerTo_wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsu__Timestamp **)soap_malloc(soap, sizeof(struct _wsu__Timestamp *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsu__Timestamp(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsu__Timestamp);
	if (soap_out_PointerTo_wsu__Timestamp(soap, tag?tag:"wsu:Timestamp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp ** SOAP_FMAC4 soap_get_PointerTo_wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence))
		soap_serialize___wsc__DerivedKeyTokenType_sequence(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, int id, struct __wsc__DerivedKeyTokenType_sequence *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence);
	if (id < 0)
		return soap->error;
	return soap_out___wsc__DerivedKeyTokenType_sequence(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence ** SOAP_FMAC4 soap_in_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, struct __wsc__DerivedKeyTokenType_sequence **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __wsc__DerivedKeyTokenType_sequence **)soap_malloc(soap, sizeof(struct __wsc__DerivedKeyTokenType_sequence *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___wsc__DerivedKeyTokenType_sequence(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __wsc__DerivedKeyTokenType_sequence **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, sizeof(struct __wsc__DerivedKeyTokenType_sequence), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__wsc__DerivedKeyTokenType_sequence);
	if (soap_out_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, tag?tag:"-wsc:DerivedKeyTokenType-sequence", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence ** SOAP_FMAC4 soap_get_PointerTo__wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__wsc__DerivedKeyTokenType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTounsignedLONG64(struct soap *soap, ULONG64 *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_unsignedLONG64);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTounsignedLONG64(struct soap *soap, const char *tag, int id, ULONG64 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_unsignedLONG64);
	if (id < 0)
		return soap->error;
	return soap_out_unsignedLONG64(soap, tag, id, *a, type);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_in_PointerTounsignedLONG64(struct soap *soap, const char *tag, ULONG64 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ULONG64 **)soap_malloc(soap, sizeof(ULONG64 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_unsignedLONG64(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ULONG64 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_unsignedLONG64, sizeof(ULONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTounsignedLONG64(struct soap *soap, ULONG64 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTounsignedLONG64);
	if (soap_out_PointerTounsignedLONG64(soap, tag?tag:"unsignedLong", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 ULONG64 ** SOAP_FMAC4 soap_get_PointerTounsignedLONG64(struct soap *soap, ULONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTounsignedLONG64(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsc__PropertiesType))
		soap_serialize_wsc__PropertiesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsc__PropertiesType(struct soap *soap, const char *tag, int id, struct wsc__PropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsc__PropertiesType);
	if (id < 0)
		return soap->error;
	return soap_out_wsc__PropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsc__PropertiesType ** SOAP_FMAC4 soap_in_PointerTowsc__PropertiesType(struct soap *soap, const char *tag, struct wsc__PropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsc__PropertiesType **)soap_malloc(soap, sizeof(struct wsc__PropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsc__PropertiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsc__PropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsc__PropertiesType);
	if (soap_out_PointerTowsc__PropertiesType(soap, tag?tag:"wsc:PropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__PropertiesType ** SOAP_FMAC4 soap_get_PointerTowsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsc__PropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__FaultCodeOpenEnumType(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_wsc__FaultCodeOpenEnumType);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__FaultCodeOpenEnumType(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_wsc__FaultCodeOpenEnumType);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_wsc__FaultCodeOpenEnumType(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_wsc__FaultCodeOpenEnumType, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__FaultCodeOpenEnumType(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsc__FaultCodeOpenEnumType);
	if (soap_out_wsc__FaultCodeOpenEnumType(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_wsc__FaultCodeOpenEnumType(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__FaultCodeOpenEnumType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__xenc__ReferenceList))
		soap_serialize__xenc__ReferenceList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_xenc__ReferenceList(struct soap *soap, const char *tag, int id, struct _xenc__ReferenceList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__xenc__ReferenceList);
	if (id < 0)
		return soap->error;
	return soap_out__xenc__ReferenceList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _xenc__ReferenceList ** SOAP_FMAC4 soap_in_PointerTo_xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _xenc__ReferenceList **)soap_malloc(soap, sizeof(struct _xenc__ReferenceList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__xenc__ReferenceList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _xenc__ReferenceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_xenc__ReferenceList);
	if (soap_out_PointerTo_xenc__ReferenceList(soap, tag?tag:"xenc:ReferenceList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList ** SOAP_FMAC4 soap_get_PointerTo_xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_xenc__ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___xenc__union_ReferenceList))
		soap_serialize___xenc__union_ReferenceList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__xenc__union_ReferenceList(struct soap *soap, const char *tag, int id, struct __xenc__union_ReferenceList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___xenc__union_ReferenceList);
	if (id < 0)
		return soap->error;
	return soap_out___xenc__union_ReferenceList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __xenc__union_ReferenceList ** SOAP_FMAC4 soap_in_PointerTo__xenc__union_ReferenceList(struct soap *soap, const char *tag, struct __xenc__union_ReferenceList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __xenc__union_ReferenceList **)soap_malloc(soap, sizeof(struct __xenc__union_ReferenceList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___xenc__union_ReferenceList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __xenc__union_ReferenceList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__xenc__union_ReferenceList);
	if (soap_out_PointerTo__xenc__union_ReferenceList(soap, tag?tag:"-xenc:union-ReferenceList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __xenc__union_ReferenceList ** SOAP_FMAC4 soap_get_PointerTo__xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__xenc__union_ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__ReferenceType))
		soap_serialize_xenc__ReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__ReferenceType(struct soap *soap, const char *tag, int id, struct xenc__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__ReferenceType ** SOAP_FMAC4 soap_in_PointerToxenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__ReferenceType **)soap_malloc(soap, sizeof(struct xenc__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__ReferenceType);
	if (soap_out_PointerToxenc__ReferenceType(soap, tag?tag:"xenc:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType ** SOAP_FMAC4 soap_get_PointerToxenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionPropertyType))
		soap_serialize_xenc__EncryptionPropertyType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionPropertyType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionPropertyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionPropertyType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionPropertyType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionPropertyType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionPropertyType **)soap_malloc(soap, sizeof(struct xenc__EncryptionPropertyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionPropertyType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__EncryptionPropertyType);
	if (soap_out_PointerToxenc__EncryptionPropertyType(soap, tag?tag:"xenc:EncryptionPropertyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionPropertyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__TransformsType))
		soap_serialize_xenc__TransformsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__TransformsType(struct soap *soap, const char *tag, int id, struct xenc__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__TransformsType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__TransformsType ** SOAP_FMAC4 soap_in_PointerToxenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__TransformsType **)soap_malloc(soap, sizeof(struct xenc__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__TransformsType);
	if (soap_out_PointerToxenc__TransformsType(soap, tag?tag:"xenc:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType ** SOAP_FMAC4 soap_get_PointerToxenc__TransformsType(struct soap *soap, struct xenc__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__CipherReferenceType))
		soap_serialize_xenc__CipherReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__CipherReferenceType(struct soap *soap, const char *tag, int id, struct xenc__CipherReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__CipherReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__CipherReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__CipherReferenceType ** SOAP_FMAC4 soap_in_PointerToxenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__CipherReferenceType **)soap_malloc(soap, sizeof(struct xenc__CipherReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__CipherReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__CipherReferenceType);
	if (soap_out_PointerToxenc__CipherReferenceType(soap, tag?tag:"xenc:CipherReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType ** SOAP_FMAC4 soap_get_PointerToxenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__CipherReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionPropertiesType))
		soap_serialize_xenc__EncryptionPropertiesType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionPropertiesType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionPropertiesType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionPropertiesType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionPropertiesType **)soap_malloc(soap, sizeof(struct xenc__EncryptionPropertiesType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionPropertiesType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertiesType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__EncryptionPropertiesType);
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, tag?tag:"xenc:EncryptionPropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__CipherDataType))
		soap_serialize_xenc__CipherDataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__CipherDataType(struct soap *soap, const char *tag, int id, struct xenc__CipherDataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__CipherDataType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__CipherDataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__CipherDataType ** SOAP_FMAC4 soap_in_PointerToxenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__CipherDataType **)soap_malloc(soap, sizeof(struct xenc__CipherDataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__CipherDataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherDataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__CipherDataType);
	if (soap_out_PointerToxenc__CipherDataType(soap, tag?tag:"xenc:CipherDataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType ** SOAP_FMAC4 soap_get_PointerToxenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__CipherDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ds__KeyInfo))
		soap_serialize__ds__KeyInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ds__KeyInfo(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ds__KeyInfo);
	if (id < 0)
		return soap->error;
	return soap_out__ds__KeyInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTo_ds__KeyInfo(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ds__KeyInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ds__KeyInfo, sizeof(struct ds__KeyInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ds__KeyInfo);
	if (soap_out_PointerTo_ds__KeyInfo(soap, tag?tag:"ds:KeyInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTo_ds__KeyInfo(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ds__KeyInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_xenc__EncryptionMethodType))
		soap_serialize_xenc__EncryptionMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, struct xenc__EncryptionMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xenc__EncryptionMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_xenc__EncryptionMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType ** SOAP_FMAC4 soap_in_PointerToxenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct xenc__EncryptionMethodType **)soap_malloc(soap, sizeof(struct xenc__EncryptionMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xenc__EncryptionMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxenc__EncryptionMethodType);
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, tag?tag:"xenc:EncryptionMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType ** SOAP_FMAC4 soap_get_PointerToxenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxenc__EncryptionMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509IssuerSerialType))
		soap_serialize_ds__X509IssuerSerialType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, int id, struct ds__X509IssuerSerialType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509IssuerSerialType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509IssuerSerialType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_in_PointerTods__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509IssuerSerialType **)soap_malloc(soap, sizeof(struct ds__X509IssuerSerialType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509IssuerSerialType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509IssuerSerialType);
	if (soap_out_PointerTods__X509IssuerSerialType(soap, tag?tag:"ds:X509IssuerSerialType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType ** SOAP_FMAC4 soap_get_PointerTods__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RSAKeyValueType))
		soap_serialize_ds__RSAKeyValueType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__RSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__RSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RSAKeyValueType);
	if (soap_out_PointerTods__RSAKeyValueType(soap, tag?tag:"ds:RSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DSAKeyValueType))
		soap_serialize_ds__DSAKeyValueType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, int id, struct ds__DSAKeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DSAKeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DSAKeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_in_PointerTods__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DSAKeyValueType **)soap_malloc(soap, sizeof(struct ds__DSAKeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DSAKeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DSAKeyValueType);
	if (soap_out_PointerTods__DSAKeyValueType(soap, tag?tag:"ds:DSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType ** SOAP_FMAC4 soap_get_PointerTods__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformType))
		soap_serialize_ds__TransformType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformType(struct soap *soap, const char *tag, int id, struct ds__TransformType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_in_PointerTods__TransformType(struct soap *soap, const char *tag, struct ds__TransformType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformType **)soap_malloc(soap, sizeof(struct ds__TransformType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformType(struct soap *soap, struct ds__TransformType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformType);
	if (soap_out_PointerTods__TransformType(soap, tag?tag:"ds:TransformType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType ** SOAP_FMAC4 soap_get_PointerTods__TransformType(struct soap *soap, struct ds__TransformType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__DigestMethodType))
		soap_serialize_ds__DigestMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__DigestMethodType(struct soap *soap, const char *tag, int id, struct ds__DigestMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__DigestMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__DigestMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_in_PointerTods__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__DigestMethodType **)soap_malloc(soap, sizeof(struct ds__DigestMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__DigestMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__DigestMethodType);
	if (soap_out_PointerTods__DigestMethodType(soap, tag?tag:"ds:DigestMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType ** SOAP_FMAC4 soap_get_PointerTods__DigestMethodType(struct soap *soap, struct ds__DigestMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__TransformsType))
		soap_serialize_ds__TransformsType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__TransformsType(struct soap *soap, const char *tag, int id, struct ds__TransformsType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__TransformsType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__TransformsType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_in_PointerTods__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__TransformsType **)soap_malloc(soap, sizeof(struct ds__TransformsType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__TransformsType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__TransformsType);
	if (soap_out_PointerTods__TransformsType(soap, tag?tag:"ds:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType ** SOAP_FMAC4 soap_get_PointerTods__TransformsType(struct soap *soap, struct ds__TransformsType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToint(struct soap *soap, int *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToint(struct soap *soap, const char *tag, int id, int *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_int);
	if (id < 0)
		return soap->error;
	return soap_out_int(soap, tag, id, *a, type);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_in_PointerToint(struct soap *soap, const char *tag, int **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (int **)soap_malloc(soap, sizeof(int *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_int(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (int **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_int, sizeof(int), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToint(struct soap *soap, int *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToint);
	if (soap_out_PointerToint(soap, tag?tag:"int", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int ** SOAP_FMAC4 soap_get_PointerToint(struct soap *soap, int **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTods__ReferenceType))
		soap_serialize_PointerTods__ReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTods__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTods__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_in_PointerToPointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType ***)soap_malloc(soap, sizeof(struct ds__ReferenceType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTods__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTods__ReferenceType, sizeof(struct ds__ReferenceType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTods__ReferenceType);
	if (soap_out_PointerToPointerTods__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType *** SOAP_FMAC4 soap_get_PointerToPointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__ReferenceType))
		soap_serialize_ds__ReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__ReferenceType(struct soap *soap, const char *tag, int id, struct ds__ReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__ReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__ReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_in_PointerTods__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__ReferenceType **)soap_malloc(soap, sizeof(struct ds__ReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__ReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__ReferenceType);
	if (soap_out_PointerTods__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType ** SOAP_FMAC4 soap_get_PointerTods__ReferenceType(struct soap *soap, struct ds__ReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignatureMethodType))
		soap_serialize_ds__SignatureMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, int id, struct ds__SignatureMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignatureMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignatureMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_in_PointerTods__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignatureMethodType **)soap_malloc(soap, sizeof(struct ds__SignatureMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignatureMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignatureMethodType);
	if (soap_out_PointerTods__SignatureMethodType(soap, tag?tag:"ds:SignatureMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType ** SOAP_FMAC4 soap_get_PointerTods__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__CanonicalizationMethodType))
		soap_serialize_ds__CanonicalizationMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, struct ds__CanonicalizationMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__CanonicalizationMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_in_PointerTods__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__CanonicalizationMethodType **)soap_malloc(soap, sizeof(struct ds__CanonicalizationMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__CanonicalizationMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__CanonicalizationMethodType);
	if (soap_out_PointerTods__CanonicalizationMethodType(soap, tag?tag:"ds:CanonicalizationMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType ** SOAP_FMAC4 soap_get_PointerTods__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__SecurityTokenReference))
		soap_serialize__wsse__SecurityTokenReference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, struct _wsse__SecurityTokenReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__SecurityTokenReference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__SecurityTokenReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_in_PointerTo_wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__SecurityTokenReference **)soap_malloc(soap, sizeof(struct _wsse__SecurityTokenReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__SecurityTokenReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__SecurityTokenReference);
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, tag?tag:"wsse:SecurityTokenReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference ** SOAP_FMAC4 soap_get_PointerTo_wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__RetrievalMethodType))
		soap_serialize_ds__RetrievalMethodType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, int id, struct ds__RetrievalMethodType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__RetrievalMethodType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__RetrievalMethodType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_in_PointerTods__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__RetrievalMethodType **)soap_malloc(soap, sizeof(struct ds__RetrievalMethodType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__RetrievalMethodType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__RetrievalMethodType);
	if (soap_out_PointerTods__RetrievalMethodType(soap, tag?tag:"ds:RetrievalMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType ** SOAP_FMAC4 soap_get_PointerTods__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyValueType))
		soap_serialize_ds__KeyValueType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyValueType(struct soap *soap, const char *tag, int id, struct ds__KeyValueType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyValueType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyValueType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_in_PointerTods__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyValueType **)soap_malloc(soap, sizeof(struct ds__KeyValueType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyValueType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyValueType);
	if (soap_out_PointerTods__KeyValueType(soap, tag?tag:"ds:KeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType ** SOAP_FMAC4 soap_get_PointerTods__KeyValueType(struct soap *soap, struct ds__KeyValueType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__c14n__InclusiveNamespaces))
		soap_serialize__c14n__InclusiveNamespaces(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, struct _c14n__InclusiveNamespaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (id < 0)
		return soap->error;
	return soap_out__c14n__InclusiveNamespaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_in_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _c14n__InclusiveNamespaces **)soap_malloc(soap, sizeof(struct _c14n__InclusiveNamespaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__c14n__InclusiveNamespaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces);
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, tag?tag:"c14n:InclusiveNamespaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces ** SOAP_FMAC4 soap_get_PointerTo_c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__KeyInfoType))
		soap_serialize_ds__KeyInfoType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__KeyInfoType(struct soap *soap, const char *tag, int id, struct ds__KeyInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__KeyInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__KeyInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_in_PointerTods__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__KeyInfoType **)soap_malloc(soap, sizeof(struct ds__KeyInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__KeyInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__KeyInfoType);
	if (soap_out_PointerTods__KeyInfoType(soap, tag?tag:"ds:KeyInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType ** SOAP_FMAC4 soap_get_PointerTods__KeyInfoType(struct soap *soap, struct ds__KeyInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__SignedInfoType))
		soap_serialize_ds__SignedInfoType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__SignedInfoType(struct soap *soap, const char *tag, int id, struct ds__SignedInfoType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__SignedInfoType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__SignedInfoType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_in_PointerTods__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__SignedInfoType **)soap_malloc(soap, sizeof(struct ds__SignedInfoType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__SignedInfoType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__SignedInfoType);
	if (soap_out_PointerTods__SignedInfoType(soap, tag?tag:"ds:SignedInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType ** SOAP_FMAC4 soap_get_PointerTods__SignedInfoType(struct soap *soap, struct ds__SignedInfoType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_ds__X509DataType))
		soap_serialize_ds__X509DataType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTods__X509DataType(struct soap *soap, const char *tag, int id, struct ds__X509DataType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ds__X509DataType);
	if (id < 0)
		return soap->error;
	return soap_out_ds__X509DataType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_in_PointerTods__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct ds__X509DataType **)soap_malloc(soap, sizeof(struct ds__X509DataType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_ds__X509DataType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTods__X509DataType);
	if (soap_out_PointerTods__X509DataType(soap, tag?tag:"ds:X509DataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType ** SOAP_FMAC4 soap_get_PointerTods__X509DataType(struct soap *soap, struct ds__X509DataType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTods__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Embedded))
		soap_serialize__wsse__Embedded(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, int id, struct _wsse__Embedded *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Embedded);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Embedded(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_in_PointerTo_wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Embedded **)soap_malloc(soap, sizeof(struct _wsse__Embedded *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Embedded(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Embedded);
	if (soap_out_PointerTo_wsse__Embedded(soap, tag?tag:"wsse:Embedded", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded ** SOAP_FMAC4 soap_get_PointerTo_wsse__Embedded(struct soap *soap, struct _wsse__Embedded **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__KeyIdentifier))
		soap_serialize__wsse__KeyIdentifier(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, struct _wsse__KeyIdentifier *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__KeyIdentifier);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__KeyIdentifier(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_in_PointerTo_wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__KeyIdentifier **)soap_malloc(soap, sizeof(struct _wsse__KeyIdentifier *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__KeyIdentifier(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__KeyIdentifier **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__KeyIdentifier);
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, tag?tag:"wsse:KeyIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier ** SOAP_FMAC4 soap_get_PointerTo_wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Reference))
		soap_serialize__wsse__Reference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Reference(struct soap *soap, const char *tag, int id, struct _wsse__Reference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Reference);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Reference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_in_PointerTo_wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Reference **)soap_malloc(soap, sizeof(struct _wsse__Reference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Reference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Reference);
	if (soap_out_PointerTo_wsse__Reference(soap, tag?tag:"wsse:Reference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference ** SOAP_FMAC4 soap_get_PointerTo_wsse__Reference(struct soap *soap, struct _wsse__Reference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsse__Password))
		soap_serialize__wsse__Password(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsse__Password(struct soap *soap, const char *tag, int id, struct _wsse__Password *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsse__Password);
	if (id < 0)
		return soap->error;
	return soap_out__wsse__Password(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_in_PointerTo_wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsse__Password **)soap_malloc(soap, sizeof(struct _wsse__Password *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsse__Password(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsse__Password **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsse__Password);
	if (soap_out_PointerTo_wsse__Password(soap, tag?tag:"wsse:Password", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password ** SOAP_FMAC4 soap_get_PointerTo_wsse__Password(struct soap *soap, struct _wsse__Password **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{
	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{	char **p;
	p = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1);
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif
