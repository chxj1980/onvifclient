#include "soapH.h"

SOAP_FMAC3 _trt__GetAudioEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *tag, _trt__GetAudioEncoderConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioEncoderConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetAudioEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioEncoderConfigurationOptions *)soap_instantiate__trt__GetAudioEncoderConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioEncoderConfigurationOptions ** p = (_trt__GetAudioEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions, sizeof(_trt__GetAudioEncoderConfigurationOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, _trt__GetAudioEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfigurationOptions);
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurationOptions(soap, tag?tag:"trt:GetAudioEncoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, _trt__GetAudioEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, _trt__GetAudioSourceConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, _trt__GetAudioSourceConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioSourceConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, _trt__GetAudioSourceConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioSourceConfigurationOptionsResponse **)soap_malloc(soap, sizeof(_trt__GetAudioSourceConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioSourceConfigurationOptionsResponse *)soap_instantiate__trt__GetAudioSourceConfigurationOptionsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioSourceConfigurationOptionsResponse ** p = (_trt__GetAudioSourceConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse, sizeof(_trt__GetAudioSourceConfigurationOptionsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, _trt__GetAudioSourceConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(soap, tag?tag:"trt:GetAudioSourceConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioSourceConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, _trt__GetAudioSourceConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, _trt__GetAudioSourceConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, _trt__GetAudioSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, _trt__GetAudioSourceConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioSourceConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetAudioSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioSourceConfigurationOptions *)soap_instantiate__trt__GetAudioSourceConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioSourceConfigurationOptions ** p = (_trt__GetAudioSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions, sizeof(_trt__GetAudioSourceConfigurationOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, _trt__GetAudioSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourceConfigurationOptions);
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurationOptions(soap, tag?tag:"trt:GetAudioSourceConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, _trt__GetAudioSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, _trt__GetVideoEncoderConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, _trt__GetVideoEncoderConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetVideoEncoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, _trt__GetVideoEncoderConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoEncoderConfigurationOptionsResponse **)soap_malloc(soap, sizeof(_trt__GetVideoEncoderConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoEncoderConfigurationOptionsResponse *)soap_instantiate__trt__GetVideoEncoderConfigurationOptionsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetVideoEncoderConfigurationOptionsResponse ** p = (_trt__GetVideoEncoderConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse, sizeof(_trt__GetVideoEncoderConfigurationOptionsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, _trt__GetVideoEncoderConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(soap, tag?tag:"trt:GetVideoEncoderConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoEncoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, _trt__GetVideoEncoderConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, _trt__GetVideoEncoderConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, _trt__GetVideoEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetVideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, _trt__GetVideoEncoderConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoEncoderConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetVideoEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoEncoderConfigurationOptions *)soap_instantiate__trt__GetVideoEncoderConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetVideoEncoderConfigurationOptions ** p = (_trt__GetVideoEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions, sizeof(_trt__GetVideoEncoderConfigurationOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, _trt__GetVideoEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurationOptions);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, tag?tag:"trt:GetVideoEncoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, _trt__GetVideoEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, _trt__GetVideoSourceConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, _trt__GetVideoSourceConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetVideoSourceConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, _trt__GetVideoSourceConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoSourceConfigurationOptionsResponse **)soap_malloc(soap, sizeof(_trt__GetVideoSourceConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoSourceConfigurationOptionsResponse *)soap_instantiate__trt__GetVideoSourceConfigurationOptionsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetVideoSourceConfigurationOptionsResponse ** p = (_trt__GetVideoSourceConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse, sizeof(_trt__GetVideoSourceConfigurationOptionsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, _trt__GetVideoSourceConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(soap, tag?tag:"trt:GetVideoSourceConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoSourceConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, _trt__GetVideoSourceConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, _trt__GetVideoSourceConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, _trt__GetVideoSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetVideoSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, _trt__GetVideoSourceConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoSourceConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetVideoSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoSourceConfigurationOptions *)soap_instantiate__trt__GetVideoSourceConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetVideoSourceConfigurationOptions ** p = (_trt__GetVideoSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions, sizeof(_trt__GetVideoSourceConfigurationOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, _trt__GetVideoSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourceConfigurationOptions);
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurationOptions(soap, tag?tag:"trt:GetVideoSourceConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, _trt__GetVideoSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioDecoderConfigurationResponse(struct soap *soap, _trt__SetAudioDecoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__SetAudioDecoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__SetAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, _trt__SetAudioDecoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetAudioDecoderConfigurationResponse **)soap_malloc(soap, sizeof(_trt__SetAudioDecoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetAudioDecoderConfigurationResponse *)soap_instantiate__trt__SetAudioDecoderConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__SetAudioDecoderConfigurationResponse ** p = (_trt__SetAudioDecoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse, sizeof(_trt__SetAudioDecoderConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioDecoderConfigurationResponse(struct soap *soap, _trt__SetAudioDecoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioDecoderConfigurationResponse);
	if (soap_out_PointerTo_trt__SetAudioDecoderConfigurationResponse(soap, tag?tag:"trt:SetAudioDecoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioDecoderConfigurationResponse(struct soap *soap, _trt__SetAudioDecoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, _trt__SetAudioDecoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioDecoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, _trt__SetAudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioDecoderConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__SetAudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, const char *tag, _trt__SetAudioDecoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetAudioDecoderConfiguration **)soap_malloc(soap, sizeof(_trt__SetAudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetAudioDecoderConfiguration *)soap_instantiate__trt__SetAudioDecoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__SetAudioDecoderConfiguration ** p = (_trt__SetAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioDecoderConfiguration, sizeof(_trt__SetAudioDecoderConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, _trt__SetAudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioDecoderConfiguration);
	if (soap_out_PointerTo_trt__SetAudioDecoderConfiguration(soap, tag?tag:"trt:SetAudioDecoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetAudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, _trt__SetAudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioOutputConfigurationResponse(struct soap *soap, _trt__SetAudioOutputConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioOutputConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__SetAudioOutputConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioOutputConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__SetAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, _trt__SetAudioOutputConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetAudioOutputConfigurationResponse **)soap_malloc(soap, sizeof(_trt__SetAudioOutputConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetAudioOutputConfigurationResponse *)soap_instantiate__trt__SetAudioOutputConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__SetAudioOutputConfigurationResponse ** p = (_trt__SetAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioOutputConfigurationResponse, sizeof(_trt__SetAudioOutputConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioOutputConfigurationResponse(struct soap *soap, _trt__SetAudioOutputConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioOutputConfigurationResponse);
	if (soap_out_PointerTo_trt__SetAudioOutputConfigurationResponse(soap, tag?tag:"trt:SetAudioOutputConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioOutputConfigurationResponse(struct soap *soap, _trt__SetAudioOutputConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, _trt__SetAudioOutputConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioOutputConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, _trt__SetAudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioOutputConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__SetAudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, const char *tag, _trt__SetAudioOutputConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetAudioOutputConfiguration **)soap_malloc(soap, sizeof(_trt__SetAudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetAudioOutputConfiguration *)soap_instantiate__trt__SetAudioOutputConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__SetAudioOutputConfiguration ** p = (_trt__SetAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioOutputConfiguration, sizeof(_trt__SetAudioOutputConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, _trt__SetAudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioOutputConfiguration);
	if (soap_out_PointerTo_trt__SetAudioOutputConfiguration(soap, tag?tag:"trt:SetAudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetAudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, _trt__SetAudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetMetadataConfigurationResponse(struct soap *soap, _trt__SetMetadataConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetMetadataConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetMetadataConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__SetMetadataConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetMetadataConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__SetMetadataConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetMetadataConfigurationResponse(struct soap *soap, const char *tag, _trt__SetMetadataConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetMetadataConfigurationResponse **)soap_malloc(soap, sizeof(_trt__SetMetadataConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetMetadataConfigurationResponse *)soap_instantiate__trt__SetMetadataConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__SetMetadataConfigurationResponse ** p = (_trt__SetMetadataConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetMetadataConfigurationResponse, sizeof(_trt__SetMetadataConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetMetadataConfigurationResponse(struct soap *soap, _trt__SetMetadataConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetMetadataConfigurationResponse);
	if (soap_out_PointerTo_trt__SetMetadataConfigurationResponse(soap, tag?tag:"trt:SetMetadataConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetMetadataConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetMetadataConfigurationResponse(struct soap *soap, _trt__SetMetadataConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetMetadataConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, _trt__SetMetadataConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetMetadataConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, const char *tag, int id, _trt__SetMetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetMetadataConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__SetMetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, const char *tag, _trt__SetMetadataConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetMetadataConfiguration **)soap_malloc(soap, sizeof(_trt__SetMetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetMetadataConfiguration *)soap_instantiate__trt__SetMetadataConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__SetMetadataConfiguration ** p = (_trt__SetMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetMetadataConfiguration, sizeof(_trt__SetMetadataConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, _trt__SetMetadataConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetMetadataConfiguration);
	if (soap_out_PointerTo_trt__SetMetadataConfiguration(soap, tag?tag:"trt:SetMetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetMetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, _trt__SetMetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(struct soap *soap, _trt__SetVideoAnalyticsConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__SetVideoAnalyticsConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__SetVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, _trt__SetVideoAnalyticsConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetVideoAnalyticsConfigurationResponse **)soap_malloc(soap, sizeof(_trt__SetVideoAnalyticsConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetVideoAnalyticsConfigurationResponse *)soap_instantiate__trt__SetVideoAnalyticsConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__SetVideoAnalyticsConfigurationResponse ** p = (_trt__SetVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse, sizeof(_trt__SetVideoAnalyticsConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(struct soap *soap, _trt__SetVideoAnalyticsConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoAnalyticsConfigurationResponse);
	if (soap_out_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(soap, tag?tag:"trt:SetVideoAnalyticsConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(struct soap *soap, _trt__SetVideoAnalyticsConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, _trt__SetVideoAnalyticsConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoAnalyticsConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, _trt__SetVideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoAnalyticsConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__SetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, _trt__SetVideoAnalyticsConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(_trt__SetVideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetVideoAnalyticsConfiguration *)soap_instantiate__trt__SetVideoAnalyticsConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__SetVideoAnalyticsConfiguration ** p = (_trt__SetVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoAnalyticsConfiguration, sizeof(_trt__SetVideoAnalyticsConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, _trt__SetVideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoAnalyticsConfiguration);
	if (soap_out_PointerTo_trt__SetVideoAnalyticsConfiguration(soap, tag?tag:"trt:SetVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, _trt__SetVideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioEncoderConfigurationResponse(struct soap *soap, _trt__SetAudioEncoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__SetAudioEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__SetAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, _trt__SetAudioEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetAudioEncoderConfigurationResponse **)soap_malloc(soap, sizeof(_trt__SetAudioEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetAudioEncoderConfigurationResponse *)soap_instantiate__trt__SetAudioEncoderConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__SetAudioEncoderConfigurationResponse ** p = (_trt__SetAudioEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse, sizeof(_trt__SetAudioEncoderConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioEncoderConfigurationResponse(struct soap *soap, _trt__SetAudioEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__SetAudioEncoderConfigurationResponse(soap, tag?tag:"trt:SetAudioEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioEncoderConfigurationResponse(struct soap *soap, _trt__SetAudioEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, _trt__SetAudioEncoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioEncoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, _trt__SetAudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__SetAudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, const char *tag, _trt__SetAudioEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetAudioEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__SetAudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetAudioEncoderConfiguration *)soap_instantiate__trt__SetAudioEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__SetAudioEncoderConfiguration ** p = (_trt__SetAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioEncoderConfiguration, sizeof(_trt__SetAudioEncoderConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, _trt__SetAudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioEncoderConfiguration);
	if (soap_out_PointerTo_trt__SetAudioEncoderConfiguration(soap, tag?tag:"trt:SetAudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetAudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, _trt__SetAudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioSourceConfigurationResponse(struct soap *soap, _trt__SetAudioSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioSourceConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__SetAudioSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__SetAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, _trt__SetAudioSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetAudioSourceConfigurationResponse **)soap_malloc(soap, sizeof(_trt__SetAudioSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetAudioSourceConfigurationResponse *)soap_instantiate__trt__SetAudioSourceConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__SetAudioSourceConfigurationResponse ** p = (_trt__SetAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioSourceConfigurationResponse, sizeof(_trt__SetAudioSourceConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioSourceConfigurationResponse(struct soap *soap, _trt__SetAudioSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__SetAudioSourceConfigurationResponse(soap, tag?tag:"trt:SetAudioSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioSourceConfigurationResponse(struct soap *soap, _trt__SetAudioSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, _trt__SetAudioSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioSourceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, _trt__SetAudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioSourceConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__SetAudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, const char *tag, _trt__SetAudioSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetAudioSourceConfiguration **)soap_malloc(soap, sizeof(_trt__SetAudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetAudioSourceConfiguration *)soap_instantiate__trt__SetAudioSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__SetAudioSourceConfiguration ** p = (_trt__SetAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioSourceConfiguration, sizeof(_trt__SetAudioSourceConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, _trt__SetAudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioSourceConfiguration);
	if (soap_out_PointerTo_trt__SetAudioSourceConfiguration(soap, tag?tag:"trt:SetAudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetAudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, _trt__SetAudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, _trt__SetVideoEncoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__SetVideoEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__SetVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, _trt__SetVideoEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetVideoEncoderConfigurationResponse **)soap_malloc(soap, sizeof(_trt__SetVideoEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetVideoEncoderConfigurationResponse *)soap_instantiate__trt__SetVideoEncoderConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__SetVideoEncoderConfigurationResponse ** p = (_trt__SetVideoEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse, sizeof(_trt__SetVideoEncoderConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, _trt__SetVideoEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__SetVideoEncoderConfigurationResponse(soap, tag?tag:"trt:SetVideoEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, _trt__SetVideoEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, _trt__SetVideoEncoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoEncoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, _trt__SetVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__SetVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, _trt__SetVideoEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetVideoEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__SetVideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetVideoEncoderConfiguration *)soap_instantiate__trt__SetVideoEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__SetVideoEncoderConfiguration ** p = (_trt__SetVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoEncoderConfiguration, sizeof(_trt__SetVideoEncoderConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, _trt__SetVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoEncoderConfiguration);
	if (soap_out_PointerTo_trt__SetVideoEncoderConfiguration(soap, tag?tag:"trt:SetVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, _trt__SetVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoSourceConfigurationResponse(struct soap *soap, _trt__SetVideoSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoSourceConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__SetVideoSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__SetVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, _trt__SetVideoSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetVideoSourceConfigurationResponse **)soap_malloc(soap, sizeof(_trt__SetVideoSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetVideoSourceConfigurationResponse *)soap_instantiate__trt__SetVideoSourceConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__SetVideoSourceConfigurationResponse ** p = (_trt__SetVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoSourceConfigurationResponse, sizeof(_trt__SetVideoSourceConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoSourceConfigurationResponse(struct soap *soap, _trt__SetVideoSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__SetVideoSourceConfigurationResponse(soap, tag?tag:"trt:SetVideoSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoSourceConfigurationResponse(struct soap *soap, _trt__SetVideoSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, _trt__SetVideoSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoSourceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, _trt__SetVideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoSourceConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__SetVideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, const char *tag, _trt__SetVideoSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetVideoSourceConfiguration **)soap_malloc(soap, sizeof(_trt__SetVideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetVideoSourceConfiguration *)soap_instantiate__trt__SetVideoSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__SetVideoSourceConfiguration ** p = (_trt__SetVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoSourceConfiguration, sizeof(_trt__SetVideoSourceConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, _trt__SetVideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoSourceConfiguration);
	if (soap_out_PointerTo_trt__SetVideoSourceConfiguration(soap, tag?tag:"trt:SetVideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetVideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, _trt__SetVideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap *soap, _trt__GetCompatibleAudioDecoderConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap *soap, const char *tag, int id, _trt__GetCompatibleAudioDecoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetCompatibleAudioDecoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap *soap, const char *tag, _trt__GetCompatibleAudioDecoderConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleAudioDecoderConfigurationsResponse **)soap_malloc(soap, sizeof(_trt__GetCompatibleAudioDecoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleAudioDecoderConfigurationsResponse *)soap_instantiate__trt__GetCompatibleAudioDecoderConfigurationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetCompatibleAudioDecoderConfigurationsResponse ** p = (_trt__GetCompatibleAudioDecoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse, sizeof(_trt__GetCompatibleAudioDecoderConfigurationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap *soap, _trt__GetCompatibleAudioDecoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleAudioDecoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleAudioDecoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap *soap, _trt__GetCompatibleAudioDecoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, _trt__GetCompatibleAudioDecoderConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const char *tag, int id, _trt__GetCompatibleAudioDecoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetCompatibleAudioDecoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const char *tag, _trt__GetCompatibleAudioDecoderConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleAudioDecoderConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleAudioDecoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleAudioDecoderConfigurations *)soap_instantiate__trt__GetCompatibleAudioDecoderConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetCompatibleAudioDecoderConfigurations ** p = (_trt__GetCompatibleAudioDecoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations, sizeof(_trt__GetCompatibleAudioDecoderConfigurations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, _trt__GetCompatibleAudioDecoderConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioDecoderConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(soap, tag?tag:"trt:GetCompatibleAudioDecoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleAudioDecoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, _trt__GetCompatibleAudioDecoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, _trt__GetCompatibleAudioOutputConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, int id, _trt__GetCompatibleAudioOutputConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetCompatibleAudioOutputConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, _trt__GetCompatibleAudioOutputConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleAudioOutputConfigurationsResponse **)soap_malloc(soap, sizeof(_trt__GetCompatibleAudioOutputConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleAudioOutputConfigurationsResponse *)soap_instantiate__trt__GetCompatibleAudioOutputConfigurationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetCompatibleAudioOutputConfigurationsResponse ** p = (_trt__GetCompatibleAudioOutputConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse, sizeof(_trt__GetCompatibleAudioOutputConfigurationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, _trt__GetCompatibleAudioOutputConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleAudioOutputConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleAudioOutputConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, _trt__GetCompatibleAudioOutputConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, _trt__GetCompatibleAudioOutputConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const char *tag, int id, _trt__GetCompatibleAudioOutputConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetCompatibleAudioOutputConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const char *tag, _trt__GetCompatibleAudioOutputConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleAudioOutputConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleAudioOutputConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleAudioOutputConfigurations *)soap_instantiate__trt__GetCompatibleAudioOutputConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetCompatibleAudioOutputConfigurations ** p = (_trt__GetCompatibleAudioOutputConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations, sizeof(_trt__GetCompatibleAudioOutputConfigurations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, _trt__GetCompatibleAudioOutputConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioOutputConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleAudioOutputConfigurations(soap, tag?tag:"trt:GetCompatibleAudioOutputConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleAudioOutputConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, _trt__GetCompatibleAudioOutputConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioOutputConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, _trt__GetCompatibleMetadataConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, const char *tag, int id, _trt__GetCompatibleMetadataConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetCompatibleMetadataConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, const char *tag, _trt__GetCompatibleMetadataConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleMetadataConfigurationsResponse **)soap_malloc(soap, sizeof(_trt__GetCompatibleMetadataConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleMetadataConfigurationsResponse *)soap_instantiate__trt__GetCompatibleMetadataConfigurationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetCompatibleMetadataConfigurationsResponse ** p = (_trt__GetCompatibleMetadataConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse, sizeof(_trt__GetCompatibleMetadataConfigurationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, _trt__GetCompatibleMetadataConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleMetadataConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleMetadataConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, _trt__GetCompatibleMetadataConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, _trt__GetCompatibleMetadataConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, const char *tag, int id, _trt__GetCompatibleMetadataConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetCompatibleMetadataConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, const char *tag, _trt__GetCompatibleMetadataConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleMetadataConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleMetadataConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleMetadataConfigurations *)soap_instantiate__trt__GetCompatibleMetadataConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetCompatibleMetadataConfigurations ** p = (_trt__GetCompatibleMetadataConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations, sizeof(_trt__GetCompatibleMetadataConfigurations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, _trt__GetCompatibleMetadataConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleMetadataConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleMetadataConfigurations(soap, tag?tag:"trt:GetCompatibleMetadataConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleMetadataConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, _trt__GetCompatibleMetadataConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleMetadataConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, int id, _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetCompatibleVideoAnalyticsConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, _trt__GetCompatibleVideoAnalyticsConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleVideoAnalyticsConfigurationsResponse **)soap_malloc(soap, sizeof(_trt__GetCompatibleVideoAnalyticsConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleVideoAnalyticsConfigurationsResponse *)soap_instantiate__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetCompatibleVideoAnalyticsConfigurationsResponse ** p = (_trt__GetCompatibleVideoAnalyticsConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse, sizeof(_trt__GetCompatibleVideoAnalyticsConfigurationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleVideoAnalyticsConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleVideoAnalyticsConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, _trt__GetCompatibleVideoAnalyticsConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, _trt__GetCompatibleVideoAnalyticsConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const char *tag, int id, _trt__GetCompatibleVideoAnalyticsConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetCompatibleVideoAnalyticsConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const char *tag, _trt__GetCompatibleVideoAnalyticsConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleVideoAnalyticsConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleVideoAnalyticsConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleVideoAnalyticsConfigurations *)soap_instantiate__trt__GetCompatibleVideoAnalyticsConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetCompatibleVideoAnalyticsConfigurations ** p = (_trt__GetCompatibleVideoAnalyticsConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations, sizeof(_trt__GetCompatibleVideoAnalyticsConfigurations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, _trt__GetCompatibleVideoAnalyticsConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag?tag:"trt:GetCompatibleVideoAnalyticsConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleVideoAnalyticsConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, _trt__GetCompatibleVideoAnalyticsConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, _trt__GetCompatibleAudioSourceConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, _trt__GetCompatibleAudioSourceConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetCompatibleAudioSourceConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, _trt__GetCompatibleAudioSourceConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleAudioSourceConfigurationsResponse **)soap_malloc(soap, sizeof(_trt__GetCompatibleAudioSourceConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleAudioSourceConfigurationsResponse *)soap_instantiate__trt__GetCompatibleAudioSourceConfigurationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetCompatibleAudioSourceConfigurationsResponse ** p = (_trt__GetCompatibleAudioSourceConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse, sizeof(_trt__GetCompatibleAudioSourceConfigurationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, _trt__GetCompatibleAudioSourceConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleAudioSourceConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleAudioSourceConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, _trt__GetCompatibleAudioSourceConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, _trt__GetCompatibleAudioSourceConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const char *tag, int id, _trt__GetCompatibleAudioSourceConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetCompatibleAudioSourceConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const char *tag, _trt__GetCompatibleAudioSourceConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleAudioSourceConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleAudioSourceConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleAudioSourceConfigurations *)soap_instantiate__trt__GetCompatibleAudioSourceConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetCompatibleAudioSourceConfigurations ** p = (_trt__GetCompatibleAudioSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations, sizeof(_trt__GetCompatibleAudioSourceConfigurations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, _trt__GetCompatibleAudioSourceConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioSourceConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleAudioSourceConfigurations(soap, tag?tag:"trt:GetCompatibleAudioSourceConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleAudioSourceConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, _trt__GetCompatibleAudioSourceConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, _trt__GetCompatibleAudioEncoderConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, _trt__GetCompatibleAudioEncoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetCompatibleAudioEncoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, _trt__GetCompatibleAudioEncoderConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleAudioEncoderConfigurationsResponse **)soap_malloc(soap, sizeof(_trt__GetCompatibleAudioEncoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleAudioEncoderConfigurationsResponse *)soap_instantiate__trt__GetCompatibleAudioEncoderConfigurationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetCompatibleAudioEncoderConfigurationsResponse ** p = (_trt__GetCompatibleAudioEncoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse, sizeof(_trt__GetCompatibleAudioEncoderConfigurationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, _trt__GetCompatibleAudioEncoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleAudioEncoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleAudioEncoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, _trt__GetCompatibleAudioEncoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, _trt__GetCompatibleAudioEncoderConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const char *tag, int id, _trt__GetCompatibleAudioEncoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetCompatibleAudioEncoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const char *tag, _trt__GetCompatibleAudioEncoderConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleAudioEncoderConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleAudioEncoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleAudioEncoderConfigurations *)soap_instantiate__trt__GetCompatibleAudioEncoderConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetCompatibleAudioEncoderConfigurations ** p = (_trt__GetCompatibleAudioEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations, sizeof(_trt__GetCompatibleAudioEncoderConfigurations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, _trt__GetCompatibleAudioEncoderConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioEncoderConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(soap, tag?tag:"trt:GetCompatibleAudioEncoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleAudioEncoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, _trt__GetCompatibleAudioEncoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, _trt__GetCompatibleVideoSourceConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, _trt__GetCompatibleVideoSourceConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetCompatibleVideoSourceConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, _trt__GetCompatibleVideoSourceConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleVideoSourceConfigurationsResponse **)soap_malloc(soap, sizeof(_trt__GetCompatibleVideoSourceConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleVideoSourceConfigurationsResponse *)soap_instantiate__trt__GetCompatibleVideoSourceConfigurationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetCompatibleVideoSourceConfigurationsResponse ** p = (_trt__GetCompatibleVideoSourceConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse, sizeof(_trt__GetCompatibleVideoSourceConfigurationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, _trt__GetCompatibleVideoSourceConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleVideoSourceConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleVideoSourceConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, _trt__GetCompatibleVideoSourceConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, _trt__GetCompatibleVideoSourceConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const char *tag, int id, _trt__GetCompatibleVideoSourceConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetCompatibleVideoSourceConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const char *tag, _trt__GetCompatibleVideoSourceConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleVideoSourceConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleVideoSourceConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleVideoSourceConfigurations *)soap_instantiate__trt__GetCompatibleVideoSourceConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetCompatibleVideoSourceConfigurations ** p = (_trt__GetCompatibleVideoSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations, sizeof(_trt__GetCompatibleVideoSourceConfigurations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, _trt__GetCompatibleVideoSourceConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleVideoSourceConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleVideoSourceConfigurations(soap, tag?tag:"trt:GetCompatibleVideoSourceConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleVideoSourceConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, _trt__GetCompatibleVideoSourceConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, _trt__GetCompatibleVideoEncoderConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, _trt__GetCompatibleVideoEncoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetCompatibleVideoEncoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, _trt__GetCompatibleVideoEncoderConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleVideoEncoderConfigurationsResponse **)soap_malloc(soap, sizeof(_trt__GetCompatibleVideoEncoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleVideoEncoderConfigurationsResponse *)soap_instantiate__trt__GetCompatibleVideoEncoderConfigurationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetCompatibleVideoEncoderConfigurationsResponse ** p = (_trt__GetCompatibleVideoEncoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse, sizeof(_trt__GetCompatibleVideoEncoderConfigurationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, _trt__GetCompatibleVideoEncoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleVideoEncoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleVideoEncoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, _trt__GetCompatibleVideoEncoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, _trt__GetCompatibleVideoEncoderConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const char *tag, int id, _trt__GetCompatibleVideoEncoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetCompatibleVideoEncoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const char *tag, _trt__GetCompatibleVideoEncoderConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetCompatibleVideoEncoderConfigurations **)soap_malloc(soap, sizeof(_trt__GetCompatibleVideoEncoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetCompatibleVideoEncoderConfigurations *)soap_instantiate__trt__GetCompatibleVideoEncoderConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetCompatibleVideoEncoderConfigurations ** p = (_trt__GetCompatibleVideoEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations, sizeof(_trt__GetCompatibleVideoEncoderConfigurations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, _trt__GetCompatibleVideoEncoderConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleVideoEncoderConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(soap, tag?tag:"trt:GetCompatibleVideoEncoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetCompatibleVideoEncoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, _trt__GetCompatibleVideoEncoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfigurationResponse(struct soap *soap, _trt__GetAudioDecoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__GetAudioDecoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, _trt__GetAudioDecoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioDecoderConfigurationResponse **)soap_malloc(soap, sizeof(_trt__GetAudioDecoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioDecoderConfigurationResponse *)soap_instantiate__trt__GetAudioDecoderConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioDecoderConfigurationResponse ** p = (_trt__GetAudioDecoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse, sizeof(_trt__GetAudioDecoderConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfigurationResponse(struct soap *soap, _trt__GetAudioDecoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfigurationResponse);
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurationResponse(soap, tag?tag:"trt:GetAudioDecoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfigurationResponse(struct soap *soap, _trt__GetAudioDecoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, _trt__GetAudioDecoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, _trt__GetAudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, const char *tag, _trt__GetAudioDecoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioDecoderConfiguration **)soap_malloc(soap, sizeof(_trt__GetAudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioDecoderConfiguration *)soap_instantiate__trt__GetAudioDecoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioDecoderConfiguration ** p = (_trt__GetAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfiguration, sizeof(_trt__GetAudioDecoderConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, _trt__GetAudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfiguration);
	if (soap_out_PointerTo_trt__GetAudioDecoderConfiguration(soap, tag?tag:"trt:GetAudioDecoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, _trt__GetAudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfigurationResponse(struct soap *soap, _trt__GetAudioOutputConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__GetAudioOutputConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, _trt__GetAudioOutputConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioOutputConfigurationResponse **)soap_malloc(soap, sizeof(_trt__GetAudioOutputConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioOutputConfigurationResponse *)soap_instantiate__trt__GetAudioOutputConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioOutputConfigurationResponse ** p = (_trt__GetAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurationResponse, sizeof(_trt__GetAudioOutputConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfigurationResponse(struct soap *soap, _trt__GetAudioOutputConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputConfigurationResponse);
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurationResponse(soap, tag?tag:"trt:GetAudioOutputConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfigurationResponse(struct soap *soap, _trt__GetAudioOutputConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, _trt__GetAudioOutputConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, _trt__GetAudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, const char *tag, _trt__GetAudioOutputConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioOutputConfiguration **)soap_malloc(soap, sizeof(_trt__GetAudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioOutputConfiguration *)soap_instantiate__trt__GetAudioOutputConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioOutputConfiguration ** p = (_trt__GetAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfiguration, sizeof(_trt__GetAudioOutputConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, _trt__GetAudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputConfiguration);
	if (soap_out_PointerTo_trt__GetAudioOutputConfiguration(soap, tag?tag:"trt:GetAudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, _trt__GetAudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfigurationResponse(struct soap *soap, _trt__GetMetadataConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__GetMetadataConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetMetadataConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfigurationResponse(struct soap *soap, const char *tag, _trt__GetMetadataConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetMetadataConfigurationResponse **)soap_malloc(soap, sizeof(_trt__GetMetadataConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetMetadataConfigurationResponse *)soap_instantiate__trt__GetMetadataConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetMetadataConfigurationResponse ** p = (_trt__GetMetadataConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurationResponse, sizeof(_trt__GetMetadataConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfigurationResponse(struct soap *soap, _trt__GetMetadataConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetMetadataConfigurationResponse);
	if (soap_out_PointerTo_trt__GetMetadataConfigurationResponse(soap, tag?tag:"trt:GetMetadataConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetMetadataConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfigurationResponse(struct soap *soap, _trt__GetMetadataConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, _trt__GetMetadataConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, const char *tag, int id, _trt__GetMetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetMetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, const char *tag, _trt__GetMetadataConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetMetadataConfiguration **)soap_malloc(soap, sizeof(_trt__GetMetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetMetadataConfiguration *)soap_instantiate__trt__GetMetadataConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetMetadataConfiguration ** p = (_trt__GetMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfiguration, sizeof(_trt__GetMetadataConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, _trt__GetMetadataConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetMetadataConfiguration);
	if (soap_out_PointerTo_trt__GetMetadataConfiguration(soap, tag?tag:"trt:GetMetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetMetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, _trt__GetMetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, _trt__GetVideoAnalyticsConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__GetVideoAnalyticsConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, _trt__GetVideoAnalyticsConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoAnalyticsConfigurationResponse **)soap_malloc(soap, sizeof(_trt__GetVideoAnalyticsConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoAnalyticsConfigurationResponse *)soap_instantiate__trt__GetVideoAnalyticsConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetVideoAnalyticsConfigurationResponse ** p = (_trt__GetVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse, sizeof(_trt__GetVideoAnalyticsConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, _trt__GetVideoAnalyticsConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoAnalyticsConfigurationResponse);
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(soap, tag?tag:"trt:GetVideoAnalyticsConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, _trt__GetVideoAnalyticsConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, _trt__GetVideoAnalyticsConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, _trt__GetVideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, _trt__GetVideoAnalyticsConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(_trt__GetVideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoAnalyticsConfiguration *)soap_instantiate__trt__GetVideoAnalyticsConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetVideoAnalyticsConfiguration ** p = (_trt__GetVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration, sizeof(_trt__GetVideoAnalyticsConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, _trt__GetVideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoAnalyticsConfiguration);
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfiguration(soap, tag?tag:"trt:GetVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, _trt__GetVideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfigurationResponse(struct soap *soap, _trt__GetAudioEncoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__GetAudioEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, _trt__GetAudioEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioEncoderConfigurationResponse **)soap_malloc(soap, sizeof(_trt__GetAudioEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioEncoderConfigurationResponse *)soap_instantiate__trt__GetAudioEncoderConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioEncoderConfigurationResponse ** p = (_trt__GetAudioEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse, sizeof(_trt__GetAudioEncoderConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfigurationResponse(struct soap *soap, _trt__GetAudioEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurationResponse(soap, tag?tag:"trt:GetAudioEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfigurationResponse(struct soap *soap, _trt__GetAudioEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, _trt__GetAudioEncoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, _trt__GetAudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, const char *tag, _trt__GetAudioEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__GetAudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioEncoderConfiguration *)soap_instantiate__trt__GetAudioEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioEncoderConfiguration ** p = (_trt__GetAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfiguration, sizeof(_trt__GetAudioEncoderConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, _trt__GetAudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfiguration);
	if (soap_out_PointerTo_trt__GetAudioEncoderConfiguration(soap, tag?tag:"trt:GetAudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, _trt__GetAudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfigurationResponse(struct soap *soap, _trt__GetAudioSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__GetAudioSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, _trt__GetAudioSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioSourceConfigurationResponse **)soap_malloc(soap, sizeof(_trt__GetAudioSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioSourceConfigurationResponse *)soap_instantiate__trt__GetAudioSourceConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioSourceConfigurationResponse ** p = (_trt__GetAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurationResponse, sizeof(_trt__GetAudioSourceConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfigurationResponse(struct soap *soap, _trt__GetAudioSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurationResponse(soap, tag?tag:"trt:GetAudioSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfigurationResponse(struct soap *soap, _trt__GetAudioSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, _trt__GetAudioSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, _trt__GetAudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, const char *tag, _trt__GetAudioSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioSourceConfiguration **)soap_malloc(soap, sizeof(_trt__GetAudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioSourceConfiguration *)soap_instantiate__trt__GetAudioSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioSourceConfiguration ** p = (_trt__GetAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfiguration, sizeof(_trt__GetAudioSourceConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, _trt__GetAudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourceConfiguration);
	if (soap_out_PointerTo_trt__GetAudioSourceConfiguration(soap, tag?tag:"trt:GetAudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, _trt__GetAudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, _trt__GetVideoEncoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__GetVideoEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, _trt__GetVideoEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoEncoderConfigurationResponse **)soap_malloc(soap, sizeof(_trt__GetVideoEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoEncoderConfigurationResponse *)soap_instantiate__trt__GetVideoEncoderConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetVideoEncoderConfigurationResponse ** p = (_trt__GetVideoEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse, sizeof(_trt__GetVideoEncoderConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, _trt__GetVideoEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationResponse(soap, tag?tag:"trt:GetVideoEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, _trt__GetVideoEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, _trt__GetVideoEncoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, _trt__GetVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, _trt__GetVideoEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__GetVideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoEncoderConfiguration *)soap_instantiate__trt__GetVideoEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetVideoEncoderConfiguration ** p = (_trt__GetVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfiguration, sizeof(_trt__GetVideoEncoderConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, _trt__GetVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfiguration);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfiguration(soap, tag?tag:"trt:GetVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, _trt__GetVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfigurationResponse(struct soap *soap, _trt__GetVideoSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__GetVideoSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, _trt__GetVideoSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoSourceConfigurationResponse **)soap_malloc(soap, sizeof(_trt__GetVideoSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoSourceConfigurationResponse *)soap_instantiate__trt__GetVideoSourceConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetVideoSourceConfigurationResponse ** p = (_trt__GetVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurationResponse, sizeof(_trt__GetVideoSourceConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfigurationResponse(struct soap *soap, _trt__GetVideoSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurationResponse(soap, tag?tag:"trt:GetVideoSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfigurationResponse(struct soap *soap, _trt__GetVideoSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, _trt__GetVideoSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, _trt__GetVideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetVideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, const char *tag, _trt__GetVideoSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoSourceConfiguration **)soap_malloc(soap, sizeof(_trt__GetVideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoSourceConfiguration *)soap_instantiate__trt__GetVideoSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetVideoSourceConfiguration ** p = (_trt__GetVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfiguration, sizeof(_trt__GetVideoSourceConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, _trt__GetVideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourceConfiguration);
	if (soap_out_PointerTo_trt__GetVideoSourceConfiguration(soap, tag?tag:"trt:GetVideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, _trt__GetVideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, _trt__GetAudioDecoderConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, const char *tag, int id, _trt__GetAudioDecoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioDecoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, const char *tag, _trt__GetAudioDecoderConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioDecoderConfigurationsResponse **)soap_malloc(soap, sizeof(_trt__GetAudioDecoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioDecoderConfigurationsResponse *)soap_instantiate__trt__GetAudioDecoderConfigurationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioDecoderConfigurationsResponse ** p = (_trt__GetAudioDecoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse, sizeof(_trt__GetAudioDecoderConfigurationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, _trt__GetAudioDecoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurationsResponse(soap, tag?tag:"trt:GetAudioDecoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioDecoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, _trt__GetAudioDecoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, _trt__GetAudioDecoderConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, const char *tag, int id, _trt__GetAudioDecoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfigurations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioDecoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, const char *tag, _trt__GetAudioDecoderConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioDecoderConfigurations **)soap_malloc(soap, sizeof(_trt__GetAudioDecoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioDecoderConfigurations *)soap_instantiate__trt__GetAudioDecoderConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioDecoderConfigurations ** p = (_trt__GetAudioDecoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurations, sizeof(_trt__GetAudioDecoderConfigurations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, _trt__GetAudioDecoderConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfigurations);
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurations(soap, tag?tag:"trt:GetAudioDecoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioDecoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, _trt__GetAudioDecoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfigurationsResponse(struct soap *soap, _trt__GetAudioOutputConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, int id, _trt__GetAudioOutputConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioOutputConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, _trt__GetAudioOutputConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioOutputConfigurationsResponse **)soap_malloc(soap, sizeof(_trt__GetAudioOutputConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioOutputConfigurationsResponse *)soap_instantiate__trt__GetAudioOutputConfigurationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioOutputConfigurationsResponse ** p = (_trt__GetAudioOutputConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse, sizeof(_trt__GetAudioOutputConfigurationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfigurationsResponse(struct soap *soap, _trt__GetAudioOutputConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurationsResponse(soap, tag?tag:"trt:GetAudioOutputConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioOutputConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfigurationsResponse(struct soap *soap, _trt__GetAudioOutputConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, _trt__GetAudioOutputConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, const char *tag, int id, _trt__GetAudioOutputConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfigurations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioOutputConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, const char *tag, _trt__GetAudioOutputConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioOutputConfigurations **)soap_malloc(soap, sizeof(_trt__GetAudioOutputConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioOutputConfigurations *)soap_instantiate__trt__GetAudioOutputConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioOutputConfigurations ** p = (_trt__GetAudioOutputConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurations, sizeof(_trt__GetAudioOutputConfigurations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, _trt__GetAudioOutputConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputConfigurations);
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurations(soap, tag?tag:"trt:GetAudioOutputConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioOutputConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, _trt__GetAudioOutputConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfigurationsResponse(struct soap *soap, _trt__GetMetadataConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfigurationsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfigurationsResponse(struct soap *soap, const char *tag, int id, _trt__GetMetadataConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetMetadataConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfigurationsResponse(struct soap *soap, const char *tag, _trt__GetMetadataConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetMetadataConfigurationsResponse **)soap_malloc(soap, sizeof(_trt__GetMetadataConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetMetadataConfigurationsResponse *)soap_instantiate__trt__GetMetadataConfigurationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetMetadataConfigurationsResponse ** p = (_trt__GetMetadataConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurationsResponse, sizeof(_trt__GetMetadataConfigurationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfigurationsResponse(struct soap *soap, _trt__GetMetadataConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetMetadataConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetMetadataConfigurationsResponse(soap, tag?tag:"trt:GetMetadataConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetMetadataConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfigurationsResponse(struct soap *soap, _trt__GetMetadataConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, _trt__GetMetadataConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, const char *tag, int id, _trt__GetMetadataConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfigurations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetMetadataConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, const char *tag, _trt__GetMetadataConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetMetadataConfigurations **)soap_malloc(soap, sizeof(_trt__GetMetadataConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetMetadataConfigurations *)soap_instantiate__trt__GetMetadataConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetMetadataConfigurations ** p = (_trt__GetMetadataConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurations, sizeof(_trt__GetMetadataConfigurations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, _trt__GetMetadataConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetMetadataConfigurations);
	if (soap_out_PointerTo_trt__GetMetadataConfigurations(soap, tag?tag:"trt:GetMetadataConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetMetadataConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, _trt__GetMetadataConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, _trt__GetVideoAnalyticsConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, int id, _trt__GetVideoAnalyticsConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetVideoAnalyticsConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, _trt__GetVideoAnalyticsConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoAnalyticsConfigurationsResponse **)soap_malloc(soap, sizeof(_trt__GetVideoAnalyticsConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoAnalyticsConfigurationsResponse *)soap_instantiate__trt__GetVideoAnalyticsConfigurationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetVideoAnalyticsConfigurationsResponse ** p = (_trt__GetVideoAnalyticsConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse, sizeof(_trt__GetVideoAnalyticsConfigurationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, _trt__GetVideoAnalyticsConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(soap, tag?tag:"trt:GetVideoAnalyticsConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoAnalyticsConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, _trt__GetVideoAnalyticsConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, _trt__GetVideoAnalyticsConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, int id, _trt__GetVideoAnalyticsConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetVideoAnalyticsConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, _trt__GetVideoAnalyticsConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoAnalyticsConfigurations **)soap_malloc(soap, sizeof(_trt__GetVideoAnalyticsConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoAnalyticsConfigurations *)soap_instantiate__trt__GetVideoAnalyticsConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetVideoAnalyticsConfigurations ** p = (_trt__GetVideoAnalyticsConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations, sizeof(_trt__GetVideoAnalyticsConfigurations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, _trt__GetVideoAnalyticsConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoAnalyticsConfigurations);
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfigurations(soap, tag?tag:"trt:GetVideoAnalyticsConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoAnalyticsConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, _trt__GetVideoAnalyticsConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoAnalyticsConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, _trt__GetAudioEncoderConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, _trt__GetAudioEncoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioEncoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, _trt__GetAudioEncoderConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioEncoderConfigurationsResponse **)soap_malloc(soap, sizeof(_trt__GetAudioEncoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioEncoderConfigurationsResponse *)soap_instantiate__trt__GetAudioEncoderConfigurationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioEncoderConfigurationsResponse ** p = (_trt__GetAudioEncoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse, sizeof(_trt__GetAudioEncoderConfigurationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, _trt__GetAudioEncoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurationsResponse(soap, tag?tag:"trt:GetAudioEncoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioEncoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, _trt__GetAudioEncoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, _trt__GetAudioEncoderConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, const char *tag, int id, _trt__GetAudioEncoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfigurations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioEncoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, const char *tag, _trt__GetAudioEncoderConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioEncoderConfigurations **)soap_malloc(soap, sizeof(_trt__GetAudioEncoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioEncoderConfigurations *)soap_instantiate__trt__GetAudioEncoderConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioEncoderConfigurations ** p = (_trt__GetAudioEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurations, sizeof(_trt__GetAudioEncoderConfigurations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, _trt__GetAudioEncoderConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfigurations);
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurations(soap, tag?tag:"trt:GetAudioEncoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioEncoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, _trt__GetAudioEncoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfigurationsResponse(struct soap *soap, _trt__GetAudioSourceConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, _trt__GetAudioSourceConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioSourceConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, _trt__GetAudioSourceConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioSourceConfigurationsResponse **)soap_malloc(soap, sizeof(_trt__GetAudioSourceConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioSourceConfigurationsResponse *)soap_instantiate__trt__GetAudioSourceConfigurationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioSourceConfigurationsResponse ** p = (_trt__GetAudioSourceConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse, sizeof(_trt__GetAudioSourceConfigurationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfigurationsResponse(struct soap *soap, _trt__GetAudioSourceConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourceConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurationsResponse(soap, tag?tag:"trt:GetAudioSourceConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioSourceConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfigurationsResponse(struct soap *soap, _trt__GetAudioSourceConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, _trt__GetAudioSourceConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, const char *tag, int id, _trt__GetAudioSourceConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfigurations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioSourceConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, const char *tag, _trt__GetAudioSourceConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioSourceConfigurations **)soap_malloc(soap, sizeof(_trt__GetAudioSourceConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioSourceConfigurations *)soap_instantiate__trt__GetAudioSourceConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioSourceConfigurations ** p = (_trt__GetAudioSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurations, sizeof(_trt__GetAudioSourceConfigurations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, _trt__GetAudioSourceConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourceConfigurations);
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurations(soap, tag?tag:"trt:GetAudioSourceConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioSourceConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, _trt__GetAudioSourceConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, _trt__GetVideoEncoderConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, _trt__GetVideoEncoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetVideoEncoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, _trt__GetVideoEncoderConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoEncoderConfigurationsResponse **)soap_malloc(soap, sizeof(_trt__GetVideoEncoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoEncoderConfigurationsResponse *)soap_instantiate__trt__GetVideoEncoderConfigurationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetVideoEncoderConfigurationsResponse ** p = (_trt__GetVideoEncoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse, sizeof(_trt__GetVideoEncoderConfigurationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, _trt__GetVideoEncoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationsResponse(soap, tag?tag:"trt:GetVideoEncoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoEncoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, _trt__GetVideoEncoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, _trt__GetVideoEncoderConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, const char *tag, int id, _trt__GetVideoEncoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetVideoEncoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, const char *tag, _trt__GetVideoEncoderConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoEncoderConfigurations **)soap_malloc(soap, sizeof(_trt__GetVideoEncoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoEncoderConfigurations *)soap_instantiate__trt__GetVideoEncoderConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetVideoEncoderConfigurations ** p = (_trt__GetVideoEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurations, sizeof(_trt__GetVideoEncoderConfigurations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, _trt__GetVideoEncoderConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurations);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurations(soap, tag?tag:"trt:GetVideoEncoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoEncoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, _trt__GetVideoEncoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfigurationsResponse(struct soap *soap, _trt__GetVideoSourceConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, _trt__GetVideoSourceConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetVideoSourceConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, _trt__GetVideoSourceConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoSourceConfigurationsResponse **)soap_malloc(soap, sizeof(_trt__GetVideoSourceConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoSourceConfigurationsResponse *)soap_instantiate__trt__GetVideoSourceConfigurationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetVideoSourceConfigurationsResponse ** p = (_trt__GetVideoSourceConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse, sizeof(_trt__GetVideoSourceConfigurationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfigurationsResponse(struct soap *soap, _trt__GetVideoSourceConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourceConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurationsResponse(soap, tag?tag:"trt:GetVideoSourceConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoSourceConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfigurationsResponse(struct soap *soap, _trt__GetVideoSourceConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, _trt__GetVideoSourceConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, const char *tag, int id, _trt__GetVideoSourceConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfigurations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetVideoSourceConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, const char *tag, _trt__GetVideoSourceConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoSourceConfigurations **)soap_malloc(soap, sizeof(_trt__GetVideoSourceConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoSourceConfigurations *)soap_instantiate__trt__GetVideoSourceConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetVideoSourceConfigurations ** p = (_trt__GetVideoSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurations, sizeof(_trt__GetVideoSourceConfigurations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, _trt__GetVideoSourceConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourceConfigurations);
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurations(soap, tag?tag:"trt:GetVideoSourceConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoSourceConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, _trt__GetVideoSourceConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__DeleteProfileResponse(struct soap *soap, _trt__DeleteProfileResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__DeleteProfileResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__DeleteProfileResponse(struct soap *soap, const char *tag, int id, _trt__DeleteProfileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__DeleteProfileResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__DeleteProfileResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__DeleteProfileResponse(struct soap *soap, const char *tag, _trt__DeleteProfileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__DeleteProfileResponse **)soap_malloc(soap, sizeof(_trt__DeleteProfileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__DeleteProfileResponse *)soap_instantiate__trt__DeleteProfileResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__DeleteProfileResponse ** p = (_trt__DeleteProfileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__DeleteProfileResponse, sizeof(_trt__DeleteProfileResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__DeleteProfileResponse(struct soap *soap, _trt__DeleteProfileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__DeleteProfileResponse);
	if (soap_out_PointerTo_trt__DeleteProfileResponse(soap, tag?tag:"trt:DeleteProfileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__DeleteProfileResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__DeleteProfileResponse(struct soap *soap, _trt__DeleteProfileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__DeleteProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__DeleteProfile(struct soap *soap, _trt__DeleteProfile *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__DeleteProfile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__DeleteProfile(struct soap *soap, const char *tag, int id, _trt__DeleteProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__DeleteProfile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__DeleteProfile ** SOAP_FMAC4 soap_in_PointerTo_trt__DeleteProfile(struct soap *soap, const char *tag, _trt__DeleteProfile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__DeleteProfile **)soap_malloc(soap, sizeof(_trt__DeleteProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__DeleteProfile *)soap_instantiate__trt__DeleteProfile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__DeleteProfile ** p = (_trt__DeleteProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__DeleteProfile, sizeof(_trt__DeleteProfile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__DeleteProfile(struct soap *soap, _trt__DeleteProfile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__DeleteProfile);
	if (soap_out_PointerTo_trt__DeleteProfile(soap, tag?tag:"trt:DeleteProfile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__DeleteProfile ** SOAP_FMAC4 soap_get_PointerTo_trt__DeleteProfile(struct soap *soap, _trt__DeleteProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__DeleteProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, _trt__RemoveAudioDecoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__RemoveAudioDecoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__RemoveAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, _trt__RemoveAudioDecoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveAudioDecoderConfigurationResponse **)soap_malloc(soap, sizeof(_trt__RemoveAudioDecoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveAudioDecoderConfigurationResponse *)soap_instantiate__trt__RemoveAudioDecoderConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__RemoveAudioDecoderConfigurationResponse ** p = (_trt__RemoveAudioDecoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse, sizeof(_trt__RemoveAudioDecoderConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, _trt__RemoveAudioDecoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioDecoderConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(soap, tag?tag:"trt:RemoveAudioDecoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, _trt__RemoveAudioDecoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, _trt__RemoveAudioDecoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, _trt__RemoveAudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__RemoveAudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *tag, _trt__RemoveAudioDecoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveAudioDecoderConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveAudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveAudioDecoderConfiguration *)soap_instantiate__trt__RemoveAudioDecoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__RemoveAudioDecoderConfiguration ** p = (_trt__RemoveAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration, sizeof(_trt__RemoveAudioDecoderConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, _trt__RemoveAudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioDecoderConfiguration);
	if (soap_out_PointerTo_trt__RemoveAudioDecoderConfiguration(soap, tag?tag:"trt:RemoveAudioDecoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveAudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, _trt__RemoveAudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, _trt__RemoveAudioOutputConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__RemoveAudioOutputConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__RemoveAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, const char *tag, _trt__RemoveAudioOutputConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveAudioOutputConfigurationResponse **)soap_malloc(soap, sizeof(_trt__RemoveAudioOutputConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveAudioOutputConfigurationResponse *)soap_instantiate__trt__RemoveAudioOutputConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__RemoveAudioOutputConfigurationResponse ** p = (_trt__RemoveAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse, sizeof(_trt__RemoveAudioOutputConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, _trt__RemoveAudioOutputConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioOutputConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveAudioOutputConfigurationResponse(soap, tag?tag:"trt:RemoveAudioOutputConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, _trt__RemoveAudioOutputConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, _trt__RemoveAudioOutputConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioOutputConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *tag, int id, _trt__RemoveAudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioOutputConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__RemoveAudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *tag, _trt__RemoveAudioOutputConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveAudioOutputConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveAudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveAudioOutputConfiguration *)soap_instantiate__trt__RemoveAudioOutputConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__RemoveAudioOutputConfiguration ** p = (_trt__RemoveAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioOutputConfiguration, sizeof(_trt__RemoveAudioOutputConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, _trt__RemoveAudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioOutputConfiguration);
	if (soap_out_PointerTo_trt__RemoveAudioOutputConfiguration(soap, tag?tag:"trt:RemoveAudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveAudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, _trt__RemoveAudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveMetadataConfigurationResponse(struct soap *soap, _trt__RemoveMetadataConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveMetadataConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__RemoveMetadataConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__RemoveMetadataConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveMetadataConfigurationResponse(struct soap *soap, const char *tag, _trt__RemoveMetadataConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveMetadataConfigurationResponse **)soap_malloc(soap, sizeof(_trt__RemoveMetadataConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveMetadataConfigurationResponse *)soap_instantiate__trt__RemoveMetadataConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__RemoveMetadataConfigurationResponse ** p = (_trt__RemoveMetadataConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse, sizeof(_trt__RemoveMetadataConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveMetadataConfigurationResponse(struct soap *soap, _trt__RemoveMetadataConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveMetadataConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveMetadataConfigurationResponse(soap, tag?tag:"trt:RemoveMetadataConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveMetadataConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveMetadataConfigurationResponse(struct soap *soap, _trt__RemoveMetadataConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveMetadataConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, _trt__RemoveMetadataConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveMetadataConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, const char *tag, int id, _trt__RemoveMetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveMetadataConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__RemoveMetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, const char *tag, _trt__RemoveMetadataConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveMetadataConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveMetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveMetadataConfiguration *)soap_instantiate__trt__RemoveMetadataConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__RemoveMetadataConfiguration ** p = (_trt__RemoveMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveMetadataConfiguration, sizeof(_trt__RemoveMetadataConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, _trt__RemoveMetadataConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveMetadataConfiguration);
	if (soap_out_PointerTo_trt__RemoveMetadataConfiguration(soap, tag?tag:"trt:RemoveMetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveMetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, _trt__RemoveMetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, _trt__RemoveVideoAnalyticsConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__RemoveVideoAnalyticsConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__RemoveVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, _trt__RemoveVideoAnalyticsConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveVideoAnalyticsConfigurationResponse **)soap_malloc(soap, sizeof(_trt__RemoveVideoAnalyticsConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveVideoAnalyticsConfigurationResponse *)soap_instantiate__trt__RemoveVideoAnalyticsConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__RemoveVideoAnalyticsConfigurationResponse ** p = (_trt__RemoveVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse, sizeof(_trt__RemoveVideoAnalyticsConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, _trt__RemoveVideoAnalyticsConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(soap, tag?tag:"trt:RemoveVideoAnalyticsConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, _trt__RemoveVideoAnalyticsConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, _trt__RemoveVideoAnalyticsConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, _trt__RemoveVideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__RemoveVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *tag, _trt__RemoveVideoAnalyticsConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveVideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveVideoAnalyticsConfiguration *)soap_instantiate__trt__RemoveVideoAnalyticsConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__RemoveVideoAnalyticsConfiguration ** p = (_trt__RemoveVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration, sizeof(_trt__RemoveVideoAnalyticsConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, _trt__RemoveVideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveVideoAnalyticsConfiguration);
	if (soap_out_PointerTo_trt__RemoveVideoAnalyticsConfiguration(soap, tag?tag:"trt:RemoveVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, _trt__RemoveVideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemovePTZConfigurationResponse(struct soap *soap, _trt__RemovePTZConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemovePTZConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemovePTZConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__RemovePTZConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemovePTZConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__RemovePTZConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemovePTZConfigurationResponse(struct soap *soap, const char *tag, _trt__RemovePTZConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemovePTZConfigurationResponse **)soap_malloc(soap, sizeof(_trt__RemovePTZConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemovePTZConfigurationResponse *)soap_instantiate__trt__RemovePTZConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__RemovePTZConfigurationResponse ** p = (_trt__RemovePTZConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemovePTZConfigurationResponse, sizeof(_trt__RemovePTZConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemovePTZConfigurationResponse(struct soap *soap, _trt__RemovePTZConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemovePTZConfigurationResponse);
	if (soap_out_PointerTo_trt__RemovePTZConfigurationResponse(soap, tag?tag:"trt:RemovePTZConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemovePTZConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemovePTZConfigurationResponse(struct soap *soap, _trt__RemovePTZConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemovePTZConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, _trt__RemovePTZConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemovePTZConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, const char *tag, int id, _trt__RemovePTZConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemovePTZConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__RemovePTZConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, const char *tag, _trt__RemovePTZConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemovePTZConfiguration **)soap_malloc(soap, sizeof(_trt__RemovePTZConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemovePTZConfiguration *)soap_instantiate__trt__RemovePTZConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__RemovePTZConfiguration ** p = (_trt__RemovePTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemovePTZConfiguration, sizeof(_trt__RemovePTZConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, _trt__RemovePTZConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemovePTZConfiguration);
	if (soap_out_PointerTo_trt__RemovePTZConfiguration(soap, tag?tag:"trt:RemovePTZConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemovePTZConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, _trt__RemovePTZConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemovePTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, _trt__RemoveAudioSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__RemoveAudioSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__RemoveAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, const char *tag, _trt__RemoveAudioSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveAudioSourceConfigurationResponse **)soap_malloc(soap, sizeof(_trt__RemoveAudioSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveAudioSourceConfigurationResponse *)soap_instantiate__trt__RemoveAudioSourceConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__RemoveAudioSourceConfigurationResponse ** p = (_trt__RemoveAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse, sizeof(_trt__RemoveAudioSourceConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, _trt__RemoveAudioSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveAudioSourceConfigurationResponse(soap, tag?tag:"trt:RemoveAudioSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, _trt__RemoveAudioSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, _trt__RemoveAudioSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioSourceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *tag, int id, _trt__RemoveAudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioSourceConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__RemoveAudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *tag, _trt__RemoveAudioSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveAudioSourceConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveAudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveAudioSourceConfiguration *)soap_instantiate__trt__RemoveAudioSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__RemoveAudioSourceConfiguration ** p = (_trt__RemoveAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioSourceConfiguration, sizeof(_trt__RemoveAudioSourceConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, _trt__RemoveAudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioSourceConfiguration);
	if (soap_out_PointerTo_trt__RemoveAudioSourceConfiguration(soap, tag?tag:"trt:RemoveAudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveAudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, _trt__RemoveAudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, _trt__RemoveAudioEncoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__RemoveAudioEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__RemoveAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, _trt__RemoveAudioEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveAudioEncoderConfigurationResponse **)soap_malloc(soap, sizeof(_trt__RemoveAudioEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveAudioEncoderConfigurationResponse *)soap_instantiate__trt__RemoveAudioEncoderConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__RemoveAudioEncoderConfigurationResponse ** p = (_trt__RemoveAudioEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse, sizeof(_trt__RemoveAudioEncoderConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, _trt__RemoveAudioEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(soap, tag?tag:"trt:RemoveAudioEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, _trt__RemoveAudioEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, _trt__RemoveAudioEncoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, _trt__RemoveAudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__RemoveAudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *tag, _trt__RemoveAudioEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveAudioEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveAudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveAudioEncoderConfiguration *)soap_instantiate__trt__RemoveAudioEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__RemoveAudioEncoderConfiguration ** p = (_trt__RemoveAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration, sizeof(_trt__RemoveAudioEncoderConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, _trt__RemoveAudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioEncoderConfiguration);
	if (soap_out_PointerTo_trt__RemoveAudioEncoderConfiguration(soap, tag?tag:"trt:RemoveAudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveAudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, _trt__RemoveAudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, _trt__RemoveVideoSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__RemoveVideoSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__RemoveVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, const char *tag, _trt__RemoveVideoSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveVideoSourceConfigurationResponse **)soap_malloc(soap, sizeof(_trt__RemoveVideoSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveVideoSourceConfigurationResponse *)soap_instantiate__trt__RemoveVideoSourceConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__RemoveVideoSourceConfigurationResponse ** p = (_trt__RemoveVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse, sizeof(_trt__RemoveVideoSourceConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, _trt__RemoveVideoSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveVideoSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveVideoSourceConfigurationResponse(soap, tag?tag:"trt:RemoveVideoSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, _trt__RemoveVideoSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, _trt__RemoveVideoSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoSourceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *tag, int id, _trt__RemoveVideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoSourceConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__RemoveVideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *tag, _trt__RemoveVideoSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveVideoSourceConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveVideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveVideoSourceConfiguration *)soap_instantiate__trt__RemoveVideoSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__RemoveVideoSourceConfiguration ** p = (_trt__RemoveVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoSourceConfiguration, sizeof(_trt__RemoveVideoSourceConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, _trt__RemoveVideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveVideoSourceConfiguration);
	if (soap_out_PointerTo_trt__RemoveVideoSourceConfiguration(soap, tag?tag:"trt:RemoveVideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveVideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, _trt__RemoveVideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, _trt__RemoveVideoEncoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__RemoveVideoEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__RemoveVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, _trt__RemoveVideoEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveVideoEncoderConfigurationResponse **)soap_malloc(soap, sizeof(_trt__RemoveVideoEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveVideoEncoderConfigurationResponse *)soap_instantiate__trt__RemoveVideoEncoderConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__RemoveVideoEncoderConfigurationResponse ** p = (_trt__RemoveVideoEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse, sizeof(_trt__RemoveVideoEncoderConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, _trt__RemoveVideoEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveVideoEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(soap, tag?tag:"trt:RemoveVideoEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, _trt__RemoveVideoEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, _trt__RemoveVideoEncoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, _trt__RemoveVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__RemoveVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *tag, _trt__RemoveVideoEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__RemoveVideoEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__RemoveVideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__RemoveVideoEncoderConfiguration *)soap_instantiate__trt__RemoveVideoEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__RemoveVideoEncoderConfiguration ** p = (_trt__RemoveVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration, sizeof(_trt__RemoveVideoEncoderConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, _trt__RemoveVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveVideoEncoderConfiguration);
	if (soap_out_PointerTo_trt__RemoveVideoEncoderConfiguration(soap, tag?tag:"trt:RemoveVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__RemoveVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, _trt__RemoveVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioDecoderConfigurationResponse(struct soap *soap, _trt__AddAudioDecoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__AddAudioDecoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__AddAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, _trt__AddAudioDecoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddAudioDecoderConfigurationResponse **)soap_malloc(soap, sizeof(_trt__AddAudioDecoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddAudioDecoderConfigurationResponse *)soap_instantiate__trt__AddAudioDecoderConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__AddAudioDecoderConfigurationResponse ** p = (_trt__AddAudioDecoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse, sizeof(_trt__AddAudioDecoderConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioDecoderConfigurationResponse(struct soap *soap, _trt__AddAudioDecoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioDecoderConfigurationResponse);
	if (soap_out_PointerTo_trt__AddAudioDecoderConfigurationResponse(soap, tag?tag:"trt:AddAudioDecoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioDecoderConfigurationResponse(struct soap *soap, _trt__AddAudioDecoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, _trt__AddAudioDecoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioDecoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, _trt__AddAudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioDecoderConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__AddAudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, const char *tag, _trt__AddAudioDecoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddAudioDecoderConfiguration **)soap_malloc(soap, sizeof(_trt__AddAudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddAudioDecoderConfiguration *)soap_instantiate__trt__AddAudioDecoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__AddAudioDecoderConfiguration ** p = (_trt__AddAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioDecoderConfiguration, sizeof(_trt__AddAudioDecoderConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, _trt__AddAudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioDecoderConfiguration);
	if (soap_out_PointerTo_trt__AddAudioDecoderConfiguration(soap, tag?tag:"trt:AddAudioDecoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddAudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, _trt__AddAudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioOutputConfigurationResponse(struct soap *soap, _trt__AddAudioOutputConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__AddAudioOutputConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__AddAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioOutputConfigurationResponse(struct soap *soap, const char *tag, _trt__AddAudioOutputConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddAudioOutputConfigurationResponse **)soap_malloc(soap, sizeof(_trt__AddAudioOutputConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddAudioOutputConfigurationResponse *)soap_instantiate__trt__AddAudioOutputConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__AddAudioOutputConfigurationResponse ** p = (_trt__AddAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse, sizeof(_trt__AddAudioOutputConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioOutputConfigurationResponse(struct soap *soap, _trt__AddAudioOutputConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioOutputConfigurationResponse);
	if (soap_out_PointerTo_trt__AddAudioOutputConfigurationResponse(soap, tag?tag:"trt:AddAudioOutputConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioOutputConfigurationResponse(struct soap *soap, _trt__AddAudioOutputConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, _trt__AddAudioOutputConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioOutputConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, const char *tag, int id, _trt__AddAudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioOutputConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__AddAudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, const char *tag, _trt__AddAudioOutputConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddAudioOutputConfiguration **)soap_malloc(soap, sizeof(_trt__AddAudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddAudioOutputConfiguration *)soap_instantiate__trt__AddAudioOutputConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__AddAudioOutputConfiguration ** p = (_trt__AddAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioOutputConfiguration, sizeof(_trt__AddAudioOutputConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, _trt__AddAudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioOutputConfiguration);
	if (soap_out_PointerTo_trt__AddAudioOutputConfiguration(soap, tag?tag:"trt:AddAudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddAudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, _trt__AddAudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddMetadataConfigurationResponse(struct soap *soap, _trt__AddMetadataConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddMetadataConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddMetadataConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__AddMetadataConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddMetadataConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__AddMetadataConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddMetadataConfigurationResponse(struct soap *soap, const char *tag, _trt__AddMetadataConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddMetadataConfigurationResponse **)soap_malloc(soap, sizeof(_trt__AddMetadataConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddMetadataConfigurationResponse *)soap_instantiate__trt__AddMetadataConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__AddMetadataConfigurationResponse ** p = (_trt__AddMetadataConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddMetadataConfigurationResponse, sizeof(_trt__AddMetadataConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddMetadataConfigurationResponse(struct soap *soap, _trt__AddMetadataConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddMetadataConfigurationResponse);
	if (soap_out_PointerTo_trt__AddMetadataConfigurationResponse(soap, tag?tag:"trt:AddMetadataConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddMetadataConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddMetadataConfigurationResponse(struct soap *soap, _trt__AddMetadataConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddMetadataConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, _trt__AddMetadataConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddMetadataConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, const char *tag, int id, _trt__AddMetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddMetadataConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__AddMetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, const char *tag, _trt__AddMetadataConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddMetadataConfiguration **)soap_malloc(soap, sizeof(_trt__AddMetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddMetadataConfiguration *)soap_instantiate__trt__AddMetadataConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__AddMetadataConfiguration ** p = (_trt__AddMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddMetadataConfiguration, sizeof(_trt__AddMetadataConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, _trt__AddMetadataConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddMetadataConfiguration);
	if (soap_out_PointerTo_trt__AddMetadataConfiguration(soap, tag?tag:"trt:AddMetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddMetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, _trt__AddMetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, _trt__AddVideoAnalyticsConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__AddVideoAnalyticsConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__AddVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, _trt__AddVideoAnalyticsConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddVideoAnalyticsConfigurationResponse **)soap_malloc(soap, sizeof(_trt__AddVideoAnalyticsConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddVideoAnalyticsConfigurationResponse *)soap_instantiate__trt__AddVideoAnalyticsConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__AddVideoAnalyticsConfigurationResponse ** p = (_trt__AddVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse, sizeof(_trt__AddVideoAnalyticsConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, _trt__AddVideoAnalyticsConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddVideoAnalyticsConfigurationResponse);
	if (soap_out_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(soap, tag?tag:"trt:AddVideoAnalyticsConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, _trt__AddVideoAnalyticsConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, _trt__AddVideoAnalyticsConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, _trt__AddVideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__AddVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *tag, _trt__AddVideoAnalyticsConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(_trt__AddVideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddVideoAnalyticsConfiguration *)soap_instantiate__trt__AddVideoAnalyticsConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__AddVideoAnalyticsConfiguration ** p = (_trt__AddVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration, sizeof(_trt__AddVideoAnalyticsConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, _trt__AddVideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddVideoAnalyticsConfiguration);
	if (soap_out_PointerTo_trt__AddVideoAnalyticsConfiguration(soap, tag?tag:"trt:AddVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, _trt__AddVideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddPTZConfigurationResponse(struct soap *soap, _trt__AddPTZConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddPTZConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddPTZConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__AddPTZConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddPTZConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__AddPTZConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddPTZConfigurationResponse(struct soap *soap, const char *tag, _trt__AddPTZConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddPTZConfigurationResponse **)soap_malloc(soap, sizeof(_trt__AddPTZConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddPTZConfigurationResponse *)soap_instantiate__trt__AddPTZConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__AddPTZConfigurationResponse ** p = (_trt__AddPTZConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddPTZConfigurationResponse, sizeof(_trt__AddPTZConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddPTZConfigurationResponse(struct soap *soap, _trt__AddPTZConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddPTZConfigurationResponse);
	if (soap_out_PointerTo_trt__AddPTZConfigurationResponse(soap, tag?tag:"trt:AddPTZConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddPTZConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddPTZConfigurationResponse(struct soap *soap, _trt__AddPTZConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddPTZConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddPTZConfiguration(struct soap *soap, _trt__AddPTZConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddPTZConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddPTZConfiguration(struct soap *soap, const char *tag, int id, _trt__AddPTZConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddPTZConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__AddPTZConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddPTZConfiguration(struct soap *soap, const char *tag, _trt__AddPTZConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddPTZConfiguration **)soap_malloc(soap, sizeof(_trt__AddPTZConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddPTZConfiguration *)soap_instantiate__trt__AddPTZConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__AddPTZConfiguration ** p = (_trt__AddPTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddPTZConfiguration, sizeof(_trt__AddPTZConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddPTZConfiguration(struct soap *soap, _trt__AddPTZConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddPTZConfiguration);
	if (soap_out_PointerTo_trt__AddPTZConfiguration(soap, tag?tag:"trt:AddPTZConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddPTZConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddPTZConfiguration(struct soap *soap, _trt__AddPTZConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddPTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioSourceConfigurationResponse(struct soap *soap, _trt__AddAudioSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__AddAudioSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__AddAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioSourceConfigurationResponse(struct soap *soap, const char *tag, _trt__AddAudioSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddAudioSourceConfigurationResponse **)soap_malloc(soap, sizeof(_trt__AddAudioSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddAudioSourceConfigurationResponse *)soap_instantiate__trt__AddAudioSourceConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__AddAudioSourceConfigurationResponse ** p = (_trt__AddAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse, sizeof(_trt__AddAudioSourceConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioSourceConfigurationResponse(struct soap *soap, _trt__AddAudioSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__AddAudioSourceConfigurationResponse(soap, tag?tag:"trt:AddAudioSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioSourceConfigurationResponse(struct soap *soap, _trt__AddAudioSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, _trt__AddAudioSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioSourceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, const char *tag, int id, _trt__AddAudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioSourceConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__AddAudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, const char *tag, _trt__AddAudioSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddAudioSourceConfiguration **)soap_malloc(soap, sizeof(_trt__AddAudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddAudioSourceConfiguration *)soap_instantiate__trt__AddAudioSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__AddAudioSourceConfiguration ** p = (_trt__AddAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioSourceConfiguration, sizeof(_trt__AddAudioSourceConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, _trt__AddAudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioSourceConfiguration);
	if (soap_out_PointerTo_trt__AddAudioSourceConfiguration(soap, tag?tag:"trt:AddAudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddAudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, _trt__AddAudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioEncoderConfigurationResponse(struct soap *soap, _trt__AddAudioEncoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__AddAudioEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__AddAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, _trt__AddAudioEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddAudioEncoderConfigurationResponse **)soap_malloc(soap, sizeof(_trt__AddAudioEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddAudioEncoderConfigurationResponse *)soap_instantiate__trt__AddAudioEncoderConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__AddAudioEncoderConfigurationResponse ** p = (_trt__AddAudioEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse, sizeof(_trt__AddAudioEncoderConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioEncoderConfigurationResponse(struct soap *soap, _trt__AddAudioEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__AddAudioEncoderConfigurationResponse(soap, tag?tag:"trt:AddAudioEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioEncoderConfigurationResponse(struct soap *soap, _trt__AddAudioEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, _trt__AddAudioEncoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioEncoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, _trt__AddAudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__AddAudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, const char *tag, _trt__AddAudioEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddAudioEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__AddAudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddAudioEncoderConfiguration *)soap_instantiate__trt__AddAudioEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__AddAudioEncoderConfiguration ** p = (_trt__AddAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioEncoderConfiguration, sizeof(_trt__AddAudioEncoderConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, _trt__AddAudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioEncoderConfiguration);
	if (soap_out_PointerTo_trt__AddAudioEncoderConfiguration(soap, tag?tag:"trt:AddAudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddAudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, _trt__AddAudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoSourceConfigurationResponse(struct soap *soap, _trt__AddVideoSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__AddVideoSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__AddVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoSourceConfigurationResponse(struct soap *soap, const char *tag, _trt__AddVideoSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddVideoSourceConfigurationResponse **)soap_malloc(soap, sizeof(_trt__AddVideoSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddVideoSourceConfigurationResponse *)soap_instantiate__trt__AddVideoSourceConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__AddVideoSourceConfigurationResponse ** p = (_trt__AddVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse, sizeof(_trt__AddVideoSourceConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoSourceConfigurationResponse(struct soap *soap, _trt__AddVideoSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddVideoSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__AddVideoSourceConfigurationResponse(soap, tag?tag:"trt:AddVideoSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoSourceConfigurationResponse(struct soap *soap, _trt__AddVideoSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, _trt__AddVideoSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoSourceConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, const char *tag, int id, _trt__AddVideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoSourceConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__AddVideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, const char *tag, _trt__AddVideoSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddVideoSourceConfiguration **)soap_malloc(soap, sizeof(_trt__AddVideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddVideoSourceConfiguration *)soap_instantiate__trt__AddVideoSourceConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__AddVideoSourceConfiguration ** p = (_trt__AddVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoSourceConfiguration, sizeof(_trt__AddVideoSourceConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, _trt__AddVideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddVideoSourceConfiguration);
	if (soap_out_PointerTo_trt__AddVideoSourceConfiguration(soap, tag?tag:"trt:AddVideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddVideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, _trt__AddVideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoEncoderConfigurationResponse(struct soap *soap, _trt__AddVideoEncoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, _trt__AddVideoEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__AddVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, _trt__AddVideoEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddVideoEncoderConfigurationResponse **)soap_malloc(soap, sizeof(_trt__AddVideoEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddVideoEncoderConfigurationResponse *)soap_instantiate__trt__AddVideoEncoderConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__AddVideoEncoderConfigurationResponse ** p = (_trt__AddVideoEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse, sizeof(_trt__AddVideoEncoderConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoEncoderConfigurationResponse(struct soap *soap, _trt__AddVideoEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddVideoEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__AddVideoEncoderConfigurationResponse(soap, tag?tag:"trt:AddVideoEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoEncoderConfigurationResponse(struct soap *soap, _trt__AddVideoEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, _trt__AddVideoEncoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoEncoderConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, _trt__AddVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__AddVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, const char *tag, _trt__AddVideoEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__AddVideoEncoderConfiguration **)soap_malloc(soap, sizeof(_trt__AddVideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__AddVideoEncoderConfiguration *)soap_instantiate__trt__AddVideoEncoderConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__AddVideoEncoderConfiguration ** p = (_trt__AddVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoEncoderConfiguration, sizeof(_trt__AddVideoEncoderConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, _trt__AddVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddVideoEncoderConfiguration);
	if (soap_out_PointerTo_trt__AddVideoEncoderConfiguration(soap, tag?tag:"trt:AddVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__AddVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, _trt__AddVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfilesResponse(struct soap *soap, _trt__GetProfilesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfilesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfilesResponse(struct soap *soap, const char *tag, int id, _trt__GetProfilesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfilesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetProfilesResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfilesResponse(struct soap *soap, const char *tag, _trt__GetProfilesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetProfilesResponse **)soap_malloc(soap, sizeof(_trt__GetProfilesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetProfilesResponse *)soap_instantiate__trt__GetProfilesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetProfilesResponse ** p = (_trt__GetProfilesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfilesResponse, sizeof(_trt__GetProfilesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfilesResponse(struct soap *soap, _trt__GetProfilesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetProfilesResponse);
	if (soap_out_PointerTo_trt__GetProfilesResponse(soap, tag?tag:"trt:GetProfilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetProfilesResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfilesResponse(struct soap *soap, _trt__GetProfilesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfiles(struct soap *soap, _trt__GetProfiles *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfiles))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfiles(struct soap *soap, const char *tag, int id, _trt__GetProfiles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfiles);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetProfiles ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfiles(struct soap *soap, const char *tag, _trt__GetProfiles **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetProfiles **)soap_malloc(soap, sizeof(_trt__GetProfiles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetProfiles *)soap_instantiate__trt__GetProfiles(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetProfiles ** p = (_trt__GetProfiles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfiles, sizeof(_trt__GetProfiles), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfiles(struct soap *soap, _trt__GetProfiles *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetProfiles);
	if (soap_out_PointerTo_trt__GetProfiles(soap, tag?tag:"trt:GetProfiles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetProfiles ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfiles(struct soap *soap, _trt__GetProfiles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfileResponse(struct soap *soap, _trt__GetProfileResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfileResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfileResponse(struct soap *soap, const char *tag, int id, _trt__GetProfileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfileResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetProfileResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfileResponse(struct soap *soap, const char *tag, _trt__GetProfileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetProfileResponse **)soap_malloc(soap, sizeof(_trt__GetProfileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetProfileResponse *)soap_instantiate__trt__GetProfileResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetProfileResponse ** p = (_trt__GetProfileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfileResponse, sizeof(_trt__GetProfileResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfileResponse(struct soap *soap, _trt__GetProfileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetProfileResponse);
	if (soap_out_PointerTo_trt__GetProfileResponse(soap, tag?tag:"trt:GetProfileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetProfileResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfileResponse(struct soap *soap, _trt__GetProfileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfile(struct soap *soap, _trt__GetProfile *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfile(struct soap *soap, const char *tag, int id, _trt__GetProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetProfile ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfile(struct soap *soap, const char *tag, _trt__GetProfile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetProfile **)soap_malloc(soap, sizeof(_trt__GetProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetProfile *)soap_instantiate__trt__GetProfile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetProfile ** p = (_trt__GetProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfile, sizeof(_trt__GetProfile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfile(struct soap *soap, _trt__GetProfile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetProfile);
	if (soap_out_PointerTo_trt__GetProfile(soap, tag?tag:"trt:GetProfile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetProfile ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfile(struct soap *soap, _trt__GetProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__CreateProfileResponse(struct soap *soap, _trt__CreateProfileResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__CreateProfileResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__CreateProfileResponse(struct soap *soap, const char *tag, int id, _trt__CreateProfileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__CreateProfileResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__CreateProfileResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__CreateProfileResponse(struct soap *soap, const char *tag, _trt__CreateProfileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__CreateProfileResponse **)soap_malloc(soap, sizeof(_trt__CreateProfileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__CreateProfileResponse *)soap_instantiate__trt__CreateProfileResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__CreateProfileResponse ** p = (_trt__CreateProfileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__CreateProfileResponse, sizeof(_trt__CreateProfileResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__CreateProfileResponse(struct soap *soap, _trt__CreateProfileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__CreateProfileResponse);
	if (soap_out_PointerTo_trt__CreateProfileResponse(soap, tag?tag:"trt:CreateProfileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__CreateProfileResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__CreateProfileResponse(struct soap *soap, _trt__CreateProfileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__CreateProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__CreateProfile(struct soap *soap, _trt__CreateProfile *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__CreateProfile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__CreateProfile(struct soap *soap, const char *tag, int id, _trt__CreateProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__CreateProfile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__CreateProfile ** SOAP_FMAC4 soap_in_PointerTo_trt__CreateProfile(struct soap *soap, const char *tag, _trt__CreateProfile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__CreateProfile **)soap_malloc(soap, sizeof(_trt__CreateProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__CreateProfile *)soap_instantiate__trt__CreateProfile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__CreateProfile ** p = (_trt__CreateProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__CreateProfile, sizeof(_trt__CreateProfile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__CreateProfile(struct soap *soap, _trt__CreateProfile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__CreateProfile);
	if (soap_out_PointerTo_trt__CreateProfile(soap, tag?tag:"trt:CreateProfile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__CreateProfile ** SOAP_FMAC4 soap_get_PointerTo_trt__CreateProfile(struct soap *soap, _trt__CreateProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__CreateProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputsResponse(struct soap *soap, _trt__GetAudioOutputsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputsResponse(struct soap *soap, const char *tag, int id, _trt__GetAudioOutputsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioOutputsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputsResponse(struct soap *soap, const char *tag, _trt__GetAudioOutputsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioOutputsResponse **)soap_malloc(soap, sizeof(_trt__GetAudioOutputsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioOutputsResponse *)soap_instantiate__trt__GetAudioOutputsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioOutputsResponse ** p = (_trt__GetAudioOutputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputsResponse, sizeof(_trt__GetAudioOutputsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputsResponse(struct soap *soap, _trt__GetAudioOutputsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputsResponse);
	if (soap_out_PointerTo_trt__GetAudioOutputsResponse(soap, tag?tag:"trt:GetAudioOutputsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioOutputsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputsResponse(struct soap *soap, _trt__GetAudioOutputsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputs(struct soap *soap, _trt__GetAudioOutputs *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputs(struct soap *soap, const char *tag, int id, _trt__GetAudioOutputs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputs);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioOutputs ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputs(struct soap *soap, const char *tag, _trt__GetAudioOutputs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioOutputs **)soap_malloc(soap, sizeof(_trt__GetAudioOutputs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioOutputs *)soap_instantiate__trt__GetAudioOutputs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioOutputs ** p = (_trt__GetAudioOutputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputs, sizeof(_trt__GetAudioOutputs), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputs(struct soap *soap, _trt__GetAudioOutputs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputs);
	if (soap_out_PointerTo_trt__GetAudioOutputs(soap, tag?tag:"trt:GetAudioOutputs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioOutputs ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputs(struct soap *soap, _trt__GetAudioOutputs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourcesResponse(struct soap *soap, _trt__GetAudioSourcesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourcesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourcesResponse(struct soap *soap, const char *tag, int id, _trt__GetAudioSourcesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourcesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioSourcesResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourcesResponse(struct soap *soap, const char *tag, _trt__GetAudioSourcesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioSourcesResponse **)soap_malloc(soap, sizeof(_trt__GetAudioSourcesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioSourcesResponse *)soap_instantiate__trt__GetAudioSourcesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioSourcesResponse ** p = (_trt__GetAudioSourcesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourcesResponse, sizeof(_trt__GetAudioSourcesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourcesResponse(struct soap *soap, _trt__GetAudioSourcesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourcesResponse);
	if (soap_out_PointerTo_trt__GetAudioSourcesResponse(soap, tag?tag:"trt:GetAudioSourcesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioSourcesResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourcesResponse(struct soap *soap, _trt__GetAudioSourcesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourcesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSources(struct soap *soap, _trt__GetAudioSources *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSources))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSources(struct soap *soap, const char *tag, int id, _trt__GetAudioSources *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSources);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioSources ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSources(struct soap *soap, const char *tag, _trt__GetAudioSources **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioSources **)soap_malloc(soap, sizeof(_trt__GetAudioSources *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioSources *)soap_instantiate__trt__GetAudioSources(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioSources ** p = (_trt__GetAudioSources **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSources, sizeof(_trt__GetAudioSources), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSources(struct soap *soap, _trt__GetAudioSources *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSources);
	if (soap_out_PointerTo_trt__GetAudioSources(soap, tag?tag:"trt:GetAudioSources", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioSources ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSources(struct soap *soap, _trt__GetAudioSources **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSources(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourcesResponse(struct soap *soap, _trt__GetVideoSourcesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourcesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourcesResponse(struct soap *soap, const char *tag, int id, _trt__GetVideoSourcesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourcesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetVideoSourcesResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourcesResponse(struct soap *soap, const char *tag, _trt__GetVideoSourcesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoSourcesResponse **)soap_malloc(soap, sizeof(_trt__GetVideoSourcesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoSourcesResponse *)soap_instantiate__trt__GetVideoSourcesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetVideoSourcesResponse ** p = (_trt__GetVideoSourcesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourcesResponse, sizeof(_trt__GetVideoSourcesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourcesResponse(struct soap *soap, _trt__GetVideoSourcesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourcesResponse);
	if (soap_out_PointerTo_trt__GetVideoSourcesResponse(soap, tag?tag:"trt:GetVideoSourcesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoSourcesResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourcesResponse(struct soap *soap, _trt__GetVideoSourcesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourcesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSources(struct soap *soap, _trt__GetVideoSources *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSources))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSources(struct soap *soap, const char *tag, int id, _trt__GetVideoSources *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSources);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetVideoSources ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSources(struct soap *soap, const char *tag, _trt__GetVideoSources **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetVideoSources **)soap_malloc(soap, sizeof(_trt__GetVideoSources *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetVideoSources *)soap_instantiate__trt__GetVideoSources(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetVideoSources ** p = (_trt__GetVideoSources **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSources, sizeof(_trt__GetVideoSources), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSources(struct soap *soap, _trt__GetVideoSources *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSources);
	if (soap_out_PointerTo_trt__GetVideoSources(soap, tag?tag:"trt:GetVideoSources", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetVideoSources ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSources(struct soap *soap, _trt__GetVideoSources **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSources(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, _trt__GetServiceCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetServiceCapabilitiesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, _trt__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, _trt__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(_trt__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetServiceCapabilitiesResponse *)soap_instantiate__trt__GetServiceCapabilitiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetServiceCapabilitiesResponse ** p = (_trt__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetServiceCapabilitiesResponse, sizeof(_trt__GetServiceCapabilitiesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, _trt__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_trt__GetServiceCapabilitiesResponse(soap, tag?tag:"trt:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, _trt__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetServiceCapabilities(struct soap *soap, _trt__GetServiceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetServiceCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetServiceCapabilities(struct soap *soap, const char *tag, int id, _trt__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_trt__GetServiceCapabilities(struct soap *soap, const char *tag, _trt__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetServiceCapabilities **)soap_malloc(soap, sizeof(_trt__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetServiceCapabilities *)soap_instantiate__trt__GetServiceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetServiceCapabilities ** p = (_trt__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetServiceCapabilities, sizeof(_trt__GetServiceCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetServiceCapabilities(struct soap *soap, _trt__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetServiceCapabilities);
	if (soap_out_PointerTo_trt__GetServiceCapabilities(soap, tag?tag:"trt:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_trt__GetServiceCapabilities(struct soap *soap, _trt__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RemovePresetTourResponse(struct soap *soap, _tptz__RemovePresetTourResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RemovePresetTourResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RemovePresetTourResponse(struct soap *soap, const char *tag, int id, _tptz__RemovePresetTourResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RemovePresetTourResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__RemovePresetTourResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__RemovePresetTourResponse(struct soap *soap, const char *tag, _tptz__RemovePresetTourResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__RemovePresetTourResponse **)soap_malloc(soap, sizeof(_tptz__RemovePresetTourResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__RemovePresetTourResponse *)soap_instantiate__tptz__RemovePresetTourResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__RemovePresetTourResponse ** p = (_tptz__RemovePresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RemovePresetTourResponse, sizeof(_tptz__RemovePresetTourResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RemovePresetTourResponse(struct soap *soap, _tptz__RemovePresetTourResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__RemovePresetTourResponse);
	if (soap_out_PointerTo_tptz__RemovePresetTourResponse(soap, tag?tag:"tptz:RemovePresetTourResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__RemovePresetTourResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__RemovePresetTourResponse(struct soap *soap, _tptz__RemovePresetTourResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RemovePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RemovePresetTour(struct soap *soap, _tptz__RemovePresetTour *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RemovePresetTour))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RemovePresetTour(struct soap *soap, const char *tag, int id, _tptz__RemovePresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RemovePresetTour);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__RemovePresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__RemovePresetTour(struct soap *soap, const char *tag, _tptz__RemovePresetTour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__RemovePresetTour **)soap_malloc(soap, sizeof(_tptz__RemovePresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__RemovePresetTour *)soap_instantiate__tptz__RemovePresetTour(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__RemovePresetTour ** p = (_tptz__RemovePresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RemovePresetTour, sizeof(_tptz__RemovePresetTour), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RemovePresetTour(struct soap *soap, _tptz__RemovePresetTour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__RemovePresetTour);
	if (soap_out_PointerTo_tptz__RemovePresetTour(soap, tag?tag:"tptz:RemovePresetTour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__RemovePresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__RemovePresetTour(struct soap *soap, _tptz__RemovePresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RemovePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__OperatePresetTourResponse(struct soap *soap, _tptz__OperatePresetTourResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__OperatePresetTourResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__OperatePresetTourResponse(struct soap *soap, const char *tag, int id, _tptz__OperatePresetTourResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__OperatePresetTourResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__OperatePresetTourResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__OperatePresetTourResponse(struct soap *soap, const char *tag, _tptz__OperatePresetTourResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__OperatePresetTourResponse **)soap_malloc(soap, sizeof(_tptz__OperatePresetTourResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__OperatePresetTourResponse *)soap_instantiate__tptz__OperatePresetTourResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__OperatePresetTourResponse ** p = (_tptz__OperatePresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__OperatePresetTourResponse, sizeof(_tptz__OperatePresetTourResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__OperatePresetTourResponse(struct soap *soap, _tptz__OperatePresetTourResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__OperatePresetTourResponse);
	if (soap_out_PointerTo_tptz__OperatePresetTourResponse(soap, tag?tag:"tptz:OperatePresetTourResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__OperatePresetTourResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__OperatePresetTourResponse(struct soap *soap, _tptz__OperatePresetTourResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__OperatePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__OperatePresetTour(struct soap *soap, _tptz__OperatePresetTour *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__OperatePresetTour))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__OperatePresetTour(struct soap *soap, const char *tag, int id, _tptz__OperatePresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__OperatePresetTour);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__OperatePresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__OperatePresetTour(struct soap *soap, const char *tag, _tptz__OperatePresetTour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__OperatePresetTour **)soap_malloc(soap, sizeof(_tptz__OperatePresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__OperatePresetTour *)soap_instantiate__tptz__OperatePresetTour(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__OperatePresetTour ** p = (_tptz__OperatePresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__OperatePresetTour, sizeof(_tptz__OperatePresetTour), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__OperatePresetTour(struct soap *soap, _tptz__OperatePresetTour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__OperatePresetTour);
	if (soap_out_PointerTo_tptz__OperatePresetTour(soap, tag?tag:"tptz:OperatePresetTour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__OperatePresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__OperatePresetTour(struct soap *soap, _tptz__OperatePresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__OperatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__ModifyPresetTourResponse(struct soap *soap, _tptz__ModifyPresetTourResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__ModifyPresetTourResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__ModifyPresetTourResponse(struct soap *soap, const char *tag, int id, _tptz__ModifyPresetTourResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__ModifyPresetTourResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__ModifyPresetTourResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__ModifyPresetTourResponse(struct soap *soap, const char *tag, _tptz__ModifyPresetTourResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__ModifyPresetTourResponse **)soap_malloc(soap, sizeof(_tptz__ModifyPresetTourResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__ModifyPresetTourResponse *)soap_instantiate__tptz__ModifyPresetTourResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__ModifyPresetTourResponse ** p = (_tptz__ModifyPresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ModifyPresetTourResponse, sizeof(_tptz__ModifyPresetTourResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__ModifyPresetTourResponse(struct soap *soap, _tptz__ModifyPresetTourResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__ModifyPresetTourResponse);
	if (soap_out_PointerTo_tptz__ModifyPresetTourResponse(soap, tag?tag:"tptz:ModifyPresetTourResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__ModifyPresetTourResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__ModifyPresetTourResponse(struct soap *soap, _tptz__ModifyPresetTourResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__ModifyPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__ModifyPresetTour(struct soap *soap, _tptz__ModifyPresetTour *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__ModifyPresetTour))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__ModifyPresetTour(struct soap *soap, const char *tag, int id, _tptz__ModifyPresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__ModifyPresetTour);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__ModifyPresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__ModifyPresetTour(struct soap *soap, const char *tag, _tptz__ModifyPresetTour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__ModifyPresetTour **)soap_malloc(soap, sizeof(_tptz__ModifyPresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__ModifyPresetTour *)soap_instantiate__tptz__ModifyPresetTour(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__ModifyPresetTour ** p = (_tptz__ModifyPresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ModifyPresetTour, sizeof(_tptz__ModifyPresetTour), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__ModifyPresetTour(struct soap *soap, _tptz__ModifyPresetTour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__ModifyPresetTour);
	if (soap_out_PointerTo_tptz__ModifyPresetTour(soap, tag?tag:"tptz:ModifyPresetTour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__ModifyPresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__ModifyPresetTour(struct soap *soap, _tptz__ModifyPresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__ModifyPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__CreatePresetTourResponse(struct soap *soap, _tptz__CreatePresetTourResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__CreatePresetTourResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__CreatePresetTourResponse(struct soap *soap, const char *tag, int id, _tptz__CreatePresetTourResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__CreatePresetTourResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__CreatePresetTourResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__CreatePresetTourResponse(struct soap *soap, const char *tag, _tptz__CreatePresetTourResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__CreatePresetTourResponse **)soap_malloc(soap, sizeof(_tptz__CreatePresetTourResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__CreatePresetTourResponse *)soap_instantiate__tptz__CreatePresetTourResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__CreatePresetTourResponse ** p = (_tptz__CreatePresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__CreatePresetTourResponse, sizeof(_tptz__CreatePresetTourResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__CreatePresetTourResponse(struct soap *soap, _tptz__CreatePresetTourResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__CreatePresetTourResponse);
	if (soap_out_PointerTo_tptz__CreatePresetTourResponse(soap, tag?tag:"tptz:CreatePresetTourResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__CreatePresetTourResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__CreatePresetTourResponse(struct soap *soap, _tptz__CreatePresetTourResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__CreatePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__CreatePresetTour(struct soap *soap, _tptz__CreatePresetTour *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__CreatePresetTour))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__CreatePresetTour(struct soap *soap, const char *tag, int id, _tptz__CreatePresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__CreatePresetTour);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__CreatePresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__CreatePresetTour(struct soap *soap, const char *tag, _tptz__CreatePresetTour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__CreatePresetTour **)soap_malloc(soap, sizeof(_tptz__CreatePresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__CreatePresetTour *)soap_instantiate__tptz__CreatePresetTour(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__CreatePresetTour ** p = (_tptz__CreatePresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__CreatePresetTour, sizeof(_tptz__CreatePresetTour), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__CreatePresetTour(struct soap *soap, _tptz__CreatePresetTour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__CreatePresetTour);
	if (soap_out_PointerTo_tptz__CreatePresetTour(soap, tag?tag:"tptz:CreatePresetTour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__CreatePresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__CreatePresetTour(struct soap *soap, _tptz__CreatePresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__CreatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetTourOptionsResponse(struct soap *soap, _tptz__GetPresetTourOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetTourOptionsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetTourOptionsResponse(struct soap *soap, const char *tag, int id, _tptz__GetPresetTourOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetTourOptionsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetPresetTourOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetTourOptionsResponse(struct soap *soap, const char *tag, _tptz__GetPresetTourOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetPresetTourOptionsResponse **)soap_malloc(soap, sizeof(_tptz__GetPresetTourOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetPresetTourOptionsResponse *)soap_instantiate__tptz__GetPresetTourOptionsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetPresetTourOptionsResponse ** p = (_tptz__GetPresetTourOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, sizeof(_tptz__GetPresetTourOptionsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetTourOptionsResponse(struct soap *soap, _tptz__GetPresetTourOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetPresetTourOptionsResponse);
	if (soap_out_PointerTo_tptz__GetPresetTourOptionsResponse(soap, tag?tag:"tptz:GetPresetTourOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetPresetTourOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetTourOptionsResponse(struct soap *soap, _tptz__GetPresetTourOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetTourOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, _tptz__GetPresetTourOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetTourOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, const char *tag, int id, _tptz__GetPresetTourOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetTourOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetPresetTourOptions ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, const char *tag, _tptz__GetPresetTourOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetPresetTourOptions **)soap_malloc(soap, sizeof(_tptz__GetPresetTourOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetPresetTourOptions *)soap_instantiate__tptz__GetPresetTourOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetPresetTourOptions ** p = (_tptz__GetPresetTourOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTourOptions, sizeof(_tptz__GetPresetTourOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, _tptz__GetPresetTourOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetPresetTourOptions);
	if (soap_out_PointerTo_tptz__GetPresetTourOptions(soap, tag?tag:"tptz:GetPresetTourOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetPresetTourOptions ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, _tptz__GetPresetTourOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetTourOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetTourResponse(struct soap *soap, _tptz__GetPresetTourResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetTourResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetTourResponse(struct soap *soap, const char *tag, int id, _tptz__GetPresetTourResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetTourResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetPresetTourResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetTourResponse(struct soap *soap, const char *tag, _tptz__GetPresetTourResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetPresetTourResponse **)soap_malloc(soap, sizeof(_tptz__GetPresetTourResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetPresetTourResponse *)soap_instantiate__tptz__GetPresetTourResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetPresetTourResponse ** p = (_tptz__GetPresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTourResponse, sizeof(_tptz__GetPresetTourResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetTourResponse(struct soap *soap, _tptz__GetPresetTourResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetPresetTourResponse);
	if (soap_out_PointerTo_tptz__GetPresetTourResponse(soap, tag?tag:"tptz:GetPresetTourResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetPresetTourResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetTourResponse(struct soap *soap, _tptz__GetPresetTourResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetTour(struct soap *soap, _tptz__GetPresetTour *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetTour))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetTour(struct soap *soap, const char *tag, int id, _tptz__GetPresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetTour);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetPresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetTour(struct soap *soap, const char *tag, _tptz__GetPresetTour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetPresetTour **)soap_malloc(soap, sizeof(_tptz__GetPresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetPresetTour *)soap_instantiate__tptz__GetPresetTour(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetPresetTour ** p = (_tptz__GetPresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTour, sizeof(_tptz__GetPresetTour), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetTour(struct soap *soap, _tptz__GetPresetTour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetPresetTour);
	if (soap_out_PointerTo_tptz__GetPresetTour(soap, tag?tag:"tptz:GetPresetTour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetPresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetTour(struct soap *soap, _tptz__GetPresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetToursResponse(struct soap *soap, _tptz__GetPresetToursResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetToursResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetToursResponse(struct soap *soap, const char *tag, int id, _tptz__GetPresetToursResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetToursResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetPresetToursResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetToursResponse(struct soap *soap, const char *tag, _tptz__GetPresetToursResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetPresetToursResponse **)soap_malloc(soap, sizeof(_tptz__GetPresetToursResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetPresetToursResponse *)soap_instantiate__tptz__GetPresetToursResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetPresetToursResponse ** p = (_tptz__GetPresetToursResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetToursResponse, sizeof(_tptz__GetPresetToursResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetToursResponse(struct soap *soap, _tptz__GetPresetToursResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetPresetToursResponse);
	if (soap_out_PointerTo_tptz__GetPresetToursResponse(soap, tag?tag:"tptz:GetPresetToursResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetPresetToursResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetToursResponse(struct soap *soap, _tptz__GetPresetToursResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetToursResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetTours(struct soap *soap, _tptz__GetPresetTours *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetTours))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetTours(struct soap *soap, const char *tag, int id, _tptz__GetPresetTours *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetTours);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetPresetTours ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetTours(struct soap *soap, const char *tag, _tptz__GetPresetTours **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetPresetTours **)soap_malloc(soap, sizeof(_tptz__GetPresetTours *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetPresetTours *)soap_instantiate__tptz__GetPresetTours(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetPresetTours ** p = (_tptz__GetPresetTours **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTours, sizeof(_tptz__GetPresetTours), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetTours(struct soap *soap, _tptz__GetPresetTours *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetPresetTours);
	if (soap_out_PointerTo_tptz__GetPresetTours(soap, tag?tag:"tptz:GetPresetTours", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetPresetTours ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetTours(struct soap *soap, _tptz__GetPresetTours **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetTours(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__StopResponse(struct soap *soap, _tptz__StopResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__StopResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__StopResponse(struct soap *soap, const char *tag, int id, _tptz__StopResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__StopResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__StopResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__StopResponse(struct soap *soap, const char *tag, _tptz__StopResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__StopResponse **)soap_malloc(soap, sizeof(_tptz__StopResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__StopResponse *)soap_instantiate__tptz__StopResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__StopResponse ** p = (_tptz__StopResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__StopResponse, sizeof(_tptz__StopResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__StopResponse(struct soap *soap, _tptz__StopResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__StopResponse);
	if (soap_out_PointerTo_tptz__StopResponse(soap, tag?tag:"tptz:StopResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__StopResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__StopResponse(struct soap *soap, _tptz__StopResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__StopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__Stop(struct soap *soap, _tptz__Stop *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__Stop))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__Stop(struct soap *soap, const char *tag, int id, _tptz__Stop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__Stop);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__Stop ** SOAP_FMAC4 soap_in_PointerTo_tptz__Stop(struct soap *soap, const char *tag, _tptz__Stop **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__Stop **)soap_malloc(soap, sizeof(_tptz__Stop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__Stop *)soap_instantiate__tptz__Stop(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__Stop ** p = (_tptz__Stop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__Stop, sizeof(_tptz__Stop), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__Stop(struct soap *soap, _tptz__Stop *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__Stop);
	if (soap_out_PointerTo_tptz__Stop(soap, tag?tag:"tptz:Stop", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__Stop ** SOAP_FMAC4 soap_get_PointerTo_tptz__Stop(struct soap *soap, _tptz__Stop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, _tptz__AbsoluteMoveResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__AbsoluteMoveResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, const char *tag, int id, _tptz__AbsoluteMoveResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__AbsoluteMoveResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__AbsoluteMoveResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, const char *tag, _tptz__AbsoluteMoveResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__AbsoluteMoveResponse **)soap_malloc(soap, sizeof(_tptz__AbsoluteMoveResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__AbsoluteMoveResponse *)soap_instantiate__tptz__AbsoluteMoveResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__AbsoluteMoveResponse ** p = (_tptz__AbsoluteMoveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__AbsoluteMoveResponse, sizeof(_tptz__AbsoluteMoveResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, _tptz__AbsoluteMoveResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__AbsoluteMoveResponse);
	if (soap_out_PointerTo_tptz__AbsoluteMoveResponse(soap, tag?tag:"tptz:AbsoluteMoveResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__AbsoluteMoveResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, _tptz__AbsoluteMoveResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__AbsoluteMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__AbsoluteMove(struct soap *soap, _tptz__AbsoluteMove *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__AbsoluteMove))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__AbsoluteMove(struct soap *soap, const char *tag, int id, _tptz__AbsoluteMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__AbsoluteMove);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__AbsoluteMove ** SOAP_FMAC4 soap_in_PointerTo_tptz__AbsoluteMove(struct soap *soap, const char *tag, _tptz__AbsoluteMove **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__AbsoluteMove **)soap_malloc(soap, sizeof(_tptz__AbsoluteMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__AbsoluteMove *)soap_instantiate__tptz__AbsoluteMove(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__AbsoluteMove ** p = (_tptz__AbsoluteMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__AbsoluteMove, sizeof(_tptz__AbsoluteMove), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__AbsoluteMove(struct soap *soap, _tptz__AbsoluteMove *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__AbsoluteMove);
	if (soap_out_PointerTo_tptz__AbsoluteMove(soap, tag?tag:"tptz:AbsoluteMove", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__AbsoluteMove ** SOAP_FMAC4 soap_get_PointerTo_tptz__AbsoluteMove(struct soap *soap, _tptz__AbsoluteMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__AbsoluteMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, _tptz__SendAuxiliaryCommandResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, _tptz__SendAuxiliaryCommandResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__SendAuxiliaryCommandResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, _tptz__SendAuxiliaryCommandResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__SendAuxiliaryCommandResponse **)soap_malloc(soap, sizeof(_tptz__SendAuxiliaryCommandResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__SendAuxiliaryCommandResponse *)soap_instantiate__tptz__SendAuxiliaryCommandResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__SendAuxiliaryCommandResponse ** p = (_tptz__SendAuxiliaryCommandResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, sizeof(_tptz__SendAuxiliaryCommandResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, _tptz__SendAuxiliaryCommandResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SendAuxiliaryCommandResponse);
	if (soap_out_PointerTo_tptz__SendAuxiliaryCommandResponse(soap, tag?tag:"tptz:SendAuxiliaryCommandResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__SendAuxiliaryCommandResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, _tptz__SendAuxiliaryCommandResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SendAuxiliaryCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, _tptz__SendAuxiliaryCommand *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SendAuxiliaryCommand))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, _tptz__SendAuxiliaryCommand *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SendAuxiliaryCommand);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__SendAuxiliaryCommand ** SOAP_FMAC4 soap_in_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, _tptz__SendAuxiliaryCommand **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__SendAuxiliaryCommand **)soap_malloc(soap, sizeof(_tptz__SendAuxiliaryCommand *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__SendAuxiliaryCommand *)soap_instantiate__tptz__SendAuxiliaryCommand(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__SendAuxiliaryCommand ** p = (_tptz__SendAuxiliaryCommand **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SendAuxiliaryCommand, sizeof(_tptz__SendAuxiliaryCommand), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, _tptz__SendAuxiliaryCommand *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SendAuxiliaryCommand);
	if (soap_out_PointerTo_tptz__SendAuxiliaryCommand(soap, tag?tag:"tptz:SendAuxiliaryCommand", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__SendAuxiliaryCommand ** SOAP_FMAC4 soap_get_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, _tptz__SendAuxiliaryCommand **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, _tptz__RelativeMoveResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RelativeMoveResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, const char *tag, int id, _tptz__RelativeMoveResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RelativeMoveResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__RelativeMoveResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, const char *tag, _tptz__RelativeMoveResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__RelativeMoveResponse **)soap_malloc(soap, sizeof(_tptz__RelativeMoveResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__RelativeMoveResponse *)soap_instantiate__tptz__RelativeMoveResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__RelativeMoveResponse ** p = (_tptz__RelativeMoveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RelativeMoveResponse, sizeof(_tptz__RelativeMoveResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, _tptz__RelativeMoveResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__RelativeMoveResponse);
	if (soap_out_PointerTo_tptz__RelativeMoveResponse(soap, tag?tag:"tptz:RelativeMoveResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__RelativeMoveResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, _tptz__RelativeMoveResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RelativeMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RelativeMove(struct soap *soap, _tptz__RelativeMove *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RelativeMove))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RelativeMove(struct soap *soap, const char *tag, int id, _tptz__RelativeMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RelativeMove);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__RelativeMove ** SOAP_FMAC4 soap_in_PointerTo_tptz__RelativeMove(struct soap *soap, const char *tag, _tptz__RelativeMove **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__RelativeMove **)soap_malloc(soap, sizeof(_tptz__RelativeMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__RelativeMove *)soap_instantiate__tptz__RelativeMove(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__RelativeMove ** p = (_tptz__RelativeMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RelativeMove, sizeof(_tptz__RelativeMove), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RelativeMove(struct soap *soap, _tptz__RelativeMove *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__RelativeMove);
	if (soap_out_PointerTo_tptz__RelativeMove(soap, tag?tag:"tptz:RelativeMove", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__RelativeMove ** SOAP_FMAC4 soap_get_PointerTo_tptz__RelativeMove(struct soap *soap, _tptz__RelativeMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RelativeMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, _tptz__ContinuousMoveResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__ContinuousMoveResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, const char *tag, int id, _tptz__ContinuousMoveResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__ContinuousMoveResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__ContinuousMoveResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, const char *tag, _tptz__ContinuousMoveResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__ContinuousMoveResponse **)soap_malloc(soap, sizeof(_tptz__ContinuousMoveResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__ContinuousMoveResponse *)soap_instantiate__tptz__ContinuousMoveResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__ContinuousMoveResponse ** p = (_tptz__ContinuousMoveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ContinuousMoveResponse, sizeof(_tptz__ContinuousMoveResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, _tptz__ContinuousMoveResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__ContinuousMoveResponse);
	if (soap_out_PointerTo_tptz__ContinuousMoveResponse(soap, tag?tag:"tptz:ContinuousMoveResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__ContinuousMoveResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, _tptz__ContinuousMoveResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__ContinuousMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__ContinuousMove(struct soap *soap, _tptz__ContinuousMove *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__ContinuousMove))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__ContinuousMove(struct soap *soap, const char *tag, int id, _tptz__ContinuousMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__ContinuousMove);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__ContinuousMove ** SOAP_FMAC4 soap_in_PointerTo_tptz__ContinuousMove(struct soap *soap, const char *tag, _tptz__ContinuousMove **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__ContinuousMove **)soap_malloc(soap, sizeof(_tptz__ContinuousMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__ContinuousMove *)soap_instantiate__tptz__ContinuousMove(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__ContinuousMove ** p = (_tptz__ContinuousMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ContinuousMove, sizeof(_tptz__ContinuousMove), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__ContinuousMove(struct soap *soap, _tptz__ContinuousMove *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__ContinuousMove);
	if (soap_out_PointerTo_tptz__ContinuousMove(soap, tag?tag:"tptz:ContinuousMove", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__ContinuousMove ** SOAP_FMAC4 soap_get_PointerTo_tptz__ContinuousMove(struct soap *soap, _tptz__ContinuousMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__ContinuousMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, _tptz__SetHomePositionResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetHomePositionResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, const char *tag, int id, _tptz__SetHomePositionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetHomePositionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__SetHomePositionResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, const char *tag, _tptz__SetHomePositionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__SetHomePositionResponse **)soap_malloc(soap, sizeof(_tptz__SetHomePositionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__SetHomePositionResponse *)soap_instantiate__tptz__SetHomePositionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__SetHomePositionResponse ** p = (_tptz__SetHomePositionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetHomePositionResponse, sizeof(_tptz__SetHomePositionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, _tptz__SetHomePositionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SetHomePositionResponse);
	if (soap_out_PointerTo_tptz__SetHomePositionResponse(soap, tag?tag:"tptz:SetHomePositionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__SetHomePositionResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, _tptz__SetHomePositionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetHomePositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetHomePosition(struct soap *soap, _tptz__SetHomePosition *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetHomePosition))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetHomePosition(struct soap *soap, const char *tag, int id, _tptz__SetHomePosition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetHomePosition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__SetHomePosition ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetHomePosition(struct soap *soap, const char *tag, _tptz__SetHomePosition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__SetHomePosition **)soap_malloc(soap, sizeof(_tptz__SetHomePosition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__SetHomePosition *)soap_instantiate__tptz__SetHomePosition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__SetHomePosition ** p = (_tptz__SetHomePosition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetHomePosition, sizeof(_tptz__SetHomePosition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetHomePosition(struct soap *soap, _tptz__SetHomePosition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SetHomePosition);
	if (soap_out_PointerTo_tptz__SetHomePosition(soap, tag?tag:"tptz:SetHomePosition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__SetHomePosition ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetHomePosition(struct soap *soap, _tptz__SetHomePosition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, _tptz__GotoHomePositionResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GotoHomePositionResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, const char *tag, int id, _tptz__GotoHomePositionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GotoHomePositionResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GotoHomePositionResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, const char *tag, _tptz__GotoHomePositionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GotoHomePositionResponse **)soap_malloc(soap, sizeof(_tptz__GotoHomePositionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GotoHomePositionResponse *)soap_instantiate__tptz__GotoHomePositionResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GotoHomePositionResponse ** p = (_tptz__GotoHomePositionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoHomePositionResponse, sizeof(_tptz__GotoHomePositionResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, _tptz__GotoHomePositionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GotoHomePositionResponse);
	if (soap_out_PointerTo_tptz__GotoHomePositionResponse(soap, tag?tag:"tptz:GotoHomePositionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GotoHomePositionResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, _tptz__GotoHomePositionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GotoHomePositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GotoHomePosition(struct soap *soap, _tptz__GotoHomePosition *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GotoHomePosition))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GotoHomePosition(struct soap *soap, const char *tag, int id, _tptz__GotoHomePosition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GotoHomePosition);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GotoHomePosition ** SOAP_FMAC4 soap_in_PointerTo_tptz__GotoHomePosition(struct soap *soap, const char *tag, _tptz__GotoHomePosition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GotoHomePosition **)soap_malloc(soap, sizeof(_tptz__GotoHomePosition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GotoHomePosition *)soap_instantiate__tptz__GotoHomePosition(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GotoHomePosition ** p = (_tptz__GotoHomePosition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoHomePosition, sizeof(_tptz__GotoHomePosition), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GotoHomePosition(struct soap *soap, _tptz__GotoHomePosition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GotoHomePosition);
	if (soap_out_PointerTo_tptz__GotoHomePosition(soap, tag?tag:"tptz:GotoHomePosition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GotoHomePosition ** SOAP_FMAC4 soap_get_PointerTo_tptz__GotoHomePosition(struct soap *soap, _tptz__GotoHomePosition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GotoHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfigurationOptionsResponse(struct soap *soap, _tptz__GetConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfigurationOptionsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, _tptz__GetConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfigurationOptionsResponse(struct soap *soap, const char *tag, _tptz__GetConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetConfigurationOptionsResponse **)soap_malloc(soap, sizeof(_tptz__GetConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetConfigurationOptionsResponse *)soap_instantiate__tptz__GetConfigurationOptionsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetConfigurationOptionsResponse ** p = (_tptz__GetConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurationOptionsResponse, sizeof(_tptz__GetConfigurationOptionsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfigurationOptionsResponse(struct soap *soap, _tptz__GetConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetConfigurationOptionsResponse);
	if (soap_out_PointerTo_tptz__GetConfigurationOptionsResponse(soap, tag?tag:"tptz:GetConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfigurationOptionsResponse(struct soap *soap, _tptz__GetConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, _tptz__GetConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, const char *tag, int id, _tptz__GetConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfigurationOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, const char *tag, _tptz__GetConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetConfigurationOptions **)soap_malloc(soap, sizeof(_tptz__GetConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetConfigurationOptions *)soap_instantiate__tptz__GetConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetConfigurationOptions ** p = (_tptz__GetConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurationOptions, sizeof(_tptz__GetConfigurationOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, _tptz__GetConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetConfigurationOptions);
	if (soap_out_PointerTo_tptz__GetConfigurationOptions(soap, tag?tag:"tptz:GetConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, _tptz__GetConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetConfigurationResponse(struct soap *soap, _tptz__SetConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetConfigurationResponse(struct soap *soap, const char *tag, int id, _tptz__SetConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__SetConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetConfigurationResponse(struct soap *soap, const char *tag, _tptz__SetConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__SetConfigurationResponse **)soap_malloc(soap, sizeof(_tptz__SetConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__SetConfigurationResponse *)soap_instantiate__tptz__SetConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__SetConfigurationResponse ** p = (_tptz__SetConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetConfigurationResponse, sizeof(_tptz__SetConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetConfigurationResponse(struct soap *soap, _tptz__SetConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SetConfigurationResponse);
	if (soap_out_PointerTo_tptz__SetConfigurationResponse(soap, tag?tag:"tptz:SetConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__SetConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetConfigurationResponse(struct soap *soap, _tptz__SetConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetConfiguration(struct soap *soap, _tptz__SetConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetConfiguration(struct soap *soap, const char *tag, int id, _tptz__SetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__SetConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetConfiguration(struct soap *soap, const char *tag, _tptz__SetConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__SetConfiguration **)soap_malloc(soap, sizeof(_tptz__SetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__SetConfiguration *)soap_instantiate__tptz__SetConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__SetConfiguration ** p = (_tptz__SetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetConfiguration, sizeof(_tptz__SetConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetConfiguration(struct soap *soap, _tptz__SetConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SetConfiguration);
	if (soap_out_PointerTo_tptz__SetConfiguration(soap, tag?tag:"tptz:SetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__SetConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetConfiguration(struct soap *soap, _tptz__SetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetNodeResponse(struct soap *soap, _tptz__GetNodeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetNodeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetNodeResponse(struct soap *soap, const char *tag, int id, _tptz__GetNodeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetNodeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetNodeResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetNodeResponse(struct soap *soap, const char *tag, _tptz__GetNodeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetNodeResponse **)soap_malloc(soap, sizeof(_tptz__GetNodeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetNodeResponse *)soap_instantiate__tptz__GetNodeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetNodeResponse ** p = (_tptz__GetNodeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetNodeResponse, sizeof(_tptz__GetNodeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetNodeResponse(struct soap *soap, _tptz__GetNodeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetNodeResponse);
	if (soap_out_PointerTo_tptz__GetNodeResponse(soap, tag?tag:"tptz:GetNodeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetNodeResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetNodeResponse(struct soap *soap, _tptz__GetNodeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetNodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetNode(struct soap *soap, _tptz__GetNode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetNode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetNode(struct soap *soap, const char *tag, int id, _tptz__GetNode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetNode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetNode ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetNode(struct soap *soap, const char *tag, _tptz__GetNode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetNode **)soap_malloc(soap, sizeof(_tptz__GetNode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetNode *)soap_instantiate__tptz__GetNode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetNode ** p = (_tptz__GetNode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetNode, sizeof(_tptz__GetNode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetNode(struct soap *soap, _tptz__GetNode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetNode);
	if (soap_out_PointerTo_tptz__GetNode(soap, tag?tag:"tptz:GetNode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetNode ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetNode(struct soap *soap, _tptz__GetNode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetNodesResponse(struct soap *soap, _tptz__GetNodesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetNodesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetNodesResponse(struct soap *soap, const char *tag, int id, _tptz__GetNodesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetNodesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetNodesResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetNodesResponse(struct soap *soap, const char *tag, _tptz__GetNodesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetNodesResponse **)soap_malloc(soap, sizeof(_tptz__GetNodesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetNodesResponse *)soap_instantiate__tptz__GetNodesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetNodesResponse ** p = (_tptz__GetNodesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetNodesResponse, sizeof(_tptz__GetNodesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetNodesResponse(struct soap *soap, _tptz__GetNodesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetNodesResponse);
	if (soap_out_PointerTo_tptz__GetNodesResponse(soap, tag?tag:"tptz:GetNodesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetNodesResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetNodesResponse(struct soap *soap, _tptz__GetNodesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetNodesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetNodes(struct soap *soap, _tptz__GetNodes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetNodes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetNodes(struct soap *soap, const char *tag, int id, _tptz__GetNodes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetNodes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetNodes ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetNodes(struct soap *soap, const char *tag, _tptz__GetNodes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetNodes **)soap_malloc(soap, sizeof(_tptz__GetNodes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetNodes *)soap_instantiate__tptz__GetNodes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetNodes ** p = (_tptz__GetNodes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetNodes, sizeof(_tptz__GetNodes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetNodes(struct soap *soap, _tptz__GetNodes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetNodes);
	if (soap_out_PointerTo_tptz__GetNodes(soap, tag?tag:"tptz:GetNodes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetNodes ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetNodes(struct soap *soap, _tptz__GetNodes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetNodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfigurationResponse(struct soap *soap, _tptz__GetConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfigurationResponse(struct soap *soap, const char *tag, int id, _tptz__GetConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfigurationResponse(struct soap *soap, const char *tag, _tptz__GetConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetConfigurationResponse **)soap_malloc(soap, sizeof(_tptz__GetConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetConfigurationResponse *)soap_instantiate__tptz__GetConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetConfigurationResponse ** p = (_tptz__GetConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurationResponse, sizeof(_tptz__GetConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfigurationResponse(struct soap *soap, _tptz__GetConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetConfigurationResponse);
	if (soap_out_PointerTo_tptz__GetConfigurationResponse(soap, tag?tag:"tptz:GetConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfigurationResponse(struct soap *soap, _tptz__GetConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfiguration(struct soap *soap, _tptz__GetConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfiguration(struct soap *soap, const char *tag, int id, _tptz__GetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfiguration(struct soap *soap, const char *tag, _tptz__GetConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetConfiguration **)soap_malloc(soap, sizeof(_tptz__GetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetConfiguration *)soap_instantiate__tptz__GetConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetConfiguration ** p = (_tptz__GetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfiguration, sizeof(_tptz__GetConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfiguration(struct soap *soap, _tptz__GetConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetConfiguration);
	if (soap_out_PointerTo_tptz__GetConfiguration(soap, tag?tag:"tptz:GetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfiguration(struct soap *soap, _tptz__GetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetStatusResponse(struct soap *soap, _tptz__GetStatusResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetStatusResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetStatusResponse(struct soap *soap, const char *tag, int id, _tptz__GetStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetStatusResponse(struct soap *soap, const char *tag, _tptz__GetStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetStatusResponse **)soap_malloc(soap, sizeof(_tptz__GetStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetStatusResponse *)soap_instantiate__tptz__GetStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetStatusResponse ** p = (_tptz__GetStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetStatusResponse, sizeof(_tptz__GetStatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetStatusResponse(struct soap *soap, _tptz__GetStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetStatusResponse);
	if (soap_out_PointerTo_tptz__GetStatusResponse(soap, tag?tag:"tptz:GetStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetStatusResponse(struct soap *soap, _tptz__GetStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetStatus(struct soap *soap, _tptz__GetStatus *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetStatus(struct soap *soap, const char *tag, int id, _tptz__GetStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetStatus ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetStatus(struct soap *soap, const char *tag, _tptz__GetStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetStatus **)soap_malloc(soap, sizeof(_tptz__GetStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetStatus *)soap_instantiate__tptz__GetStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetStatus ** p = (_tptz__GetStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetStatus, sizeof(_tptz__GetStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetStatus(struct soap *soap, _tptz__GetStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetStatus);
	if (soap_out_PointerTo_tptz__GetStatus(soap, tag?tag:"tptz:GetStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetStatus ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetStatus(struct soap *soap, _tptz__GetStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GotoPresetResponse(struct soap *soap, _tptz__GotoPresetResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GotoPresetResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GotoPresetResponse(struct soap *soap, const char *tag, int id, _tptz__GotoPresetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GotoPresetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GotoPresetResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GotoPresetResponse(struct soap *soap, const char *tag, _tptz__GotoPresetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GotoPresetResponse **)soap_malloc(soap, sizeof(_tptz__GotoPresetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GotoPresetResponse *)soap_instantiate__tptz__GotoPresetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GotoPresetResponse ** p = (_tptz__GotoPresetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoPresetResponse, sizeof(_tptz__GotoPresetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GotoPresetResponse(struct soap *soap, _tptz__GotoPresetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GotoPresetResponse);
	if (soap_out_PointerTo_tptz__GotoPresetResponse(soap, tag?tag:"tptz:GotoPresetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GotoPresetResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GotoPresetResponse(struct soap *soap, _tptz__GotoPresetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GotoPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GotoPreset(struct soap *soap, _tptz__GotoPreset *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GotoPreset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GotoPreset(struct soap *soap, const char *tag, int id, _tptz__GotoPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GotoPreset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GotoPreset ** SOAP_FMAC4 soap_in_PointerTo_tptz__GotoPreset(struct soap *soap, const char *tag, _tptz__GotoPreset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GotoPreset **)soap_malloc(soap, sizeof(_tptz__GotoPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GotoPreset *)soap_instantiate__tptz__GotoPreset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GotoPreset ** p = (_tptz__GotoPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoPreset, sizeof(_tptz__GotoPreset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GotoPreset(struct soap *soap, _tptz__GotoPreset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GotoPreset);
	if (soap_out_PointerTo_tptz__GotoPreset(soap, tag?tag:"tptz:GotoPreset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GotoPreset ** SOAP_FMAC4 soap_get_PointerTo_tptz__GotoPreset(struct soap *soap, _tptz__GotoPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GotoPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RemovePresetResponse(struct soap *soap, _tptz__RemovePresetResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RemovePresetResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RemovePresetResponse(struct soap *soap, const char *tag, int id, _tptz__RemovePresetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RemovePresetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__RemovePresetResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__RemovePresetResponse(struct soap *soap, const char *tag, _tptz__RemovePresetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__RemovePresetResponse **)soap_malloc(soap, sizeof(_tptz__RemovePresetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__RemovePresetResponse *)soap_instantiate__tptz__RemovePresetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__RemovePresetResponse ** p = (_tptz__RemovePresetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RemovePresetResponse, sizeof(_tptz__RemovePresetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RemovePresetResponse(struct soap *soap, _tptz__RemovePresetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__RemovePresetResponse);
	if (soap_out_PointerTo_tptz__RemovePresetResponse(soap, tag?tag:"tptz:RemovePresetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__RemovePresetResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__RemovePresetResponse(struct soap *soap, _tptz__RemovePresetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RemovePresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RemovePreset(struct soap *soap, _tptz__RemovePreset *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RemovePreset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RemovePreset(struct soap *soap, const char *tag, int id, _tptz__RemovePreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RemovePreset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__RemovePreset ** SOAP_FMAC4 soap_in_PointerTo_tptz__RemovePreset(struct soap *soap, const char *tag, _tptz__RemovePreset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__RemovePreset **)soap_malloc(soap, sizeof(_tptz__RemovePreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__RemovePreset *)soap_instantiate__tptz__RemovePreset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__RemovePreset ** p = (_tptz__RemovePreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RemovePreset, sizeof(_tptz__RemovePreset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RemovePreset(struct soap *soap, _tptz__RemovePreset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__RemovePreset);
	if (soap_out_PointerTo_tptz__RemovePreset(soap, tag?tag:"tptz:RemovePreset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__RemovePreset ** SOAP_FMAC4 soap_get_PointerTo_tptz__RemovePreset(struct soap *soap, _tptz__RemovePreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RemovePreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetPresetResponse(struct soap *soap, _tptz__SetPresetResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetPresetResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetPresetResponse(struct soap *soap, const char *tag, int id, _tptz__SetPresetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetPresetResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__SetPresetResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetPresetResponse(struct soap *soap, const char *tag, _tptz__SetPresetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__SetPresetResponse **)soap_malloc(soap, sizeof(_tptz__SetPresetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__SetPresetResponse *)soap_instantiate__tptz__SetPresetResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__SetPresetResponse ** p = (_tptz__SetPresetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetPresetResponse, sizeof(_tptz__SetPresetResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetPresetResponse(struct soap *soap, _tptz__SetPresetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SetPresetResponse);
	if (soap_out_PointerTo_tptz__SetPresetResponse(soap, tag?tag:"tptz:SetPresetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__SetPresetResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetPresetResponse(struct soap *soap, _tptz__SetPresetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetPreset(struct soap *soap, _tptz__SetPreset *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetPreset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetPreset(struct soap *soap, const char *tag, int id, _tptz__SetPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetPreset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__SetPreset ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetPreset(struct soap *soap, const char *tag, _tptz__SetPreset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__SetPreset **)soap_malloc(soap, sizeof(_tptz__SetPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__SetPreset *)soap_instantiate__tptz__SetPreset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__SetPreset ** p = (_tptz__SetPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetPreset, sizeof(_tptz__SetPreset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetPreset(struct soap *soap, _tptz__SetPreset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SetPreset);
	if (soap_out_PointerTo_tptz__SetPreset(soap, tag?tag:"tptz:SetPreset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__SetPreset ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetPreset(struct soap *soap, _tptz__SetPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetsResponse(struct soap *soap, _tptz__GetPresetsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetsResponse(struct soap *soap, const char *tag, int id, _tptz__GetPresetsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetPresetsResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetsResponse(struct soap *soap, const char *tag, _tptz__GetPresetsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetPresetsResponse **)soap_malloc(soap, sizeof(_tptz__GetPresetsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetPresetsResponse *)soap_instantiate__tptz__GetPresetsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetPresetsResponse ** p = (_tptz__GetPresetsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetsResponse, sizeof(_tptz__GetPresetsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetsResponse(struct soap *soap, _tptz__GetPresetsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetPresetsResponse);
	if (soap_out_PointerTo_tptz__GetPresetsResponse(soap, tag?tag:"tptz:GetPresetsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetPresetsResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetsResponse(struct soap *soap, _tptz__GetPresetsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresets(struct soap *soap, _tptz__GetPresets *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresets))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresets(struct soap *soap, const char *tag, int id, _tptz__GetPresets *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresets);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetPresets ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresets(struct soap *soap, const char *tag, _tptz__GetPresets **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetPresets **)soap_malloc(soap, sizeof(_tptz__GetPresets *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetPresets *)soap_instantiate__tptz__GetPresets(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetPresets ** p = (_tptz__GetPresets **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresets, sizeof(_tptz__GetPresets), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresets(struct soap *soap, _tptz__GetPresets *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetPresets);
	if (soap_out_PointerTo_tptz__GetPresets(soap, tag?tag:"tptz:GetPresets", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetPresets ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresets(struct soap *soap, _tptz__GetPresets **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfigurationsResponse(struct soap *soap, _tptz__GetConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfigurationsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfigurationsResponse(struct soap *soap, const char *tag, int id, _tptz__GetConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfigurationsResponse(struct soap *soap, const char *tag, _tptz__GetConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetConfigurationsResponse **)soap_malloc(soap, sizeof(_tptz__GetConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetConfigurationsResponse *)soap_instantiate__tptz__GetConfigurationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetConfigurationsResponse ** p = (_tptz__GetConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurationsResponse, sizeof(_tptz__GetConfigurationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfigurationsResponse(struct soap *soap, _tptz__GetConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetConfigurationsResponse);
	if (soap_out_PointerTo_tptz__GetConfigurationsResponse(soap, tag?tag:"tptz:GetConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfigurationsResponse(struct soap *soap, _tptz__GetConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfigurations(struct soap *soap, _tptz__GetConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfigurations(struct soap *soap, const char *tag, int id, _tptz__GetConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfigurations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetConfigurations ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfigurations(struct soap *soap, const char *tag, _tptz__GetConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetConfigurations **)soap_malloc(soap, sizeof(_tptz__GetConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetConfigurations *)soap_instantiate__tptz__GetConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetConfigurations ** p = (_tptz__GetConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurations, sizeof(_tptz__GetConfigurations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfigurations(struct soap *soap, _tptz__GetConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetConfigurations);
	if (soap_out_PointerTo_tptz__GetConfigurations(soap, tag?tag:"tptz:GetConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetConfigurations ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfigurations(struct soap *soap, _tptz__GetConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetServiceCapabilitiesResponse(struct soap *soap, _tptz__GetServiceCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, _tptz__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, _tptz__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(_tptz__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetServiceCapabilitiesResponse *)soap_instantiate__tptz__GetServiceCapabilitiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetServiceCapabilitiesResponse ** p = (_tptz__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse, sizeof(_tptz__GetServiceCapabilitiesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetServiceCapabilitiesResponse(struct soap *soap, _tptz__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_tptz__GetServiceCapabilitiesResponse(soap, tag?tag:"tptz:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetServiceCapabilitiesResponse(struct soap *soap, _tptz__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, _tptz__GetServiceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetServiceCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, const char *tag, int id, _tptz__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tptz__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, const char *tag, _tptz__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tptz__GetServiceCapabilities **)soap_malloc(soap, sizeof(_tptz__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tptz__GetServiceCapabilities *)soap_instantiate__tptz__GetServiceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tptz__GetServiceCapabilities ** p = (_tptz__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetServiceCapabilities, sizeof(_tptz__GetServiceCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, _tptz__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetServiceCapabilities);
	if (soap_out_PointerTo_tptz__GetServiceCapabilities(soap, tag?tag:"tptz:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tptz__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, _tptz__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetMoveOptionsResponse(struct soap *soap, _timg__GetMoveOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetMoveOptionsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetMoveOptionsResponse(struct soap *soap, const char *tag, int id, _timg__GetMoveOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetMoveOptionsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _timg__GetMoveOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__GetMoveOptionsResponse(struct soap *soap, const char *tag, _timg__GetMoveOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetMoveOptionsResponse **)soap_malloc(soap, sizeof(_timg__GetMoveOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetMoveOptionsResponse *)soap_instantiate__timg__GetMoveOptionsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_timg__GetMoveOptionsResponse ** p = (_timg__GetMoveOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetMoveOptionsResponse, sizeof(_timg__GetMoveOptionsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetMoveOptionsResponse(struct soap *soap, _timg__GetMoveOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetMoveOptionsResponse);
	if (soap_out_PointerTo_timg__GetMoveOptionsResponse(soap, tag?tag:"timg:GetMoveOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetMoveOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__GetMoveOptionsResponse(struct soap *soap, _timg__GetMoveOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetMoveOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetMoveOptions(struct soap *soap, _timg__GetMoveOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetMoveOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetMoveOptions(struct soap *soap, const char *tag, int id, _timg__GetMoveOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetMoveOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _timg__GetMoveOptions ** SOAP_FMAC4 soap_in_PointerTo_timg__GetMoveOptions(struct soap *soap, const char *tag, _timg__GetMoveOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetMoveOptions **)soap_malloc(soap, sizeof(_timg__GetMoveOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetMoveOptions *)soap_instantiate__timg__GetMoveOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_timg__GetMoveOptions ** p = (_timg__GetMoveOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetMoveOptions, sizeof(_timg__GetMoveOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetMoveOptions(struct soap *soap, _timg__GetMoveOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetMoveOptions);
	if (soap_out_PointerTo_timg__GetMoveOptions(soap, tag?tag:"timg:GetMoveOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetMoveOptions ** SOAP_FMAC4 soap_get_PointerTo_timg__GetMoveOptions(struct soap *soap, _timg__GetMoveOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetMoveOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetStatusResponse(struct soap *soap, _timg__GetStatusResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetStatusResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetStatusResponse(struct soap *soap, const char *tag, int id, _timg__GetStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _timg__GetStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__GetStatusResponse(struct soap *soap, const char *tag, _timg__GetStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetStatusResponse **)soap_malloc(soap, sizeof(_timg__GetStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetStatusResponse *)soap_instantiate__timg__GetStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_timg__GetStatusResponse ** p = (_timg__GetStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetStatusResponse, sizeof(_timg__GetStatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetStatusResponse(struct soap *soap, _timg__GetStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetStatusResponse);
	if (soap_out_PointerTo_timg__GetStatusResponse(soap, tag?tag:"timg:GetStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__GetStatusResponse(struct soap *soap, _timg__GetStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetStatus(struct soap *soap, _timg__GetStatus *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetStatus(struct soap *soap, const char *tag, int id, _timg__GetStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _timg__GetStatus ** SOAP_FMAC4 soap_in_PointerTo_timg__GetStatus(struct soap *soap, const char *tag, _timg__GetStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetStatus **)soap_malloc(soap, sizeof(_timg__GetStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetStatus *)soap_instantiate__timg__GetStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_timg__GetStatus ** p = (_timg__GetStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetStatus, sizeof(_timg__GetStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetStatus(struct soap *soap, _timg__GetStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetStatus);
	if (soap_out_PointerTo_timg__GetStatus(soap, tag?tag:"timg:GetStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetStatus ** SOAP_FMAC4 soap_get_PointerTo_timg__GetStatus(struct soap *soap, _timg__GetStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__StopResponse(struct soap *soap, _timg__StopResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__StopResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__StopResponse(struct soap *soap, const char *tag, int id, _timg__StopResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__StopResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _timg__StopResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__StopResponse(struct soap *soap, const char *tag, _timg__StopResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__StopResponse **)soap_malloc(soap, sizeof(_timg__StopResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__StopResponse *)soap_instantiate__timg__StopResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_timg__StopResponse ** p = (_timg__StopResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__StopResponse, sizeof(_timg__StopResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__StopResponse(struct soap *soap, _timg__StopResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__StopResponse);
	if (soap_out_PointerTo_timg__StopResponse(soap, tag?tag:"timg:StopResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__StopResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__StopResponse(struct soap *soap, _timg__StopResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__StopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__Stop(struct soap *soap, _timg__Stop *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__Stop))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__Stop(struct soap *soap, const char *tag, int id, _timg__Stop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__Stop);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _timg__Stop ** SOAP_FMAC4 soap_in_PointerTo_timg__Stop(struct soap *soap, const char *tag, _timg__Stop **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__Stop **)soap_malloc(soap, sizeof(_timg__Stop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__Stop *)soap_instantiate__timg__Stop(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_timg__Stop ** p = (_timg__Stop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__Stop, sizeof(_timg__Stop), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__Stop(struct soap *soap, _timg__Stop *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__Stop);
	if (soap_out_PointerTo_timg__Stop(soap, tag?tag:"timg:Stop", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__Stop ** SOAP_FMAC4 soap_get_PointerTo_timg__Stop(struct soap *soap, _timg__Stop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__MoveResponse(struct soap *soap, _timg__MoveResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__MoveResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__MoveResponse(struct soap *soap, const char *tag, int id, _timg__MoveResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__MoveResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _timg__MoveResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__MoveResponse(struct soap *soap, const char *tag, _timg__MoveResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__MoveResponse **)soap_malloc(soap, sizeof(_timg__MoveResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__MoveResponse *)soap_instantiate__timg__MoveResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_timg__MoveResponse ** p = (_timg__MoveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__MoveResponse, sizeof(_timg__MoveResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__MoveResponse(struct soap *soap, _timg__MoveResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__MoveResponse);
	if (soap_out_PointerTo_timg__MoveResponse(soap, tag?tag:"timg:MoveResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__MoveResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__MoveResponse(struct soap *soap, _timg__MoveResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__MoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__Move(struct soap *soap, _timg__Move *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__Move))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__Move(struct soap *soap, const char *tag, int id, _timg__Move *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__Move);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _timg__Move ** SOAP_FMAC4 soap_in_PointerTo_timg__Move(struct soap *soap, const char *tag, _timg__Move **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__Move **)soap_malloc(soap, sizeof(_timg__Move *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__Move *)soap_instantiate__timg__Move(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_timg__Move ** p = (_timg__Move **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__Move, sizeof(_timg__Move), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__Move(struct soap *soap, _timg__Move *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__Move);
	if (soap_out_PointerTo_timg__Move(soap, tag?tag:"timg:Move", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__Move ** SOAP_FMAC4 soap_get_PointerTo_timg__Move(struct soap *soap, _timg__Move **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__Move(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetOptionsResponse(struct soap *soap, _timg__GetOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetOptionsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetOptionsResponse(struct soap *soap, const char *tag, int id, _timg__GetOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetOptionsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _timg__GetOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__GetOptionsResponse(struct soap *soap, const char *tag, _timg__GetOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetOptionsResponse **)soap_malloc(soap, sizeof(_timg__GetOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetOptionsResponse *)soap_instantiate__timg__GetOptionsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_timg__GetOptionsResponse ** p = (_timg__GetOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetOptionsResponse, sizeof(_timg__GetOptionsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetOptionsResponse(struct soap *soap, _timg__GetOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetOptionsResponse);
	if (soap_out_PointerTo_timg__GetOptionsResponse(soap, tag?tag:"timg:GetOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__GetOptionsResponse(struct soap *soap, _timg__GetOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetOptions(struct soap *soap, _timg__GetOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetOptions(struct soap *soap, const char *tag, int id, _timg__GetOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _timg__GetOptions ** SOAP_FMAC4 soap_in_PointerTo_timg__GetOptions(struct soap *soap, const char *tag, _timg__GetOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetOptions **)soap_malloc(soap, sizeof(_timg__GetOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetOptions *)soap_instantiate__timg__GetOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_timg__GetOptions ** p = (_timg__GetOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetOptions, sizeof(_timg__GetOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetOptions(struct soap *soap, _timg__GetOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetOptions);
	if (soap_out_PointerTo_timg__GetOptions(soap, tag?tag:"timg:GetOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetOptions ** SOAP_FMAC4 soap_get_PointerTo_timg__GetOptions(struct soap *soap, _timg__GetOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__SetImagingSettingsResponse(struct soap *soap, _timg__SetImagingSettingsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__SetImagingSettingsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__SetImagingSettingsResponse(struct soap *soap, const char *tag, int id, _timg__SetImagingSettingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__SetImagingSettingsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _timg__SetImagingSettingsResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__SetImagingSettingsResponse(struct soap *soap, const char *tag, _timg__SetImagingSettingsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__SetImagingSettingsResponse **)soap_malloc(soap, sizeof(_timg__SetImagingSettingsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__SetImagingSettingsResponse *)soap_instantiate__timg__SetImagingSettingsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_timg__SetImagingSettingsResponse ** p = (_timg__SetImagingSettingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__SetImagingSettingsResponse, sizeof(_timg__SetImagingSettingsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__SetImagingSettingsResponse(struct soap *soap, _timg__SetImagingSettingsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__SetImagingSettingsResponse);
	if (soap_out_PointerTo_timg__SetImagingSettingsResponse(soap, tag?tag:"timg:SetImagingSettingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__SetImagingSettingsResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__SetImagingSettingsResponse(struct soap *soap, _timg__SetImagingSettingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__SetImagingSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__SetImagingSettings(struct soap *soap, _timg__SetImagingSettings *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__SetImagingSettings))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__SetImagingSettings(struct soap *soap, const char *tag, int id, _timg__SetImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__SetImagingSettings);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _timg__SetImagingSettings ** SOAP_FMAC4 soap_in_PointerTo_timg__SetImagingSettings(struct soap *soap, const char *tag, _timg__SetImagingSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__SetImagingSettings **)soap_malloc(soap, sizeof(_timg__SetImagingSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__SetImagingSettings *)soap_instantiate__timg__SetImagingSettings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_timg__SetImagingSettings ** p = (_timg__SetImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__SetImagingSettings, sizeof(_timg__SetImagingSettings), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__SetImagingSettings(struct soap *soap, _timg__SetImagingSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__SetImagingSettings);
	if (soap_out_PointerTo_timg__SetImagingSettings(soap, tag?tag:"timg:SetImagingSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__SetImagingSettings ** SOAP_FMAC4 soap_get_PointerTo_timg__SetImagingSettings(struct soap *soap, _timg__SetImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__SetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetImagingSettingsResponse(struct soap *soap, _timg__GetImagingSettingsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetImagingSettingsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetImagingSettingsResponse(struct soap *soap, const char *tag, int id, _timg__GetImagingSettingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetImagingSettingsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _timg__GetImagingSettingsResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__GetImagingSettingsResponse(struct soap *soap, const char *tag, _timg__GetImagingSettingsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetImagingSettingsResponse **)soap_malloc(soap, sizeof(_timg__GetImagingSettingsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetImagingSettingsResponse *)soap_instantiate__timg__GetImagingSettingsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_timg__GetImagingSettingsResponse ** p = (_timg__GetImagingSettingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetImagingSettingsResponse, sizeof(_timg__GetImagingSettingsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetImagingSettingsResponse(struct soap *soap, _timg__GetImagingSettingsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetImagingSettingsResponse);
	if (soap_out_PointerTo_timg__GetImagingSettingsResponse(soap, tag?tag:"timg:GetImagingSettingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetImagingSettingsResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__GetImagingSettingsResponse(struct soap *soap, _timg__GetImagingSettingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetImagingSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetImagingSettings(struct soap *soap, _timg__GetImagingSettings *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetImagingSettings))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetImagingSettings(struct soap *soap, const char *tag, int id, _timg__GetImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetImagingSettings);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _timg__GetImagingSettings ** SOAP_FMAC4 soap_in_PointerTo_timg__GetImagingSettings(struct soap *soap, const char *tag, _timg__GetImagingSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetImagingSettings **)soap_malloc(soap, sizeof(_timg__GetImagingSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetImagingSettings *)soap_instantiate__timg__GetImagingSettings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_timg__GetImagingSettings ** p = (_timg__GetImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetImagingSettings, sizeof(_timg__GetImagingSettings), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetImagingSettings(struct soap *soap, _timg__GetImagingSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetImagingSettings);
	if (soap_out_PointerTo_timg__GetImagingSettings(soap, tag?tag:"timg:GetImagingSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetImagingSettings ** SOAP_FMAC4 soap_get_PointerTo_timg__GetImagingSettings(struct soap *soap, _timg__GetImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetServiceCapabilitiesResponse(struct soap *soap, _timg__GetServiceCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetServiceCapabilitiesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, _timg__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _timg__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, _timg__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(_timg__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetServiceCapabilitiesResponse *)soap_instantiate__timg__GetServiceCapabilitiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_timg__GetServiceCapabilitiesResponse ** p = (_timg__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetServiceCapabilitiesResponse, sizeof(_timg__GetServiceCapabilitiesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetServiceCapabilitiesResponse(struct soap *soap, _timg__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_timg__GetServiceCapabilitiesResponse(soap, tag?tag:"timg:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__GetServiceCapabilitiesResponse(struct soap *soap, _timg__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetServiceCapabilities(struct soap *soap, _timg__GetServiceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetServiceCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetServiceCapabilities(struct soap *soap, const char *tag, int id, _timg__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _timg__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_timg__GetServiceCapabilities(struct soap *soap, const char *tag, _timg__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_timg__GetServiceCapabilities **)soap_malloc(soap, sizeof(_timg__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_timg__GetServiceCapabilities *)soap_instantiate__timg__GetServiceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_timg__GetServiceCapabilities ** p = (_timg__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetServiceCapabilities, sizeof(_timg__GetServiceCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetServiceCapabilities(struct soap *soap, _timg__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetServiceCapabilities);
	if (soap_out_PointerTo_timg__GetServiceCapabilities(soap, tag?tag:"timg:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _timg__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_timg__GetServiceCapabilities(struct soap *soap, _timg__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StartSystemRestoreResponse(struct soap *soap, _tds__StartSystemRestoreResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StartSystemRestoreResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, int id, _tds__StartSystemRestoreResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StartSystemRestoreResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__StartSystemRestoreResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, _tds__StartSystemRestoreResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__StartSystemRestoreResponse **)soap_malloc(soap, sizeof(_tds__StartSystemRestoreResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__StartSystemRestoreResponse *)soap_instantiate__tds__StartSystemRestoreResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__StartSystemRestoreResponse ** p = (_tds__StartSystemRestoreResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartSystemRestoreResponse, sizeof(_tds__StartSystemRestoreResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StartSystemRestoreResponse(struct soap *soap, _tds__StartSystemRestoreResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__StartSystemRestoreResponse);
	if (soap_out_PointerTo_tds__StartSystemRestoreResponse(soap, tag?tag:"tds:StartSystemRestoreResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__StartSystemRestoreResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__StartSystemRestoreResponse(struct soap *soap, _tds__StartSystemRestoreResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StartSystemRestoreResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StartSystemRestore(struct soap *soap, _tds__StartSystemRestore *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StartSystemRestore))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StartSystemRestore(struct soap *soap, const char *tag, int id, _tds__StartSystemRestore *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StartSystemRestore);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__StartSystemRestore ** SOAP_FMAC4 soap_in_PointerTo_tds__StartSystemRestore(struct soap *soap, const char *tag, _tds__StartSystemRestore **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__StartSystemRestore **)soap_malloc(soap, sizeof(_tds__StartSystemRestore *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__StartSystemRestore *)soap_instantiate__tds__StartSystemRestore(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__StartSystemRestore ** p = (_tds__StartSystemRestore **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartSystemRestore, sizeof(_tds__StartSystemRestore), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StartSystemRestore(struct soap *soap, _tds__StartSystemRestore *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__StartSystemRestore);
	if (soap_out_PointerTo_tds__StartSystemRestore(soap, tag?tag:"tds:StartSystemRestore", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__StartSystemRestore ** SOAP_FMAC4 soap_get_PointerTo_tds__StartSystemRestore(struct soap *soap, _tds__StartSystemRestore **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StartSystemRestore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StartFirmwareUpgradeResponse(struct soap *soap, _tds__StartFirmwareUpgradeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, int id, _tds__StartFirmwareUpgradeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StartFirmwareUpgradeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__StartFirmwareUpgradeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, _tds__StartFirmwareUpgradeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__StartFirmwareUpgradeResponse **)soap_malloc(soap, sizeof(_tds__StartFirmwareUpgradeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__StartFirmwareUpgradeResponse *)soap_instantiate__tds__StartFirmwareUpgradeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__StartFirmwareUpgradeResponse ** p = (_tds__StartFirmwareUpgradeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, sizeof(_tds__StartFirmwareUpgradeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StartFirmwareUpgradeResponse(struct soap *soap, _tds__StartFirmwareUpgradeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__StartFirmwareUpgradeResponse);
	if (soap_out_PointerTo_tds__StartFirmwareUpgradeResponse(soap, tag?tag:"tds:StartFirmwareUpgradeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__StartFirmwareUpgradeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__StartFirmwareUpgradeResponse(struct soap *soap, _tds__StartFirmwareUpgradeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StartFirmwareUpgradeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, _tds__StartFirmwareUpgrade *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StartFirmwareUpgrade))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, int id, _tds__StartFirmwareUpgrade *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StartFirmwareUpgrade);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__StartFirmwareUpgrade ** SOAP_FMAC4 soap_in_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, _tds__StartFirmwareUpgrade **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__StartFirmwareUpgrade **)soap_malloc(soap, sizeof(_tds__StartFirmwareUpgrade *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__StartFirmwareUpgrade *)soap_instantiate__tds__StartFirmwareUpgrade(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__StartFirmwareUpgrade ** p = (_tds__StartFirmwareUpgrade **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(_tds__StartFirmwareUpgrade), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, _tds__StartFirmwareUpgrade *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__StartFirmwareUpgrade);
	if (soap_out_PointerTo_tds__StartFirmwareUpgrade(soap, tag?tag:"tds:StartFirmwareUpgrade", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__StartFirmwareUpgrade ** SOAP_FMAC4 soap_get_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, _tds__StartFirmwareUpgrade **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StartFirmwareUpgrade(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemUrisResponse(struct soap *soap, _tds__GetSystemUrisResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemUrisResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemUrisResponse(struct soap *soap, const char *tag, int id, _tds__GetSystemUrisResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemUrisResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetSystemUrisResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemUrisResponse(struct soap *soap, const char *tag, _tds__GetSystemUrisResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemUrisResponse **)soap_malloc(soap, sizeof(_tds__GetSystemUrisResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemUrisResponse *)soap_instantiate__tds__GetSystemUrisResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetSystemUrisResponse ** p = (_tds__GetSystemUrisResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemUrisResponse, sizeof(_tds__GetSystemUrisResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemUrisResponse(struct soap *soap, _tds__GetSystemUrisResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemUrisResponse);
	if (soap_out_PointerTo_tds__GetSystemUrisResponse(soap, tag?tag:"tds:GetSystemUrisResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemUrisResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemUrisResponse(struct soap *soap, _tds__GetSystemUrisResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemUrisResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemUris(struct soap *soap, _tds__GetSystemUris *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemUris))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemUris(struct soap *soap, const char *tag, int id, _tds__GetSystemUris *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemUris);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetSystemUris ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemUris(struct soap *soap, const char *tag, _tds__GetSystemUris **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemUris **)soap_malloc(soap, sizeof(_tds__GetSystemUris *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemUris *)soap_instantiate__tds__GetSystemUris(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetSystemUris ** p = (_tds__GetSystemUris **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemUris, sizeof(_tds__GetSystemUris), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemUris(struct soap *soap, _tds__GetSystemUris *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemUris);
	if (soap_out_PointerTo_tds__GetSystemUris(soap, tag?tag:"tds:GetSystemUris", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemUris ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemUris(struct soap *soap, _tds__GetSystemUris **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemUris(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__ScanAvailableDot11NetworksResponse(struct soap *soap, _tds__ScanAvailableDot11NetworksResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, int id, _tds__ScanAvailableDot11NetworksResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__ScanAvailableDot11NetworksResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, _tds__ScanAvailableDot11NetworksResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__ScanAvailableDot11NetworksResponse **)soap_malloc(soap, sizeof(_tds__ScanAvailableDot11NetworksResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__ScanAvailableDot11NetworksResponse *)soap_instantiate__tds__ScanAvailableDot11NetworksResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__ScanAvailableDot11NetworksResponse ** p = (_tds__ScanAvailableDot11NetworksResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, sizeof(_tds__ScanAvailableDot11NetworksResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__ScanAvailableDot11NetworksResponse(struct soap *soap, _tds__ScanAvailableDot11NetworksResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__ScanAvailableDot11NetworksResponse);
	if (soap_out_PointerTo_tds__ScanAvailableDot11NetworksResponse(soap, tag?tag:"tds:ScanAvailableDot11NetworksResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__ScanAvailableDot11NetworksResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__ScanAvailableDot11NetworksResponse(struct soap *soap, _tds__ScanAvailableDot11NetworksResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__ScanAvailableDot11NetworksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, _tds__ScanAvailableDot11Networks *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__ScanAvailableDot11Networks))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, int id, _tds__ScanAvailableDot11Networks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__ScanAvailableDot11Networks);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__ScanAvailableDot11Networks ** SOAP_FMAC4 soap_in_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, _tds__ScanAvailableDot11Networks **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__ScanAvailableDot11Networks **)soap_malloc(soap, sizeof(_tds__ScanAvailableDot11Networks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__ScanAvailableDot11Networks *)soap_instantiate__tds__ScanAvailableDot11Networks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__ScanAvailableDot11Networks ** p = (_tds__ScanAvailableDot11Networks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(_tds__ScanAvailableDot11Networks), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, _tds__ScanAvailableDot11Networks *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__ScanAvailableDot11Networks);
	if (soap_out_PointerTo_tds__ScanAvailableDot11Networks(soap, tag?tag:"tds:ScanAvailableDot11Networks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__ScanAvailableDot11Networks ** SOAP_FMAC4 soap_get_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, _tds__ScanAvailableDot11Networks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__ScanAvailableDot11Networks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot11StatusResponse(struct soap *soap, _tds__GetDot11StatusResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot11StatusResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot11StatusResponse(struct soap *soap, const char *tag, int id, _tds__GetDot11StatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot11StatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetDot11StatusResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot11StatusResponse(struct soap *soap, const char *tag, _tds__GetDot11StatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDot11StatusResponse **)soap_malloc(soap, sizeof(_tds__GetDot11StatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDot11StatusResponse *)soap_instantiate__tds__GetDot11StatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetDot11StatusResponse ** p = (_tds__GetDot11StatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11StatusResponse, sizeof(_tds__GetDot11StatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot11StatusResponse(struct soap *soap, _tds__GetDot11StatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot11StatusResponse);
	if (soap_out_PointerTo_tds__GetDot11StatusResponse(soap, tag?tag:"tds:GetDot11StatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDot11StatusResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot11StatusResponse(struct soap *soap, _tds__GetDot11StatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot11StatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot11Status(struct soap *soap, _tds__GetDot11Status *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot11Status))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot11Status(struct soap *soap, const char *tag, int id, _tds__GetDot11Status *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot11Status);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetDot11Status ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot11Status(struct soap *soap, const char *tag, _tds__GetDot11Status **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDot11Status **)soap_malloc(soap, sizeof(_tds__GetDot11Status *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDot11Status *)soap_instantiate__tds__GetDot11Status(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetDot11Status ** p = (_tds__GetDot11Status **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11Status, sizeof(_tds__GetDot11Status), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot11Status(struct soap *soap, _tds__GetDot11Status *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot11Status);
	if (soap_out_PointerTo_tds__GetDot11Status(soap, tag?tag:"tds:GetDot11Status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDot11Status ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot11Status(struct soap *soap, _tds__GetDot11Status **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot11CapabilitiesResponse(struct soap *soap, _tds__GetDot11CapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, int id, _tds__GetDot11CapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot11CapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetDot11CapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, _tds__GetDot11CapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDot11CapabilitiesResponse **)soap_malloc(soap, sizeof(_tds__GetDot11CapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDot11CapabilitiesResponse *)soap_instantiate__tds__GetDot11CapabilitiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetDot11CapabilitiesResponse ** p = (_tds__GetDot11CapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, sizeof(_tds__GetDot11CapabilitiesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot11CapabilitiesResponse(struct soap *soap, _tds__GetDot11CapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot11CapabilitiesResponse);
	if (soap_out_PointerTo_tds__GetDot11CapabilitiesResponse(soap, tag?tag:"tds:GetDot11CapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDot11CapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot11CapabilitiesResponse(struct soap *soap, _tds__GetDot11CapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot11CapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot11Capabilities(struct soap *soap, _tds__GetDot11Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot11Capabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot11Capabilities(struct soap *soap, const char *tag, int id, _tds__GetDot11Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot11Capabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetDot11Capabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot11Capabilities(struct soap *soap, const char *tag, _tds__GetDot11Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDot11Capabilities **)soap_malloc(soap, sizeof(_tds__GetDot11Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDot11Capabilities *)soap_instantiate__tds__GetDot11Capabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetDot11Capabilities ** p = (_tds__GetDot11Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(_tds__GetDot11Capabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot11Capabilities(struct soap *soap, _tds__GetDot11Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot11Capabilities);
	if (soap_out_PointerTo_tds__GetDot11Capabilities(soap, tag?tag:"tds:GetDot11Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDot11Capabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot11Capabilities(struct soap *soap, _tds__GetDot11Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteDot1XConfigurationResponse(struct soap *soap, _tds__DeleteDot1XConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, _tds__DeleteDot1XConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__DeleteDot1XConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__DeleteDot1XConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__DeleteDot1XConfigurationResponse **)soap_malloc(soap, sizeof(_tds__DeleteDot1XConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__DeleteDot1XConfigurationResponse *)soap_instantiate__tds__DeleteDot1XConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__DeleteDot1XConfigurationResponse ** p = (_tds__DeleteDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, sizeof(_tds__DeleteDot1XConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteDot1XConfigurationResponse(struct soap *soap, _tds__DeleteDot1XConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteDot1XConfigurationResponse);
	if (soap_out_PointerTo_tds__DeleteDot1XConfigurationResponse(soap, tag?tag:"tds:DeleteDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__DeleteDot1XConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteDot1XConfigurationResponse(struct soap *soap, _tds__DeleteDot1XConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, _tds__DeleteDot1XConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteDot1XConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, int id, _tds__DeleteDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteDot1XConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__DeleteDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, _tds__DeleteDot1XConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__DeleteDot1XConfiguration **)soap_malloc(soap, sizeof(_tds__DeleteDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__DeleteDot1XConfiguration *)soap_instantiate__tds__DeleteDot1XConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__DeleteDot1XConfiguration ** p = (_tds__DeleteDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(_tds__DeleteDot1XConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, _tds__DeleteDot1XConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteDot1XConfiguration);
	if (soap_out_PointerTo_tds__DeleteDot1XConfiguration(soap, tag?tag:"tds:DeleteDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__DeleteDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, _tds__DeleteDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot1XConfigurationsResponse(struct soap *soap, _tds__GetDot1XConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, int id, _tds__GetDot1XConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot1XConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, _tds__GetDot1XConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDot1XConfigurationsResponse **)soap_malloc(soap, sizeof(_tds__GetDot1XConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDot1XConfigurationsResponse *)soap_instantiate__tds__GetDot1XConfigurationsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetDot1XConfigurationsResponse ** p = (_tds__GetDot1XConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, sizeof(_tds__GetDot1XConfigurationsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot1XConfigurationsResponse(struct soap *soap, _tds__GetDot1XConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot1XConfigurationsResponse);
	if (soap_out_PointerTo_tds__GetDot1XConfigurationsResponse(soap, tag?tag:"tds:GetDot1XConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot1XConfigurationsResponse(struct soap *soap, _tds__GetDot1XConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot1XConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, _tds__GetDot1XConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot1XConfigurations))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, const char *tag, int id, _tds__GetDot1XConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot1XConfigurations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurations ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, const char *tag, _tds__GetDot1XConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDot1XConfigurations **)soap_malloc(soap, sizeof(_tds__GetDot1XConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDot1XConfigurations *)soap_instantiate__tds__GetDot1XConfigurations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetDot1XConfigurations ** p = (_tds__GetDot1XConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfigurations, sizeof(_tds__GetDot1XConfigurations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, _tds__GetDot1XConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot1XConfigurations);
	if (soap_out_PointerTo_tds__GetDot1XConfigurations(soap, tag?tag:"tds:GetDot1XConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDot1XConfigurations ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, _tds__GetDot1XConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot1XConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot1XConfigurationResponse(struct soap *soap, _tds__GetDot1XConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot1XConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, _tds__GetDot1XConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot1XConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__GetDot1XConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDot1XConfigurationResponse **)soap_malloc(soap, sizeof(_tds__GetDot1XConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDot1XConfigurationResponse *)soap_instantiate__tds__GetDot1XConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetDot1XConfigurationResponse ** p = (_tds__GetDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfigurationResponse, sizeof(_tds__GetDot1XConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot1XConfigurationResponse(struct soap *soap, _tds__GetDot1XConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot1XConfigurationResponse);
	if (soap_out_PointerTo_tds__GetDot1XConfigurationResponse(soap, tag?tag:"tds:GetDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot1XConfigurationResponse(struct soap *soap, _tds__GetDot1XConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, _tds__GetDot1XConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot1XConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, const char *tag, int id, _tds__GetDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot1XConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, const char *tag, _tds__GetDot1XConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDot1XConfiguration **)soap_malloc(soap, sizeof(_tds__GetDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDot1XConfiguration *)soap_instantiate__tds__GetDot1XConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetDot1XConfiguration ** p = (_tds__GetDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfiguration, sizeof(_tds__GetDot1XConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, _tds__GetDot1XConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot1XConfiguration);
	if (soap_out_PointerTo_tds__GetDot1XConfiguration(soap, tag?tag:"tds:GetDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, _tds__GetDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDot1XConfigurationResponse(struct soap *soap, _tds__SetDot1XConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDot1XConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, _tds__SetDot1XConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDot1XConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetDot1XConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__SetDot1XConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDot1XConfigurationResponse **)soap_malloc(soap, sizeof(_tds__SetDot1XConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDot1XConfigurationResponse *)soap_instantiate__tds__SetDot1XConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetDot1XConfigurationResponse ** p = (_tds__SetDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDot1XConfigurationResponse, sizeof(_tds__SetDot1XConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDot1XConfigurationResponse(struct soap *soap, _tds__SetDot1XConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDot1XConfigurationResponse);
	if (soap_out_PointerTo_tds__SetDot1XConfigurationResponse(soap, tag?tag:"tds:SetDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDot1XConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDot1XConfigurationResponse(struct soap *soap, _tds__SetDot1XConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, _tds__SetDot1XConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDot1XConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, const char *tag, int id, _tds__SetDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDot1XConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, const char *tag, _tds__SetDot1XConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDot1XConfiguration **)soap_malloc(soap, sizeof(_tds__SetDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDot1XConfiguration *)soap_instantiate__tds__SetDot1XConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetDot1XConfiguration ** p = (_tds__SetDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDot1XConfiguration, sizeof(_tds__SetDot1XConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, _tds__SetDot1XConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDot1XConfiguration);
	if (soap_out_PointerTo_tds__SetDot1XConfiguration(soap, tag?tag:"tds:SetDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, _tds__SetDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateDot1XConfigurationResponse(struct soap *soap, _tds__CreateDot1XConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, _tds__CreateDot1XConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateDot1XConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__CreateDot1XConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__CreateDot1XConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__CreateDot1XConfigurationResponse **)soap_malloc(soap, sizeof(_tds__CreateDot1XConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__CreateDot1XConfigurationResponse *)soap_instantiate__tds__CreateDot1XConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__CreateDot1XConfigurationResponse ** p = (_tds__CreateDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, sizeof(_tds__CreateDot1XConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateDot1XConfigurationResponse(struct soap *soap, _tds__CreateDot1XConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateDot1XConfigurationResponse);
	if (soap_out_PointerTo_tds__CreateDot1XConfigurationResponse(soap, tag?tag:"tds:CreateDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__CreateDot1XConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateDot1XConfigurationResponse(struct soap *soap, _tds__CreateDot1XConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, _tds__CreateDot1XConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateDot1XConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, int id, _tds__CreateDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateDot1XConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__CreateDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, _tds__CreateDot1XConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__CreateDot1XConfiguration **)soap_malloc(soap, sizeof(_tds__CreateDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__CreateDot1XConfiguration *)soap_instantiate__tds__CreateDot1XConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__CreateDot1XConfiguration ** p = (_tds__CreateDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateDot1XConfiguration, sizeof(_tds__CreateDot1XConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, _tds__CreateDot1XConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateDot1XConfiguration);
	if (soap_out_PointerTo_tds__CreateDot1XConfiguration(soap, tag?tag:"tds:CreateDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__CreateDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, _tds__CreateDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCACertificatesResponse(struct soap *soap, _tds__LoadCACertificatesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCACertificatesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, int id, _tds__LoadCACertificatesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCACertificatesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__LoadCACertificatesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, _tds__LoadCACertificatesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__LoadCACertificatesResponse **)soap_malloc(soap, sizeof(_tds__LoadCACertificatesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__LoadCACertificatesResponse *)soap_instantiate__tds__LoadCACertificatesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__LoadCACertificatesResponse ** p = (_tds__LoadCACertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCACertificatesResponse, sizeof(_tds__LoadCACertificatesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCACertificatesResponse(struct soap *soap, _tds__LoadCACertificatesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__LoadCACertificatesResponse);
	if (soap_out_PointerTo_tds__LoadCACertificatesResponse(soap, tag?tag:"tds:LoadCACertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__LoadCACertificatesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCACertificatesResponse(struct soap *soap, _tds__LoadCACertificatesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCACertificates(struct soap *soap, _tds__LoadCACertificates *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCACertificates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCACertificates(struct soap *soap, const char *tag, int id, _tds__LoadCACertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCACertificates);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__LoadCACertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCACertificates(struct soap *soap, const char *tag, _tds__LoadCACertificates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__LoadCACertificates **)soap_malloc(soap, sizeof(_tds__LoadCACertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__LoadCACertificates *)soap_instantiate__tds__LoadCACertificates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__LoadCACertificates ** p = (_tds__LoadCACertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCACertificates, sizeof(_tds__LoadCACertificates), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCACertificates(struct soap *soap, _tds__LoadCACertificates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__LoadCACertificates);
	if (soap_out_PointerTo_tds__LoadCACertificates(soap, tag?tag:"tds:LoadCACertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__LoadCACertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCACertificates(struct soap *soap, _tds__LoadCACertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificateInformationResponse(struct soap *soap, _tds__GetCertificateInformationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificateInformationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, int id, _tds__GetCertificateInformationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificateInformationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetCertificateInformationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, _tds__GetCertificateInformationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCertificateInformationResponse **)soap_malloc(soap, sizeof(_tds__GetCertificateInformationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCertificateInformationResponse *)soap_instantiate__tds__GetCertificateInformationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetCertificateInformationResponse ** p = (_tds__GetCertificateInformationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificateInformationResponse, sizeof(_tds__GetCertificateInformationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificateInformationResponse(struct soap *soap, _tds__GetCertificateInformationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCertificateInformationResponse);
	if (soap_out_PointerTo_tds__GetCertificateInformationResponse(soap, tag?tag:"tds:GetCertificateInformationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCertificateInformationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificateInformationResponse(struct soap *soap, _tds__GetCertificateInformationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificateInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificateInformation(struct soap *soap, _tds__GetCertificateInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificateInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificateInformation(struct soap *soap, const char *tag, int id, _tds__GetCertificateInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificateInformation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetCertificateInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificateInformation(struct soap *soap, const char *tag, _tds__GetCertificateInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCertificateInformation **)soap_malloc(soap, sizeof(_tds__GetCertificateInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCertificateInformation *)soap_instantiate__tds__GetCertificateInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetCertificateInformation ** p = (_tds__GetCertificateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificateInformation, sizeof(_tds__GetCertificateInformation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificateInformation(struct soap *soap, _tds__GetCertificateInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCertificateInformation);
	if (soap_out_PointerTo_tds__GetCertificateInformation(soap, tag?tag:"tds:GetCertificateInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCertificateInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificateInformation(struct soap *soap, _tds__GetCertificateInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, _tds__LoadCertificateWithPrivateKeyResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, int id, _tds__LoadCertificateWithPrivateKeyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKeyResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, _tds__LoadCertificateWithPrivateKeyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__LoadCertificateWithPrivateKeyResponse **)soap_malloc(soap, sizeof(_tds__LoadCertificateWithPrivateKeyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__LoadCertificateWithPrivateKeyResponse *)soap_instantiate__tds__LoadCertificateWithPrivateKeyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__LoadCertificateWithPrivateKeyResponse ** p = (_tds__LoadCertificateWithPrivateKeyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, sizeof(_tds__LoadCertificateWithPrivateKeyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, _tds__LoadCertificateWithPrivateKeyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__LoadCertificateWithPrivateKeyResponse);
	if (soap_out_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(soap, tag?tag:"tds:LoadCertificateWithPrivateKeyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKeyResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, _tds__LoadCertificateWithPrivateKeyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, _tds__LoadCertificateWithPrivateKey *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, int id, _tds__LoadCertificateWithPrivateKey *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCertificateWithPrivateKey);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKey ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, _tds__LoadCertificateWithPrivateKey **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__LoadCertificateWithPrivateKey **)soap_malloc(soap, sizeof(_tds__LoadCertificateWithPrivateKey *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__LoadCertificateWithPrivateKey *)soap_instantiate__tds__LoadCertificateWithPrivateKey(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__LoadCertificateWithPrivateKey ** p = (_tds__LoadCertificateWithPrivateKey **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, sizeof(_tds__LoadCertificateWithPrivateKey), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, _tds__LoadCertificateWithPrivateKey *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__LoadCertificateWithPrivateKey);
	if (soap_out_PointerTo_tds__LoadCertificateWithPrivateKey(soap, tag?tag:"tds:LoadCertificateWithPrivateKey", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKey ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, _tds__LoadCertificateWithPrivateKey **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCACertificatesResponse(struct soap *soap, _tds__GetCACertificatesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCACertificatesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCACertificatesResponse(struct soap *soap, const char *tag, int id, _tds__GetCACertificatesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCACertificatesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetCACertificatesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCACertificatesResponse(struct soap *soap, const char *tag, _tds__GetCACertificatesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCACertificatesResponse **)soap_malloc(soap, sizeof(_tds__GetCACertificatesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCACertificatesResponse *)soap_instantiate__tds__GetCACertificatesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetCACertificatesResponse ** p = (_tds__GetCACertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCACertificatesResponse, sizeof(_tds__GetCACertificatesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCACertificatesResponse(struct soap *soap, _tds__GetCACertificatesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCACertificatesResponse);
	if (soap_out_PointerTo_tds__GetCACertificatesResponse(soap, tag?tag:"tds:GetCACertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCACertificatesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCACertificatesResponse(struct soap *soap, _tds__GetCACertificatesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCACertificates(struct soap *soap, _tds__GetCACertificates *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCACertificates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCACertificates(struct soap *soap, const char *tag, int id, _tds__GetCACertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCACertificates);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetCACertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCACertificates(struct soap *soap, const char *tag, _tds__GetCACertificates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCACertificates **)soap_malloc(soap, sizeof(_tds__GetCACertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCACertificates *)soap_instantiate__tds__GetCACertificates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetCACertificates ** p = (_tds__GetCACertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCACertificates, sizeof(_tds__GetCACertificates), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCACertificates(struct soap *soap, _tds__GetCACertificates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCACertificates);
	if (soap_out_PointerTo_tds__GetCACertificates(soap, tag?tag:"tds:GetCACertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCACertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCACertificates(struct soap *soap, _tds__GetCACertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, _tds__SendAuxiliaryCommandResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, _tds__SendAuxiliaryCommandResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SendAuxiliaryCommandResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommandResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, _tds__SendAuxiliaryCommandResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SendAuxiliaryCommandResponse **)soap_malloc(soap, sizeof(_tds__SendAuxiliaryCommandResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SendAuxiliaryCommandResponse *)soap_instantiate__tds__SendAuxiliaryCommandResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SendAuxiliaryCommandResponse ** p = (_tds__SendAuxiliaryCommandResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(_tds__SendAuxiliaryCommandResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, _tds__SendAuxiliaryCommandResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SendAuxiliaryCommandResponse);
	if (soap_out_PointerTo_tds__SendAuxiliaryCommandResponse(soap, tag?tag:"tds:SendAuxiliaryCommandResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommandResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, _tds__SendAuxiliaryCommandResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SendAuxiliaryCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, _tds__SendAuxiliaryCommand *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SendAuxiliaryCommand))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, _tds__SendAuxiliaryCommand *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SendAuxiliaryCommand);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommand ** SOAP_FMAC4 soap_in_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, _tds__SendAuxiliaryCommand **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SendAuxiliaryCommand **)soap_malloc(soap, sizeof(_tds__SendAuxiliaryCommand *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SendAuxiliaryCommand *)soap_instantiate__tds__SendAuxiliaryCommand(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SendAuxiliaryCommand ** p = (_tds__SendAuxiliaryCommand **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(_tds__SendAuxiliaryCommand), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, _tds__SendAuxiliaryCommand *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SendAuxiliaryCommand);
	if (soap_out_PointerTo_tds__SendAuxiliaryCommand(soap, tag?tag:"tds:SendAuxiliaryCommand", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommand ** SOAP_FMAC4 soap_get_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, _tds__SendAuxiliaryCommand **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, _tds__SetRelayOutputStateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputStateResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, int id, _tds__SetRelayOutputStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputStateResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetRelayOutputStateResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, _tds__SetRelayOutputStateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetRelayOutputStateResponse **)soap_malloc(soap, sizeof(_tds__SetRelayOutputStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetRelayOutputStateResponse *)soap_instantiate__tds__SetRelayOutputStateResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetRelayOutputStateResponse ** p = (_tds__SetRelayOutputStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(_tds__SetRelayOutputStateResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, _tds__SetRelayOutputStateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRelayOutputStateResponse);
	if (soap_out_PointerTo_tds__SetRelayOutputStateResponse(soap, tag?tag:"tds:SetRelayOutputStateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetRelayOutputStateResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, _tds__SetRelayOutputStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputState(struct soap *soap, _tds__SetRelayOutputState *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputState))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputState(struct soap *soap, const char *tag, int id, _tds__SetRelayOutputState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputState);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetRelayOutputState ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputState(struct soap *soap, const char *tag, _tds__SetRelayOutputState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetRelayOutputState **)soap_malloc(soap, sizeof(_tds__SetRelayOutputState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetRelayOutputState *)soap_instantiate__tds__SetRelayOutputState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetRelayOutputState ** p = (_tds__SetRelayOutputState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputState, sizeof(_tds__SetRelayOutputState), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputState(struct soap *soap, _tds__SetRelayOutputState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRelayOutputState);
	if (soap_out_PointerTo_tds__SetRelayOutputState(soap, tag?tag:"tds:SetRelayOutputState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetRelayOutputState ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputState(struct soap *soap, _tds__SetRelayOutputState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, _tds__SetRelayOutputSettingsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, int id, _tds__SetRelayOutputSettingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputSettingsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetRelayOutputSettingsResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, _tds__SetRelayOutputSettingsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetRelayOutputSettingsResponse **)soap_malloc(soap, sizeof(_tds__SetRelayOutputSettingsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetRelayOutputSettingsResponse *)soap_instantiate__tds__SetRelayOutputSettingsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetRelayOutputSettingsResponse ** p = (_tds__SetRelayOutputSettingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(_tds__SetRelayOutputSettingsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, _tds__SetRelayOutputSettingsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRelayOutputSettingsResponse);
	if (soap_out_PointerTo_tds__SetRelayOutputSettingsResponse(soap, tag?tag:"tds:SetRelayOutputSettingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetRelayOutputSettingsResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, _tds__SetRelayOutputSettingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, _tds__SetRelayOutputSettings *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputSettings))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, _tds__SetRelayOutputSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputSettings);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetRelayOutputSettings ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, const char *tag, _tds__SetRelayOutputSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetRelayOutputSettings **)soap_malloc(soap, sizeof(_tds__SetRelayOutputSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetRelayOutputSettings *)soap_instantiate__tds__SetRelayOutputSettings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetRelayOutputSettings ** p = (_tds__SetRelayOutputSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(_tds__SetRelayOutputSettings), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, _tds__SetRelayOutputSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRelayOutputSettings);
	if (soap_out_PointerTo_tds__SetRelayOutputSettings(soap, tag?tag:"tds:SetRelayOutputSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetRelayOutputSettings ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, _tds__SetRelayOutputSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, _tds__GetRelayOutputsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRelayOutputsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, int id, _tds__GetRelayOutputsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRelayOutputsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetRelayOutputsResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, _tds__GetRelayOutputsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetRelayOutputsResponse **)soap_malloc(soap, sizeof(_tds__GetRelayOutputsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetRelayOutputsResponse *)soap_instantiate__tds__GetRelayOutputsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetRelayOutputsResponse ** p = (_tds__GetRelayOutputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(_tds__GetRelayOutputsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, _tds__GetRelayOutputsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRelayOutputsResponse);
	if (soap_out_PointerTo_tds__GetRelayOutputsResponse(soap, tag?tag:"tds:GetRelayOutputsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetRelayOutputsResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, _tds__GetRelayOutputsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRelayOutputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRelayOutputs(struct soap *soap, _tds__GetRelayOutputs *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRelayOutputs))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRelayOutputs(struct soap *soap, const char *tag, int id, _tds__GetRelayOutputs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRelayOutputs);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetRelayOutputs ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRelayOutputs(struct soap *soap, const char *tag, _tds__GetRelayOutputs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetRelayOutputs **)soap_malloc(soap, sizeof(_tds__GetRelayOutputs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetRelayOutputs *)soap_instantiate__tds__GetRelayOutputs(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetRelayOutputs ** p = (_tds__GetRelayOutputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRelayOutputs, sizeof(_tds__GetRelayOutputs), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRelayOutputs(struct soap *soap, _tds__GetRelayOutputs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRelayOutputs);
	if (soap_out_PointerTo_tds__GetRelayOutputs(soap, tag?tag:"tds:GetRelayOutputs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetRelayOutputs ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRelayOutputs(struct soap *soap, _tds__GetRelayOutputs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRelayOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetClientCertificateModeResponse(struct soap *soap, _tds__SetClientCertificateModeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetClientCertificateModeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, _tds__SetClientCertificateModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetClientCertificateModeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetClientCertificateModeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, _tds__SetClientCertificateModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetClientCertificateModeResponse **)soap_malloc(soap, sizeof(_tds__SetClientCertificateModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetClientCertificateModeResponse *)soap_instantiate__tds__SetClientCertificateModeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetClientCertificateModeResponse ** p = (_tds__SetClientCertificateModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetClientCertificateModeResponse, sizeof(_tds__SetClientCertificateModeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetClientCertificateModeResponse(struct soap *soap, _tds__SetClientCertificateModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetClientCertificateModeResponse);
	if (soap_out_PointerTo_tds__SetClientCertificateModeResponse(soap, tag?tag:"tds:SetClientCertificateModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetClientCertificateModeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetClientCertificateModeResponse(struct soap *soap, _tds__SetClientCertificateModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetClientCertificateMode(struct soap *soap, _tds__SetClientCertificateMode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetClientCertificateMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetClientCertificateMode(struct soap *soap, const char *tag, int id, _tds__SetClientCertificateMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetClientCertificateMode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetClientCertificateMode ** SOAP_FMAC4 soap_in_PointerTo_tds__SetClientCertificateMode(struct soap *soap, const char *tag, _tds__SetClientCertificateMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetClientCertificateMode **)soap_malloc(soap, sizeof(_tds__SetClientCertificateMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetClientCertificateMode *)soap_instantiate__tds__SetClientCertificateMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetClientCertificateMode ** p = (_tds__SetClientCertificateMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetClientCertificateMode, sizeof(_tds__SetClientCertificateMode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetClientCertificateMode(struct soap *soap, _tds__SetClientCertificateMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetClientCertificateMode);
	if (soap_out_PointerTo_tds__SetClientCertificateMode(soap, tag?tag:"tds:SetClientCertificateMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetClientCertificateMode ** SOAP_FMAC4 soap_get_PointerTo_tds__SetClientCertificateMode(struct soap *soap, _tds__SetClientCertificateMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetClientCertificateModeResponse(struct soap *soap, _tds__GetClientCertificateModeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetClientCertificateModeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, _tds__GetClientCertificateModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetClientCertificateModeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetClientCertificateModeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, _tds__GetClientCertificateModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetClientCertificateModeResponse **)soap_malloc(soap, sizeof(_tds__GetClientCertificateModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetClientCertificateModeResponse *)soap_instantiate__tds__GetClientCertificateModeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetClientCertificateModeResponse ** p = (_tds__GetClientCertificateModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetClientCertificateModeResponse, sizeof(_tds__GetClientCertificateModeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetClientCertificateModeResponse(struct soap *soap, _tds__GetClientCertificateModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetClientCertificateModeResponse);
	if (soap_out_PointerTo_tds__GetClientCertificateModeResponse(soap, tag?tag:"tds:GetClientCertificateModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetClientCertificateModeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetClientCertificateModeResponse(struct soap *soap, _tds__GetClientCertificateModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetClientCertificateMode(struct soap *soap, _tds__GetClientCertificateMode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetClientCertificateMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetClientCertificateMode(struct soap *soap, const char *tag, int id, _tds__GetClientCertificateMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetClientCertificateMode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetClientCertificateMode ** SOAP_FMAC4 soap_in_PointerTo_tds__GetClientCertificateMode(struct soap *soap, const char *tag, _tds__GetClientCertificateMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetClientCertificateMode **)soap_malloc(soap, sizeof(_tds__GetClientCertificateMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetClientCertificateMode *)soap_instantiate__tds__GetClientCertificateMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetClientCertificateMode ** p = (_tds__GetClientCertificateMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetClientCertificateMode, sizeof(_tds__GetClientCertificateMode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetClientCertificateMode(struct soap *soap, _tds__GetClientCertificateMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetClientCertificateMode);
	if (soap_out_PointerTo_tds__GetClientCertificateMode(soap, tag?tag:"tds:GetClientCertificateMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetClientCertificateMode ** SOAP_FMAC4 soap_get_PointerTo_tds__GetClientCertificateMode(struct soap *soap, _tds__GetClientCertificateMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCertificatesResponse(struct soap *soap, _tds__LoadCertificatesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCertificatesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCertificatesResponse(struct soap *soap, const char *tag, int id, _tds__LoadCertificatesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCertificatesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__LoadCertificatesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCertificatesResponse(struct soap *soap, const char *tag, _tds__LoadCertificatesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__LoadCertificatesResponse **)soap_malloc(soap, sizeof(_tds__LoadCertificatesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__LoadCertificatesResponse *)soap_instantiate__tds__LoadCertificatesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__LoadCertificatesResponse ** p = (_tds__LoadCertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificatesResponse, sizeof(_tds__LoadCertificatesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCertificatesResponse(struct soap *soap, _tds__LoadCertificatesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__LoadCertificatesResponse);
	if (soap_out_PointerTo_tds__LoadCertificatesResponse(soap, tag?tag:"tds:LoadCertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__LoadCertificatesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCertificatesResponse(struct soap *soap, _tds__LoadCertificatesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCertificates(struct soap *soap, _tds__LoadCertificates *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCertificates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCertificates(struct soap *soap, const char *tag, int id, _tds__LoadCertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCertificates);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__LoadCertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCertificates(struct soap *soap, const char *tag, _tds__LoadCertificates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__LoadCertificates **)soap_malloc(soap, sizeof(_tds__LoadCertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__LoadCertificates *)soap_instantiate__tds__LoadCertificates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__LoadCertificates ** p = (_tds__LoadCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificates, sizeof(_tds__LoadCertificates), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCertificates(struct soap *soap, _tds__LoadCertificates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__LoadCertificates);
	if (soap_out_PointerTo_tds__LoadCertificates(soap, tag?tag:"tds:LoadCertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__LoadCertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCertificates(struct soap *soap, _tds__LoadCertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetPkcs10RequestResponse(struct soap *soap, _tds__GetPkcs10RequestResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetPkcs10RequestResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, int id, _tds__GetPkcs10RequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetPkcs10RequestResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetPkcs10RequestResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, _tds__GetPkcs10RequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetPkcs10RequestResponse **)soap_malloc(soap, sizeof(_tds__GetPkcs10RequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetPkcs10RequestResponse *)soap_instantiate__tds__GetPkcs10RequestResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetPkcs10RequestResponse ** p = (_tds__GetPkcs10RequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetPkcs10RequestResponse, sizeof(_tds__GetPkcs10RequestResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetPkcs10RequestResponse(struct soap *soap, _tds__GetPkcs10RequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetPkcs10RequestResponse);
	if (soap_out_PointerTo_tds__GetPkcs10RequestResponse(soap, tag?tag:"tds:GetPkcs10RequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetPkcs10RequestResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetPkcs10RequestResponse(struct soap *soap, _tds__GetPkcs10RequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetPkcs10RequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetPkcs10Request(struct soap *soap, _tds__GetPkcs10Request *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetPkcs10Request))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetPkcs10Request(struct soap *soap, const char *tag, int id, _tds__GetPkcs10Request *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetPkcs10Request);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetPkcs10Request ** SOAP_FMAC4 soap_in_PointerTo_tds__GetPkcs10Request(struct soap *soap, const char *tag, _tds__GetPkcs10Request **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetPkcs10Request **)soap_malloc(soap, sizeof(_tds__GetPkcs10Request *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetPkcs10Request *)soap_instantiate__tds__GetPkcs10Request(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetPkcs10Request ** p = (_tds__GetPkcs10Request **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetPkcs10Request, sizeof(_tds__GetPkcs10Request), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetPkcs10Request(struct soap *soap, _tds__GetPkcs10Request *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetPkcs10Request);
	if (soap_out_PointerTo_tds__GetPkcs10Request(soap, tag?tag:"tds:GetPkcs10Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetPkcs10Request ** SOAP_FMAC4 soap_get_PointerTo_tds__GetPkcs10Request(struct soap *soap, _tds__GetPkcs10Request **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetPkcs10Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteCertificatesResponse(struct soap *soap, _tds__DeleteCertificatesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteCertificatesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, int id, _tds__DeleteCertificatesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteCertificatesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__DeleteCertificatesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, _tds__DeleteCertificatesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__DeleteCertificatesResponse **)soap_malloc(soap, sizeof(_tds__DeleteCertificatesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__DeleteCertificatesResponse *)soap_instantiate__tds__DeleteCertificatesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__DeleteCertificatesResponse ** p = (_tds__DeleteCertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteCertificatesResponse, sizeof(_tds__DeleteCertificatesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteCertificatesResponse(struct soap *soap, _tds__DeleteCertificatesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteCertificatesResponse);
	if (soap_out_PointerTo_tds__DeleteCertificatesResponse(soap, tag?tag:"tds:DeleteCertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__DeleteCertificatesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteCertificatesResponse(struct soap *soap, _tds__DeleteCertificatesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteCertificates(struct soap *soap, _tds__DeleteCertificates *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteCertificates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteCertificates(struct soap *soap, const char *tag, int id, _tds__DeleteCertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteCertificates);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__DeleteCertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteCertificates(struct soap *soap, const char *tag, _tds__DeleteCertificates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__DeleteCertificates **)soap_malloc(soap, sizeof(_tds__DeleteCertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__DeleteCertificates *)soap_instantiate__tds__DeleteCertificates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__DeleteCertificates ** p = (_tds__DeleteCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteCertificates, sizeof(_tds__DeleteCertificates), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteCertificates(struct soap *soap, _tds__DeleteCertificates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteCertificates);
	if (soap_out_PointerTo_tds__DeleteCertificates(soap, tag?tag:"tds:DeleteCertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__DeleteCertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteCertificates(struct soap *soap, _tds__DeleteCertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetCertificatesStatusResponse(struct soap *soap, _tds__SetCertificatesStatusResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetCertificatesStatusResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, _tds__SetCertificatesStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetCertificatesStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetCertificatesStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, _tds__SetCertificatesStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetCertificatesStatusResponse **)soap_malloc(soap, sizeof(_tds__SetCertificatesStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetCertificatesStatusResponse *)soap_instantiate__tds__SetCertificatesStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetCertificatesStatusResponse ** p = (_tds__SetCertificatesStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetCertificatesStatusResponse, sizeof(_tds__SetCertificatesStatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetCertificatesStatusResponse(struct soap *soap, _tds__SetCertificatesStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetCertificatesStatusResponse);
	if (soap_out_PointerTo_tds__SetCertificatesStatusResponse(soap, tag?tag:"tds:SetCertificatesStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetCertificatesStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetCertificatesStatusResponse(struct soap *soap, _tds__SetCertificatesStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetCertificatesStatus(struct soap *soap, _tds__SetCertificatesStatus *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetCertificatesStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetCertificatesStatus(struct soap *soap, const char *tag, int id, _tds__SetCertificatesStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetCertificatesStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetCertificatesStatus ** SOAP_FMAC4 soap_in_PointerTo_tds__SetCertificatesStatus(struct soap *soap, const char *tag, _tds__SetCertificatesStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetCertificatesStatus **)soap_malloc(soap, sizeof(_tds__SetCertificatesStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetCertificatesStatus *)soap_instantiate__tds__SetCertificatesStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetCertificatesStatus ** p = (_tds__SetCertificatesStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetCertificatesStatus, sizeof(_tds__SetCertificatesStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetCertificatesStatus(struct soap *soap, _tds__SetCertificatesStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetCertificatesStatus);
	if (soap_out_PointerTo_tds__SetCertificatesStatus(soap, tag?tag:"tds:SetCertificatesStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetCertificatesStatus ** SOAP_FMAC4 soap_get_PointerTo_tds__SetCertificatesStatus(struct soap *soap, _tds__SetCertificatesStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificatesStatusResponse(struct soap *soap, _tds__GetCertificatesStatusResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificatesStatusResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, _tds__GetCertificatesStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificatesStatusResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetCertificatesStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, _tds__GetCertificatesStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCertificatesStatusResponse **)soap_malloc(soap, sizeof(_tds__GetCertificatesStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCertificatesStatusResponse *)soap_instantiate__tds__GetCertificatesStatusResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetCertificatesStatusResponse ** p = (_tds__GetCertificatesStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificatesStatusResponse, sizeof(_tds__GetCertificatesStatusResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificatesStatusResponse(struct soap *soap, _tds__GetCertificatesStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCertificatesStatusResponse);
	if (soap_out_PointerTo_tds__GetCertificatesStatusResponse(soap, tag?tag:"tds:GetCertificatesStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCertificatesStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificatesStatusResponse(struct soap *soap, _tds__GetCertificatesStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificatesStatus(struct soap *soap, _tds__GetCertificatesStatus *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificatesStatus))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificatesStatus(struct soap *soap, const char *tag, int id, _tds__GetCertificatesStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificatesStatus);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetCertificatesStatus ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificatesStatus(struct soap *soap, const char *tag, _tds__GetCertificatesStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCertificatesStatus **)soap_malloc(soap, sizeof(_tds__GetCertificatesStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCertificatesStatus *)soap_instantiate__tds__GetCertificatesStatus(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetCertificatesStatus ** p = (_tds__GetCertificatesStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificatesStatus, sizeof(_tds__GetCertificatesStatus), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificatesStatus(struct soap *soap, _tds__GetCertificatesStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCertificatesStatus);
	if (soap_out_PointerTo_tds__GetCertificatesStatus(soap, tag?tag:"tds:GetCertificatesStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCertificatesStatus ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificatesStatus(struct soap *soap, _tds__GetCertificatesStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificatesResponse(struct soap *soap, _tds__GetCertificatesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificatesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificatesResponse(struct soap *soap, const char *tag, int id, _tds__GetCertificatesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificatesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetCertificatesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificatesResponse(struct soap *soap, const char *tag, _tds__GetCertificatesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCertificatesResponse **)soap_malloc(soap, sizeof(_tds__GetCertificatesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCertificatesResponse *)soap_instantiate__tds__GetCertificatesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetCertificatesResponse ** p = (_tds__GetCertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificatesResponse, sizeof(_tds__GetCertificatesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificatesResponse(struct soap *soap, _tds__GetCertificatesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCertificatesResponse);
	if (soap_out_PointerTo_tds__GetCertificatesResponse(soap, tag?tag:"tds:GetCertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCertificatesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificatesResponse(struct soap *soap, _tds__GetCertificatesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificates(struct soap *soap, _tds__GetCertificates *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificates))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificates(struct soap *soap, const char *tag, int id, _tds__GetCertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificates);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetCertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificates(struct soap *soap, const char *tag, _tds__GetCertificates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCertificates **)soap_malloc(soap, sizeof(_tds__GetCertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCertificates *)soap_instantiate__tds__GetCertificates(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetCertificates ** p = (_tds__GetCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificates, sizeof(_tds__GetCertificates), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificates(struct soap *soap, _tds__GetCertificates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCertificates);
	if (soap_out_PointerTo_tds__GetCertificates(soap, tag?tag:"tds:GetCertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificates(struct soap *soap, _tds__GetCertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateCertificateResponse(struct soap *soap, _tds__CreateCertificateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateCertificateResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateCertificateResponse(struct soap *soap, const char *tag, int id, _tds__CreateCertificateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateCertificateResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__CreateCertificateResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateCertificateResponse(struct soap *soap, const char *tag, _tds__CreateCertificateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__CreateCertificateResponse **)soap_malloc(soap, sizeof(_tds__CreateCertificateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__CreateCertificateResponse *)soap_instantiate__tds__CreateCertificateResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__CreateCertificateResponse ** p = (_tds__CreateCertificateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateCertificateResponse, sizeof(_tds__CreateCertificateResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateCertificateResponse(struct soap *soap, _tds__CreateCertificateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateCertificateResponse);
	if (soap_out_PointerTo_tds__CreateCertificateResponse(soap, tag?tag:"tds:CreateCertificateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__CreateCertificateResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateCertificateResponse(struct soap *soap, _tds__CreateCertificateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateCertificateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateCertificate(struct soap *soap, _tds__CreateCertificate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateCertificate))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateCertificate(struct soap *soap, const char *tag, int id, _tds__CreateCertificate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateCertificate);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__CreateCertificate ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateCertificate(struct soap *soap, const char *tag, _tds__CreateCertificate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__CreateCertificate **)soap_malloc(soap, sizeof(_tds__CreateCertificate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__CreateCertificate *)soap_instantiate__tds__CreateCertificate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__CreateCertificate ** p = (_tds__CreateCertificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateCertificate, sizeof(_tds__CreateCertificate), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateCertificate(struct soap *soap, _tds__CreateCertificate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateCertificate);
	if (soap_out_PointerTo_tds__CreateCertificate(soap, tag?tag:"tds:CreateCertificate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__CreateCertificate ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateCertificate(struct soap *soap, _tds__CreateCertificate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetAccessPolicyResponse(struct soap *soap, _tds__SetAccessPolicyResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetAccessPolicyResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, int id, _tds__SetAccessPolicyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetAccessPolicyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetAccessPolicyResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, _tds__SetAccessPolicyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetAccessPolicyResponse **)soap_malloc(soap, sizeof(_tds__SetAccessPolicyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetAccessPolicyResponse *)soap_instantiate__tds__SetAccessPolicyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetAccessPolicyResponse ** p = (_tds__SetAccessPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetAccessPolicyResponse, sizeof(_tds__SetAccessPolicyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetAccessPolicyResponse(struct soap *soap, _tds__SetAccessPolicyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetAccessPolicyResponse);
	if (soap_out_PointerTo_tds__SetAccessPolicyResponse(soap, tag?tag:"tds:SetAccessPolicyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetAccessPolicyResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetAccessPolicyResponse(struct soap *soap, _tds__SetAccessPolicyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetAccessPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetAccessPolicy(struct soap *soap, _tds__SetAccessPolicy *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetAccessPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetAccessPolicy(struct soap *soap, const char *tag, int id, _tds__SetAccessPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetAccessPolicy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetAccessPolicy ** SOAP_FMAC4 soap_in_PointerTo_tds__SetAccessPolicy(struct soap *soap, const char *tag, _tds__SetAccessPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetAccessPolicy **)soap_malloc(soap, sizeof(_tds__SetAccessPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetAccessPolicy *)soap_instantiate__tds__SetAccessPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetAccessPolicy ** p = (_tds__SetAccessPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetAccessPolicy, sizeof(_tds__SetAccessPolicy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetAccessPolicy(struct soap *soap, _tds__SetAccessPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetAccessPolicy);
	if (soap_out_PointerTo_tds__SetAccessPolicy(soap, tag?tag:"tds:SetAccessPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetAccessPolicy ** SOAP_FMAC4 soap_get_PointerTo_tds__SetAccessPolicy(struct soap *soap, _tds__SetAccessPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetAccessPolicyResponse(struct soap *soap, _tds__GetAccessPolicyResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetAccessPolicyResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetAccessPolicyResponse(struct soap *soap, const char *tag, int id, _tds__GetAccessPolicyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetAccessPolicyResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetAccessPolicyResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetAccessPolicyResponse(struct soap *soap, const char *tag, _tds__GetAccessPolicyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetAccessPolicyResponse **)soap_malloc(soap, sizeof(_tds__GetAccessPolicyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetAccessPolicyResponse *)soap_instantiate__tds__GetAccessPolicyResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetAccessPolicyResponse ** p = (_tds__GetAccessPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetAccessPolicyResponse, sizeof(_tds__GetAccessPolicyResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetAccessPolicyResponse(struct soap *soap, _tds__GetAccessPolicyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetAccessPolicyResponse);
	if (soap_out_PointerTo_tds__GetAccessPolicyResponse(soap, tag?tag:"tds:GetAccessPolicyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetAccessPolicyResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetAccessPolicyResponse(struct soap *soap, _tds__GetAccessPolicyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetAccessPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetAccessPolicy(struct soap *soap, _tds__GetAccessPolicy *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetAccessPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetAccessPolicy(struct soap *soap, const char *tag, int id, _tds__GetAccessPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetAccessPolicy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetAccessPolicy ** SOAP_FMAC4 soap_in_PointerTo_tds__GetAccessPolicy(struct soap *soap, const char *tag, _tds__GetAccessPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetAccessPolicy **)soap_malloc(soap, sizeof(_tds__GetAccessPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetAccessPolicy *)soap_instantiate__tds__GetAccessPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetAccessPolicy ** p = (_tds__GetAccessPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetAccessPolicy, sizeof(_tds__GetAccessPolicy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetAccessPolicy(struct soap *soap, _tds__GetAccessPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetAccessPolicy);
	if (soap_out_PointerTo_tds__GetAccessPolicy(soap, tag?tag:"tds:GetAccessPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetAccessPolicy ** SOAP_FMAC4 soap_get_PointerTo_tds__GetAccessPolicy(struct soap *soap, _tds__GetAccessPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, _tds__RemoveIPAddressFilterResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, int id, _tds__RemoveIPAddressFilterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RemoveIPAddressFilterResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilterResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__RemoveIPAddressFilterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__RemoveIPAddressFilterResponse **)soap_malloc(soap, sizeof(_tds__RemoveIPAddressFilterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__RemoveIPAddressFilterResponse *)soap_instantiate__tds__RemoveIPAddressFilterResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__RemoveIPAddressFilterResponse ** p = (_tds__RemoveIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, sizeof(_tds__RemoveIPAddressFilterResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, _tds__RemoveIPAddressFilterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RemoveIPAddressFilterResponse);
	if (soap_out_PointerTo_tds__RemoveIPAddressFilterResponse(soap, tag?tag:"tds:RemoveIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilterResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, _tds__RemoveIPAddressFilterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RemoveIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, _tds__RemoveIPAddressFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RemoveIPAddressFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, int id, _tds__RemoveIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RemoveIPAddressFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, _tds__RemoveIPAddressFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__RemoveIPAddressFilter **)soap_malloc(soap, sizeof(_tds__RemoveIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__RemoveIPAddressFilter *)soap_instantiate__tds__RemoveIPAddressFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__RemoveIPAddressFilter ** p = (_tds__RemoveIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(_tds__RemoveIPAddressFilter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, _tds__RemoveIPAddressFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RemoveIPAddressFilter);
	if (soap_out_PointerTo_tds__RemoveIPAddressFilter(soap, tag?tag:"tds:RemoveIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, _tds__RemoveIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RemoveIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, _tds__AddIPAddressFilterResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__AddIPAddressFilterResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, int id, _tds__AddIPAddressFilterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__AddIPAddressFilterResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__AddIPAddressFilterResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__AddIPAddressFilterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__AddIPAddressFilterResponse **)soap_malloc(soap, sizeof(_tds__AddIPAddressFilterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__AddIPAddressFilterResponse *)soap_instantiate__tds__AddIPAddressFilterResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__AddIPAddressFilterResponse ** p = (_tds__AddIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddIPAddressFilterResponse, sizeof(_tds__AddIPAddressFilterResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, _tds__AddIPAddressFilterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__AddIPAddressFilterResponse);
	if (soap_out_PointerTo_tds__AddIPAddressFilterResponse(soap, tag?tag:"tds:AddIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__AddIPAddressFilterResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, _tds__AddIPAddressFilterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__AddIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__AddIPAddressFilter(struct soap *soap, _tds__AddIPAddressFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__AddIPAddressFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__AddIPAddressFilter(struct soap *soap, const char *tag, int id, _tds__AddIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__AddIPAddressFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__AddIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__AddIPAddressFilter(struct soap *soap, const char *tag, _tds__AddIPAddressFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__AddIPAddressFilter **)soap_malloc(soap, sizeof(_tds__AddIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__AddIPAddressFilter *)soap_instantiate__tds__AddIPAddressFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__AddIPAddressFilter ** p = (_tds__AddIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(_tds__AddIPAddressFilter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__AddIPAddressFilter(struct soap *soap, _tds__AddIPAddressFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__AddIPAddressFilter);
	if (soap_out_PointerTo_tds__AddIPAddressFilter(soap, tag?tag:"tds:AddIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__AddIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__AddIPAddressFilter(struct soap *soap, _tds__AddIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__AddIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, _tds__SetIPAddressFilterResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetIPAddressFilterResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, _tds__SetIPAddressFilterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetIPAddressFilterResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetIPAddressFilterResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__SetIPAddressFilterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetIPAddressFilterResponse **)soap_malloc(soap, sizeof(_tds__SetIPAddressFilterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetIPAddressFilterResponse *)soap_instantiate__tds__SetIPAddressFilterResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetIPAddressFilterResponse ** p = (_tds__SetIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetIPAddressFilterResponse, sizeof(_tds__SetIPAddressFilterResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, _tds__SetIPAddressFilterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetIPAddressFilterResponse);
	if (soap_out_PointerTo_tds__SetIPAddressFilterResponse(soap, tag?tag:"tds:SetIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetIPAddressFilterResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, _tds__SetIPAddressFilterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetIPAddressFilter(struct soap *soap, _tds__SetIPAddressFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetIPAddressFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetIPAddressFilter(struct soap *soap, const char *tag, int id, _tds__SetIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetIPAddressFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__SetIPAddressFilter(struct soap *soap, const char *tag, _tds__SetIPAddressFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetIPAddressFilter **)soap_malloc(soap, sizeof(_tds__SetIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetIPAddressFilter *)soap_instantiate__tds__SetIPAddressFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetIPAddressFilter ** p = (_tds__SetIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(_tds__SetIPAddressFilter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetIPAddressFilter(struct soap *soap, _tds__SetIPAddressFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetIPAddressFilter);
	if (soap_out_PointerTo_tds__SetIPAddressFilter(soap, tag?tag:"tds:SetIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__SetIPAddressFilter(struct soap *soap, _tds__SetIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, _tds__GetIPAddressFilterResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetIPAddressFilterResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, _tds__GetIPAddressFilterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetIPAddressFilterResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetIPAddressFilterResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__GetIPAddressFilterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetIPAddressFilterResponse **)soap_malloc(soap, sizeof(_tds__GetIPAddressFilterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetIPAddressFilterResponse *)soap_instantiate__tds__GetIPAddressFilterResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetIPAddressFilterResponse ** p = (_tds__GetIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetIPAddressFilterResponse, sizeof(_tds__GetIPAddressFilterResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, _tds__GetIPAddressFilterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetIPAddressFilterResponse);
	if (soap_out_PointerTo_tds__GetIPAddressFilterResponse(soap, tag?tag:"tds:GetIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetIPAddressFilterResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, _tds__GetIPAddressFilterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetIPAddressFilter(struct soap *soap, _tds__GetIPAddressFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetIPAddressFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetIPAddressFilter(struct soap *soap, const char *tag, int id, _tds__GetIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetIPAddressFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__GetIPAddressFilter(struct soap *soap, const char *tag, _tds__GetIPAddressFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetIPAddressFilter **)soap_malloc(soap, sizeof(_tds__GetIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetIPAddressFilter *)soap_instantiate__tds__GetIPAddressFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetIPAddressFilter ** p = (_tds__GetIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(_tds__GetIPAddressFilter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetIPAddressFilter(struct soap *soap, _tds__GetIPAddressFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetIPAddressFilter);
	if (soap_out_PointerTo_tds__GetIPAddressFilter(soap, tag?tag:"tds:GetIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__GetIPAddressFilter(struct soap *soap, _tds__GetIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetZeroConfigurationResponse(struct soap *soap, _tds__SetZeroConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetZeroConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetZeroConfigurationResponse(struct soap *soap, const char *tag, int id, _tds__SetZeroConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetZeroConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetZeroConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetZeroConfigurationResponse(struct soap *soap, const char *tag, _tds__SetZeroConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetZeroConfigurationResponse **)soap_malloc(soap, sizeof(_tds__SetZeroConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetZeroConfigurationResponse *)soap_instantiate__tds__SetZeroConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetZeroConfigurationResponse ** p = (_tds__SetZeroConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetZeroConfigurationResponse, sizeof(_tds__SetZeroConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetZeroConfigurationResponse(struct soap *soap, _tds__SetZeroConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetZeroConfigurationResponse);
	if (soap_out_PointerTo_tds__SetZeroConfigurationResponse(soap, tag?tag:"tds:SetZeroConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetZeroConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetZeroConfigurationResponse(struct soap *soap, _tds__SetZeroConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetZeroConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetZeroConfiguration(struct soap *soap, _tds__SetZeroConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetZeroConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetZeroConfiguration(struct soap *soap, const char *tag, int id, _tds__SetZeroConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetZeroConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetZeroConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__SetZeroConfiguration(struct soap *soap, const char *tag, _tds__SetZeroConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetZeroConfiguration **)soap_malloc(soap, sizeof(_tds__SetZeroConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetZeroConfiguration *)soap_instantiate__tds__SetZeroConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetZeroConfiguration ** p = (_tds__SetZeroConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetZeroConfiguration, sizeof(_tds__SetZeroConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetZeroConfiguration(struct soap *soap, _tds__SetZeroConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetZeroConfiguration);
	if (soap_out_PointerTo_tds__SetZeroConfiguration(soap, tag?tag:"tds:SetZeroConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetZeroConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__SetZeroConfiguration(struct soap *soap, _tds__SetZeroConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetZeroConfigurationResponse(struct soap *soap, _tds__GetZeroConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetZeroConfigurationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetZeroConfigurationResponse(struct soap *soap, const char *tag, int id, _tds__GetZeroConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetZeroConfigurationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetZeroConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetZeroConfigurationResponse(struct soap *soap, const char *tag, _tds__GetZeroConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetZeroConfigurationResponse **)soap_malloc(soap, sizeof(_tds__GetZeroConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetZeroConfigurationResponse *)soap_instantiate__tds__GetZeroConfigurationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetZeroConfigurationResponse ** p = (_tds__GetZeroConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetZeroConfigurationResponse, sizeof(_tds__GetZeroConfigurationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetZeroConfigurationResponse(struct soap *soap, _tds__GetZeroConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetZeroConfigurationResponse);
	if (soap_out_PointerTo_tds__GetZeroConfigurationResponse(soap, tag?tag:"tds:GetZeroConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetZeroConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetZeroConfigurationResponse(struct soap *soap, _tds__GetZeroConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetZeroConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetZeroConfiguration(struct soap *soap, _tds__GetZeroConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetZeroConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetZeroConfiguration(struct soap *soap, const char *tag, int id, _tds__GetZeroConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetZeroConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetZeroConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__GetZeroConfiguration(struct soap *soap, const char *tag, _tds__GetZeroConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetZeroConfiguration **)soap_malloc(soap, sizeof(_tds__GetZeroConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetZeroConfiguration *)soap_instantiate__tds__GetZeroConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetZeroConfiguration ** p = (_tds__GetZeroConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetZeroConfiguration, sizeof(_tds__GetZeroConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetZeroConfiguration(struct soap *soap, _tds__GetZeroConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetZeroConfiguration);
	if (soap_out_PointerTo_tds__GetZeroConfiguration(soap, tag?tag:"tds:GetZeroConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetZeroConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__GetZeroConfiguration(struct soap *soap, _tds__GetZeroConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, _tds__SetNetworkDefaultGatewayResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, _tds__SetNetworkDefaultGatewayResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGatewayResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, _tds__SetNetworkDefaultGatewayResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetNetworkDefaultGatewayResponse **)soap_malloc(soap, sizeof(_tds__SetNetworkDefaultGatewayResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetNetworkDefaultGatewayResponse *)soap_instantiate__tds__SetNetworkDefaultGatewayResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetNetworkDefaultGatewayResponse ** p = (_tds__SetNetworkDefaultGatewayResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(_tds__SetNetworkDefaultGatewayResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, _tds__SetNetworkDefaultGatewayResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkDefaultGatewayResponse);
	if (soap_out_PointerTo_tds__SetNetworkDefaultGatewayResponse(soap, tag?tag:"tds:SetNetworkDefaultGatewayResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGatewayResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, _tds__SetNetworkDefaultGatewayResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, _tds__SetNetworkDefaultGateway *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkDefaultGateway))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, _tds__SetNetworkDefaultGateway *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkDefaultGateway);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGateway ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, _tds__SetNetworkDefaultGateway **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetNetworkDefaultGateway **)soap_malloc(soap, sizeof(_tds__SetNetworkDefaultGateway *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetNetworkDefaultGateway *)soap_instantiate__tds__SetNetworkDefaultGateway(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetNetworkDefaultGateway ** p = (_tds__SetNetworkDefaultGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(_tds__SetNetworkDefaultGateway), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, _tds__SetNetworkDefaultGateway *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkDefaultGateway);
	if (soap_out_PointerTo_tds__SetNetworkDefaultGateway(soap, tag?tag:"tds:SetNetworkDefaultGateway", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGateway ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, _tds__SetNetworkDefaultGateway **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, _tds__GetNetworkDefaultGatewayResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, _tds__GetNetworkDefaultGatewayResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGatewayResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, _tds__GetNetworkDefaultGatewayResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetNetworkDefaultGatewayResponse **)soap_malloc(soap, sizeof(_tds__GetNetworkDefaultGatewayResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetNetworkDefaultGatewayResponse *)soap_instantiate__tds__GetNetworkDefaultGatewayResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetNetworkDefaultGatewayResponse ** p = (_tds__GetNetworkDefaultGatewayResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(_tds__GetNetworkDefaultGatewayResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, _tds__GetNetworkDefaultGatewayResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkDefaultGatewayResponse);
	if (soap_out_PointerTo_tds__GetNetworkDefaultGatewayResponse(soap, tag?tag:"tds:GetNetworkDefaultGatewayResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGatewayResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, _tds__GetNetworkDefaultGatewayResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, _tds__GetNetworkDefaultGateway *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkDefaultGateway))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, _tds__GetNetworkDefaultGateway *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkDefaultGateway);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGateway ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, _tds__GetNetworkDefaultGateway **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetNetworkDefaultGateway **)soap_malloc(soap, sizeof(_tds__GetNetworkDefaultGateway *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetNetworkDefaultGateway *)soap_instantiate__tds__GetNetworkDefaultGateway(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetNetworkDefaultGateway ** p = (_tds__GetNetworkDefaultGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(_tds__GetNetworkDefaultGateway), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, _tds__GetNetworkDefaultGateway *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkDefaultGateway);
	if (soap_out_PointerTo_tds__GetNetworkDefaultGateway(soap, tag?tag:"tds:GetNetworkDefaultGateway", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGateway ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, _tds__GetNetworkDefaultGateway **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, _tds__SetNetworkProtocolsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkProtocolsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, _tds__SetNetworkProtocolsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkProtocolsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetNetworkProtocolsResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, _tds__SetNetworkProtocolsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetNetworkProtocolsResponse **)soap_malloc(soap, sizeof(_tds__SetNetworkProtocolsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetNetworkProtocolsResponse *)soap_instantiate__tds__SetNetworkProtocolsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetNetworkProtocolsResponse ** p = (_tds__SetNetworkProtocolsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(_tds__SetNetworkProtocolsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, _tds__SetNetworkProtocolsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkProtocolsResponse);
	if (soap_out_PointerTo_tds__SetNetworkProtocolsResponse(soap, tag?tag:"tds:SetNetworkProtocolsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetNetworkProtocolsResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, _tds__SetNetworkProtocolsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkProtocols(struct soap *soap, _tds__SetNetworkProtocols *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkProtocols))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkProtocols(struct soap *soap, const char *tag, int id, _tds__SetNetworkProtocols *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkProtocols);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetNetworkProtocols ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkProtocols(struct soap *soap, const char *tag, _tds__SetNetworkProtocols **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetNetworkProtocols **)soap_malloc(soap, sizeof(_tds__SetNetworkProtocols *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetNetworkProtocols *)soap_instantiate__tds__SetNetworkProtocols(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetNetworkProtocols ** p = (_tds__SetNetworkProtocols **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(_tds__SetNetworkProtocols), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkProtocols(struct soap *soap, _tds__SetNetworkProtocols *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkProtocols);
	if (soap_out_PointerTo_tds__SetNetworkProtocols(soap, tag?tag:"tds:SetNetworkProtocols", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetNetworkProtocols ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkProtocols(struct soap *soap, _tds__SetNetworkProtocols **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, _tds__GetNetworkProtocolsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkProtocolsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, _tds__GetNetworkProtocolsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkProtocolsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetNetworkProtocolsResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, _tds__GetNetworkProtocolsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetNetworkProtocolsResponse **)soap_malloc(soap, sizeof(_tds__GetNetworkProtocolsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetNetworkProtocolsResponse *)soap_instantiate__tds__GetNetworkProtocolsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetNetworkProtocolsResponse ** p = (_tds__GetNetworkProtocolsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(_tds__GetNetworkProtocolsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, _tds__GetNetworkProtocolsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkProtocolsResponse);
	if (soap_out_PointerTo_tds__GetNetworkProtocolsResponse(soap, tag?tag:"tds:GetNetworkProtocolsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetNetworkProtocolsResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, _tds__GetNetworkProtocolsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkProtocols(struct soap *soap, _tds__GetNetworkProtocols *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkProtocols))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkProtocols(struct soap *soap, const char *tag, int id, _tds__GetNetworkProtocols *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkProtocols);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetNetworkProtocols ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkProtocols(struct soap *soap, const char *tag, _tds__GetNetworkProtocols **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetNetworkProtocols **)soap_malloc(soap, sizeof(_tds__GetNetworkProtocols *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetNetworkProtocols *)soap_instantiate__tds__GetNetworkProtocols(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetNetworkProtocols ** p = (_tds__GetNetworkProtocols **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(_tds__GetNetworkProtocols), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkProtocols(struct soap *soap, _tds__GetNetworkProtocols *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkProtocols);
	if (soap_out_PointerTo_tds__GetNetworkProtocols(soap, tag?tag:"tds:GetNetworkProtocols", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetNetworkProtocols ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkProtocols(struct soap *soap, _tds__GetNetworkProtocols **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, _tds__SetNetworkInterfacesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkInterfacesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, _tds__SetNetworkInterfacesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkInterfacesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetNetworkInterfacesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, _tds__SetNetworkInterfacesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetNetworkInterfacesResponse **)soap_malloc(soap, sizeof(_tds__SetNetworkInterfacesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetNetworkInterfacesResponse *)soap_instantiate__tds__SetNetworkInterfacesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetNetworkInterfacesResponse ** p = (_tds__SetNetworkInterfacesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(_tds__SetNetworkInterfacesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, _tds__SetNetworkInterfacesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkInterfacesResponse);
	if (soap_out_PointerTo_tds__SetNetworkInterfacesResponse(soap, tag?tag:"tds:SetNetworkInterfacesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetNetworkInterfacesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, _tds__SetNetworkInterfacesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, _tds__SetNetworkInterfaces *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkInterfaces))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, const char *tag, int id, _tds__SetNetworkInterfaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkInterfaces);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetNetworkInterfaces ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, const char *tag, _tds__SetNetworkInterfaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetNetworkInterfaces **)soap_malloc(soap, sizeof(_tds__SetNetworkInterfaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetNetworkInterfaces *)soap_instantiate__tds__SetNetworkInterfaces(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetNetworkInterfaces ** p = (_tds__SetNetworkInterfaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(_tds__SetNetworkInterfaces), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, _tds__SetNetworkInterfaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkInterfaces);
	if (soap_out_PointerTo_tds__SetNetworkInterfaces(soap, tag?tag:"tds:SetNetworkInterfaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetNetworkInterfaces ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, _tds__SetNetworkInterfaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, _tds__GetNetworkInterfacesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkInterfacesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, _tds__GetNetworkInterfacesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkInterfacesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetNetworkInterfacesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, _tds__GetNetworkInterfacesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetNetworkInterfacesResponse **)soap_malloc(soap, sizeof(_tds__GetNetworkInterfacesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetNetworkInterfacesResponse *)soap_instantiate__tds__GetNetworkInterfacesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetNetworkInterfacesResponse ** p = (_tds__GetNetworkInterfacesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(_tds__GetNetworkInterfacesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, _tds__GetNetworkInterfacesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkInterfacesResponse);
	if (soap_out_PointerTo_tds__GetNetworkInterfacesResponse(soap, tag?tag:"tds:GetNetworkInterfacesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetNetworkInterfacesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, _tds__GetNetworkInterfacesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, _tds__GetNetworkInterfaces *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkInterfaces))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, const char *tag, int id, _tds__GetNetworkInterfaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkInterfaces);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetNetworkInterfaces ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, const char *tag, _tds__GetNetworkInterfaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetNetworkInterfaces **)soap_malloc(soap, sizeof(_tds__GetNetworkInterfaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetNetworkInterfaces *)soap_instantiate__tds__GetNetworkInterfaces(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetNetworkInterfaces ** p = (_tds__GetNetworkInterfaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(_tds__GetNetworkInterfaces), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, _tds__GetNetworkInterfaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkInterfaces);
	if (soap_out_PointerTo_tds__GetNetworkInterfaces(soap, tag?tag:"tds:GetNetworkInterfaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetNetworkInterfaces ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, _tds__GetNetworkInterfaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, _tds__SetDynamicDNSResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDynamicDNSResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, int id, _tds__SetDynamicDNSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDynamicDNSResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetDynamicDNSResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, _tds__SetDynamicDNSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDynamicDNSResponse **)soap_malloc(soap, sizeof(_tds__SetDynamicDNSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDynamicDNSResponse *)soap_instantiate__tds__SetDynamicDNSResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetDynamicDNSResponse ** p = (_tds__SetDynamicDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(_tds__SetDynamicDNSResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, _tds__SetDynamicDNSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDynamicDNSResponse);
	if (soap_out_PointerTo_tds__SetDynamicDNSResponse(soap, tag?tag:"tds:SetDynamicDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDynamicDNSResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, _tds__SetDynamicDNSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDynamicDNS(struct soap *soap, _tds__SetDynamicDNS *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDynamicDNS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDynamicDNS(struct soap *soap, const char *tag, int id, _tds__SetDynamicDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDynamicDNS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetDynamicDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDynamicDNS(struct soap *soap, const char *tag, _tds__SetDynamicDNS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDynamicDNS **)soap_malloc(soap, sizeof(_tds__SetDynamicDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDynamicDNS *)soap_instantiate__tds__SetDynamicDNS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetDynamicDNS ** p = (_tds__SetDynamicDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDynamicDNS, sizeof(_tds__SetDynamicDNS), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDynamicDNS(struct soap *soap, _tds__SetDynamicDNS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDynamicDNS);
	if (soap_out_PointerTo_tds__SetDynamicDNS(soap, tag?tag:"tds:SetDynamicDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDynamicDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDynamicDNS(struct soap *soap, _tds__SetDynamicDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, _tds__GetDynamicDNSResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDynamicDNSResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, int id, _tds__GetDynamicDNSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDynamicDNSResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetDynamicDNSResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, _tds__GetDynamicDNSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDynamicDNSResponse **)soap_malloc(soap, sizeof(_tds__GetDynamicDNSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDynamicDNSResponse *)soap_instantiate__tds__GetDynamicDNSResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetDynamicDNSResponse ** p = (_tds__GetDynamicDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(_tds__GetDynamicDNSResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, _tds__GetDynamicDNSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDynamicDNSResponse);
	if (soap_out_PointerTo_tds__GetDynamicDNSResponse(soap, tag?tag:"tds:GetDynamicDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDynamicDNSResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, _tds__GetDynamicDNSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDynamicDNS(struct soap *soap, _tds__GetDynamicDNS *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDynamicDNS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDynamicDNS(struct soap *soap, const char *tag, int id, _tds__GetDynamicDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDynamicDNS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetDynamicDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDynamicDNS(struct soap *soap, const char *tag, _tds__GetDynamicDNS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDynamicDNS **)soap_malloc(soap, sizeof(_tds__GetDynamicDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDynamicDNS *)soap_instantiate__tds__GetDynamicDNS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetDynamicDNS ** p = (_tds__GetDynamicDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDynamicDNS, sizeof(_tds__GetDynamicDNS), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDynamicDNS(struct soap *soap, _tds__GetDynamicDNS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDynamicDNS);
	if (soap_out_PointerTo_tds__GetDynamicDNS(soap, tag?tag:"tds:GetDynamicDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDynamicDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDynamicDNS(struct soap *soap, _tds__GetDynamicDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNTPResponse(struct soap *soap, _tds__SetNTPResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNTPResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNTPResponse(struct soap *soap, const char *tag, int id, _tds__SetNTPResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNTPResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetNTPResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNTPResponse(struct soap *soap, const char *tag, _tds__SetNTPResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetNTPResponse **)soap_malloc(soap, sizeof(_tds__SetNTPResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetNTPResponse *)soap_instantiate__tds__SetNTPResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetNTPResponse ** p = (_tds__SetNTPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNTPResponse, sizeof(_tds__SetNTPResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNTPResponse(struct soap *soap, _tds__SetNTPResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNTPResponse);
	if (soap_out_PointerTo_tds__SetNTPResponse(soap, tag?tag:"tds:SetNTPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetNTPResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNTPResponse(struct soap *soap, _tds__SetNTPResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNTP(struct soap *soap, _tds__SetNTP *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNTP))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNTP(struct soap *soap, const char *tag, int id, _tds__SetNTP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNTP);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetNTP ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNTP(struct soap *soap, const char *tag, _tds__SetNTP **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetNTP **)soap_malloc(soap, sizeof(_tds__SetNTP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetNTP *)soap_instantiate__tds__SetNTP(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetNTP ** p = (_tds__SetNTP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNTP, sizeof(_tds__SetNTP), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNTP(struct soap *soap, _tds__SetNTP *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNTP);
	if (soap_out_PointerTo_tds__SetNTP(soap, tag?tag:"tds:SetNTP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetNTP ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNTP(struct soap *soap, _tds__SetNTP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNTPResponse(struct soap *soap, _tds__GetNTPResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNTPResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNTPResponse(struct soap *soap, const char *tag, int id, _tds__GetNTPResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNTPResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetNTPResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNTPResponse(struct soap *soap, const char *tag, _tds__GetNTPResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetNTPResponse **)soap_malloc(soap, sizeof(_tds__GetNTPResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetNTPResponse *)soap_instantiate__tds__GetNTPResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetNTPResponse ** p = (_tds__GetNTPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNTPResponse, sizeof(_tds__GetNTPResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNTPResponse(struct soap *soap, _tds__GetNTPResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNTPResponse);
	if (soap_out_PointerTo_tds__GetNTPResponse(soap, tag?tag:"tds:GetNTPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetNTPResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNTPResponse(struct soap *soap, _tds__GetNTPResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNTP(struct soap *soap, _tds__GetNTP *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNTP))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNTP(struct soap *soap, const char *tag, int id, _tds__GetNTP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNTP);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetNTP ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNTP(struct soap *soap, const char *tag, _tds__GetNTP **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetNTP **)soap_malloc(soap, sizeof(_tds__GetNTP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetNTP *)soap_instantiate__tds__GetNTP(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetNTP ** p = (_tds__GetNTP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNTP, sizeof(_tds__GetNTP), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNTP(struct soap *soap, _tds__GetNTP *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNTP);
	if (soap_out_PointerTo_tds__GetNTP(soap, tag?tag:"tds:GetNTP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetNTP ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNTP(struct soap *soap, _tds__GetNTP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDNSResponse(struct soap *soap, _tds__SetDNSResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDNSResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDNSResponse(struct soap *soap, const char *tag, int id, _tds__SetDNSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDNSResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetDNSResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDNSResponse(struct soap *soap, const char *tag, _tds__SetDNSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDNSResponse **)soap_malloc(soap, sizeof(_tds__SetDNSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDNSResponse *)soap_instantiate__tds__SetDNSResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetDNSResponse ** p = (_tds__SetDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDNSResponse, sizeof(_tds__SetDNSResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDNSResponse(struct soap *soap, _tds__SetDNSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDNSResponse);
	if (soap_out_PointerTo_tds__SetDNSResponse(soap, tag?tag:"tds:SetDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDNSResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDNSResponse(struct soap *soap, _tds__SetDNSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDNS(struct soap *soap, _tds__SetDNS *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDNS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDNS(struct soap *soap, const char *tag, int id, _tds__SetDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDNS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDNS(struct soap *soap, const char *tag, _tds__SetDNS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDNS **)soap_malloc(soap, sizeof(_tds__SetDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDNS *)soap_instantiate__tds__SetDNS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetDNS ** p = (_tds__SetDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDNS, sizeof(_tds__SetDNS), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDNS(struct soap *soap, _tds__SetDNS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDNS);
	if (soap_out_PointerTo_tds__SetDNS(soap, tag?tag:"tds:SetDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDNS(struct soap *soap, _tds__SetDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDNSResponse(struct soap *soap, _tds__GetDNSResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDNSResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDNSResponse(struct soap *soap, const char *tag, int id, _tds__GetDNSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDNSResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetDNSResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDNSResponse(struct soap *soap, const char *tag, _tds__GetDNSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDNSResponse **)soap_malloc(soap, sizeof(_tds__GetDNSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDNSResponse *)soap_instantiate__tds__GetDNSResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetDNSResponse ** p = (_tds__GetDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDNSResponse, sizeof(_tds__GetDNSResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDNSResponse(struct soap *soap, _tds__GetDNSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDNSResponse);
	if (soap_out_PointerTo_tds__GetDNSResponse(soap, tag?tag:"tds:GetDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDNSResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDNSResponse(struct soap *soap, _tds__GetDNSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDNS(struct soap *soap, _tds__GetDNS *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDNS))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDNS(struct soap *soap, const char *tag, int id, _tds__GetDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDNS);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDNS(struct soap *soap, const char *tag, _tds__GetDNS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDNS **)soap_malloc(soap, sizeof(_tds__GetDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDNS *)soap_instantiate__tds__GetDNS(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetDNS ** p = (_tds__GetDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDNS, sizeof(_tds__GetDNS), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDNS(struct soap *soap, _tds__GetDNS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDNS);
	if (soap_out_PointerTo_tds__GetDNS(soap, tag?tag:"tds:GetDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDNS(struct soap *soap, _tds__GetDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, _tds__SetHostnameFromDHCPResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, int id, _tds__SetHostnameFromDHCPResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostnameFromDHCPResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCPResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, _tds__SetHostnameFromDHCPResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetHostnameFromDHCPResponse **)soap_malloc(soap, sizeof(_tds__SetHostnameFromDHCPResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetHostnameFromDHCPResponse *)soap_instantiate__tds__SetHostnameFromDHCPResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetHostnameFromDHCPResponse ** p = (_tds__SetHostnameFromDHCPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(_tds__SetHostnameFromDHCPResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, _tds__SetHostnameFromDHCPResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetHostnameFromDHCPResponse);
	if (soap_out_PointerTo_tds__SetHostnameFromDHCPResponse(soap, tag?tag:"tds:SetHostnameFromDHCPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCPResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, _tds__SetHostnameFromDHCPResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostnameFromDHCPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, _tds__SetHostnameFromDHCP *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostnameFromDHCP))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, _tds__SetHostnameFromDHCP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostnameFromDHCP);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCP ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, _tds__SetHostnameFromDHCP **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetHostnameFromDHCP **)soap_malloc(soap, sizeof(_tds__SetHostnameFromDHCP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetHostnameFromDHCP *)soap_instantiate__tds__SetHostnameFromDHCP(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetHostnameFromDHCP ** p = (_tds__SetHostnameFromDHCP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(_tds__SetHostnameFromDHCP), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, _tds__SetHostnameFromDHCP *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetHostnameFromDHCP);
	if (soap_out_PointerTo_tds__SetHostnameFromDHCP(soap, tag?tag:"tds:SetHostnameFromDHCP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCP ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, _tds__SetHostnameFromDHCP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostnameResponse(struct soap *soap, _tds__SetHostnameResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostnameResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostnameResponse(struct soap *soap, const char *tag, int id, _tds__SetHostnameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostnameResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetHostnameResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostnameResponse(struct soap *soap, const char *tag, _tds__SetHostnameResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetHostnameResponse **)soap_malloc(soap, sizeof(_tds__SetHostnameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetHostnameResponse *)soap_instantiate__tds__SetHostnameResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetHostnameResponse ** p = (_tds__SetHostnameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostnameResponse, sizeof(_tds__SetHostnameResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostnameResponse(struct soap *soap, _tds__SetHostnameResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetHostnameResponse);
	if (soap_out_PointerTo_tds__SetHostnameResponse(soap, tag?tag:"tds:SetHostnameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetHostnameResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostnameResponse(struct soap *soap, _tds__SetHostnameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostname(struct soap *soap, _tds__SetHostname *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostname))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostname(struct soap *soap, const char *tag, int id, _tds__SetHostname *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostname);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetHostname ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostname(struct soap *soap, const char *tag, _tds__SetHostname **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetHostname **)soap_malloc(soap, sizeof(_tds__SetHostname *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetHostname *)soap_instantiate__tds__SetHostname(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetHostname ** p = (_tds__SetHostname **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostname, sizeof(_tds__SetHostname), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostname(struct soap *soap, _tds__SetHostname *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetHostname);
	if (soap_out_PointerTo_tds__SetHostname(soap, tag?tag:"tds:SetHostname", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetHostname ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostname(struct soap *soap, _tds__SetHostname **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetHostnameResponse(struct soap *soap, _tds__GetHostnameResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetHostnameResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetHostnameResponse(struct soap *soap, const char *tag, int id, _tds__GetHostnameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetHostnameResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetHostnameResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetHostnameResponse(struct soap *soap, const char *tag, _tds__GetHostnameResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetHostnameResponse **)soap_malloc(soap, sizeof(_tds__GetHostnameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetHostnameResponse *)soap_instantiate__tds__GetHostnameResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetHostnameResponse ** p = (_tds__GetHostnameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetHostnameResponse, sizeof(_tds__GetHostnameResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetHostnameResponse(struct soap *soap, _tds__GetHostnameResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetHostnameResponse);
	if (soap_out_PointerTo_tds__GetHostnameResponse(soap, tag?tag:"tds:GetHostnameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetHostnameResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetHostnameResponse(struct soap *soap, _tds__GetHostnameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetHostname(struct soap *soap, _tds__GetHostname *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetHostname))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetHostname(struct soap *soap, const char *tag, int id, _tds__GetHostname *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetHostname);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetHostname ** SOAP_FMAC4 soap_in_PointerTo_tds__GetHostname(struct soap *soap, const char *tag, _tds__GetHostname **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetHostname **)soap_malloc(soap, sizeof(_tds__GetHostname *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetHostname *)soap_instantiate__tds__GetHostname(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetHostname ** p = (_tds__GetHostname **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetHostname, sizeof(_tds__GetHostname), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetHostname(struct soap *soap, _tds__GetHostname *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetHostname);
	if (soap_out_PointerTo_tds__GetHostname(soap, tag?tag:"tds:GetHostname", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetHostname ** SOAP_FMAC4 soap_get_PointerTo_tds__GetHostname(struct soap *soap, _tds__GetHostname **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDPAddressesResponse(struct soap *soap, _tds__SetDPAddressesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDPAddressesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDPAddressesResponse(struct soap *soap, const char *tag, int id, _tds__SetDPAddressesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDPAddressesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetDPAddressesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDPAddressesResponse(struct soap *soap, const char *tag, _tds__SetDPAddressesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDPAddressesResponse **)soap_malloc(soap, sizeof(_tds__SetDPAddressesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDPAddressesResponse *)soap_instantiate__tds__SetDPAddressesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetDPAddressesResponse ** p = (_tds__SetDPAddressesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDPAddressesResponse, sizeof(_tds__SetDPAddressesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDPAddressesResponse(struct soap *soap, _tds__SetDPAddressesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDPAddressesResponse);
	if (soap_out_PointerTo_tds__SetDPAddressesResponse(soap, tag?tag:"tds:SetDPAddressesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDPAddressesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDPAddressesResponse(struct soap *soap, _tds__SetDPAddressesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDPAddressesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDPAddresses(struct soap *soap, _tds__SetDPAddresses *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDPAddresses))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDPAddresses(struct soap *soap, const char *tag, int id, _tds__SetDPAddresses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDPAddresses);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetDPAddresses ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDPAddresses(struct soap *soap, const char *tag, _tds__SetDPAddresses **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDPAddresses **)soap_malloc(soap, sizeof(_tds__SetDPAddresses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDPAddresses *)soap_instantiate__tds__SetDPAddresses(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetDPAddresses ** p = (_tds__SetDPAddresses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDPAddresses, sizeof(_tds__SetDPAddresses), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDPAddresses(struct soap *soap, _tds__SetDPAddresses *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDPAddresses);
	if (soap_out_PointerTo_tds__SetDPAddresses(soap, tag?tag:"tds:SetDPAddresses", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDPAddresses ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDPAddresses(struct soap *soap, _tds__SetDPAddresses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, _tds__GetCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCapabilitiesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, int id, _tds__GetCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, _tds__GetCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCapabilitiesResponse **)soap_malloc(soap, sizeof(_tds__GetCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCapabilitiesResponse *)soap_instantiate__tds__GetCapabilitiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetCapabilitiesResponse ** p = (_tds__GetCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(_tds__GetCapabilitiesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, _tds__GetCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCapabilitiesResponse);
	if (soap_out_PointerTo_tds__GetCapabilitiesResponse(soap, tag?tag:"tds:GetCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, _tds__GetCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCapabilities(struct soap *soap, _tds__GetCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCapabilities(struct soap *soap, const char *tag, int id, _tds__GetCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCapabilities(struct soap *soap, const char *tag, _tds__GetCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetCapabilities **)soap_malloc(soap, sizeof(_tds__GetCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetCapabilities *)soap_instantiate__tds__GetCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetCapabilities ** p = (_tds__GetCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCapabilities, sizeof(_tds__GetCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCapabilities(struct soap *soap, _tds__GetCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCapabilities);
	if (soap_out_PointerTo_tds__GetCapabilities(soap, tag?tag:"tds:GetCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCapabilities(struct soap *soap, _tds__GetCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetWsdlUrlResponse(struct soap *soap, _tds__GetWsdlUrlResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetWsdlUrlResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, int id, _tds__GetWsdlUrlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetWsdlUrlResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetWsdlUrlResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, _tds__GetWsdlUrlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetWsdlUrlResponse **)soap_malloc(soap, sizeof(_tds__GetWsdlUrlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetWsdlUrlResponse *)soap_instantiate__tds__GetWsdlUrlResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetWsdlUrlResponse ** p = (_tds__GetWsdlUrlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(_tds__GetWsdlUrlResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetWsdlUrlResponse(struct soap *soap, _tds__GetWsdlUrlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetWsdlUrlResponse);
	if (soap_out_PointerTo_tds__GetWsdlUrlResponse(soap, tag?tag:"tds:GetWsdlUrlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetWsdlUrlResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetWsdlUrlResponse(struct soap *soap, _tds__GetWsdlUrlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetWsdlUrlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetWsdlUrl(struct soap *soap, _tds__GetWsdlUrl *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetWsdlUrl))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetWsdlUrl(struct soap *soap, const char *tag, int id, _tds__GetWsdlUrl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetWsdlUrl);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetWsdlUrl ** SOAP_FMAC4 soap_in_PointerTo_tds__GetWsdlUrl(struct soap *soap, const char *tag, _tds__GetWsdlUrl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetWsdlUrl **)soap_malloc(soap, sizeof(_tds__GetWsdlUrl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetWsdlUrl *)soap_instantiate__tds__GetWsdlUrl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetWsdlUrl ** p = (_tds__GetWsdlUrl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetWsdlUrl, sizeof(_tds__GetWsdlUrl), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetWsdlUrl(struct soap *soap, _tds__GetWsdlUrl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetWsdlUrl);
	if (soap_out_PointerTo_tds__GetWsdlUrl(soap, tag?tag:"tds:GetWsdlUrl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetWsdlUrl ** SOAP_FMAC4 soap_get_PointerTo_tds__GetWsdlUrl(struct soap *soap, _tds__GetWsdlUrl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetWsdlUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetUserResponse(struct soap *soap, _tds__SetUserResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetUserResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetUserResponse(struct soap *soap, const char *tag, int id, _tds__SetUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetUserResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetUserResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetUserResponse(struct soap *soap, const char *tag, _tds__SetUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetUserResponse **)soap_malloc(soap, sizeof(_tds__SetUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetUserResponse *)soap_instantiate__tds__SetUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetUserResponse ** p = (_tds__SetUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetUserResponse, sizeof(_tds__SetUserResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetUserResponse(struct soap *soap, _tds__SetUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetUserResponse);
	if (soap_out_PointerTo_tds__SetUserResponse(soap, tag?tag:"tds:SetUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetUserResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetUserResponse(struct soap *soap, _tds__SetUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetUser(struct soap *soap, _tds__SetUser *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetUser))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetUser(struct soap *soap, const char *tag, int id, _tds__SetUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetUser ** SOAP_FMAC4 soap_in_PointerTo_tds__SetUser(struct soap *soap, const char *tag, _tds__SetUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetUser **)soap_malloc(soap, sizeof(_tds__SetUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetUser *)soap_instantiate__tds__SetUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetUser ** p = (_tds__SetUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetUser, sizeof(_tds__SetUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetUser(struct soap *soap, _tds__SetUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetUser);
	if (soap_out_PointerTo_tds__SetUser(soap, tag?tag:"tds:SetUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetUser ** SOAP_FMAC4 soap_get_PointerTo_tds__SetUser(struct soap *soap, _tds__SetUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteUsersResponse(struct soap *soap, _tds__DeleteUsersResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteUsersResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteUsersResponse(struct soap *soap, const char *tag, int id, _tds__DeleteUsersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteUsersResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__DeleteUsersResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteUsersResponse(struct soap *soap, const char *tag, _tds__DeleteUsersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__DeleteUsersResponse **)soap_malloc(soap, sizeof(_tds__DeleteUsersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__DeleteUsersResponse *)soap_instantiate__tds__DeleteUsersResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__DeleteUsersResponse ** p = (_tds__DeleteUsersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(_tds__DeleteUsersResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteUsersResponse(struct soap *soap, _tds__DeleteUsersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteUsersResponse);
	if (soap_out_PointerTo_tds__DeleteUsersResponse(soap, tag?tag:"tds:DeleteUsersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__DeleteUsersResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteUsersResponse(struct soap *soap, _tds__DeleteUsersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteUsers(struct soap *soap, _tds__DeleteUsers *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteUsers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteUsers(struct soap *soap, const char *tag, int id, _tds__DeleteUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteUsers);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__DeleteUsers ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteUsers(struct soap *soap, const char *tag, _tds__DeleteUsers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__DeleteUsers **)soap_malloc(soap, sizeof(_tds__DeleteUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__DeleteUsers *)soap_instantiate__tds__DeleteUsers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__DeleteUsers ** p = (_tds__DeleteUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteUsers, sizeof(_tds__DeleteUsers), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteUsers(struct soap *soap, _tds__DeleteUsers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteUsers);
	if (soap_out_PointerTo_tds__DeleteUsers(soap, tag?tag:"tds:DeleteUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__DeleteUsers ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteUsers(struct soap *soap, _tds__DeleteUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateUsersResponse(struct soap *soap, _tds__CreateUsersResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateUsersResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateUsersResponse(struct soap *soap, const char *tag, int id, _tds__CreateUsersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateUsersResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__CreateUsersResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateUsersResponse(struct soap *soap, const char *tag, _tds__CreateUsersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__CreateUsersResponse **)soap_malloc(soap, sizeof(_tds__CreateUsersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__CreateUsersResponse *)soap_instantiate__tds__CreateUsersResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__CreateUsersResponse ** p = (_tds__CreateUsersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateUsersResponse, sizeof(_tds__CreateUsersResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateUsersResponse(struct soap *soap, _tds__CreateUsersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateUsersResponse);
	if (soap_out_PointerTo_tds__CreateUsersResponse(soap, tag?tag:"tds:CreateUsersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__CreateUsersResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateUsersResponse(struct soap *soap, _tds__CreateUsersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateUsers(struct soap *soap, _tds__CreateUsers *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateUsers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateUsers(struct soap *soap, const char *tag, int id, _tds__CreateUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateUsers);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__CreateUsers ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateUsers(struct soap *soap, const char *tag, _tds__CreateUsers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__CreateUsers **)soap_malloc(soap, sizeof(_tds__CreateUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__CreateUsers *)soap_instantiate__tds__CreateUsers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__CreateUsers ** p = (_tds__CreateUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateUsers, sizeof(_tds__CreateUsers), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateUsers(struct soap *soap, _tds__CreateUsers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateUsers);
	if (soap_out_PointerTo_tds__CreateUsers(soap, tag?tag:"tds:CreateUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__CreateUsers ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateUsers(struct soap *soap, _tds__CreateUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetUsersResponse(struct soap *soap, _tds__GetUsersResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetUsersResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetUsersResponse(struct soap *soap, const char *tag, int id, _tds__GetUsersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetUsersResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetUsersResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetUsersResponse(struct soap *soap, const char *tag, _tds__GetUsersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetUsersResponse **)soap_malloc(soap, sizeof(_tds__GetUsersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetUsersResponse *)soap_instantiate__tds__GetUsersResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetUsersResponse ** p = (_tds__GetUsersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetUsersResponse, sizeof(_tds__GetUsersResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetUsersResponse(struct soap *soap, _tds__GetUsersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetUsersResponse);
	if (soap_out_PointerTo_tds__GetUsersResponse(soap, tag?tag:"tds:GetUsersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetUsersResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetUsersResponse(struct soap *soap, _tds__GetUsersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetUsers(struct soap *soap, _tds__GetUsers *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetUsers))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetUsers(struct soap *soap, const char *tag, int id, _tds__GetUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetUsers);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetUsers ** SOAP_FMAC4 soap_in_PointerTo_tds__GetUsers(struct soap *soap, const char *tag, _tds__GetUsers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetUsers **)soap_malloc(soap, sizeof(_tds__GetUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetUsers *)soap_instantiate__tds__GetUsers(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetUsers ** p = (_tds__GetUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetUsers, sizeof(_tds__GetUsers), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetUsers(struct soap *soap, _tds__GetUsers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetUsers);
	if (soap_out_PointerTo_tds__GetUsers(soap, tag?tag:"tds:GetUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetUsers ** SOAP_FMAC4 soap_get_PointerTo_tds__GetUsers(struct soap *soap, _tds__GetUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRemoteUserResponse(struct soap *soap, _tds__SetRemoteUserResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRemoteUserResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRemoteUserResponse(struct soap *soap, const char *tag, int id, _tds__SetRemoteUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRemoteUserResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetRemoteUserResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRemoteUserResponse(struct soap *soap, const char *tag, _tds__SetRemoteUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetRemoteUserResponse **)soap_malloc(soap, sizeof(_tds__SetRemoteUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetRemoteUserResponse *)soap_instantiate__tds__SetRemoteUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetRemoteUserResponse ** p = (_tds__SetRemoteUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteUserResponse, sizeof(_tds__SetRemoteUserResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRemoteUserResponse(struct soap *soap, _tds__SetRemoteUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRemoteUserResponse);
	if (soap_out_PointerTo_tds__SetRemoteUserResponse(soap, tag?tag:"tds:SetRemoteUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetRemoteUserResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRemoteUserResponse(struct soap *soap, _tds__SetRemoteUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRemoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRemoteUser(struct soap *soap, _tds__SetRemoteUser *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRemoteUser))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRemoteUser(struct soap *soap, const char *tag, int id, _tds__SetRemoteUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRemoteUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetRemoteUser ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRemoteUser(struct soap *soap, const char *tag, _tds__SetRemoteUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetRemoteUser **)soap_malloc(soap, sizeof(_tds__SetRemoteUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetRemoteUser *)soap_instantiate__tds__SetRemoteUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetRemoteUser ** p = (_tds__SetRemoteUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteUser, sizeof(_tds__SetRemoteUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRemoteUser(struct soap *soap, _tds__SetRemoteUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRemoteUser);
	if (soap_out_PointerTo_tds__SetRemoteUser(soap, tag?tag:"tds:SetRemoteUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetRemoteUser ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRemoteUser(struct soap *soap, _tds__SetRemoteUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRemoteUserResponse(struct soap *soap, _tds__GetRemoteUserResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRemoteUserResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRemoteUserResponse(struct soap *soap, const char *tag, int id, _tds__GetRemoteUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRemoteUserResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetRemoteUserResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRemoteUserResponse(struct soap *soap, const char *tag, _tds__GetRemoteUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetRemoteUserResponse **)soap_malloc(soap, sizeof(_tds__GetRemoteUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetRemoteUserResponse *)soap_instantiate__tds__GetRemoteUserResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetRemoteUserResponse ** p = (_tds__GetRemoteUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteUserResponse, sizeof(_tds__GetRemoteUserResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRemoteUserResponse(struct soap *soap, _tds__GetRemoteUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRemoteUserResponse);
	if (soap_out_PointerTo_tds__GetRemoteUserResponse(soap, tag?tag:"tds:GetRemoteUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetRemoteUserResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRemoteUserResponse(struct soap *soap, _tds__GetRemoteUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRemoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRemoteUser(struct soap *soap, _tds__GetRemoteUser *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRemoteUser))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRemoteUser(struct soap *soap, const char *tag, int id, _tds__GetRemoteUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRemoteUser);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetRemoteUser ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRemoteUser(struct soap *soap, const char *tag, _tds__GetRemoteUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetRemoteUser **)soap_malloc(soap, sizeof(_tds__GetRemoteUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetRemoteUser *)soap_instantiate__tds__GetRemoteUser(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetRemoteUser ** p = (_tds__GetRemoteUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteUser, sizeof(_tds__GetRemoteUser), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRemoteUser(struct soap *soap, _tds__GetRemoteUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRemoteUser);
	if (soap_out_PointerTo_tds__GetRemoteUser(soap, tag?tag:"tds:GetRemoteUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetRemoteUser ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRemoteUser(struct soap *soap, _tds__GetRemoteUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetEndpointReferenceResponse(struct soap *soap, _tds__GetEndpointReferenceResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetEndpointReferenceResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetEndpointReferenceResponse(struct soap *soap, const char *tag, int id, _tds__GetEndpointReferenceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetEndpointReferenceResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetEndpointReferenceResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetEndpointReferenceResponse(struct soap *soap, const char *tag, _tds__GetEndpointReferenceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetEndpointReferenceResponse **)soap_malloc(soap, sizeof(_tds__GetEndpointReferenceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetEndpointReferenceResponse *)soap_instantiate__tds__GetEndpointReferenceResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetEndpointReferenceResponse ** p = (_tds__GetEndpointReferenceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetEndpointReferenceResponse, sizeof(_tds__GetEndpointReferenceResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetEndpointReferenceResponse(struct soap *soap, _tds__GetEndpointReferenceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetEndpointReferenceResponse);
	if (soap_out_PointerTo_tds__GetEndpointReferenceResponse(soap, tag?tag:"tds:GetEndpointReferenceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetEndpointReferenceResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetEndpointReferenceResponse(struct soap *soap, _tds__GetEndpointReferenceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetEndpointReferenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetEndpointReference(struct soap *soap, _tds__GetEndpointReference *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetEndpointReference))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetEndpointReference(struct soap *soap, const char *tag, int id, _tds__GetEndpointReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetEndpointReference);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetEndpointReference ** SOAP_FMAC4 soap_in_PointerTo_tds__GetEndpointReference(struct soap *soap, const char *tag, _tds__GetEndpointReference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetEndpointReference **)soap_malloc(soap, sizeof(_tds__GetEndpointReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetEndpointReference *)soap_instantiate__tds__GetEndpointReference(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetEndpointReference ** p = (_tds__GetEndpointReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetEndpointReference, sizeof(_tds__GetEndpointReference), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetEndpointReference(struct soap *soap, _tds__GetEndpointReference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetEndpointReference);
	if (soap_out_PointerTo_tds__GetEndpointReference(soap, tag?tag:"tds:GetEndpointReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetEndpointReference ** SOAP_FMAC4 soap_get_PointerTo_tds__GetEndpointReference(struct soap *soap, _tds__GetEndpointReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetEndpointReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDPAddressesResponse(struct soap *soap, _tds__GetDPAddressesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDPAddressesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDPAddressesResponse(struct soap *soap, const char *tag, int id, _tds__GetDPAddressesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDPAddressesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetDPAddressesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDPAddressesResponse(struct soap *soap, const char *tag, _tds__GetDPAddressesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDPAddressesResponse **)soap_malloc(soap, sizeof(_tds__GetDPAddressesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDPAddressesResponse *)soap_instantiate__tds__GetDPAddressesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetDPAddressesResponse ** p = (_tds__GetDPAddressesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDPAddressesResponse, sizeof(_tds__GetDPAddressesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDPAddressesResponse(struct soap *soap, _tds__GetDPAddressesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDPAddressesResponse);
	if (soap_out_PointerTo_tds__GetDPAddressesResponse(soap, tag?tag:"tds:GetDPAddressesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDPAddressesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDPAddressesResponse(struct soap *soap, _tds__GetDPAddressesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDPAddressesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDPAddresses(struct soap *soap, _tds__GetDPAddresses *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDPAddresses))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDPAddresses(struct soap *soap, const char *tag, int id, _tds__GetDPAddresses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDPAddresses);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetDPAddresses ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDPAddresses(struct soap *soap, const char *tag, _tds__GetDPAddresses **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDPAddresses **)soap_malloc(soap, sizeof(_tds__GetDPAddresses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDPAddresses *)soap_instantiate__tds__GetDPAddresses(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetDPAddresses ** p = (_tds__GetDPAddresses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDPAddresses, sizeof(_tds__GetDPAddresses), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDPAddresses(struct soap *soap, _tds__GetDPAddresses *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDPAddresses);
	if (soap_out_PointerTo_tds__GetDPAddresses(soap, tag?tag:"tds:GetDPAddresses", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDPAddresses ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDPAddresses(struct soap *soap, _tds__GetDPAddresses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRemoteDiscoveryModeResponse(struct soap *soap, _tds__SetRemoteDiscoveryModeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, int id, _tds__SetRemoteDiscoveryModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetRemoteDiscoveryModeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, _tds__SetRemoteDiscoveryModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetRemoteDiscoveryModeResponse **)soap_malloc(soap, sizeof(_tds__SetRemoteDiscoveryModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetRemoteDiscoveryModeResponse *)soap_instantiate__tds__SetRemoteDiscoveryModeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetRemoteDiscoveryModeResponse ** p = (_tds__SetRemoteDiscoveryModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, sizeof(_tds__SetRemoteDiscoveryModeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRemoteDiscoveryModeResponse(struct soap *soap, _tds__SetRemoteDiscoveryModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRemoteDiscoveryModeResponse);
	if (soap_out_PointerTo_tds__SetRemoteDiscoveryModeResponse(soap, tag?tag:"tds:SetRemoteDiscoveryModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetRemoteDiscoveryModeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRemoteDiscoveryModeResponse(struct soap *soap, _tds__SetRemoteDiscoveryModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRemoteDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, _tds__SetRemoteDiscoveryMode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRemoteDiscoveryMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, _tds__SetRemoteDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRemoteDiscoveryMode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetRemoteDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, _tds__SetRemoteDiscoveryMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetRemoteDiscoveryMode **)soap_malloc(soap, sizeof(_tds__SetRemoteDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetRemoteDiscoveryMode *)soap_instantiate__tds__SetRemoteDiscoveryMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetRemoteDiscoveryMode ** p = (_tds__SetRemoteDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteDiscoveryMode, sizeof(_tds__SetRemoteDiscoveryMode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, _tds__SetRemoteDiscoveryMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRemoteDiscoveryMode);
	if (soap_out_PointerTo_tds__SetRemoteDiscoveryMode(soap, tag?tag:"tds:SetRemoteDiscoveryMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetRemoteDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, _tds__SetRemoteDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRemoteDiscoveryModeResponse(struct soap *soap, _tds__GetRemoteDiscoveryModeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, int id, _tds__GetRemoteDiscoveryModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetRemoteDiscoveryModeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, _tds__GetRemoteDiscoveryModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetRemoteDiscoveryModeResponse **)soap_malloc(soap, sizeof(_tds__GetRemoteDiscoveryModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetRemoteDiscoveryModeResponse *)soap_instantiate__tds__GetRemoteDiscoveryModeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetRemoteDiscoveryModeResponse ** p = (_tds__GetRemoteDiscoveryModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, sizeof(_tds__GetRemoteDiscoveryModeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRemoteDiscoveryModeResponse(struct soap *soap, _tds__GetRemoteDiscoveryModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRemoteDiscoveryModeResponse);
	if (soap_out_PointerTo_tds__GetRemoteDiscoveryModeResponse(soap, tag?tag:"tds:GetRemoteDiscoveryModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetRemoteDiscoveryModeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRemoteDiscoveryModeResponse(struct soap *soap, _tds__GetRemoteDiscoveryModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRemoteDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, _tds__GetRemoteDiscoveryMode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRemoteDiscoveryMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, _tds__GetRemoteDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRemoteDiscoveryMode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetRemoteDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, _tds__GetRemoteDiscoveryMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetRemoteDiscoveryMode **)soap_malloc(soap, sizeof(_tds__GetRemoteDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetRemoteDiscoveryMode *)soap_instantiate__tds__GetRemoteDiscoveryMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetRemoteDiscoveryMode ** p = (_tds__GetRemoteDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteDiscoveryMode, sizeof(_tds__GetRemoteDiscoveryMode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, _tds__GetRemoteDiscoveryMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRemoteDiscoveryMode);
	if (soap_out_PointerTo_tds__GetRemoteDiscoveryMode(soap, tag?tag:"tds:GetRemoteDiscoveryMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetRemoteDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, _tds__GetRemoteDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDiscoveryModeResponse(struct soap *soap, _tds__SetDiscoveryModeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDiscoveryModeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDiscoveryModeResponse(struct soap *soap, const char *tag, int id, _tds__SetDiscoveryModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDiscoveryModeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetDiscoveryModeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDiscoveryModeResponse(struct soap *soap, const char *tag, _tds__SetDiscoveryModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDiscoveryModeResponse **)soap_malloc(soap, sizeof(_tds__SetDiscoveryModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDiscoveryModeResponse *)soap_instantiate__tds__SetDiscoveryModeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetDiscoveryModeResponse ** p = (_tds__SetDiscoveryModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDiscoveryModeResponse, sizeof(_tds__SetDiscoveryModeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDiscoveryModeResponse(struct soap *soap, _tds__SetDiscoveryModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDiscoveryModeResponse);
	if (soap_out_PointerTo_tds__SetDiscoveryModeResponse(soap, tag?tag:"tds:SetDiscoveryModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDiscoveryModeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDiscoveryModeResponse(struct soap *soap, _tds__SetDiscoveryModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDiscoveryMode(struct soap *soap, _tds__SetDiscoveryMode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDiscoveryMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDiscoveryMode(struct soap *soap, const char *tag, int id, _tds__SetDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDiscoveryMode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDiscoveryMode(struct soap *soap, const char *tag, _tds__SetDiscoveryMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetDiscoveryMode **)soap_malloc(soap, sizeof(_tds__SetDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetDiscoveryMode *)soap_instantiate__tds__SetDiscoveryMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetDiscoveryMode ** p = (_tds__SetDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDiscoveryMode, sizeof(_tds__SetDiscoveryMode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDiscoveryMode(struct soap *soap, _tds__SetDiscoveryMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDiscoveryMode);
	if (soap_out_PointerTo_tds__SetDiscoveryMode(soap, tag?tag:"tds:SetDiscoveryMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDiscoveryMode(struct soap *soap, _tds__SetDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDiscoveryModeResponse(struct soap *soap, _tds__GetDiscoveryModeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDiscoveryModeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDiscoveryModeResponse(struct soap *soap, const char *tag, int id, _tds__GetDiscoveryModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDiscoveryModeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetDiscoveryModeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDiscoveryModeResponse(struct soap *soap, const char *tag, _tds__GetDiscoveryModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDiscoveryModeResponse **)soap_malloc(soap, sizeof(_tds__GetDiscoveryModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDiscoveryModeResponse *)soap_instantiate__tds__GetDiscoveryModeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetDiscoveryModeResponse ** p = (_tds__GetDiscoveryModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDiscoveryModeResponse, sizeof(_tds__GetDiscoveryModeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDiscoveryModeResponse(struct soap *soap, _tds__GetDiscoveryModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDiscoveryModeResponse);
	if (soap_out_PointerTo_tds__GetDiscoveryModeResponse(soap, tag?tag:"tds:GetDiscoveryModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDiscoveryModeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDiscoveryModeResponse(struct soap *soap, _tds__GetDiscoveryModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDiscoveryMode(struct soap *soap, _tds__GetDiscoveryMode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDiscoveryMode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDiscoveryMode(struct soap *soap, const char *tag, int id, _tds__GetDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDiscoveryMode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDiscoveryMode(struct soap *soap, const char *tag, _tds__GetDiscoveryMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDiscoveryMode **)soap_malloc(soap, sizeof(_tds__GetDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDiscoveryMode *)soap_instantiate__tds__GetDiscoveryMode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetDiscoveryMode ** p = (_tds__GetDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDiscoveryMode, sizeof(_tds__GetDiscoveryMode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDiscoveryMode(struct soap *soap, _tds__GetDiscoveryMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDiscoveryMode);
	if (soap_out_PointerTo_tds__GetDiscoveryMode(soap, tag?tag:"tds:GetDiscoveryMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDiscoveryMode(struct soap *soap, _tds__GetDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RemoveScopesResponse(struct soap *soap, _tds__RemoveScopesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RemoveScopesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RemoveScopesResponse(struct soap *soap, const char *tag, int id, _tds__RemoveScopesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RemoveScopesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__RemoveScopesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__RemoveScopesResponse(struct soap *soap, const char *tag, _tds__RemoveScopesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__RemoveScopesResponse **)soap_malloc(soap, sizeof(_tds__RemoveScopesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__RemoveScopesResponse *)soap_instantiate__tds__RemoveScopesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__RemoveScopesResponse ** p = (_tds__RemoveScopesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveScopesResponse, sizeof(_tds__RemoveScopesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RemoveScopesResponse(struct soap *soap, _tds__RemoveScopesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RemoveScopesResponse);
	if (soap_out_PointerTo_tds__RemoveScopesResponse(soap, tag?tag:"tds:RemoveScopesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__RemoveScopesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__RemoveScopesResponse(struct soap *soap, _tds__RemoveScopesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RemoveScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RemoveScopes(struct soap *soap, _tds__RemoveScopes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RemoveScopes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RemoveScopes(struct soap *soap, const char *tag, int id, _tds__RemoveScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RemoveScopes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__RemoveScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__RemoveScopes(struct soap *soap, const char *tag, _tds__RemoveScopes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__RemoveScopes **)soap_malloc(soap, sizeof(_tds__RemoveScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__RemoveScopes *)soap_instantiate__tds__RemoveScopes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__RemoveScopes ** p = (_tds__RemoveScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveScopes, sizeof(_tds__RemoveScopes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RemoveScopes(struct soap *soap, _tds__RemoveScopes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RemoveScopes);
	if (soap_out_PointerTo_tds__RemoveScopes(soap, tag?tag:"tds:RemoveScopes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__RemoveScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__RemoveScopes(struct soap *soap, _tds__RemoveScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RemoveScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__AddScopesResponse(struct soap *soap, _tds__AddScopesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__AddScopesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__AddScopesResponse(struct soap *soap, const char *tag, int id, _tds__AddScopesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__AddScopesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__AddScopesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__AddScopesResponse(struct soap *soap, const char *tag, _tds__AddScopesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__AddScopesResponse **)soap_malloc(soap, sizeof(_tds__AddScopesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__AddScopesResponse *)soap_instantiate__tds__AddScopesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__AddScopesResponse ** p = (_tds__AddScopesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddScopesResponse, sizeof(_tds__AddScopesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__AddScopesResponse(struct soap *soap, _tds__AddScopesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__AddScopesResponse);
	if (soap_out_PointerTo_tds__AddScopesResponse(soap, tag?tag:"tds:AddScopesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__AddScopesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__AddScopesResponse(struct soap *soap, _tds__AddScopesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__AddScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__AddScopes(struct soap *soap, _tds__AddScopes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__AddScopes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__AddScopes(struct soap *soap, const char *tag, int id, _tds__AddScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__AddScopes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__AddScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__AddScopes(struct soap *soap, const char *tag, _tds__AddScopes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__AddScopes **)soap_malloc(soap, sizeof(_tds__AddScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__AddScopes *)soap_instantiate__tds__AddScopes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__AddScopes ** p = (_tds__AddScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddScopes, sizeof(_tds__AddScopes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__AddScopes(struct soap *soap, _tds__AddScopes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__AddScopes);
	if (soap_out_PointerTo_tds__AddScopes(soap, tag?tag:"tds:AddScopes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__AddScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__AddScopes(struct soap *soap, _tds__AddScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__AddScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetScopesResponse(struct soap *soap, _tds__SetScopesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetScopesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetScopesResponse(struct soap *soap, const char *tag, int id, _tds__SetScopesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetScopesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetScopesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetScopesResponse(struct soap *soap, const char *tag, _tds__SetScopesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetScopesResponse **)soap_malloc(soap, sizeof(_tds__SetScopesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetScopesResponse *)soap_instantiate__tds__SetScopesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetScopesResponse ** p = (_tds__SetScopesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetScopesResponse, sizeof(_tds__SetScopesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetScopesResponse(struct soap *soap, _tds__SetScopesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetScopesResponse);
	if (soap_out_PointerTo_tds__SetScopesResponse(soap, tag?tag:"tds:SetScopesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetScopesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetScopesResponse(struct soap *soap, _tds__SetScopesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetScopes(struct soap *soap, _tds__SetScopes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetScopes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetScopes(struct soap *soap, const char *tag, int id, _tds__SetScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetScopes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__SetScopes(struct soap *soap, const char *tag, _tds__SetScopes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetScopes **)soap_malloc(soap, sizeof(_tds__SetScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetScopes *)soap_instantiate__tds__SetScopes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetScopes ** p = (_tds__SetScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetScopes, sizeof(_tds__SetScopes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetScopes(struct soap *soap, _tds__SetScopes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetScopes);
	if (soap_out_PointerTo_tds__SetScopes(soap, tag?tag:"tds:SetScopes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__SetScopes(struct soap *soap, _tds__SetScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetScopesResponse(struct soap *soap, _tds__GetScopesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetScopesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetScopesResponse(struct soap *soap, const char *tag, int id, _tds__GetScopesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetScopesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetScopesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetScopesResponse(struct soap *soap, const char *tag, _tds__GetScopesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetScopesResponse **)soap_malloc(soap, sizeof(_tds__GetScopesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetScopesResponse *)soap_instantiate__tds__GetScopesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetScopesResponse ** p = (_tds__GetScopesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetScopesResponse, sizeof(_tds__GetScopesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetScopesResponse(struct soap *soap, _tds__GetScopesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetScopesResponse);
	if (soap_out_PointerTo_tds__GetScopesResponse(soap, tag?tag:"tds:GetScopesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetScopesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetScopesResponse(struct soap *soap, _tds__GetScopesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetScopes(struct soap *soap, _tds__GetScopes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetScopes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetScopes(struct soap *soap, const char *tag, int id, _tds__GetScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetScopes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__GetScopes(struct soap *soap, const char *tag, _tds__GetScopes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetScopes **)soap_malloc(soap, sizeof(_tds__GetScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetScopes *)soap_instantiate__tds__GetScopes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetScopes ** p = (_tds__GetScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetScopes, sizeof(_tds__GetScopes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetScopes(struct soap *soap, _tds__GetScopes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetScopes);
	if (soap_out_PointerTo_tds__GetScopes(soap, tag?tag:"tds:GetScopes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__GetScopes(struct soap *soap, _tds__GetScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemSupportInformationResponse(struct soap *soap, _tds__GetSystemSupportInformationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemSupportInformationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemSupportInformationResponse(struct soap *soap, const char *tag, int id, _tds__GetSystemSupportInformationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemSupportInformationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetSystemSupportInformationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemSupportInformationResponse(struct soap *soap, const char *tag, _tds__GetSystemSupportInformationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemSupportInformationResponse **)soap_malloc(soap, sizeof(_tds__GetSystemSupportInformationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemSupportInformationResponse *)soap_instantiate__tds__GetSystemSupportInformationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetSystemSupportInformationResponse ** p = (_tds__GetSystemSupportInformationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemSupportInformationResponse, sizeof(_tds__GetSystemSupportInformationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemSupportInformationResponse(struct soap *soap, _tds__GetSystemSupportInformationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemSupportInformationResponse);
	if (soap_out_PointerTo_tds__GetSystemSupportInformationResponse(soap, tag?tag:"tds:GetSystemSupportInformationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemSupportInformationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemSupportInformationResponse(struct soap *soap, _tds__GetSystemSupportInformationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemSupportInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, _tds__GetSystemSupportInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemSupportInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, const char *tag, int id, _tds__GetSystemSupportInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemSupportInformation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetSystemSupportInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, const char *tag, _tds__GetSystemSupportInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemSupportInformation **)soap_malloc(soap, sizeof(_tds__GetSystemSupportInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemSupportInformation *)soap_instantiate__tds__GetSystemSupportInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetSystemSupportInformation ** p = (_tds__GetSystemSupportInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(_tds__GetSystemSupportInformation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, _tds__GetSystemSupportInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemSupportInformation);
	if (soap_out_PointerTo_tds__GetSystemSupportInformation(soap, tag?tag:"tds:GetSystemSupportInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemSupportInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, _tds__GetSystemSupportInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemSupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemLogResponse(struct soap *soap, _tds__GetSystemLogResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemLogResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemLogResponse(struct soap *soap, const char *tag, int id, _tds__GetSystemLogResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemLogResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetSystemLogResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemLogResponse(struct soap *soap, const char *tag, _tds__GetSystemLogResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemLogResponse **)soap_malloc(soap, sizeof(_tds__GetSystemLogResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemLogResponse *)soap_instantiate__tds__GetSystemLogResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetSystemLogResponse ** p = (_tds__GetSystemLogResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemLogResponse, sizeof(_tds__GetSystemLogResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemLogResponse(struct soap *soap, _tds__GetSystemLogResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemLogResponse);
	if (soap_out_PointerTo_tds__GetSystemLogResponse(soap, tag?tag:"tds:GetSystemLogResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemLogResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemLogResponse(struct soap *soap, _tds__GetSystemLogResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemLog(struct soap *soap, _tds__GetSystemLog *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemLog))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemLog(struct soap *soap, const char *tag, int id, _tds__GetSystemLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemLog);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetSystemLog ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemLog(struct soap *soap, const char *tag, _tds__GetSystemLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemLog **)soap_malloc(soap, sizeof(_tds__GetSystemLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemLog *)soap_instantiate__tds__GetSystemLog(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetSystemLog ** p = (_tds__GetSystemLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemLog, sizeof(_tds__GetSystemLog), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemLog(struct soap *soap, _tds__GetSystemLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemLog);
	if (soap_out_PointerTo_tds__GetSystemLog(soap, tag?tag:"tds:GetSystemLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemLog ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemLog(struct soap *soap, _tds__GetSystemLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, _tds__GetSystemBackupResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemBackupResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, const char *tag, int id, _tds__GetSystemBackupResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemBackupResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetSystemBackupResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, const char *tag, _tds__GetSystemBackupResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemBackupResponse **)soap_malloc(soap, sizeof(_tds__GetSystemBackupResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemBackupResponse *)soap_instantiate__tds__GetSystemBackupResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetSystemBackupResponse ** p = (_tds__GetSystemBackupResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemBackupResponse, sizeof(_tds__GetSystemBackupResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, _tds__GetSystemBackupResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemBackupResponse);
	if (soap_out_PointerTo_tds__GetSystemBackupResponse(soap, tag?tag:"tds:GetSystemBackupResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemBackupResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, _tds__GetSystemBackupResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemBackupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemBackup(struct soap *soap, _tds__GetSystemBackup *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemBackup))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemBackup(struct soap *soap, const char *tag, int id, _tds__GetSystemBackup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemBackup);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetSystemBackup ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemBackup(struct soap *soap, const char *tag, _tds__GetSystemBackup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemBackup **)soap_malloc(soap, sizeof(_tds__GetSystemBackup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemBackup *)soap_instantiate__tds__GetSystemBackup(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetSystemBackup ** p = (_tds__GetSystemBackup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemBackup, sizeof(_tds__GetSystemBackup), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemBackup(struct soap *soap, _tds__GetSystemBackup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemBackup);
	if (soap_out_PointerTo_tds__GetSystemBackup(soap, tag?tag:"tds:GetSystemBackup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemBackup ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemBackup(struct soap *soap, _tds__GetSystemBackup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemBackup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RestoreSystemResponse(struct soap *soap, _tds__RestoreSystemResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RestoreSystemResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RestoreSystemResponse(struct soap *soap, const char *tag, int id, _tds__RestoreSystemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RestoreSystemResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__RestoreSystemResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__RestoreSystemResponse(struct soap *soap, const char *tag, _tds__RestoreSystemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__RestoreSystemResponse **)soap_malloc(soap, sizeof(_tds__RestoreSystemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__RestoreSystemResponse *)soap_instantiate__tds__RestoreSystemResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__RestoreSystemResponse ** p = (_tds__RestoreSystemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RestoreSystemResponse, sizeof(_tds__RestoreSystemResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RestoreSystemResponse(struct soap *soap, _tds__RestoreSystemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RestoreSystemResponse);
	if (soap_out_PointerTo_tds__RestoreSystemResponse(soap, tag?tag:"tds:RestoreSystemResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__RestoreSystemResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__RestoreSystemResponse(struct soap *soap, _tds__RestoreSystemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RestoreSystemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RestoreSystem(struct soap *soap, _tds__RestoreSystem *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RestoreSystem))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RestoreSystem(struct soap *soap, const char *tag, int id, _tds__RestoreSystem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RestoreSystem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__RestoreSystem ** SOAP_FMAC4 soap_in_PointerTo_tds__RestoreSystem(struct soap *soap, const char *tag, _tds__RestoreSystem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__RestoreSystem **)soap_malloc(soap, sizeof(_tds__RestoreSystem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__RestoreSystem *)soap_instantiate__tds__RestoreSystem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__RestoreSystem ** p = (_tds__RestoreSystem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RestoreSystem, sizeof(_tds__RestoreSystem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RestoreSystem(struct soap *soap, _tds__RestoreSystem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RestoreSystem);
	if (soap_out_PointerTo_tds__RestoreSystem(soap, tag?tag:"tds:RestoreSystem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__RestoreSystem ** SOAP_FMAC4 soap_get_PointerTo_tds__RestoreSystem(struct soap *soap, _tds__RestoreSystem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RestoreSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SystemRebootResponse(struct soap *soap, _tds__SystemRebootResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SystemRebootResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SystemRebootResponse(struct soap *soap, const char *tag, int id, _tds__SystemRebootResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SystemRebootResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SystemRebootResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SystemRebootResponse(struct soap *soap, const char *tag, _tds__SystemRebootResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SystemRebootResponse **)soap_malloc(soap, sizeof(_tds__SystemRebootResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SystemRebootResponse *)soap_instantiate__tds__SystemRebootResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SystemRebootResponse ** p = (_tds__SystemRebootResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SystemRebootResponse, sizeof(_tds__SystemRebootResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SystemRebootResponse(struct soap *soap, _tds__SystemRebootResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SystemRebootResponse);
	if (soap_out_PointerTo_tds__SystemRebootResponse(soap, tag?tag:"tds:SystemRebootResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SystemRebootResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SystemRebootResponse(struct soap *soap, _tds__SystemRebootResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SystemRebootResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SystemReboot(struct soap *soap, _tds__SystemReboot *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SystemReboot))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SystemReboot(struct soap *soap, const char *tag, int id, _tds__SystemReboot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SystemReboot);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SystemReboot ** SOAP_FMAC4 soap_in_PointerTo_tds__SystemReboot(struct soap *soap, const char *tag, _tds__SystemReboot **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SystemReboot **)soap_malloc(soap, sizeof(_tds__SystemReboot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SystemReboot *)soap_instantiate__tds__SystemReboot(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SystemReboot ** p = (_tds__SystemReboot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SystemReboot, sizeof(_tds__SystemReboot), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SystemReboot(struct soap *soap, _tds__SystemReboot *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SystemReboot);
	if (soap_out_PointerTo_tds__SystemReboot(soap, tag?tag:"tds:SystemReboot", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SystemReboot ** SOAP_FMAC4 soap_get_PointerTo_tds__SystemReboot(struct soap *soap, _tds__SystemReboot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, _tds__UpgradeSystemFirmwareResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, const char *tag, int id, _tds__UpgradeSystemFirmwareResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__UpgradeSystemFirmwareResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, const char *tag, _tds__UpgradeSystemFirmwareResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__UpgradeSystemFirmwareResponse **)soap_malloc(soap, sizeof(_tds__UpgradeSystemFirmwareResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__UpgradeSystemFirmwareResponse *)soap_instantiate__tds__UpgradeSystemFirmwareResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__UpgradeSystemFirmwareResponse ** p = (_tds__UpgradeSystemFirmwareResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, sizeof(_tds__UpgradeSystemFirmwareResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, _tds__UpgradeSystemFirmwareResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__UpgradeSystemFirmwareResponse);
	if (soap_out_PointerTo_tds__UpgradeSystemFirmwareResponse(soap, tag?tag:"tds:UpgradeSystemFirmwareResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__UpgradeSystemFirmwareResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, _tds__UpgradeSystemFirmwareResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__UpgradeSystemFirmwareResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, _tds__UpgradeSystemFirmware *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__UpgradeSystemFirmware))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, int id, _tds__UpgradeSystemFirmware *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__UpgradeSystemFirmware);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__UpgradeSystemFirmware ** SOAP_FMAC4 soap_in_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, _tds__UpgradeSystemFirmware **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__UpgradeSystemFirmware **)soap_malloc(soap, sizeof(_tds__UpgradeSystemFirmware *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__UpgradeSystemFirmware *)soap_instantiate__tds__UpgradeSystemFirmware(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__UpgradeSystemFirmware ** p = (_tds__UpgradeSystemFirmware **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__UpgradeSystemFirmware, sizeof(_tds__UpgradeSystemFirmware), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, _tds__UpgradeSystemFirmware *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__UpgradeSystemFirmware);
	if (soap_out_PointerTo_tds__UpgradeSystemFirmware(soap, tag?tag:"tds:UpgradeSystemFirmware", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__UpgradeSystemFirmware ** SOAP_FMAC4 soap_get_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, _tds__UpgradeSystemFirmware **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__UpgradeSystemFirmware(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, _tds__SetSystemFactoryDefaultResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, int id, _tds__SetSystemFactoryDefaultResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetSystemFactoryDefaultResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, _tds__SetSystemFactoryDefaultResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetSystemFactoryDefaultResponse **)soap_malloc(soap, sizeof(_tds__SetSystemFactoryDefaultResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetSystemFactoryDefaultResponse *)soap_instantiate__tds__SetSystemFactoryDefaultResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetSystemFactoryDefaultResponse ** p = (_tds__SetSystemFactoryDefaultResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, sizeof(_tds__SetSystemFactoryDefaultResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, _tds__SetSystemFactoryDefaultResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetSystemFactoryDefaultResponse);
	if (soap_out_PointerTo_tds__SetSystemFactoryDefaultResponse(soap, tag?tag:"tds:SetSystemFactoryDefaultResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetSystemFactoryDefaultResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, _tds__SetSystemFactoryDefaultResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemFactoryDefaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, _tds__SetSystemFactoryDefault *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemFactoryDefault))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, _tds__SetSystemFactoryDefault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemFactoryDefault);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetSystemFactoryDefault ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, _tds__SetSystemFactoryDefault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetSystemFactoryDefault **)soap_malloc(soap, sizeof(_tds__SetSystemFactoryDefault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetSystemFactoryDefault *)soap_instantiate__tds__SetSystemFactoryDefault(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetSystemFactoryDefault ** p = (_tds__SetSystemFactoryDefault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(_tds__SetSystemFactoryDefault), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, _tds__SetSystemFactoryDefault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetSystemFactoryDefault);
	if (soap_out_PointerTo_tds__SetSystemFactoryDefault(soap, tag?tag:"tds:SetSystemFactoryDefault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetSystemFactoryDefault ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, _tds__SetSystemFactoryDefault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, _tds__GetSystemDateAndTimeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, _tds__GetSystemDateAndTimeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemDateAndTimeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, _tds__GetSystemDateAndTimeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemDateAndTimeResponse **)soap_malloc(soap, sizeof(_tds__GetSystemDateAndTimeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemDateAndTimeResponse *)soap_instantiate__tds__GetSystemDateAndTimeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetSystemDateAndTimeResponse ** p = (_tds__GetSystemDateAndTimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, sizeof(_tds__GetSystemDateAndTimeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, _tds__GetSystemDateAndTimeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemDateAndTimeResponse);
	if (soap_out_PointerTo_tds__GetSystemDateAndTimeResponse(soap, tag?tag:"tds:GetSystemDateAndTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, _tds__GetSystemDateAndTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, _tds__GetSystemDateAndTime *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemDateAndTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, _tds__GetSystemDateAndTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemDateAndTime);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetSystemDateAndTime ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, const char *tag, _tds__GetSystemDateAndTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetSystemDateAndTime **)soap_malloc(soap, sizeof(_tds__GetSystemDateAndTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetSystemDateAndTime *)soap_instantiate__tds__GetSystemDateAndTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetSystemDateAndTime ** p = (_tds__GetSystemDateAndTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(_tds__GetSystemDateAndTime), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, _tds__GetSystemDateAndTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemDateAndTime);
	if (soap_out_PointerTo_tds__GetSystemDateAndTime(soap, tag?tag:"tds:GetSystemDateAndTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetSystemDateAndTime ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, _tds__GetSystemDateAndTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, _tds__SetSystemDateAndTimeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, _tds__SetSystemDateAndTimeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemDateAndTimeResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, _tds__SetSystemDateAndTimeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetSystemDateAndTimeResponse **)soap_malloc(soap, sizeof(_tds__SetSystemDateAndTimeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetSystemDateAndTimeResponse *)soap_instantiate__tds__SetSystemDateAndTimeResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetSystemDateAndTimeResponse ** p = (_tds__SetSystemDateAndTimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, sizeof(_tds__SetSystemDateAndTimeResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, _tds__SetSystemDateAndTimeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetSystemDateAndTimeResponse);
	if (soap_out_PointerTo_tds__SetSystemDateAndTimeResponse(soap, tag?tag:"tds:SetSystemDateAndTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, _tds__SetSystemDateAndTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, _tds__SetSystemDateAndTime *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemDateAndTime))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, _tds__SetSystemDateAndTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemDateAndTime);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__SetSystemDateAndTime ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, const char *tag, _tds__SetSystemDateAndTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__SetSystemDateAndTime **)soap_malloc(soap, sizeof(_tds__SetSystemDateAndTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__SetSystemDateAndTime *)soap_instantiate__tds__SetSystemDateAndTime(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__SetSystemDateAndTime ** p = (_tds__SetSystemDateAndTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(_tds__SetSystemDateAndTime), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, _tds__SetSystemDateAndTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetSystemDateAndTime);
	if (soap_out_PointerTo_tds__SetSystemDateAndTime(soap, tag?tag:"tds:SetSystemDateAndTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__SetSystemDateAndTime ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, _tds__SetSystemDateAndTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, _tds__GetDeviceInformationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDeviceInformationResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, int id, _tds__GetDeviceInformationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDeviceInformationResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetDeviceInformationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, _tds__GetDeviceInformationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDeviceInformationResponse **)soap_malloc(soap, sizeof(_tds__GetDeviceInformationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDeviceInformationResponse *)soap_instantiate__tds__GetDeviceInformationResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetDeviceInformationResponse ** p = (_tds__GetDeviceInformationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(_tds__GetDeviceInformationResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, _tds__GetDeviceInformationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDeviceInformationResponse);
	if (soap_out_PointerTo_tds__GetDeviceInformationResponse(soap, tag?tag:"tds:GetDeviceInformationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDeviceInformationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, _tds__GetDeviceInformationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDeviceInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDeviceInformation(struct soap *soap, _tds__GetDeviceInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDeviceInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, _tds__GetDeviceInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDeviceInformation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetDeviceInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDeviceInformation(struct soap *soap, const char *tag, _tds__GetDeviceInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetDeviceInformation **)soap_malloc(soap, sizeof(_tds__GetDeviceInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetDeviceInformation *)soap_instantiate__tds__GetDeviceInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetDeviceInformation ** p = (_tds__GetDeviceInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDeviceInformation, sizeof(_tds__GetDeviceInformation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDeviceInformation(struct soap *soap, _tds__GetDeviceInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDeviceInformation);
	if (soap_out_PointerTo_tds__GetDeviceInformation(soap, tag?tag:"tds:GetDeviceInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetDeviceInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDeviceInformation(struct soap *soap, _tds__GetDeviceInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, _tds__GetServiceCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, _tds__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, _tds__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(_tds__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetServiceCapabilitiesResponse *)soap_instantiate__tds__GetServiceCapabilitiesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetServiceCapabilitiesResponse ** p = (_tds__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, sizeof(_tds__GetServiceCapabilitiesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, _tds__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_tds__GetServiceCapabilitiesResponse(soap, tag?tag:"tds:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, _tds__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServiceCapabilities(struct soap *soap, _tds__GetServiceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServiceCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, _tds__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServiceCapabilities(struct soap *soap, const char *tag, _tds__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetServiceCapabilities **)soap_malloc(soap, sizeof(_tds__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetServiceCapabilities *)soap_instantiate__tds__GetServiceCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetServiceCapabilities ** p = (_tds__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(_tds__GetServiceCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServiceCapabilities(struct soap *soap, _tds__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetServiceCapabilities);
	if (soap_out_PointerTo_tds__GetServiceCapabilities(soap, tag?tag:"tds:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServiceCapabilities(struct soap *soap, _tds__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServicesResponse(struct soap *soap, _tds__GetServicesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServicesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServicesResponse(struct soap *soap, const char *tag, int id, _tds__GetServicesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServicesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetServicesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServicesResponse(struct soap *soap, const char *tag, _tds__GetServicesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetServicesResponse **)soap_malloc(soap, sizeof(_tds__GetServicesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetServicesResponse *)soap_instantiate__tds__GetServicesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetServicesResponse ** p = (_tds__GetServicesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServicesResponse, sizeof(_tds__GetServicesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServicesResponse(struct soap *soap, _tds__GetServicesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetServicesResponse);
	if (soap_out_PointerTo_tds__GetServicesResponse(soap, tag?tag:"tds:GetServicesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetServicesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServicesResponse(struct soap *soap, _tds__GetServicesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServices(struct soap *soap, _tds__GetServices *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServices))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServices(struct soap *soap, const char *tag, int id, _tds__GetServices *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServices);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _tds__GetServices ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServices(struct soap *soap, const char *tag, _tds__GetServices **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_tds__GetServices **)soap_malloc(soap, sizeof(_tds__GetServices *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_tds__GetServices *)soap_instantiate__tds__GetServices(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_tds__GetServices ** p = (_tds__GetServices **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServices, sizeof(_tds__GetServices), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServices(struct soap *soap, _tds__GetServices *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetServices);
	if (soap_out_PointerTo_tds__GetServices(soap, tag?tag:"tds:GetServices", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _tds__GetServices ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServices(struct soap *soap, _tds__GetServices **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, _wstop__TopicNamespaceType_Topic *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wstop__TopicNamespaceType_Topic))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, _wstop__TopicNamespaceType_Topic *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wstop__TopicNamespaceType_Topic);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _wstop__TopicNamespaceType_Topic ** SOAP_FMAC4 soap_in_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, _wstop__TopicNamespaceType_Topic **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wstop__TopicNamespaceType_Topic **)soap_malloc(soap, sizeof(_wstop__TopicNamespaceType_Topic *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wstop__TopicNamespaceType_Topic *)soap_instantiate__wstop__TopicNamespaceType_Topic(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_wstop__TopicNamespaceType_Topic ** p = (_wstop__TopicNamespaceType_Topic **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(_wstop__TopicNamespaceType_Topic), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, _wstop__TopicNamespaceType_Topic *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wstop__TopicNamespaceType_Topic);
	if (soap_out_PointerTo_wstop__TopicNamespaceType_Topic(soap, tag?tag:"wstop:TopicNamespaceType-Topic", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wstop__TopicNamespaceType_Topic ** SOAP_FMAC4 soap_get_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, _wstop__TopicNamespaceType_Topic **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wstop__TopicNamespaceType_Topic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTowstop__TopicType(struct soap *soap, wstop__TopicType **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTowstop__TopicType))
		soap_serialize_PointerTowstop__TopicType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTowstop__TopicType(struct soap *soap, const char *tag, int id, wstop__TopicType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTowstop__TopicType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTowstop__TopicType(soap, tag, id, *a, type);
}

SOAP_FMAC3 wstop__TopicType *** SOAP_FMAC4 soap_in_PointerToPointerTowstop__TopicType(struct soap *soap, const char *tag, wstop__TopicType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__TopicType ***)soap_malloc(soap, sizeof(wstop__TopicType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTowstop__TopicType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (wstop__TopicType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTowstop__TopicType, sizeof(wstop__TopicType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTowstop__TopicType(struct soap *soap, wstop__TopicType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTowstop__TopicType);
	if (soap_out_PointerToPointerTowstop__TopicType(soap, tag?tag:"wstop:TopicType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__TopicType *** SOAP_FMAC4 soap_get_PointerToPointerTowstop__TopicType(struct soap *soap, wstop__TopicType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTowstop__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicType(struct soap *soap, wstop__TopicType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicType(struct soap *soap, const char *tag, int id, wstop__TopicType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 wstop__TopicType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicType(struct soap *soap, const char *tag, wstop__TopicType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__TopicType **)soap_malloc(soap, sizeof(wstop__TopicType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__TopicType *)soap_instantiate_wstop__TopicType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	wstop__TopicType ** p = (wstop__TopicType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicType, sizeof(wstop__TopicType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicType(struct soap *soap, wstop__TopicType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowstop__TopicType);
	if (soap_out_PointerTowstop__TopicType(soap, tag?tag:"wstop:TopicType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__TopicType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicType(struct soap *soap, wstop__TopicType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__QueryExpressionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, int id, wstop__QueryExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__QueryExpressionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 wstop__QueryExpressionType ** SOAP_FMAC4 soap_in_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, wstop__QueryExpressionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__QueryExpressionType **)soap_malloc(soap, sizeof(wstop__QueryExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__QueryExpressionType *)soap_instantiate_wstop__QueryExpressionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	wstop__QueryExpressionType ** p = (wstop__QueryExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(wstop__QueryExpressionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowstop__QueryExpressionType);
	if (soap_out_PointerTowstop__QueryExpressionType(soap, tag?tag:"wstop:QueryExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__QueryExpressionType ** SOAP_FMAC4 soap_get_PointerTowstop__QueryExpressionType(struct soap *soap, wstop__QueryExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataInput(struct soap *soap, tt__MetadataInput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataInput))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataInput(struct soap *soap, const char *tag, int id, tt__MetadataInput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataInput);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__MetadataInput ** SOAP_FMAC4 soap_in_PointerTott__MetadataInput(struct soap *soap, const char *tag, tt__MetadataInput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MetadataInput **)soap_malloc(soap, sizeof(tt__MetadataInput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MetadataInput *)soap_instantiate_tt__MetadataInput(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__MetadataInput ** p = (tt__MetadataInput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataInput, sizeof(tt__MetadataInput), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataInput(struct soap *soap, tt__MetadataInput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MetadataInput);
	if (soap_out_PointerTott__MetadataInput(soap, tag?tag:"tt:MetadataInput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MetadataInput ** SOAP_FMAC4 soap_get_PointerTott__MetadataInput(struct soap *soap, tt__MetadataInput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SourceIdentification(struct soap *soap, tt__SourceIdentification *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SourceIdentification))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SourceIdentification(struct soap *soap, const char *tag, int id, tt__SourceIdentification *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SourceIdentification);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__SourceIdentification ** SOAP_FMAC4 soap_in_PointerTott__SourceIdentification(struct soap *soap, const char *tag, tt__SourceIdentification **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SourceIdentification **)soap_malloc(soap, sizeof(tt__SourceIdentification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SourceIdentification *)soap_instantiate_tt__SourceIdentification(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__SourceIdentification ** p = (tt__SourceIdentification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SourceIdentification, sizeof(tt__SourceIdentification), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SourceIdentification(struct soap *soap, tt__SourceIdentification *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SourceIdentification);
	if (soap_out_PointerTott__SourceIdentification(soap, tag?tag:"tt:SourceIdentification", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SourceIdentification ** SOAP_FMAC4 soap_get_PointerTott__SourceIdentification(struct soap *soap, tt__SourceIdentification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SourceIdentification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, tt__AnalyticsDeviceEngineConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, int id, tt__AnalyticsDeviceEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AnalyticsDeviceEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, tt__AnalyticsDeviceEngineConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsDeviceEngineConfiguration **)soap_malloc(soap, sizeof(tt__AnalyticsDeviceEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsDeviceEngineConfiguration *)soap_instantiate_tt__AnalyticsDeviceEngineConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AnalyticsDeviceEngineConfiguration ** p = (tt__AnalyticsDeviceEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, sizeof(tt__AnalyticsDeviceEngineConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, tt__AnalyticsDeviceEngineConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsDeviceEngineConfiguration);
	if (soap_out_PointerTott__AnalyticsDeviceEngineConfiguration(soap, tag?tag:"tt:AnalyticsDeviceEngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsDeviceEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, tt__AnalyticsDeviceEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsDeviceEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ObjectExtension(struct soap *soap, tt__ObjectExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ObjectExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ObjectExtension(struct soap *soap, const char *tag, int id, tt__ObjectExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ObjectExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ObjectExtension ** SOAP_FMAC4 soap_in_PointerTott__ObjectExtension(struct soap *soap, const char *tag, tt__ObjectExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ObjectExtension **)soap_malloc(soap, sizeof(tt__ObjectExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ObjectExtension *)soap_instantiate_tt__ObjectExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ObjectExtension ** p = (tt__ObjectExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ObjectExtension, sizeof(tt__ObjectExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ObjectExtension(struct soap *soap, tt__ObjectExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ObjectExtension);
	if (soap_out_PointerTott__ObjectExtension(soap, tag?tag:"tt:ObjectExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ObjectExtension ** SOAP_FMAC4 soap_get_PointerTott__ObjectExtension(struct soap *soap, tt__ObjectExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ObjectExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Behaviour(struct soap *soap, tt__Behaviour *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Behaviour))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Behaviour(struct soap *soap, const char *tag, int id, tt__Behaviour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Behaviour);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Behaviour ** SOAP_FMAC4 soap_in_PointerTott__Behaviour(struct soap *soap, const char *tag, tt__Behaviour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Behaviour **)soap_malloc(soap, sizeof(tt__Behaviour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Behaviour *)soap_instantiate_tt__Behaviour(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Behaviour ** p = (tt__Behaviour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Behaviour, sizeof(tt__Behaviour), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Behaviour(struct soap *soap, tt__Behaviour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Behaviour);
	if (soap_out_PointerTott__Behaviour(soap, tag?tag:"tt:Behaviour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Behaviour ** SOAP_FMAC4 soap_get_PointerTott__Behaviour(struct soap *soap, tt__Behaviour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Behaviour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Appearance(struct soap *soap, tt__Appearance *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Appearance))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Appearance(struct soap *soap, const char *tag, int id, tt__Appearance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Appearance);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Appearance ** SOAP_FMAC4 soap_in_PointerTott__Appearance(struct soap *soap, const char *tag, tt__Appearance **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Appearance **)soap_malloc(soap, sizeof(tt__Appearance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Appearance *)soap_instantiate_tt__Appearance(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Appearance ** p = (tt__Appearance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Appearance, sizeof(tt__Appearance), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Appearance(struct soap *soap, tt__Appearance *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Appearance);
	if (soap_out_PointerTott__Appearance(soap, tag?tag:"tt:Appearance", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Appearance ** SOAP_FMAC4 soap_get_PointerTott__Appearance(struct soap *soap, tt__Appearance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Appearance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, tt__PTZConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, tt__PTZConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZConfigurationExtension **)soap_malloc(soap, sizeof(tt__PTZConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZConfigurationExtension *)soap_instantiate_tt__PTZConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZConfigurationExtension ** p = (tt__PTZConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(tt__PTZConfigurationExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZConfigurationExtension);
	if (soap_out_PointerTott__PTZConfigurationExtension(soap, tag?tag:"tt:PTZConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationExtension(struct soap *soap, tt__PTZConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ZoomLimits(struct soap *soap, tt__ZoomLimits *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ZoomLimits))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ZoomLimits(struct soap *soap, const char *tag, int id, tt__ZoomLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ZoomLimits);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ZoomLimits ** SOAP_FMAC4 soap_in_PointerTott__ZoomLimits(struct soap *soap, const char *tag, tt__ZoomLimits **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ZoomLimits **)soap_malloc(soap, sizeof(tt__ZoomLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ZoomLimits *)soap_instantiate_tt__ZoomLimits(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ZoomLimits ** p = (tt__ZoomLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ZoomLimits, sizeof(tt__ZoomLimits), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ZoomLimits(struct soap *soap, tt__ZoomLimits *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ZoomLimits);
	if (soap_out_PointerTott__ZoomLimits(soap, tag?tag:"tt:ZoomLimits", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ZoomLimits ** SOAP_FMAC4 soap_get_PointerTott__ZoomLimits(struct soap *soap, tt__ZoomLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PanTiltLimits))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, int id, tt__PanTiltLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PanTiltLimits);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PanTiltLimits ** SOAP_FMAC4 soap_in_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, tt__PanTiltLimits **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PanTiltLimits **)soap_malloc(soap, sizeof(tt__PanTiltLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PanTiltLimits *)soap_instantiate_tt__PanTiltLimits(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PanTiltLimits ** p = (tt__PanTiltLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PanTiltLimits, sizeof(tt__PanTiltLimits), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PanTiltLimits(struct soap *soap, tt__PanTiltLimits *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PanTiltLimits);
	if (soap_out_PointerTott__PanTiltLimits(soap, tag?tag:"tt:PanTiltLimits", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PanTiltLimits ** SOAP_FMAC4 soap_get_PointerTott__PanTiltLimits(struct soap *soap, tt__PanTiltLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZNodeExtension(struct soap *soap, tt__PTZNodeExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZNodeExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZNodeExtension(struct soap *soap, const char *tag, int id, tt__PTZNodeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZNodeExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZNodeExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZNodeExtension(struct soap *soap, const char *tag, tt__PTZNodeExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZNodeExtension **)soap_malloc(soap, sizeof(tt__PTZNodeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZNodeExtension *)soap_instantiate_tt__PTZNodeExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZNodeExtension ** p = (tt__PTZNodeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZNodeExtension, sizeof(tt__PTZNodeExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZNodeExtension(struct soap *soap, tt__PTZNodeExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZNodeExtension);
	if (soap_out_PointerTott__PTZNodeExtension(soap, tag?tag:"tt:PTZNodeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZNodeExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZNodeExtension(struct soap *soap, tt__PTZNodeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZNodeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, tt__NetworkInterfaceExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceExtension **)soap_malloc(soap, sizeof(tt__NetworkInterfaceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceExtension *)soap_instantiate_tt__NetworkInterfaceExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__NetworkInterfaceExtension ** p = (tt__NetworkInterfaceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(tt__NetworkInterfaceExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceExtension);
	if (soap_out_PointerTott__NetworkInterfaceExtension(soap, tag?tag:"tt:NetworkInterfaceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceExtension(struct soap *soap, tt__NetworkInterfaceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6NetworkInterface))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, int id, tt__IPv6NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6NetworkInterface);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, tt__IPv6NetworkInterface **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv6NetworkInterface **)soap_malloc(soap, sizeof(tt__IPv6NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv6NetworkInterface *)soap_instantiate_tt__IPv6NetworkInterface(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__IPv6NetworkInterface ** p = (tt__IPv6NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(tt__IPv6NetworkInterface), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6NetworkInterface);
	if (soap_out_PointerTott__IPv6NetworkInterface(soap, tag?tag:"tt:IPv6NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv6NetworkInterface(struct soap *soap, tt__IPv6NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4NetworkInterface))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, int id, tt__IPv4NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4NetworkInterface);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, tt__IPv4NetworkInterface **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IPv4NetworkInterface **)soap_malloc(soap, sizeof(tt__IPv4NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IPv4NetworkInterface *)soap_instantiate_tt__IPv4NetworkInterface(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__IPv4NetworkInterface ** p = (tt__IPv4NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(tt__IPv4NetworkInterface), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv4NetworkInterface);
	if (soap_out_PointerTott__IPv4NetworkInterface(soap, tag?tag:"tt:IPv4NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv4NetworkInterface(struct soap *soap, tt__IPv4NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceLink))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceLink);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, tt__NetworkInterfaceLink **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceLink **)soap_malloc(soap, sizeof(tt__NetworkInterfaceLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceLink *)soap_instantiate_tt__NetworkInterfaceLink(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__NetworkInterfaceLink ** p = (tt__NetworkInterfaceLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(tt__NetworkInterfaceLink), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceLink);
	if (soap_out_PointerTott__NetworkInterfaceLink(soap, tag?tag:"tt:NetworkInterfaceLink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceLink(struct soap *soap, tt__NetworkInterfaceLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, int id, tt__NetworkInterfaceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, tt__NetworkInterfaceInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__NetworkInterfaceInfo **)soap_malloc(soap, sizeof(tt__NetworkInterfaceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__NetworkInterfaceInfo *)soap_instantiate_tt__NetworkInterfaceInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__NetworkInterfaceInfo ** p = (tt__NetworkInterfaceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(tt__NetworkInterfaceInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceInfo);
	if (soap_out_PointerTott__NetworkInterfaceInfo(soap, tag?tag:"tt:NetworkInterfaceInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceInfo(struct soap *soap, tt__NetworkInterfaceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoOutputExtension(struct soap *soap, tt__VideoOutputExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoOutputExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoOutputExtension(struct soap *soap, const char *tag, int id, tt__VideoOutputExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoOutputExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__VideoOutputExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoOutputExtension(struct soap *soap, const char *tag, tt__VideoOutputExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoOutputExtension **)soap_malloc(soap, sizeof(tt__VideoOutputExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoOutputExtension *)soap_instantiate_tt__VideoOutputExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__VideoOutputExtension ** p = (tt__VideoOutputExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoOutputExtension, sizeof(tt__VideoOutputExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoOutputExtension(struct soap *soap, tt__VideoOutputExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoOutputExtension);
	if (soap_out_PointerTott__VideoOutputExtension(soap, tag?tag:"tt:VideoOutputExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoOutputExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoOutputExtension(struct soap *soap, tt__VideoOutputExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoOutputExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Layout(struct soap *soap, tt__Layout *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Layout))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Layout(struct soap *soap, const char *tag, int id, tt__Layout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Layout);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Layout ** SOAP_FMAC4 soap_in_PointerTott__Layout(struct soap *soap, const char *tag, tt__Layout **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Layout **)soap_malloc(soap, sizeof(tt__Layout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Layout *)soap_instantiate_tt__Layout(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Layout ** p = (tt__Layout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Layout, sizeof(tt__Layout), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Layout(struct soap *soap, tt__Layout *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Layout);
	if (soap_out_PointerTott__Layout(soap, tag?tag:"tt:Layout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Layout ** SOAP_FMAC4 soap_get_PointerTott__Layout(struct soap *soap, tt__Layout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Layout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfigurationExtension(struct soap *soap, const char *tag, int id, tt__MetadataConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfigurationExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__MetadataConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfigurationExtension(struct soap *soap, const char *tag, tt__MetadataConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MetadataConfigurationExtension **)soap_malloc(soap, sizeof(tt__MetadataConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MetadataConfigurationExtension *)soap_instantiate_tt__MetadataConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__MetadataConfigurationExtension ** p = (tt__MetadataConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationExtension, sizeof(tt__MetadataConfigurationExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MetadataConfigurationExtension);
	if (soap_out_PointerTott__MetadataConfigurationExtension(soap, tag?tag:"tt:MetadataConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MetadataConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfigurationExtension(struct soap *soap, tt__MetadataConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventSubscription(struct soap *soap, tt__EventSubscription *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventSubscription))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventSubscription(struct soap *soap, const char *tag, int id, tt__EventSubscription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventSubscription);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__EventSubscription ** SOAP_FMAC4 soap_in_PointerTott__EventSubscription(struct soap *soap, const char *tag, tt__EventSubscription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EventSubscription **)soap_malloc(soap, sizeof(tt__EventSubscription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EventSubscription *)soap_instantiate_tt__EventSubscription(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__EventSubscription ** p = (tt__EventSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventSubscription, sizeof(tt__EventSubscription), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventSubscription(struct soap *soap, tt__EventSubscription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__EventSubscription);
	if (soap_out_PointerTott__EventSubscription(soap, tag?tag:"tt:EventSubscription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EventSubscription ** SOAP_FMAC4 soap_get_PointerTott__EventSubscription(struct soap *soap, tt__EventSubscription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZFilter(struct soap *soap, tt__PTZFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZFilter))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZFilter(struct soap *soap, const char *tag, int id, tt__PTZFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZFilter);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZFilter ** SOAP_FMAC4 soap_in_PointerTott__PTZFilter(struct soap *soap, const char *tag, tt__PTZFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZFilter **)soap_malloc(soap, sizeof(tt__PTZFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZFilter *)soap_instantiate_tt__PTZFilter(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZFilter ** p = (tt__PTZFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZFilter, sizeof(tt__PTZFilter), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZFilter(struct soap *soap, tt__PTZFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZFilter);
	if (soap_out_PointerTott__PTZFilter(soap, tag?tag:"tt:PTZFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZFilter ** SOAP_FMAC4 soap_get_PointerTott__PTZFilter(struct soap *soap, tt__PTZFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RuleEngineConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RuleEngineConfiguration(struct soap *soap, const char *tag, int id, tt__RuleEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RuleEngineConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RuleEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__RuleEngineConfiguration(struct soap *soap, const char *tag, tt__RuleEngineConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RuleEngineConfiguration **)soap_malloc(soap, sizeof(tt__RuleEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RuleEngineConfiguration *)soap_instantiate_tt__RuleEngineConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RuleEngineConfiguration ** p = (tt__RuleEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(tt__RuleEngineConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RuleEngineConfiguration);
	if (soap_out_PointerTott__RuleEngineConfiguration(soap, tag?tag:"tt:RuleEngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RuleEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__RuleEngineConfiguration(struct soap *soap, tt__RuleEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RuleEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, int id, tt__AnalyticsEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, tt__AnalyticsEngineConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsEngineConfiguration **)soap_malloc(soap, sizeof(tt__AnalyticsEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsEngineConfiguration *)soap_instantiate_tt__AnalyticsEngineConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AnalyticsEngineConfiguration ** p = (tt__AnalyticsEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(tt__AnalyticsEngineConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsEngineConfiguration);
	if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, tag?tag:"tt:AnalyticsEngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, tt__AnalyticsEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MulticastConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, int id, tt__MulticastConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MulticastConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__MulticastConfiguration ** SOAP_FMAC4 soap_in_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, tt__MulticastConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MulticastConfiguration **)soap_malloc(soap, sizeof(tt__MulticastConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MulticastConfiguration *)soap_instantiate_tt__MulticastConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__MulticastConfiguration ** p = (tt__MulticastConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(tt__MulticastConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MulticastConfiguration);
	if (soap_out_PointerTott__MulticastConfiguration(soap, tag?tag:"tt:MulticastConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MulticastConfiguration ** SOAP_FMAC4 soap_get_PointerTott__MulticastConfiguration(struct soap *soap, tt__MulticastConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MulticastConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Configuration(struct soap *soap, tt__H264Configuration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Configuration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Configuration(struct soap *soap, const char *tag, int id, tt__H264Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Configuration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__H264Configuration ** SOAP_FMAC4 soap_in_PointerTott__H264Configuration(struct soap *soap, const char *tag, tt__H264Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__H264Configuration **)soap_malloc(soap, sizeof(tt__H264Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__H264Configuration *)soap_instantiate_tt__H264Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__H264Configuration ** p = (tt__H264Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Configuration, sizeof(tt__H264Configuration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Configuration(struct soap *soap, tt__H264Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__H264Configuration);
	if (soap_out_PointerTott__H264Configuration(soap, tag?tag:"tt:H264Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__H264Configuration ** SOAP_FMAC4 soap_get_PointerTott__H264Configuration(struct soap *soap, tt__H264Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Configuration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, int id, tt__Mpeg4Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Configuration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Mpeg4Configuration ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, tt__Mpeg4Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Mpeg4Configuration **)soap_malloc(soap, sizeof(tt__Mpeg4Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Mpeg4Configuration *)soap_instantiate_tt__Mpeg4Configuration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Mpeg4Configuration ** p = (tt__Mpeg4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(tt__Mpeg4Configuration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Mpeg4Configuration);
	if (soap_out_PointerTott__Mpeg4Configuration(soap, tag?tag:"tt:Mpeg4Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Mpeg4Configuration ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoRateControl(struct soap *soap, tt__VideoRateControl *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoRateControl))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoRateControl(struct soap *soap, const char *tag, int id, tt__VideoRateControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoRateControl);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__VideoRateControl ** SOAP_FMAC4 soap_in_PointerTott__VideoRateControl(struct soap *soap, const char *tag, tt__VideoRateControl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoRateControl **)soap_malloc(soap, sizeof(tt__VideoRateControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoRateControl *)soap_instantiate_tt__VideoRateControl(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__VideoRateControl ** p = (tt__VideoRateControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoRateControl, sizeof(tt__VideoRateControl), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoRateControl(struct soap *soap, tt__VideoRateControl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoRateControl);
	if (soap_out_PointerTott__VideoRateControl(soap, tag?tag:"tt:VideoRateControl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoRateControl ** SOAP_FMAC4 soap_get_PointerTott__VideoRateControl(struct soap *soap, tt__VideoRateControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoRateControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, int id, tt__VideoSourceConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, tt__VideoSourceConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSourceConfigurationExtension **)soap_malloc(soap, sizeof(tt__VideoSourceConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSourceConfigurationExtension *)soap_instantiate_tt__VideoSourceConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__VideoSourceConfigurationExtension ** p = (tt__VideoSourceConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationExtension, sizeof(tt__VideoSourceConfigurationExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension);
	if (soap_out_PointerTott__VideoSourceConfigurationExtension(soap, tag?tag:"tt:VideoSourceConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRectangle(struct soap *soap, tt__IntRectangle *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRectangle))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRectangle(struct soap *soap, const char *tag, int id, tt__IntRectangle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRectangle);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__IntRectangle ** SOAP_FMAC4 soap_in_PointerTott__IntRectangle(struct soap *soap, const char *tag, tt__IntRectangle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__IntRectangle **)soap_malloc(soap, sizeof(tt__IntRectangle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__IntRectangle *)soap_instantiate_tt__IntRectangle(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__IntRectangle ** p = (tt__IntRectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRectangle, sizeof(tt__IntRectangle), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRectangle(struct soap *soap, tt__IntRectangle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IntRectangle);
	if (soap_out_PointerTott__IntRectangle(soap, tag?tag:"tt:IntRectangle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__IntRectangle ** SOAP_FMAC4 soap_get_PointerTott__IntRectangle(struct soap *soap, tt__IntRectangle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceExtension(struct soap *soap, tt__VideoSourceExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceExtension(struct soap *soap, const char *tag, int id, tt__VideoSourceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__VideoSourceExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceExtension(struct soap *soap, const char *tag, tt__VideoSourceExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSourceExtension **)soap_malloc(soap, sizeof(tt__VideoSourceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSourceExtension *)soap_instantiate_tt__VideoSourceExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__VideoSourceExtension ** p = (tt__VideoSourceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceExtension, sizeof(tt__VideoSourceExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceExtension(struct soap *soap, tt__VideoSourceExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoSourceExtension);
	if (soap_out_PointerTott__VideoSourceExtension(soap, tag?tag:"tt:VideoSourceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSourceExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceExtension(struct soap *soap, tt__VideoSourceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettings(struct soap *soap, tt__ImagingSettings *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettings))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettings(struct soap *soap, const char *tag, int id, tt__ImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettings);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ImagingSettings ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettings(struct soap *soap, const char *tag, tt__ImagingSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingSettings **)soap_malloc(soap, sizeof(tt__ImagingSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingSettings *)soap_instantiate_tt__ImagingSettings(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ImagingSettings ** p = (tt__ImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettings, sizeof(tt__ImagingSettings), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettings(struct soap *soap, tt__ImagingSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingSettings);
	if (soap_out_PointerTott__ImagingSettings(soap, tag?tag:"tt:ImagingSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingSettings ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettings(struct soap *soap, tt__ImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingStatus20(struct soap *soap, tt__ImagingStatus20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingStatus20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingStatus20(struct soap *soap, const char *tag, int id, tt__ImagingStatus20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingStatus20);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ImagingStatus20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingStatus20(struct soap *soap, const char *tag, tt__ImagingStatus20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingStatus20 **)soap_malloc(soap, sizeof(tt__ImagingStatus20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingStatus20 *)soap_instantiate_tt__ImagingStatus20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ImagingStatus20 ** p = (tt__ImagingStatus20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingStatus20, sizeof(tt__ImagingStatus20), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingStatus20(struct soap *soap, tt__ImagingStatus20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingStatus20);
	if (soap_out_PointerTott__ImagingStatus20(soap, tag?tag:"tt:ImagingStatus20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingStatus20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingStatus20(struct soap *soap, tt__ImagingStatus20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MoveOptions20(struct soap *soap, tt__MoveOptions20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MoveOptions20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MoveOptions20(struct soap *soap, const char *tag, int id, tt__MoveOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MoveOptions20);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__MoveOptions20 ** SOAP_FMAC4 soap_in_PointerTott__MoveOptions20(struct soap *soap, const char *tag, tt__MoveOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MoveOptions20 **)soap_malloc(soap, sizeof(tt__MoveOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MoveOptions20 *)soap_instantiate_tt__MoveOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__MoveOptions20 ** p = (tt__MoveOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MoveOptions20, sizeof(tt__MoveOptions20), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MoveOptions20(struct soap *soap, tt__MoveOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MoveOptions20);
	if (soap_out_PointerTott__MoveOptions20(soap, tag?tag:"tt:MoveOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MoveOptions20 ** SOAP_FMAC4 soap_get_PointerTott__MoveOptions20(struct soap *soap, tt__MoveOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MoveOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusMove(struct soap *soap, tt__FocusMove *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusMove))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusMove(struct soap *soap, const char *tag, int id, tt__FocusMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusMove);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__FocusMove ** SOAP_FMAC4 soap_in_PointerTott__FocusMove(struct soap *soap, const char *tag, tt__FocusMove **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FocusMove **)soap_malloc(soap, sizeof(tt__FocusMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FocusMove *)soap_instantiate_tt__FocusMove(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__FocusMove ** p = (tt__FocusMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusMove, sizeof(tt__FocusMove), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusMove(struct soap *soap, tt__FocusMove *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusMove);
	if (soap_out_PointerTott__FocusMove(soap, tag?tag:"tt:FocusMove", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FocusMove ** SOAP_FMAC4 soap_get_PointerTott__FocusMove(struct soap *soap, tt__FocusMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20(struct soap *soap, tt__ImagingOptions20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20(struct soap *soap, const char *tag, int id, tt__ImagingOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ImagingOptions20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20(struct soap *soap, const char *tag, tt__ImagingOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ImagingOptions20 **)soap_malloc(soap, sizeof(tt__ImagingOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ImagingOptions20 *)soap_instantiate_tt__ImagingOptions20(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ImagingOptions20 ** p = (tt__ImagingOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20, sizeof(tt__ImagingOptions20), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20(struct soap *soap, tt__ImagingOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingOptions20);
	if (soap_out_PointerTott__ImagingOptions20(soap, tag?tag:"tt:ImagingOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ImagingOptions20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20(struct soap *soap, tt__ImagingOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotimg__Capabilities(struct soap *soap, timg__Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_timg__Capabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotimg__Capabilities(struct soap *soap, const char *tag, int id, timg__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_timg__Capabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 timg__Capabilities ** SOAP_FMAC4 soap_in_PointerTotimg__Capabilities(struct soap *soap, const char *tag, timg__Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (timg__Capabilities **)soap_malloc(soap, sizeof(timg__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (timg__Capabilities *)soap_instantiate_timg__Capabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	timg__Capabilities ** p = (timg__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_timg__Capabilities, sizeof(timg__Capabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotimg__Capabilities(struct soap *soap, timg__Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotimg__Capabilities);
	if (soap_out_PointerTotimg__Capabilities(soap, tag?tag:"timg:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 timg__Capabilities ** SOAP_FMAC4 soap_get_PointerTotimg__Capabilities(struct soap *soap, timg__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotimg__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourOptions(struct soap *soap, tt__PTZPresetTourOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourOptions(struct soap *soap, const char *tag, int id, tt__PTZPresetTourOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZPresetTourOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourOptions(struct soap *soap, const char *tag, tt__PTZPresetTourOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPresetTourOptions **)soap_malloc(soap, sizeof(tt__PTZPresetTourOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPresetTourOptions *)soap_instantiate_tt__PTZPresetTourOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZPresetTourOptions ** p = (tt__PTZPresetTourOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourOptions, sizeof(tt__PTZPresetTourOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourOptions(struct soap *soap, tt__PTZPresetTourOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourOptions);
	if (soap_out_PointerTott__PTZPresetTourOptions(soap, tag?tag:"tt:PTZPresetTourOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPresetTourOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourOptions(struct soap *soap, tt__PTZPresetTourOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__PresetTour(struct soap *soap, tt__PresetTour **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__PresetTour))
		soap_serialize_PointerTott__PresetTour(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__PresetTour(struct soap *soap, const char *tag, int id, tt__PresetTour **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__PresetTour);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__PresetTour(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__PresetTour *** SOAP_FMAC4 soap_in_PointerToPointerTott__PresetTour(struct soap *soap, const char *tag, tt__PresetTour ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PresetTour ***)soap_malloc(soap, sizeof(tt__PresetTour **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__PresetTour(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__PresetTour ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__PresetTour, sizeof(tt__PresetTour *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__PresetTour(struct soap *soap, tt__PresetTour **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__PresetTour);
	if (soap_out_PointerToPointerTott__PresetTour(soap, tag?tag:"tt:PresetTour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PresetTour *** SOAP_FMAC4 soap_get_PointerToPointerTott__PresetTour(struct soap *soap, tt__PresetTour ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__PresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PresetTour(struct soap *soap, tt__PresetTour *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PresetTour))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PresetTour(struct soap *soap, const char *tag, int id, tt__PresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PresetTour);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PresetTour ** SOAP_FMAC4 soap_in_PointerTott__PresetTour(struct soap *soap, const char *tag, tt__PresetTour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PresetTour **)soap_malloc(soap, sizeof(tt__PresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PresetTour *)soap_instantiate_tt__PresetTour(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PresetTour ** p = (tt__PresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PresetTour, sizeof(tt__PresetTour), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PresetTour(struct soap *soap, tt__PresetTour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PresetTour);
	if (soap_out_PointerTott__PresetTour(soap, tag?tag:"tt:PresetTour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PresetTour ** SOAP_FMAC4 soap_get_PointerTott__PresetTour(struct soap *soap, tt__PresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__PTZPreset(struct soap *soap, tt__PTZPreset **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__PTZPreset))
		soap_serialize_PointerTott__PTZPreset(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__PTZPreset(struct soap *soap, const char *tag, int id, tt__PTZPreset **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__PTZPreset);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__PTZPreset(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__PTZPreset *** SOAP_FMAC4 soap_in_PointerToPointerTott__PTZPreset(struct soap *soap, const char *tag, tt__PTZPreset ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPreset ***)soap_malloc(soap, sizeof(tt__PTZPreset **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__PTZPreset(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__PTZPreset ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__PTZPreset, sizeof(tt__PTZPreset *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__PTZPreset(struct soap *soap, tt__PTZPreset **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__PTZPreset);
	if (soap_out_PointerToPointerTott__PTZPreset(soap, tag?tag:"tt:PTZPreset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPreset *** SOAP_FMAC4 soap_get_PointerToPointerTott__PTZPreset(struct soap *soap, tt__PTZPreset ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__PTZPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPreset(struct soap *soap, tt__PTZPreset *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPreset))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPreset(struct soap *soap, const char *tag, int id, tt__PTZPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPreset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZPreset ** SOAP_FMAC4 soap_in_PointerTott__PTZPreset(struct soap *soap, const char *tag, tt__PTZPreset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZPreset **)soap_malloc(soap, sizeof(tt__PTZPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZPreset *)soap_instantiate_tt__PTZPreset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZPreset ** p = (tt__PTZPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPreset, sizeof(tt__PTZPreset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPreset(struct soap *soap, tt__PTZPreset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPreset);
	if (soap_out_PointerTott__PTZPreset(soap, tag?tag:"tt:PTZPreset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZPreset ** SOAP_FMAC4 soap_get_PointerTott__PTZPreset(struct soap *soap, tt__PTZPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationOptions(struct soap *soap, tt__PTZConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationOptions(struct soap *soap, const char *tag, int id, tt__PTZConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationOptions(struct soap *soap, const char *tag, tt__PTZConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZConfigurationOptions **)soap_malloc(soap, sizeof(tt__PTZConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZConfigurationOptions *)soap_instantiate_tt__PTZConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZConfigurationOptions ** p = (tt__PTZConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationOptions, sizeof(tt__PTZConfigurationOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationOptions(struct soap *soap, tt__PTZConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZConfigurationOptions);
	if (soap_out_PointerTott__PTZConfigurationOptions(soap, tag?tag:"tt:PTZConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationOptions(struct soap *soap, tt__PTZConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, __tptz__SetConfigurationResponse_sequence *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___tptz__SetConfigurationResponse_sequence))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, const char *tag, int id, __tptz__SetConfigurationResponse_sequence *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___tptz__SetConfigurationResponse_sequence);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __tptz__SetConfigurationResponse_sequence ** SOAP_FMAC4 soap_in_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, const char *tag, __tptz__SetConfigurationResponse_sequence **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__tptz__SetConfigurationResponse_sequence **)soap_malloc(soap, sizeof(__tptz__SetConfigurationResponse_sequence *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__tptz__SetConfigurationResponse_sequence *)soap_instantiate___tptz__SetConfigurationResponse_sequence(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__tptz__SetConfigurationResponse_sequence ** p = (__tptz__SetConfigurationResponse_sequence **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___tptz__SetConfigurationResponse_sequence, sizeof(__tptz__SetConfigurationResponse_sequence), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, __tptz__SetConfigurationResponse_sequence *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__tptz__SetConfigurationResponse_sequence);
	if (soap_out_PointerTo__tptz__SetConfigurationResponse_sequence(soap, tag?tag:"-tptz:SetConfigurationResponse-sequence", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 __tptz__SetConfigurationResponse_sequence ** SOAP_FMAC4 soap_get_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, __tptz__SetConfigurationResponse_sequence **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__tptz__SetConfigurationResponse_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__PTZConfiguration(struct soap *soap, tt__PTZConfiguration **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__PTZConfiguration))
		soap_serialize_PointerTott__PTZConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__PTZConfiguration(struct soap *soap, const char *tag, int id, tt__PTZConfiguration **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__PTZConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__PTZConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__PTZConfiguration *** SOAP_FMAC4 soap_in_PointerToPointerTott__PTZConfiguration(struct soap *soap, const char *tag, tt__PTZConfiguration ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZConfiguration ***)soap_malloc(soap, sizeof(tt__PTZConfiguration **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__PTZConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__PTZConfiguration ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__PTZConfiguration, sizeof(tt__PTZConfiguration *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__PTZConfiguration(struct soap *soap, tt__PTZConfiguration **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__PTZConfiguration);
	if (soap_out_PointerToPointerTott__PTZConfiguration(soap, tag?tag:"tt:PTZConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZConfiguration *** SOAP_FMAC4 soap_get_PointerToPointerTott__PTZConfiguration(struct soap *soap, tt__PTZConfiguration ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__PTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__PTZNode(struct soap *soap, tt__PTZNode **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__PTZNode))
		soap_serialize_PointerTott__PTZNode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__PTZNode(struct soap *soap, const char *tag, int id, tt__PTZNode **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__PTZNode);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__PTZNode(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__PTZNode *** SOAP_FMAC4 soap_in_PointerToPointerTott__PTZNode(struct soap *soap, const char *tag, tt__PTZNode ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZNode ***)soap_malloc(soap, sizeof(tt__PTZNode **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__PTZNode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__PTZNode ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__PTZNode, sizeof(tt__PTZNode *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__PTZNode(struct soap *soap, tt__PTZNode **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__PTZNode);
	if (soap_out_PointerToPointerTott__PTZNode(soap, tag?tag:"tt:PTZNode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZNode *** SOAP_FMAC4 soap_get_PointerToPointerTott__PTZNode(struct soap *soap, tt__PTZNode ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__PTZNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZNode(struct soap *soap, tt__PTZNode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZNode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZNode(struct soap *soap, const char *tag, int id, tt__PTZNode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZNode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__PTZNode ** SOAP_FMAC4 soap_in_PointerTott__PTZNode(struct soap *soap, const char *tag, tt__PTZNode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__PTZNode **)soap_malloc(soap, sizeof(tt__PTZNode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__PTZNode *)soap_instantiate_tt__PTZNode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__PTZNode ** p = (tt__PTZNode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZNode, sizeof(tt__PTZNode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZNode(struct soap *soap, tt__PTZNode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZNode);
	if (soap_out_PointerTott__PTZNode(soap, tag?tag:"tt:PTZNode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__PTZNode ** SOAP_FMAC4 soap_get_PointerTott__PTZNode(struct soap *soap, tt__PTZNode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotptz__Capabilities(struct soap *soap, tptz__Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tptz__Capabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotptz__Capabilities(struct soap *soap, const char *tag, int id, tptz__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tptz__Capabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tptz__Capabilities ** SOAP_FMAC4 soap_in_PointerTotptz__Capabilities(struct soap *soap, const char *tag, tptz__Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tptz__Capabilities **)soap_malloc(soap, sizeof(tptz__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tptz__Capabilities *)soap_instantiate_tptz__Capabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tptz__Capabilities ** p = (tptz__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tptz__Capabilities, sizeof(tptz__Capabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotptz__Capabilities(struct soap *soap, tptz__Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotptz__Capabilities);
	if (soap_out_PointerTotptz__Capabilities(soap, tag?tag:"tptz:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tptz__Capabilities ** SOAP_FMAC4 soap_get_PointerTotptz__Capabilities(struct soap *soap, tptz__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotptz__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaUri(struct soap *soap, tt__MediaUri *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaUri))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaUri(struct soap *soap, const char *tag, int id, tt__MediaUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaUri);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__MediaUri ** SOAP_FMAC4 soap_in_PointerTott__MediaUri(struct soap *soap, const char *tag, tt__MediaUri **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MediaUri **)soap_malloc(soap, sizeof(tt__MediaUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MediaUri *)soap_instantiate_tt__MediaUri(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__MediaUri ** p = (tt__MediaUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaUri, sizeof(tt__MediaUri), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaUri(struct soap *soap, tt__MediaUri *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MediaUri);
	if (soap_out_PointerTott__MediaUri(soap, tag?tag:"tt:MediaUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MediaUri ** SOAP_FMAC4 soap_get_PointerTott__MediaUri(struct soap *soap, tt__MediaUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, tt__AudioOutputConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioOutputConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, tt__AudioOutputConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioOutputConfigurationOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AudioOutputConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, tt__AudioOutputConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioOutputConfigurationOptions **)soap_malloc(soap, sizeof(tt__AudioOutputConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioOutputConfigurationOptions *)soap_instantiate_tt__AudioOutputConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AudioOutputConfigurationOptions ** p = (tt__AudioOutputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioOutputConfigurationOptions, sizeof(tt__AudioOutputConfigurationOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, tt__AudioOutputConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioOutputConfigurationOptions);
	if (soap_out_PointerTott__AudioOutputConfigurationOptions(soap, tag?tag:"tt:AudioOutputConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioOutputConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, tt__AudioOutputConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfigurationOptions(struct soap *soap, tt__MetadataConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfigurationOptions(struct soap *soap, const char *tag, int id, tt__MetadataConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfigurationOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__MetadataConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfigurationOptions(struct soap *soap, const char *tag, tt__MetadataConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MetadataConfigurationOptions **)soap_malloc(soap, sizeof(tt__MetadataConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MetadataConfigurationOptions *)soap_instantiate_tt__MetadataConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__MetadataConfigurationOptions ** p = (tt__MetadataConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationOptions, sizeof(tt__MetadataConfigurationOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfigurationOptions(struct soap *soap, tt__MetadataConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MetadataConfigurationOptions);
	if (soap_out_PointerTott__MetadataConfigurationOptions(soap, tag?tag:"tt:MetadataConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MetadataConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfigurationOptions(struct soap *soap, tt__MetadataConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, tt__AudioSourceConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSourceConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, tt__AudioSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSourceConfigurationOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AudioSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, tt__AudioSourceConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioSourceConfigurationOptions **)soap_malloc(soap, sizeof(tt__AudioSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioSourceConfigurationOptions *)soap_instantiate_tt__AudioSourceConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AudioSourceConfigurationOptions ** p = (tt__AudioSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(tt__AudioSourceConfigurationOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, tt__AudioSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioSourceConfigurationOptions);
	if (soap_out_PointerTott__AudioSourceConfigurationOptions(soap, tag?tag:"tt:AudioSourceConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, tt__AudioSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, tt__VideoEncoderConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, tt__VideoEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderConfigurationOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__VideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, tt__VideoEncoderConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoEncoderConfigurationOptions **)soap_malloc(soap, sizeof(tt__VideoEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoEncoderConfigurationOptions *)soap_instantiate_tt__VideoEncoderConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__VideoEncoderConfigurationOptions ** p = (tt__VideoEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(tt__VideoEncoderConfigurationOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, tt__VideoEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoEncoderConfigurationOptions);
	if (soap_out_PointerTott__VideoEncoderConfigurationOptions(soap, tag?tag:"tt:VideoEncoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, tt__VideoEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, tt__VideoSourceConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, tt__VideoSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, tt__VideoSourceConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSourceConfigurationOptions **)soap_malloc(soap, sizeof(tt__VideoSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSourceConfigurationOptions *)soap_instantiate_tt__VideoSourceConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__VideoSourceConfigurationOptions ** p = (tt__VideoSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(tt__VideoSourceConfigurationOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, tt__VideoSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoSourceConfigurationOptions);
	if (soap_out_PointerTott__VideoSourceConfigurationOptions(soap, tag?tag:"tt:VideoSourceConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, tt__VideoSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__AudioDecoderConfiguration(struct soap *soap, tt__AudioDecoderConfiguration **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__AudioDecoderConfiguration))
		soap_serialize_PointerTott__AudioDecoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__AudioDecoderConfiguration(struct soap *soap, const char *tag, int id, tt__AudioDecoderConfiguration **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__AudioDecoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__AudioDecoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__AudioDecoderConfiguration *** SOAP_FMAC4 soap_in_PointerToPointerTott__AudioDecoderConfiguration(struct soap *soap, const char *tag, tt__AudioDecoderConfiguration ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioDecoderConfiguration ***)soap_malloc(soap, sizeof(tt__AudioDecoderConfiguration **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__AudioDecoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__AudioDecoderConfiguration ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__AudioDecoderConfiguration, sizeof(tt__AudioDecoderConfiguration *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__AudioDecoderConfiguration(struct soap *soap, tt__AudioDecoderConfiguration **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__AudioDecoderConfiguration);
	if (soap_out_PointerToPointerTott__AudioDecoderConfiguration(soap, tag?tag:"tt:AudioDecoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioDecoderConfiguration *** SOAP_FMAC4 soap_get_PointerToPointerTott__AudioDecoderConfiguration(struct soap *soap, tt__AudioDecoderConfiguration ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__AudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__AudioOutputConfiguration(struct soap *soap, tt__AudioOutputConfiguration **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__AudioOutputConfiguration))
		soap_serialize_PointerTott__AudioOutputConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__AudioOutputConfiguration(struct soap *soap, const char *tag, int id, tt__AudioOutputConfiguration **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__AudioOutputConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__AudioOutputConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__AudioOutputConfiguration *** SOAP_FMAC4 soap_in_PointerToPointerTott__AudioOutputConfiguration(struct soap *soap, const char *tag, tt__AudioOutputConfiguration ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioOutputConfiguration ***)soap_malloc(soap, sizeof(tt__AudioOutputConfiguration **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__AudioOutputConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__AudioOutputConfiguration ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__AudioOutputConfiguration, sizeof(tt__AudioOutputConfiguration *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__AudioOutputConfiguration(struct soap *soap, tt__AudioOutputConfiguration **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__AudioOutputConfiguration);
	if (soap_out_PointerToPointerTott__AudioOutputConfiguration(soap, tag?tag:"tt:AudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioOutputConfiguration *** SOAP_FMAC4 soap_get_PointerToPointerTott__AudioOutputConfiguration(struct soap *soap, tt__AudioOutputConfiguration ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__AudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__MetadataConfiguration(struct soap *soap, tt__MetadataConfiguration **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__MetadataConfiguration))
		soap_serialize_PointerTott__MetadataConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__MetadataConfiguration(struct soap *soap, const char *tag, int id, tt__MetadataConfiguration **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__MetadataConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__MetadataConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__MetadataConfiguration *** SOAP_FMAC4 soap_in_PointerToPointerTott__MetadataConfiguration(struct soap *soap, const char *tag, tt__MetadataConfiguration ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MetadataConfiguration ***)soap_malloc(soap, sizeof(tt__MetadataConfiguration **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__MetadataConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__MetadataConfiguration ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__MetadataConfiguration, sizeof(tt__MetadataConfiguration *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__MetadataConfiguration(struct soap *soap, tt__MetadataConfiguration **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__MetadataConfiguration);
	if (soap_out_PointerToPointerTott__MetadataConfiguration(soap, tag?tag:"tt:MetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MetadataConfiguration *** SOAP_FMAC4 soap_get_PointerToPointerTott__MetadataConfiguration(struct soap *soap, tt__MetadataConfiguration ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__MetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__VideoAnalyticsConfiguration(struct soap *soap, tt__VideoAnalyticsConfiguration **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__VideoAnalyticsConfiguration))
		soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, tt__VideoAnalyticsConfiguration **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__VideoAnalyticsConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__VideoAnalyticsConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__VideoAnalyticsConfiguration *** SOAP_FMAC4 soap_in_PointerToPointerTott__VideoAnalyticsConfiguration(struct soap *soap, const char *tag, tt__VideoAnalyticsConfiguration ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoAnalyticsConfiguration ***)soap_malloc(soap, sizeof(tt__VideoAnalyticsConfiguration **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__VideoAnalyticsConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__VideoAnalyticsConfiguration ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__VideoAnalyticsConfiguration, sizeof(tt__VideoAnalyticsConfiguration *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__VideoAnalyticsConfiguration(struct soap *soap, tt__VideoAnalyticsConfiguration **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__VideoAnalyticsConfiguration);
	if (soap_out_PointerToPointerTott__VideoAnalyticsConfiguration(soap, tag?tag:"tt:VideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoAnalyticsConfiguration *** SOAP_FMAC4 soap_get_PointerToPointerTott__VideoAnalyticsConfiguration(struct soap *soap, tt__VideoAnalyticsConfiguration ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__VideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__AudioSourceConfiguration(struct soap *soap, tt__AudioSourceConfiguration **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__AudioSourceConfiguration))
		soap_serialize_PointerTott__AudioSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, tt__AudioSourceConfiguration **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__AudioSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__AudioSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__AudioSourceConfiguration *** SOAP_FMAC4 soap_in_PointerToPointerTott__AudioSourceConfiguration(struct soap *soap, const char *tag, tt__AudioSourceConfiguration ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioSourceConfiguration ***)soap_malloc(soap, sizeof(tt__AudioSourceConfiguration **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__AudioSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__AudioSourceConfiguration ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__AudioSourceConfiguration, sizeof(tt__AudioSourceConfiguration *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__AudioSourceConfiguration(struct soap *soap, tt__AudioSourceConfiguration **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__AudioSourceConfiguration);
	if (soap_out_PointerToPointerTott__AudioSourceConfiguration(soap, tag?tag:"tt:AudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioSourceConfiguration *** SOAP_FMAC4 soap_get_PointerToPointerTott__AudioSourceConfiguration(struct soap *soap, tt__AudioSourceConfiguration ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__AudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__AudioEncoderConfiguration(struct soap *soap, tt__AudioEncoderConfiguration **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__AudioEncoderConfiguration))
		soap_serialize_PointerTott__AudioEncoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__AudioEncoderConfiguration(struct soap *soap, const char *tag, int id, tt__AudioEncoderConfiguration **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__AudioEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__AudioEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__AudioEncoderConfiguration *** SOAP_FMAC4 soap_in_PointerToPointerTott__AudioEncoderConfiguration(struct soap *soap, const char *tag, tt__AudioEncoderConfiguration ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioEncoderConfiguration ***)soap_malloc(soap, sizeof(tt__AudioEncoderConfiguration **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__AudioEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__AudioEncoderConfiguration ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__AudioEncoderConfiguration, sizeof(tt__AudioEncoderConfiguration *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__AudioEncoderConfiguration(struct soap *soap, tt__AudioEncoderConfiguration **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__AudioEncoderConfiguration);
	if (soap_out_PointerToPointerTott__AudioEncoderConfiguration(soap, tag?tag:"tt:AudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioEncoderConfiguration *** SOAP_FMAC4 soap_get_PointerToPointerTott__AudioEncoderConfiguration(struct soap *soap, tt__AudioEncoderConfiguration ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__AudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__VideoSourceConfiguration(struct soap *soap, tt__VideoSourceConfiguration **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__VideoSourceConfiguration))
		soap_serialize_PointerTott__VideoSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, tt__VideoSourceConfiguration **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__VideoSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__VideoSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__VideoSourceConfiguration *** SOAP_FMAC4 soap_in_PointerToPointerTott__VideoSourceConfiguration(struct soap *soap, const char *tag, tt__VideoSourceConfiguration ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSourceConfiguration ***)soap_malloc(soap, sizeof(tt__VideoSourceConfiguration **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__VideoSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfiguration ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__VideoSourceConfiguration, sizeof(tt__VideoSourceConfiguration *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__VideoSourceConfiguration(struct soap *soap, tt__VideoSourceConfiguration **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__VideoSourceConfiguration);
	if (soap_out_PointerToPointerTott__VideoSourceConfiguration(soap, tag?tag:"tt:VideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSourceConfiguration *** SOAP_FMAC4 soap_get_PointerToPointerTott__VideoSourceConfiguration(struct soap *soap, tt__VideoSourceConfiguration ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__VideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__VideoEncoderConfiguration(struct soap *soap, tt__VideoEncoderConfiguration **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__VideoEncoderConfiguration))
		soap_serialize_PointerTott__VideoEncoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, tt__VideoEncoderConfiguration **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__VideoEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__VideoEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__VideoEncoderConfiguration *** SOAP_FMAC4 soap_in_PointerToPointerTott__VideoEncoderConfiguration(struct soap *soap, const char *tag, tt__VideoEncoderConfiguration ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoEncoderConfiguration ***)soap_malloc(soap, sizeof(tt__VideoEncoderConfiguration **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__VideoEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__VideoEncoderConfiguration ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__VideoEncoderConfiguration, sizeof(tt__VideoEncoderConfiguration *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__VideoEncoderConfiguration(struct soap *soap, tt__VideoEncoderConfiguration **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__VideoEncoderConfiguration);
	if (soap_out_PointerToPointerTott__VideoEncoderConfiguration(soap, tag?tag:"tt:VideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoEncoderConfiguration *** SOAP_FMAC4 soap_get_PointerToPointerTott__VideoEncoderConfiguration(struct soap *soap, tt__VideoEncoderConfiguration ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__VideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__Profile(struct soap *soap, tt__Profile **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__Profile))
		soap_serialize_PointerTott__Profile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__Profile(struct soap *soap, const char *tag, int id, tt__Profile **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__Profile);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__Profile(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__Profile *** SOAP_FMAC4 soap_in_PointerToPointerTott__Profile(struct soap *soap, const char *tag, tt__Profile ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Profile ***)soap_malloc(soap, sizeof(tt__Profile **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__Profile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__Profile ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__Profile, sizeof(tt__Profile *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__Profile(struct soap *soap, tt__Profile **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__Profile);
	if (soap_out_PointerToPointerTott__Profile(soap, tag?tag:"tt:Profile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Profile *** SOAP_FMAC4 soap_get_PointerToPointerTott__Profile(struct soap *soap, tt__Profile ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Profile(struct soap *soap, tt__Profile *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Profile))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Profile(struct soap *soap, const char *tag, int id, tt__Profile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Profile);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__Profile ** SOAP_FMAC4 soap_in_PointerTott__Profile(struct soap *soap, const char *tag, tt__Profile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__Profile **)soap_malloc(soap, sizeof(tt__Profile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__Profile *)soap_instantiate_tt__Profile(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__Profile ** p = (tt__Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Profile, sizeof(tt__Profile), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Profile(struct soap *soap, tt__Profile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Profile);
	if (soap_out_PointerTott__Profile(soap, tag?tag:"tt:Profile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__Profile ** SOAP_FMAC4 soap_get_PointerTott__Profile(struct soap *soap, tt__Profile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__AudioOutput(struct soap *soap, tt__AudioOutput **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__AudioOutput))
		soap_serialize_PointerTott__AudioOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__AudioOutput(struct soap *soap, const char *tag, int id, tt__AudioOutput **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__AudioOutput);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__AudioOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__AudioOutput *** SOAP_FMAC4 soap_in_PointerToPointerTott__AudioOutput(struct soap *soap, const char *tag, tt__AudioOutput ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioOutput ***)soap_malloc(soap, sizeof(tt__AudioOutput **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__AudioOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__AudioOutput ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__AudioOutput, sizeof(tt__AudioOutput *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__AudioOutput(struct soap *soap, tt__AudioOutput **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__AudioOutput);
	if (soap_out_PointerToPointerTott__AudioOutput(soap, tag?tag:"tt:AudioOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioOutput *** SOAP_FMAC4 soap_get_PointerToPointerTott__AudioOutput(struct soap *soap, tt__AudioOutput ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__AudioOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioOutput(struct soap *soap, tt__AudioOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioOutput))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioOutput(struct soap *soap, const char *tag, int id, tt__AudioOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioOutput);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AudioOutput ** SOAP_FMAC4 soap_in_PointerTott__AudioOutput(struct soap *soap, const char *tag, tt__AudioOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioOutput **)soap_malloc(soap, sizeof(tt__AudioOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioOutput *)soap_instantiate_tt__AudioOutput(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AudioOutput ** p = (tt__AudioOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioOutput, sizeof(tt__AudioOutput), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioOutput(struct soap *soap, tt__AudioOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioOutput);
	if (soap_out_PointerTott__AudioOutput(soap, tag?tag:"tt:AudioOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioOutput ** SOAP_FMAC4 soap_get_PointerTott__AudioOutput(struct soap *soap, tt__AudioOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__AudioSource(struct soap *soap, tt__AudioSource **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__AudioSource))
		soap_serialize_PointerTott__AudioSource(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__AudioSource(struct soap *soap, const char *tag, int id, tt__AudioSource **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__AudioSource);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__AudioSource(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__AudioSource *** SOAP_FMAC4 soap_in_PointerToPointerTott__AudioSource(struct soap *soap, const char *tag, tt__AudioSource ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioSource ***)soap_malloc(soap, sizeof(tt__AudioSource **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__AudioSource(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__AudioSource ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__AudioSource, sizeof(tt__AudioSource *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__AudioSource(struct soap *soap, tt__AudioSource **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__AudioSource);
	if (soap_out_PointerToPointerTott__AudioSource(soap, tag?tag:"tt:AudioSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioSource *** SOAP_FMAC4 soap_get_PointerToPointerTott__AudioSource(struct soap *soap, tt__AudioSource ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__AudioSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSource(struct soap *soap, tt__AudioSource *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSource))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSource(struct soap *soap, const char *tag, int id, tt__AudioSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSource);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AudioSource ** SOAP_FMAC4 soap_in_PointerTott__AudioSource(struct soap *soap, const char *tag, tt__AudioSource **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioSource **)soap_malloc(soap, sizeof(tt__AudioSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioSource *)soap_instantiate_tt__AudioSource(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AudioSource ** p = (tt__AudioSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSource, sizeof(tt__AudioSource), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSource(struct soap *soap, tt__AudioSource *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioSource);
	if (soap_out_PointerTott__AudioSource(soap, tag?tag:"tt:AudioSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioSource ** SOAP_FMAC4 soap_get_PointerTott__AudioSource(struct soap *soap, tt__AudioSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__VideoSource(struct soap *soap, tt__VideoSource **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__VideoSource))
		soap_serialize_PointerTott__VideoSource(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__VideoSource(struct soap *soap, const char *tag, int id, tt__VideoSource **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__VideoSource);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__VideoSource(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__VideoSource *** SOAP_FMAC4 soap_in_PointerToPointerTott__VideoSource(struct soap *soap, const char *tag, tt__VideoSource ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSource ***)soap_malloc(soap, sizeof(tt__VideoSource **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__VideoSource(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__VideoSource ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__VideoSource, sizeof(tt__VideoSource *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__VideoSource(struct soap *soap, tt__VideoSource **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__VideoSource);
	if (soap_out_PointerToPointerTott__VideoSource(soap, tag?tag:"tt:VideoSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSource *** SOAP_FMAC4 soap_get_PointerToPointerTott__VideoSource(struct soap *soap, tt__VideoSource ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__VideoSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSource(struct soap *soap, tt__VideoSource *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSource))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSource(struct soap *soap, const char *tag, int id, tt__VideoSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSource);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__VideoSource ** SOAP_FMAC4 soap_in_PointerTott__VideoSource(struct soap *soap, const char *tag, tt__VideoSource **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoSource **)soap_malloc(soap, sizeof(tt__VideoSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoSource *)soap_instantiate_tt__VideoSource(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__VideoSource ** p = (tt__VideoSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSource, sizeof(tt__VideoSource), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSource(struct soap *soap, tt__VideoSource *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoSource);
	if (soap_out_PointerTott__VideoSource(soap, tag?tag:"tt:VideoSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoSource ** SOAP_FMAC4 soap_get_PointerTott__VideoSource(struct soap *soap, tt__VideoSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__Capabilities(struct soap *soap, trt__Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__Capabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__Capabilities(struct soap *soap, const char *tag, int id, trt__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__Capabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 trt__Capabilities ** SOAP_FMAC4 soap_in_PointerTotrt__Capabilities(struct soap *soap, const char *tag, trt__Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (trt__Capabilities **)soap_malloc(soap, sizeof(trt__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (trt__Capabilities *)soap_instantiate_trt__Capabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	trt__Capabilities ** p = (trt__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__Capabilities, sizeof(trt__Capabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__Capabilities(struct soap *soap, trt__Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrt__Capabilities);
	if (soap_out_PointerTotrt__Capabilities(soap, tag?tag:"trt:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 trt__Capabilities ** SOAP_FMAC4 soap_get_PointerTotrt__Capabilities(struct soap *soap, trt__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__StreamingCapabilities(struct soap *soap, trt__StreamingCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__StreamingCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__StreamingCapabilities(struct soap *soap, const char *tag, int id, trt__StreamingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__StreamingCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 trt__StreamingCapabilities ** SOAP_FMAC4 soap_in_PointerTotrt__StreamingCapabilities(struct soap *soap, const char *tag, trt__StreamingCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (trt__StreamingCapabilities **)soap_malloc(soap, sizeof(trt__StreamingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (trt__StreamingCapabilities *)soap_instantiate_trt__StreamingCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	trt__StreamingCapabilities ** p = (trt__StreamingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__StreamingCapabilities, sizeof(trt__StreamingCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__StreamingCapabilities(struct soap *soap, trt__StreamingCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrt__StreamingCapabilities);
	if (soap_out_PointerTotrt__StreamingCapabilities(soap, tag?tag:"trt:StreamingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 trt__StreamingCapabilities ** SOAP_FMAC4 soap_get_PointerTotrt__StreamingCapabilities(struct soap *soap, trt__StreamingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__StreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__ProfileCapabilities(struct soap *soap, trt__ProfileCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__ProfileCapabilities))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__ProfileCapabilities(struct soap *soap, const char *tag, int id, trt__ProfileCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__ProfileCapabilities);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 trt__ProfileCapabilities ** SOAP_FMAC4 soap_in_PointerTotrt__ProfileCapabilities(struct soap *soap, const char *tag, trt__ProfileCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (trt__ProfileCapabilities **)soap_malloc(soap, sizeof(trt__ProfileCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (trt__ProfileCapabilities *)soap_instantiate_trt__ProfileCapabilities(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	trt__ProfileCapabilities ** p = (trt__ProfileCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__ProfileCapabilities, sizeof(trt__ProfileCapabilities), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__ProfileCapabilities(struct soap *soap, trt__ProfileCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrt__ProfileCapabilities);
	if (soap_out_PointerTotrt__ProfileCapabilities(soap, tag?tag:"trt:ProfileCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 trt__ProfileCapabilities ** SOAP_FMAC4 soap_get_PointerTotrt__ProfileCapabilities(struct soap *soap, trt__ProfileCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__Documentation(struct soap *soap, wstop__Documentation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__Documentation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__Documentation(struct soap *soap, const char *tag, int id, wstop__Documentation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__Documentation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 wstop__Documentation ** SOAP_FMAC4 soap_in_PointerTowstop__Documentation(struct soap *soap, const char *tag, wstop__Documentation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__Documentation **)soap_malloc(soap, sizeof(wstop__Documentation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__Documentation *)soap_instantiate_wstop__Documentation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	wstop__Documentation ** p = (wstop__Documentation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__Documentation, sizeof(wstop__Documentation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__Documentation(struct soap *soap, wstop__Documentation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowstop__Documentation);
	if (soap_out_PointerTowstop__Documentation(soap, tag?tag:"wstop:Documentation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__Documentation ** SOAP_FMAC4 soap_get_PointerTowstop__Documentation(struct soap *soap, wstop__Documentation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__Documentation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, int id, _wsrfbf__BaseFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsrfbf__BaseFaultType_FaultCause **)soap_malloc(soap, sizeof(_wsrfbf__BaseFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsrfbf__BaseFaultType_FaultCause *)soap_instantiate__wsrfbf__BaseFaultType_FaultCause(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_wsrfbf__BaseFaultType_FaultCause ** p = (_wsrfbf__BaseFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_FaultCause, sizeof(_wsrfbf__BaseFaultType_FaultCause), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_FaultCause);
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag?tag:"wsrfbf:BaseFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_FaultCause(struct soap *soap, _wsrfbf__BaseFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, _wsrfbf__BaseFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_Description))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, int id, _wsrfbf__BaseFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_Description);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsrfbf__BaseFaultType_Description **)soap_malloc(soap, sizeof(_wsrfbf__BaseFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsrfbf__BaseFaultType_Description *)soap_instantiate__wsrfbf__BaseFaultType_Description(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_wsrfbf__BaseFaultType_Description ** p = (_wsrfbf__BaseFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_Description, sizeof(_wsrfbf__BaseFaultType_Description), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, _wsrfbf__BaseFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_Description);
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_Description(soap, tag?tag:"wsrfbf:BaseFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_Description(struct soap *soap, _wsrfbf__BaseFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, int id, _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, const char *tag, _wsrfbf__BaseFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsrfbf__BaseFaultType_ErrorCode **)soap_malloc(soap, sizeof(_wsrfbf__BaseFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsrfbf__BaseFaultType_ErrorCode *)soap_instantiate__wsrfbf__BaseFaultType_ErrorCode(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_wsrfbf__BaseFaultType_ErrorCode ** p = (_wsrfbf__BaseFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfbf__BaseFaultType_ErrorCode, sizeof(_wsrfbf__BaseFaultType_ErrorCode), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrfbf__BaseFaultType_ErrorCode);
	if (soap_out_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag?tag:"wsrfbf:BaseFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsrfbf__BaseFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsrfbf__BaseFaultType_ErrorCode(struct soap *soap, _wsrfbf__BaseFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfbf__BaseFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, int id, _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, const char *tag, _wsnt__Subscribe_SubscriptionPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_wsnt__Subscribe_SubscriptionPolicy **)soap_malloc(soap, sizeof(_wsnt__Subscribe_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_wsnt__Subscribe_SubscriptionPolicy *)soap_instantiate__wsnt__Subscribe_SubscriptionPolicy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_wsnt__Subscribe_SubscriptionPolicy ** p = (_wsnt__Subscribe_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Subscribe_SubscriptionPolicy, sizeof(_wsnt__Subscribe_SubscriptionPolicy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__Subscribe_SubscriptionPolicy);
	if (soap_out_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag?tag:"wsnt:Subscribe-SubscriptionPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _wsnt__Subscribe_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Subscribe_SubscriptionPolicy(struct soap *soap, _wsnt__Subscribe_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Subscribe_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTowsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType))
		soap_serialize_PointerTowsnt__NotificationMessageHolderType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, int id, wsnt__NotificationMessageHolderType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTowsnt__NotificationMessageHolderType(soap, tag, id, *a, type);
}

SOAP_FMAC3 wsnt__NotificationMessageHolderType *** SOAP_FMAC4 soap_in_PointerToPointerTowsnt__NotificationMessageHolderType(struct soap *soap, const char *tag, wsnt__NotificationMessageHolderType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__NotificationMessageHolderType ***)soap_malloc(soap, sizeof(wsnt__NotificationMessageHolderType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTowsnt__NotificationMessageHolderType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (wsnt__NotificationMessageHolderType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTowsnt__NotificationMessageHolderType, sizeof(wsnt__NotificationMessageHolderType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTowsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTowsnt__NotificationMessageHolderType);
	if (soap_out_PointerToPointerTowsnt__NotificationMessageHolderType(soap, tag?tag:"wsnt:NotificationMessageHolderType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__NotificationMessageHolderType *** SOAP_FMAC4 soap_get_PointerToPointerTowsnt__NotificationMessageHolderType(struct soap *soap, wsnt__NotificationMessageHolderType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTowsnt__NotificationMessageHolderType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__SubscriptionPolicyType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, int id, wsnt__SubscriptionPolicyType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__SubscriptionPolicyType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_in_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, const char *tag, wsnt__SubscriptionPolicyType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__SubscriptionPolicyType **)soap_malloc(soap, sizeof(wsnt__SubscriptionPolicyType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__SubscriptionPolicyType *)soap_instantiate_wsnt__SubscriptionPolicyType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	wsnt__SubscriptionPolicyType ** p = (wsnt__SubscriptionPolicyType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__SubscriptionPolicyType, sizeof(wsnt__SubscriptionPolicyType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__SubscriptionPolicyType);
	if (soap_out_PointerTowsnt__SubscriptionPolicyType(soap, tag?tag:"wsnt:SubscriptionPolicyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__SubscriptionPolicyType ** SOAP_FMAC4 soap_get_PointerTowsnt__SubscriptionPolicyType(struct soap *soap, wsnt__SubscriptionPolicyType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__SubscriptionPolicyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicSetType(struct soap *soap, wstop__TopicSetType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicSetType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, int id, wstop__TopicSetType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicSetType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 wstop__TopicSetType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicSetType(struct soap *soap, const char *tag, wstop__TopicSetType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wstop__TopicSetType **)soap_malloc(soap, sizeof(wstop__TopicSetType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wstop__TopicSetType *)soap_instantiate_wstop__TopicSetType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	wstop__TopicSetType ** p = (wstop__TopicSetType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicSetType, sizeof(wstop__TopicSetType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicSetType(struct soap *soap, wstop__TopicSetType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowstop__TopicSetType);
	if (soap_out_PointerTowstop__TopicSetType(soap, tag?tag:"wstop:TopicSetType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wstop__TopicSetType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicSetType(struct soap *soap, wstop__TopicSetType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicSetType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTowsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTowsnt__TopicExpressionType))
		soap_serialize_PointerTowsnt__TopicExpressionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, wsnt__TopicExpressionType **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTowsnt__TopicExpressionType);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTowsnt__TopicExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 wsnt__TopicExpressionType *** SOAP_FMAC4 soap_in_PointerToPointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, wsnt__TopicExpressionType ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__TopicExpressionType ***)soap_malloc(soap, sizeof(wsnt__TopicExpressionType **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTowsnt__TopicExpressionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (wsnt__TopicExpressionType ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTowsnt__TopicExpressionType, sizeof(wsnt__TopicExpressionType *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTowsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTowsnt__TopicExpressionType);
	if (soap_out_PointerToPointerTowsnt__TopicExpressionType(soap, tag?tag:"wsnt:TopicExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__TopicExpressionType *** SOAP_FMAC4 soap_get_PointerToPointerTowsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTowsnt__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__TopicExpressionType))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, int id, wsnt__TopicExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__TopicExpressionType);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 wsnt__TopicExpressionType ** SOAP_FMAC4 soap_in_PointerTowsnt__TopicExpressionType(struct soap *soap, const char *tag, wsnt__TopicExpressionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (wsnt__TopicExpressionType **)soap_malloc(soap, sizeof(wsnt__TopicExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (wsnt__TopicExpressionType *)soap_instantiate_wsnt__TopicExpressionType(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	wsnt__TopicExpressionType ** p = (wsnt__TopicExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicExpressionType, sizeof(wsnt__TopicExpressionType), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__TopicExpressionType);
	if (soap_out_PointerTowsnt__TopicExpressionType(soap, tag?tag:"wsnt:TopicExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 wsnt__TopicExpressionType ** SOAP_FMAC4 soap_get_PointerTowsnt__TopicExpressionType(struct soap *soap, wsnt__TopicExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__TopicExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsa5__EndpointReferenceType))
		soap_serialize_wsa5__EndpointReferenceType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, struct wsa5__EndpointReferenceType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsa5__EndpointReferenceType);
	if (id < 0)
		return soap->error;
	return soap_out_wsa5__EndpointReferenceType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_in_PointerTowsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsa5__EndpointReferenceType **)soap_malloc(soap, sizeof(struct wsa5__EndpointReferenceType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsa5__EndpointReferenceType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsa5__EndpointReferenceType);
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, tag?tag:"wsa5:EndpointReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType ** SOAP_FMAC4 soap_get_PointerTowsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__PropertyOperation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PropertyOperation(struct soap *soap, const char *tag, int id, enum tt__PropertyOperation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PropertyOperation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PropertyOperation(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__PropertyOperation ** SOAP_FMAC4 soap_in_PointerTott__PropertyOperation(struct soap *soap, const char *tag, enum tt__PropertyOperation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__PropertyOperation **)soap_malloc(soap, sizeof(enum tt__PropertyOperation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PropertyOperation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__PropertyOperation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PropertyOperation, sizeof(enum tt__PropertyOperation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PropertyOperation);
	if (soap_out_PointerTott__PropertyOperation(soap, tag?tag:"tt:PropertyOperation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__PropertyOperation ** SOAP_FMAC4 soap_get_PointerTott__PropertyOperation(struct soap *soap, enum tt__PropertyOperation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PropertyOperation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MessageExtension(struct soap *soap, tt__MessageExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MessageExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MessageExtension(struct soap *soap, const char *tag, int id, tt__MessageExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MessageExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__MessageExtension ** SOAP_FMAC4 soap_in_PointerTott__MessageExtension(struct soap *soap, const char *tag, tt__MessageExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MessageExtension **)soap_malloc(soap, sizeof(tt__MessageExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MessageExtension *)soap_instantiate_tt__MessageExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__MessageExtension ** p = (tt__MessageExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MessageExtension, sizeof(tt__MessageExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MessageExtension(struct soap *soap, tt__MessageExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MessageExtension);
	if (soap_out_PointerTott__MessageExtension(soap, tag?tag:"tt:MessageExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MessageExtension ** SOAP_FMAC4 soap_get_PointerTott__MessageExtension(struct soap *soap, tt__MessageExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MessageExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, tt__ActionEngineEventPayloadExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, const char *tag, int id, tt__ActionEngineEventPayloadExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ActionEngineEventPayloadExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__ActionEngineEventPayloadExtension ** SOAP_FMAC4 soap_in_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, const char *tag, tt__ActionEngineEventPayloadExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__ActionEngineEventPayloadExtension **)soap_malloc(soap, sizeof(tt__ActionEngineEventPayloadExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__ActionEngineEventPayloadExtension *)soap_instantiate_tt__ActionEngineEventPayloadExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__ActionEngineEventPayloadExtension ** p = (tt__ActionEngineEventPayloadExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ActionEngineEventPayloadExtension, sizeof(tt__ActionEngineEventPayloadExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, tt__ActionEngineEventPayloadExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ActionEngineEventPayloadExtension);
	if (soap_out_PointerTott__ActionEngineEventPayloadExtension(soap, tag?tag:"tt:ActionEngineEventPayloadExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__ActionEngineEventPayloadExtension ** SOAP_FMAC4 soap_get_PointerTott__ActionEngineEventPayloadExtension(struct soap *soap, tt__ActionEngineEventPayloadExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ActionEngineEventPayloadExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Fault))
		soap_serialize_SOAP_ENV__Fault(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Fault(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Fault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Fault);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Fault(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Fault ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Fault **)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Fault(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Fault);
	if (soap_out_PointerToSOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Envelope))
		soap_serialize_SOAP_ENV__Envelope(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Envelope(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Envelope *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Envelope);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Envelope(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Envelope(struct soap *soap, const char *tag, struct SOAP_ENV__Envelope **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Envelope **)soap_malloc(soap, sizeof(struct SOAP_ENV__Envelope *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Envelope(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Envelope **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Envelope);
	if (soap_out_PointerToSOAP_ENV__Envelope(soap, tag?tag:"SOAP-ENV:Envelope", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Envelope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsState(struct soap *soap, tt__AnalyticsState *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsState))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsState(struct soap *soap, const char *tag, int id, tt__AnalyticsState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsState);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AnalyticsState ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsState(struct soap *soap, const char *tag, tt__AnalyticsState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsState **)soap_malloc(soap, sizeof(tt__AnalyticsState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsState *)soap_instantiate_tt__AnalyticsState(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AnalyticsState ** p = (tt__AnalyticsState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsState, sizeof(tt__AnalyticsState), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsState(struct soap *soap, tt__AnalyticsState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsState);
	if (soap_out_PointerTott__AnalyticsState(soap, tag?tag:"tt:AnalyticsState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsState ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsState(struct soap *soap, tt__AnalyticsState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataInputExtension(struct soap *soap, tt__MetadataInputExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataInputExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataInputExtension(struct soap *soap, const char *tag, int id, tt__MetadataInputExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataInputExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__MetadataInputExtension ** SOAP_FMAC4 soap_in_PointerTott__MetadataInputExtension(struct soap *soap, const char *tag, tt__MetadataInputExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MetadataInputExtension **)soap_malloc(soap, sizeof(tt__MetadataInputExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MetadataInputExtension *)soap_instantiate_tt__MetadataInputExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__MetadataInputExtension ** p = (tt__MetadataInputExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataInputExtension, sizeof(tt__MetadataInputExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataInputExtension(struct soap *soap, tt__MetadataInputExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MetadataInputExtension);
	if (soap_out_PointerTott__MetadataInputExtension(soap, tag?tag:"tt:MetadataInputExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MetadataInputExtension ** SOAP_FMAC4 soap_get_PointerTott__MetadataInputExtension(struct soap *soap, tt__MetadataInputExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataInputExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SourceIdentificationExtension(struct soap *soap, tt__SourceIdentificationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SourceIdentificationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SourceIdentificationExtension(struct soap *soap, const char *tag, int id, tt__SourceIdentificationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SourceIdentificationExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__SourceIdentificationExtension ** SOAP_FMAC4 soap_in_PointerTott__SourceIdentificationExtension(struct soap *soap, const char *tag, tt__SourceIdentificationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SourceIdentificationExtension **)soap_malloc(soap, sizeof(tt__SourceIdentificationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SourceIdentificationExtension *)soap_instantiate_tt__SourceIdentificationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__SourceIdentificationExtension ** p = (tt__SourceIdentificationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SourceIdentificationExtension, sizeof(tt__SourceIdentificationExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SourceIdentificationExtension(struct soap *soap, tt__SourceIdentificationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SourceIdentificationExtension);
	if (soap_out_PointerTott__SourceIdentificationExtension(soap, tag?tag:"tt:SourceIdentificationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SourceIdentificationExtension ** SOAP_FMAC4 soap_get_PointerTott__SourceIdentificationExtension(struct soap *soap, tt__SourceIdentificationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SourceIdentificationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, tt__AnalyticsEngineInputInfoExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, int id, tt__AnalyticsEngineInputInfoExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AnalyticsEngineInputInfoExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, const char *tag, tt__AnalyticsEngineInputInfoExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsEngineInputInfoExtension **)soap_malloc(soap, sizeof(tt__AnalyticsEngineInputInfoExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsEngineInputInfoExtension *)soap_instantiate_tt__AnalyticsEngineInputInfoExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AnalyticsEngineInputInfoExtension ** p = (tt__AnalyticsEngineInputInfoExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineInputInfoExtension, sizeof(tt__AnalyticsEngineInputInfoExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, tt__AnalyticsEngineInputInfoExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsEngineInputInfoExtension);
	if (soap_out_PointerTott__AnalyticsEngineInputInfoExtension(soap, tag?tag:"tt:AnalyticsEngineInputInfoExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsEngineInputInfoExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineInputInfoExtension(struct soap *soap, tt__AnalyticsEngineInputInfoExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineInputInfoExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, tt__AnalyticsEngineInputInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineInputInfo))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, int id, tt__AnalyticsEngineInputInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineInputInfo);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AnalyticsEngineInputInfo ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, const char *tag, tt__AnalyticsEngineInputInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsEngineInputInfo **)soap_malloc(soap, sizeof(tt__AnalyticsEngineInputInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsEngineInputInfo *)soap_instantiate_tt__AnalyticsEngineInputInfo(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AnalyticsEngineInputInfo ** p = (tt__AnalyticsEngineInputInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineInputInfo, sizeof(tt__AnalyticsEngineInputInfo), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, tt__AnalyticsEngineInputInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsEngineInputInfo);
	if (soap_out_PointerTott__AnalyticsEngineInputInfo(soap, tag?tag:"tt:AnalyticsEngineInputInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsEngineInputInfo ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineInputInfo(struct soap *soap, tt__AnalyticsEngineInputInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineInputInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, tt__AnalyticsDeviceEngineConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const char *tag, int id, tt__AnalyticsDeviceEngineConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AnalyticsDeviceEngineConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, const char *tag, tt__AnalyticsDeviceEngineConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AnalyticsDeviceEngineConfigurationExtension **)soap_malloc(soap, sizeof(tt__AnalyticsDeviceEngineConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AnalyticsDeviceEngineConfigurationExtension *)soap_instantiate_tt__AnalyticsDeviceEngineConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AnalyticsDeviceEngineConfigurationExtension ** p = (tt__AnalyticsDeviceEngineConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfigurationExtension, sizeof(tt__AnalyticsDeviceEngineConfigurationExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, tt__AnalyticsDeviceEngineConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsDeviceEngineConfigurationExtension);
	if (soap_out_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, tag?tag:"tt:AnalyticsDeviceEngineConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AnalyticsDeviceEngineConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsDeviceEngineConfigurationExtension(struct soap *soap, tt__AnalyticsDeviceEngineConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsDeviceEngineConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__EngineConfiguration(struct soap *soap, tt__EngineConfiguration **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__EngineConfiguration))
		soap_serialize_PointerTott__EngineConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__EngineConfiguration(struct soap *soap, const char *tag, int id, tt__EngineConfiguration **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__EngineConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__EngineConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__EngineConfiguration *** SOAP_FMAC4 soap_in_PointerToPointerTott__EngineConfiguration(struct soap *soap, const char *tag, tt__EngineConfiguration ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EngineConfiguration ***)soap_malloc(soap, sizeof(tt__EngineConfiguration **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__EngineConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__EngineConfiguration ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__EngineConfiguration, sizeof(tt__EngineConfiguration *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__EngineConfiguration(struct soap *soap, tt__EngineConfiguration **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__EngineConfiguration);
	if (soap_out_PointerToPointerTott__EngineConfiguration(soap, tag?tag:"tt:EngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EngineConfiguration *** SOAP_FMAC4 soap_get_PointerToPointerTott__EngineConfiguration(struct soap *soap, tt__EngineConfiguration ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__EngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EngineConfiguration(struct soap *soap, tt__EngineConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EngineConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EngineConfiguration(struct soap *soap, const char *tag, int id, tt__EngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EngineConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__EngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__EngineConfiguration(struct soap *soap, const char *tag, tt__EngineConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__EngineConfiguration **)soap_malloc(soap, sizeof(tt__EngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__EngineConfiguration *)soap_instantiate_tt__EngineConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__EngineConfiguration ** p = (tt__EngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EngineConfiguration, sizeof(tt__EngineConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EngineConfiguration(struct soap *soap, tt__EngineConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__EngineConfiguration);
	if (soap_out_PointerTott__EngineConfiguration(soap, tag?tag:"tt:EngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__EngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__EngineConfiguration(struct soap *soap, tt__EngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobConfiguration(struct soap *soap, tt__RecordingJobConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobConfiguration(struct soap *soap, const char *tag, int id, tt__RecordingJobConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RecordingJobConfiguration ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobConfiguration(struct soap *soap, const char *tag, tt__RecordingJobConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobConfiguration **)soap_malloc(soap, sizeof(tt__RecordingJobConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingJobConfiguration *)soap_instantiate_tt__RecordingJobConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RecordingJobConfiguration ** p = (tt__RecordingJobConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobConfiguration, sizeof(tt__RecordingJobConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobConfiguration(struct soap *soap, tt__RecordingJobConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingJobConfiguration);
	if (soap_out_PointerTott__RecordingJobConfiguration(soap, tag?tag:"tt:RecordingJobConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobConfiguration ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobConfiguration(struct soap *soap, tt__RecordingJobConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__RecordingJobStateTrack(struct soap *soap, tt__RecordingJobStateTrack **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__RecordingJobStateTrack))
		soap_serialize_PointerTott__RecordingJobStateTrack(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__RecordingJobStateTrack(struct soap *soap, const char *tag, int id, tt__RecordingJobStateTrack **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__RecordingJobStateTrack);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__RecordingJobStateTrack(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__RecordingJobStateTrack *** SOAP_FMAC4 soap_in_PointerToPointerTott__RecordingJobStateTrack(struct soap *soap, const char *tag, tt__RecordingJobStateTrack ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobStateTrack ***)soap_malloc(soap, sizeof(tt__RecordingJobStateTrack **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__RecordingJobStateTrack(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__RecordingJobStateTrack ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__RecordingJobStateTrack, sizeof(tt__RecordingJobStateTrack *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__RecordingJobStateTrack(struct soap *soap, tt__RecordingJobStateTrack **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__RecordingJobStateTrack);
	if (soap_out_PointerToPointerTott__RecordingJobStateTrack(soap, tag?tag:"tt:RecordingJobStateTrack", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobStateTrack *** SOAP_FMAC4 soap_get_PointerToPointerTott__RecordingJobStateTrack(struct soap *soap, tt__RecordingJobStateTrack ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__RecordingJobStateTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateTrack(struct soap *soap, tt__RecordingJobStateTrack *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateTrack))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateTrack(struct soap *soap, const char *tag, int id, tt__RecordingJobStateTrack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateTrack);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RecordingJobStateTrack ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateTrack(struct soap *soap, const char *tag, tt__RecordingJobStateTrack **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobStateTrack **)soap_malloc(soap, sizeof(tt__RecordingJobStateTrack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingJobStateTrack *)soap_instantiate_tt__RecordingJobStateTrack(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RecordingJobStateTrack ** p = (tt__RecordingJobStateTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateTrack, sizeof(tt__RecordingJobStateTrack), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateTrack(struct soap *soap, tt__RecordingJobStateTrack *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingJobStateTrack);
	if (soap_out_PointerTott__RecordingJobStateTrack(soap, tag?tag:"tt:RecordingJobStateTrack", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobStateTrack ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateTrack(struct soap *soap, tt__RecordingJobStateTrack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateTracks(struct soap *soap, tt__RecordingJobStateTracks *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateTracks))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateTracks(struct soap *soap, const char *tag, int id, tt__RecordingJobStateTracks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateTracks);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RecordingJobStateTracks ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateTracks(struct soap *soap, const char *tag, tt__RecordingJobStateTracks **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobStateTracks **)soap_malloc(soap, sizeof(tt__RecordingJobStateTracks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingJobStateTracks *)soap_instantiate_tt__RecordingJobStateTracks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RecordingJobStateTracks ** p = (tt__RecordingJobStateTracks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateTracks, sizeof(tt__RecordingJobStateTracks), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateTracks(struct soap *soap, tt__RecordingJobStateTracks *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingJobStateTracks);
	if (soap_out_PointerTott__RecordingJobStateTracks(soap, tag?tag:"tt:RecordingJobStateTracks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobStateTracks ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateTracks(struct soap *soap, tt__RecordingJobStateTracks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateTracks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, tt__RecordingJobStateInformationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateInformationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, const char *tag, int id, tt__RecordingJobStateInformationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateInformationExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RecordingJobStateInformationExtension ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, const char *tag, tt__RecordingJobStateInformationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobStateInformationExtension **)soap_malloc(soap, sizeof(tt__RecordingJobStateInformationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingJobStateInformationExtension *)soap_instantiate_tt__RecordingJobStateInformationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RecordingJobStateInformationExtension ** p = (tt__RecordingJobStateInformationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateInformationExtension, sizeof(tt__RecordingJobStateInformationExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, tt__RecordingJobStateInformationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingJobStateInformationExtension);
	if (soap_out_PointerTott__RecordingJobStateInformationExtension(soap, tag?tag:"tt:RecordingJobStateInformationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobStateInformationExtension ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateInformationExtension(struct soap *soap, tt__RecordingJobStateInformationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateInformationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__RecordingJobStateSource(struct soap *soap, tt__RecordingJobStateSource **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__RecordingJobStateSource))
		soap_serialize_PointerTott__RecordingJobStateSource(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__RecordingJobStateSource(struct soap *soap, const char *tag, int id, tt__RecordingJobStateSource **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__RecordingJobStateSource);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__RecordingJobStateSource(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__RecordingJobStateSource *** SOAP_FMAC4 soap_in_PointerToPointerTott__RecordingJobStateSource(struct soap *soap, const char *tag, tt__RecordingJobStateSource ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobStateSource ***)soap_malloc(soap, sizeof(tt__RecordingJobStateSource **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__RecordingJobStateSource(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__RecordingJobStateSource ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__RecordingJobStateSource, sizeof(tt__RecordingJobStateSource *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__RecordingJobStateSource(struct soap *soap, tt__RecordingJobStateSource **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__RecordingJobStateSource);
	if (soap_out_PointerToPointerTott__RecordingJobStateSource(soap, tag?tag:"tt:RecordingJobStateSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobStateSource *** SOAP_FMAC4 soap_get_PointerToPointerTott__RecordingJobStateSource(struct soap *soap, tt__RecordingJobStateSource ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__RecordingJobStateSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateSource(struct soap *soap, tt__RecordingJobStateSource *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateSource))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateSource(struct soap *soap, const char *tag, int id, tt__RecordingJobStateSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateSource);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RecordingJobStateSource ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateSource(struct soap *soap, const char *tag, tt__RecordingJobStateSource **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobStateSource **)soap_malloc(soap, sizeof(tt__RecordingJobStateSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingJobStateSource *)soap_instantiate_tt__RecordingJobStateSource(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RecordingJobStateSource ** p = (tt__RecordingJobStateSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateSource, sizeof(tt__RecordingJobStateSource), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateSource(struct soap *soap, tt__RecordingJobStateSource *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingJobStateSource);
	if (soap_out_PointerTott__RecordingJobStateSource(soap, tag?tag:"tt:RecordingJobStateSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobStateSource ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateSource(struct soap *soap, tt__RecordingJobStateSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobSourceExtension(struct soap *soap, tt__RecordingJobSourceExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobSourceExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobSourceExtension(struct soap *soap, const char *tag, int id, tt__RecordingJobSourceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobSourceExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RecordingJobSourceExtension ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobSourceExtension(struct soap *soap, const char *tag, tt__RecordingJobSourceExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobSourceExtension **)soap_malloc(soap, sizeof(tt__RecordingJobSourceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingJobSourceExtension *)soap_instantiate_tt__RecordingJobSourceExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RecordingJobSourceExtension ** p = (tt__RecordingJobSourceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobSourceExtension, sizeof(tt__RecordingJobSourceExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobSourceExtension(struct soap *soap, tt__RecordingJobSourceExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingJobSourceExtension);
	if (soap_out_PointerTott__RecordingJobSourceExtension(soap, tag?tag:"tt:RecordingJobSourceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobSourceExtension ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobSourceExtension(struct soap *soap, tt__RecordingJobSourceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__RecordingJobTrack(struct soap *soap, tt__RecordingJobTrack **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__RecordingJobTrack))
		soap_serialize_PointerTott__RecordingJobTrack(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__RecordingJobTrack(struct soap *soap, const char *tag, int id, tt__RecordingJobTrack **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__RecordingJobTrack);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__RecordingJobTrack(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__RecordingJobTrack *** SOAP_FMAC4 soap_in_PointerToPointerTott__RecordingJobTrack(struct soap *soap, const char *tag, tt__RecordingJobTrack ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobTrack ***)soap_malloc(soap, sizeof(tt__RecordingJobTrack **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__RecordingJobTrack(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__RecordingJobTrack ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__RecordingJobTrack, sizeof(tt__RecordingJobTrack *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__RecordingJobTrack(struct soap *soap, tt__RecordingJobTrack **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__RecordingJobTrack);
	if (soap_out_PointerToPointerTott__RecordingJobTrack(soap, tag?tag:"tt:RecordingJobTrack", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobTrack *** SOAP_FMAC4 soap_get_PointerToPointerTott__RecordingJobTrack(struct soap *soap, tt__RecordingJobTrack ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__RecordingJobTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobTrack(struct soap *soap, tt__RecordingJobTrack *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobTrack))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobTrack(struct soap *soap, const char *tag, int id, tt__RecordingJobTrack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobTrack);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RecordingJobTrack ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobTrack(struct soap *soap, const char *tag, tt__RecordingJobTrack **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobTrack **)soap_malloc(soap, sizeof(tt__RecordingJobTrack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingJobTrack *)soap_instantiate_tt__RecordingJobTrack(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RecordingJobTrack ** p = (tt__RecordingJobTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobTrack, sizeof(tt__RecordingJobTrack), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobTrack(struct soap *soap, tt__RecordingJobTrack *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingJobTrack);
	if (soap_out_PointerTott__RecordingJobTrack(soap, tag?tag:"tt:RecordingJobTrack", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobTrack ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobTrack(struct soap *soap, tt__RecordingJobTrack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, tt__RecordingJobConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobConfigurationExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, const char *tag, int id, tt__RecordingJobConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobConfigurationExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RecordingJobConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, const char *tag, tt__RecordingJobConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobConfigurationExtension **)soap_malloc(soap, sizeof(tt__RecordingJobConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingJobConfigurationExtension *)soap_instantiate_tt__RecordingJobConfigurationExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RecordingJobConfigurationExtension ** p = (tt__RecordingJobConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobConfigurationExtension, sizeof(tt__RecordingJobConfigurationExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, tt__RecordingJobConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingJobConfigurationExtension);
	if (soap_out_PointerTott__RecordingJobConfigurationExtension(soap, tag?tag:"tt:RecordingJobConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobConfigurationExtension(struct soap *soap, tt__RecordingJobConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__RecordingJobSource(struct soap *soap, tt__RecordingJobSource **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__RecordingJobSource))
		soap_serialize_PointerTott__RecordingJobSource(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__RecordingJobSource(struct soap *soap, const char *tag, int id, tt__RecordingJobSource **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__RecordingJobSource);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__RecordingJobSource(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__RecordingJobSource *** SOAP_FMAC4 soap_in_PointerToPointerTott__RecordingJobSource(struct soap *soap, const char *tag, tt__RecordingJobSource ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobSource ***)soap_malloc(soap, sizeof(tt__RecordingJobSource **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__RecordingJobSource(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__RecordingJobSource ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__RecordingJobSource, sizeof(tt__RecordingJobSource *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__RecordingJobSource(struct soap *soap, tt__RecordingJobSource **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__RecordingJobSource);
	if (soap_out_PointerToPointerTott__RecordingJobSource(soap, tag?tag:"tt:RecordingJobSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobSource *** SOAP_FMAC4 soap_get_PointerToPointerTott__RecordingJobSource(struct soap *soap, tt__RecordingJobSource ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__RecordingJobSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobSource(struct soap *soap, tt__RecordingJobSource *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobSource))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobSource(struct soap *soap, const char *tag, int id, tt__RecordingJobSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobSource);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RecordingJobSource ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobSource(struct soap *soap, const char *tag, tt__RecordingJobSource **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingJobSource **)soap_malloc(soap, sizeof(tt__RecordingJobSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingJobSource *)soap_instantiate_tt__RecordingJobSource(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RecordingJobSource ** p = (tt__RecordingJobSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobSource, sizeof(tt__RecordingJobSource), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobSource(struct soap *soap, tt__RecordingJobSource *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingJobSource);
	if (soap_out_PointerTott__RecordingJobSource(soap, tag?tag:"tt:RecordingJobSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingJobSource ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobSource(struct soap *soap, tt__RecordingJobSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackConfiguration(struct soap *soap, tt__TrackConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackConfiguration(struct soap *soap, const char *tag, int id, tt__TrackConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__TrackConfiguration ** SOAP_FMAC4 soap_in_PointerTott__TrackConfiguration(struct soap *soap, const char *tag, tt__TrackConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__TrackConfiguration **)soap_malloc(soap, sizeof(tt__TrackConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__TrackConfiguration *)soap_instantiate_tt__TrackConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__TrackConfiguration ** p = (tt__TrackConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackConfiguration, sizeof(tt__TrackConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackConfiguration(struct soap *soap, tt__TrackConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__TrackConfiguration);
	if (soap_out_PointerTott__TrackConfiguration(soap, tag?tag:"tt:TrackConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__TrackConfiguration ** SOAP_FMAC4 soap_get_PointerTott__TrackConfiguration(struct soap *soap, tt__TrackConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__GetTracksResponseItem(struct soap *soap, tt__GetTracksResponseItem **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__GetTracksResponseItem))
		soap_serialize_PointerTott__GetTracksResponseItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__GetTracksResponseItem(struct soap *soap, const char *tag, int id, tt__GetTracksResponseItem **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__GetTracksResponseItem);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__GetTracksResponseItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__GetTracksResponseItem *** SOAP_FMAC4 soap_in_PointerToPointerTott__GetTracksResponseItem(struct soap *soap, const char *tag, tt__GetTracksResponseItem ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__GetTracksResponseItem ***)soap_malloc(soap, sizeof(tt__GetTracksResponseItem **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__GetTracksResponseItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__GetTracksResponseItem ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__GetTracksResponseItem, sizeof(tt__GetTracksResponseItem *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__GetTracksResponseItem(struct soap *soap, tt__GetTracksResponseItem **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__GetTracksResponseItem);
	if (soap_out_PointerToPointerTott__GetTracksResponseItem(soap, tag?tag:"tt:GetTracksResponseItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__GetTracksResponseItem *** SOAP_FMAC4 soap_get_PointerToPointerTott__GetTracksResponseItem(struct soap *soap, tt__GetTracksResponseItem ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__GetTracksResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GetTracksResponseItem(struct soap *soap, tt__GetTracksResponseItem *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GetTracksResponseItem))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GetTracksResponseItem(struct soap *soap, const char *tag, int id, tt__GetTracksResponseItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GetTracksResponseItem);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__GetTracksResponseItem ** SOAP_FMAC4 soap_in_PointerTott__GetTracksResponseItem(struct soap *soap, const char *tag, tt__GetTracksResponseItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__GetTracksResponseItem **)soap_malloc(soap, sizeof(tt__GetTracksResponseItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__GetTracksResponseItem *)soap_instantiate_tt__GetTracksResponseItem(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__GetTracksResponseItem ** p = (tt__GetTracksResponseItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GetTracksResponseItem, sizeof(tt__GetTracksResponseItem), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GetTracksResponseItem(struct soap *soap, tt__GetTracksResponseItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__GetTracksResponseItem);
	if (soap_out_PointerTott__GetTracksResponseItem(soap, tag?tag:"tt:GetTracksResponseItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__GetTracksResponseItem ** SOAP_FMAC4 soap_get_PointerTott__GetTracksResponseItem(struct soap *soap, tt__GetTracksResponseItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GetTracksResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GetTracksResponseList(struct soap *soap, tt__GetTracksResponseList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GetTracksResponseList))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GetTracksResponseList(struct soap *soap, const char *tag, int id, tt__GetTracksResponseList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GetTracksResponseList);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__GetTracksResponseList ** SOAP_FMAC4 soap_in_PointerTott__GetTracksResponseList(struct soap *soap, const char *tag, tt__GetTracksResponseList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__GetTracksResponseList **)soap_malloc(soap, sizeof(tt__GetTracksResponseList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__GetTracksResponseList *)soap_instantiate_tt__GetTracksResponseList(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__GetTracksResponseList ** p = (tt__GetTracksResponseList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GetTracksResponseList, sizeof(tt__GetTracksResponseList), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GetTracksResponseList(struct soap *soap, tt__GetTracksResponseList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__GetTracksResponseList);
	if (soap_out_PointerTott__GetTracksResponseList(soap, tag?tag:"tt:GetTracksResponseList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__GetTracksResponseList ** SOAP_FMAC4 soap_get_PointerTott__GetTracksResponseList(struct soap *soap, tt__GetTracksResponseList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GetTracksResponseList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingConfiguration(struct soap *soap, tt__RecordingConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingConfiguration))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingConfiguration(struct soap *soap, const char *tag, int id, tt__RecordingConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingConfiguration);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RecordingConfiguration ** SOAP_FMAC4 soap_in_PointerTott__RecordingConfiguration(struct soap *soap, const char *tag, tt__RecordingConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingConfiguration **)soap_malloc(soap, sizeof(tt__RecordingConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingConfiguration *)soap_instantiate_tt__RecordingConfiguration(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RecordingConfiguration ** p = (tt__RecordingConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingConfiguration, sizeof(tt__RecordingConfiguration), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingConfiguration(struct soap *soap, tt__RecordingConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingConfiguration);
	if (soap_out_PointerTott__RecordingConfiguration(soap, tag?tag:"tt:RecordingConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingConfiguration ** SOAP_FMAC4 soap_get_PointerTott__RecordingConfiguration(struct soap *soap, tt__RecordingConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackAttributesExtension(struct soap *soap, tt__TrackAttributesExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackAttributesExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackAttributesExtension(struct soap *soap, const char *tag, int id, tt__TrackAttributesExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackAttributesExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__TrackAttributesExtension ** SOAP_FMAC4 soap_in_PointerTott__TrackAttributesExtension(struct soap *soap, const char *tag, tt__TrackAttributesExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__TrackAttributesExtension **)soap_malloc(soap, sizeof(tt__TrackAttributesExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__TrackAttributesExtension *)soap_instantiate_tt__TrackAttributesExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__TrackAttributesExtension ** p = (tt__TrackAttributesExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackAttributesExtension, sizeof(tt__TrackAttributesExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackAttributesExtension(struct soap *soap, tt__TrackAttributesExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__TrackAttributesExtension);
	if (soap_out_PointerTott__TrackAttributesExtension(soap, tag?tag:"tt:TrackAttributesExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__TrackAttributesExtension ** SOAP_FMAC4 soap_get_PointerTott__TrackAttributesExtension(struct soap *soap, tt__TrackAttributesExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackAttributesExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataAttributes(struct soap *soap, tt__MetadataAttributes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataAttributes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataAttributes(struct soap *soap, const char *tag, int id, tt__MetadataAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataAttributes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__MetadataAttributes ** SOAP_FMAC4 soap_in_PointerTott__MetadataAttributes(struct soap *soap, const char *tag, tt__MetadataAttributes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__MetadataAttributes **)soap_malloc(soap, sizeof(tt__MetadataAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__MetadataAttributes *)soap_instantiate_tt__MetadataAttributes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__MetadataAttributes ** p = (tt__MetadataAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataAttributes, sizeof(tt__MetadataAttributes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataAttributes(struct soap *soap, tt__MetadataAttributes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MetadataAttributes);
	if (soap_out_PointerTott__MetadataAttributes(soap, tag?tag:"tt:MetadataAttributes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__MetadataAttributes ** SOAP_FMAC4 soap_get_PointerTott__MetadataAttributes(struct soap *soap, tt__MetadataAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioAttributes(struct soap *soap, tt__AudioAttributes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioAttributes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioAttributes(struct soap *soap, const char *tag, int id, tt__AudioAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioAttributes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__AudioAttributes ** SOAP_FMAC4 soap_in_PointerTott__AudioAttributes(struct soap *soap, const char *tag, tt__AudioAttributes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__AudioAttributes **)soap_malloc(soap, sizeof(tt__AudioAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__AudioAttributes *)soap_instantiate_tt__AudioAttributes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__AudioAttributes ** p = (tt__AudioAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioAttributes, sizeof(tt__AudioAttributes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioAttributes(struct soap *soap, tt__AudioAttributes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioAttributes);
	if (soap_out_PointerTott__AudioAttributes(soap, tag?tag:"tt:AudioAttributes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__AudioAttributes ** SOAP_FMAC4 soap_get_PointerTott__AudioAttributes(struct soap *soap, tt__AudioAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoAttributes(struct soap *soap, tt__VideoAttributes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoAttributes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoAttributes(struct soap *soap, const char *tag, int id, tt__VideoAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoAttributes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__VideoAttributes ** SOAP_FMAC4 soap_in_PointerTott__VideoAttributes(struct soap *soap, const char *tag, tt__VideoAttributes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__VideoAttributes **)soap_malloc(soap, sizeof(tt__VideoAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__VideoAttributes *)soap_instantiate_tt__VideoAttributes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__VideoAttributes ** p = (tt__VideoAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoAttributes, sizeof(tt__VideoAttributes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoAttributes(struct soap *soap, tt__VideoAttributes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoAttributes);
	if (soap_out_PointerTott__VideoAttributes(soap, tag?tag:"tt:VideoAttributes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__VideoAttributes ** SOAP_FMAC4 soap_get_PointerTott__VideoAttributes(struct soap *soap, tt__VideoAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__TrackAttributes(struct soap *soap, tt__TrackAttributes **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__TrackAttributes))
		soap_serialize_PointerTott__TrackAttributes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__TrackAttributes(struct soap *soap, const char *tag, int id, tt__TrackAttributes **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__TrackAttributes);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__TrackAttributes(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__TrackAttributes *** SOAP_FMAC4 soap_in_PointerToPointerTott__TrackAttributes(struct soap *soap, const char *tag, tt__TrackAttributes ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__TrackAttributes ***)soap_malloc(soap, sizeof(tt__TrackAttributes **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__TrackAttributes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__TrackAttributes ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__TrackAttributes, sizeof(tt__TrackAttributes *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__TrackAttributes(struct soap *soap, tt__TrackAttributes **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__TrackAttributes);
	if (soap_out_PointerToPointerTott__TrackAttributes(soap, tag?tag:"tt:TrackAttributes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__TrackAttributes *** SOAP_FMAC4 soap_get_PointerToPointerTott__TrackAttributes(struct soap *soap, tt__TrackAttributes ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__TrackAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackAttributes(struct soap *soap, tt__TrackAttributes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackAttributes))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackAttributes(struct soap *soap, const char *tag, int id, tt__TrackAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackAttributes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__TrackAttributes ** SOAP_FMAC4 soap_in_PointerTott__TrackAttributes(struct soap *soap, const char *tag, tt__TrackAttributes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__TrackAttributes **)soap_malloc(soap, sizeof(tt__TrackAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__TrackAttributes *)soap_instantiate_tt__TrackAttributes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__TrackAttributes ** p = (tt__TrackAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackAttributes, sizeof(tt__TrackAttributes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackAttributes(struct soap *soap, tt__TrackAttributes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__TrackAttributes);
	if (soap_out_PointerTott__TrackAttributes(soap, tag?tag:"tt:TrackAttributes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__TrackAttributes ** SOAP_FMAC4 soap_get_PointerTott__TrackAttributes(struct soap *soap, tt__TrackAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__TrackInformation(struct soap *soap, tt__TrackInformation **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__TrackInformation))
		soap_serialize_PointerTott__TrackInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__TrackInformation(struct soap *soap, const char *tag, int id, tt__TrackInformation **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__TrackInformation);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__TrackInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__TrackInformation *** SOAP_FMAC4 soap_in_PointerToPointerTott__TrackInformation(struct soap *soap, const char *tag, tt__TrackInformation ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__TrackInformation ***)soap_malloc(soap, sizeof(tt__TrackInformation **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__TrackInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__TrackInformation ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__TrackInformation, sizeof(tt__TrackInformation *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__TrackInformation(struct soap *soap, tt__TrackInformation **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__TrackInformation);
	if (soap_out_PointerToPointerTott__TrackInformation(soap, tag?tag:"tt:TrackInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__TrackInformation *** SOAP_FMAC4 soap_get_PointerToPointerTott__TrackInformation(struct soap *soap, tt__TrackInformation ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__TrackInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__TrackInformation(struct soap *soap, tt__TrackInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__TrackInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__TrackInformation(struct soap *soap, const char *tag, int id, tt__TrackInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__TrackInformation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__TrackInformation ** SOAP_FMAC4 soap_in_PointerTott__TrackInformation(struct soap *soap, const char *tag, tt__TrackInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__TrackInformation **)soap_malloc(soap, sizeof(tt__TrackInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__TrackInformation *)soap_instantiate_tt__TrackInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__TrackInformation ** p = (tt__TrackInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__TrackInformation, sizeof(tt__TrackInformation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__TrackInformation(struct soap *soap, tt__TrackInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__TrackInformation);
	if (soap_out_PointerTott__TrackInformation(soap, tag?tag:"tt:TrackInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__TrackInformation ** SOAP_FMAC4 soap_get_PointerTott__TrackInformation(struct soap *soap, tt__TrackInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__TrackInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingSourceInformation(struct soap *soap, tt__RecordingSourceInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingSourceInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingSourceInformation(struct soap *soap, const char *tag, int id, tt__RecordingSourceInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingSourceInformation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RecordingSourceInformation ** SOAP_FMAC4 soap_in_PointerTott__RecordingSourceInformation(struct soap *soap, const char *tag, tt__RecordingSourceInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingSourceInformation **)soap_malloc(soap, sizeof(tt__RecordingSourceInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingSourceInformation *)soap_instantiate_tt__RecordingSourceInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RecordingSourceInformation ** p = (tt__RecordingSourceInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingSourceInformation, sizeof(tt__RecordingSourceInformation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingSourceInformation(struct soap *soap, tt__RecordingSourceInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingSourceInformation);
	if (soap_out_PointerTott__RecordingSourceInformation(soap, tag?tag:"tt:RecordingSourceInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingSourceInformation ** SOAP_FMAC4 soap_get_PointerTott__RecordingSourceInformation(struct soap *soap, tt__RecordingSourceInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingSourceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__FindMetadataResult(struct soap *soap, tt__FindMetadataResult **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__FindMetadataResult))
		soap_serialize_PointerTott__FindMetadataResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__FindMetadataResult(struct soap *soap, const char *tag, int id, tt__FindMetadataResult **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__FindMetadataResult);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__FindMetadataResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__FindMetadataResult *** SOAP_FMAC4 soap_in_PointerToPointerTott__FindMetadataResult(struct soap *soap, const char *tag, tt__FindMetadataResult ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FindMetadataResult ***)soap_malloc(soap, sizeof(tt__FindMetadataResult **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__FindMetadataResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__FindMetadataResult ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__FindMetadataResult, sizeof(tt__FindMetadataResult *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__FindMetadataResult(struct soap *soap, tt__FindMetadataResult **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__FindMetadataResult);
	if (soap_out_PointerToPointerTott__FindMetadataResult(soap, tag?tag:"tt:FindMetadataResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FindMetadataResult *** SOAP_FMAC4 soap_get_PointerToPointerTott__FindMetadataResult(struct soap *soap, tt__FindMetadataResult ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__FindMetadataResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindMetadataResult(struct soap *soap, tt__FindMetadataResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindMetadataResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindMetadataResult(struct soap *soap, const char *tag, int id, tt__FindMetadataResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindMetadataResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__FindMetadataResult ** SOAP_FMAC4 soap_in_PointerTott__FindMetadataResult(struct soap *soap, const char *tag, tt__FindMetadataResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FindMetadataResult **)soap_malloc(soap, sizeof(tt__FindMetadataResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FindMetadataResult *)soap_instantiate_tt__FindMetadataResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__FindMetadataResult ** p = (tt__FindMetadataResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindMetadataResult, sizeof(tt__FindMetadataResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindMetadataResult(struct soap *soap, tt__FindMetadataResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FindMetadataResult);
	if (soap_out_PointerTott__FindMetadataResult(soap, tag?tag:"tt:FindMetadataResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FindMetadataResult ** SOAP_FMAC4 soap_get_PointerTott__FindMetadataResult(struct soap *soap, tt__FindMetadataResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindMetadataResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__FindPTZPositionResult(struct soap *soap, tt__FindPTZPositionResult **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__FindPTZPositionResult))
		soap_serialize_PointerTott__FindPTZPositionResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__FindPTZPositionResult(struct soap *soap, const char *tag, int id, tt__FindPTZPositionResult **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__FindPTZPositionResult);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__FindPTZPositionResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__FindPTZPositionResult *** SOAP_FMAC4 soap_in_PointerToPointerTott__FindPTZPositionResult(struct soap *soap, const char *tag, tt__FindPTZPositionResult ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FindPTZPositionResult ***)soap_malloc(soap, sizeof(tt__FindPTZPositionResult **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__FindPTZPositionResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__FindPTZPositionResult ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__FindPTZPositionResult, sizeof(tt__FindPTZPositionResult *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__FindPTZPositionResult(struct soap *soap, tt__FindPTZPositionResult **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__FindPTZPositionResult);
	if (soap_out_PointerToPointerTott__FindPTZPositionResult(soap, tag?tag:"tt:FindPTZPositionResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FindPTZPositionResult *** SOAP_FMAC4 soap_get_PointerToPointerTott__FindPTZPositionResult(struct soap *soap, tt__FindPTZPositionResult ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__FindPTZPositionResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindPTZPositionResult(struct soap *soap, tt__FindPTZPositionResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindPTZPositionResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindPTZPositionResult(struct soap *soap, const char *tag, int id, tt__FindPTZPositionResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindPTZPositionResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__FindPTZPositionResult ** SOAP_FMAC4 soap_in_PointerTott__FindPTZPositionResult(struct soap *soap, const char *tag, tt__FindPTZPositionResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FindPTZPositionResult **)soap_malloc(soap, sizeof(tt__FindPTZPositionResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FindPTZPositionResult *)soap_instantiate_tt__FindPTZPositionResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__FindPTZPositionResult ** p = (tt__FindPTZPositionResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindPTZPositionResult, sizeof(tt__FindPTZPositionResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindPTZPositionResult(struct soap *soap, tt__FindPTZPositionResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FindPTZPositionResult);
	if (soap_out_PointerTott__FindPTZPositionResult(soap, tag?tag:"tt:FindPTZPositionResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FindPTZPositionResult ** SOAP_FMAC4 soap_get_PointerTott__FindPTZPositionResult(struct soap *soap, tt__FindPTZPositionResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindPTZPositionResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__FindEventResult(struct soap *soap, tt__FindEventResult **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__FindEventResult))
		soap_serialize_PointerTott__FindEventResult(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__FindEventResult(struct soap *soap, const char *tag, int id, tt__FindEventResult **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__FindEventResult);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__FindEventResult(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__FindEventResult *** SOAP_FMAC4 soap_in_PointerToPointerTott__FindEventResult(struct soap *soap, const char *tag, tt__FindEventResult ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FindEventResult ***)soap_malloc(soap, sizeof(tt__FindEventResult **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__FindEventResult(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__FindEventResult ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__FindEventResult, sizeof(tt__FindEventResult *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__FindEventResult(struct soap *soap, tt__FindEventResult **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__FindEventResult);
	if (soap_out_PointerToPointerTott__FindEventResult(soap, tag?tag:"tt:FindEventResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FindEventResult *** SOAP_FMAC4 soap_get_PointerToPointerTott__FindEventResult(struct soap *soap, tt__FindEventResult ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__FindEventResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindEventResult(struct soap *soap, tt__FindEventResult *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindEventResult))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindEventResult(struct soap *soap, const char *tag, int id, tt__FindEventResult *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindEventResult);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__FindEventResult ** SOAP_FMAC4 soap_in_PointerTott__FindEventResult(struct soap *soap, const char *tag, tt__FindEventResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__FindEventResult **)soap_malloc(soap, sizeof(tt__FindEventResult *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__FindEventResult *)soap_instantiate_tt__FindEventResult(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__FindEventResult ** p = (tt__FindEventResult **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindEventResult, sizeof(tt__FindEventResult), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindEventResult(struct soap *soap, tt__FindEventResult *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FindEventResult);
	if (soap_out_PointerTott__FindEventResult(soap, tag?tag:"tt:FindEventResult", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__FindEventResult ** SOAP_FMAC4 soap_get_PointerTott__FindEventResult(struct soap *soap, tt__FindEventResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindEventResult(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__RecordingInformation(struct soap *soap, tt__RecordingInformation **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__RecordingInformation))
		soap_serialize_PointerTott__RecordingInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__RecordingInformation(struct soap *soap, const char *tag, int id, tt__RecordingInformation **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__RecordingInformation);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__RecordingInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__RecordingInformation *** SOAP_FMAC4 soap_in_PointerToPointerTott__RecordingInformation(struct soap *soap, const char *tag, tt__RecordingInformation ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingInformation ***)soap_malloc(soap, sizeof(tt__RecordingInformation **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__RecordingInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__RecordingInformation ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__RecordingInformation, sizeof(tt__RecordingInformation *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__RecordingInformation(struct soap *soap, tt__RecordingInformation **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__RecordingInformation);
	if (soap_out_PointerToPointerTott__RecordingInformation(soap, tag?tag:"tt:RecordingInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingInformation *** SOAP_FMAC4 soap_get_PointerToPointerTott__RecordingInformation(struct soap *soap, tt__RecordingInformation ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__RecordingInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingInformation(struct soap *soap, tt__RecordingInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingInformation))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingInformation(struct soap *soap, const char *tag, int id, tt__RecordingInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingInformation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__RecordingInformation ** SOAP_FMAC4 soap_in_PointerTott__RecordingInformation(struct soap *soap, const char *tag, tt__RecordingInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__RecordingInformation **)soap_malloc(soap, sizeof(tt__RecordingInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__RecordingInformation *)soap_instantiate_tt__RecordingInformation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__RecordingInformation ** p = (tt__RecordingInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingInformation, sizeof(tt__RecordingInformation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingInformation(struct soap *soap, tt__RecordingInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingInformation);
	if (soap_out_PointerTott__RecordingInformation(soap, tag?tag:"tt:RecordingInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__RecordingInformation ** SOAP_FMAC4 soap_get_PointerTott__RecordingInformation(struct soap *soap, tt__RecordingInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SearchScopeExtension(struct soap *soap, tt__SearchScopeExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SearchScopeExtension))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SearchScopeExtension(struct soap *soap, const char *tag, int id, tt__SearchScopeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SearchScopeExtension);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__SearchScopeExtension ** SOAP_FMAC4 soap_in_PointerTott__SearchScopeExtension(struct soap *soap, const char *tag, tt__SearchScopeExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SearchScopeExtension **)soap_malloc(soap, sizeof(tt__SearchScopeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SearchScopeExtension *)soap_instantiate_tt__SearchScopeExtension(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__SearchScopeExtension ** p = (tt__SearchScopeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SearchScopeExtension, sizeof(tt__SearchScopeExtension), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SearchScopeExtension(struct soap *soap, tt__SearchScopeExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SearchScopeExtension);
	if (soap_out_PointerTott__SearchScopeExtension(soap, tag?tag:"tt:SearchScopeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SearchScopeExtension ** SOAP_FMAC4 soap_get_PointerTott__SearchScopeExtension(struct soap *soap, tt__SearchScopeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SearchScopeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingReference(struct soap *soap, char **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingReference))
		soap_serialize_tt__RecordingReference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingReference(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingReference);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTott__RecordingReference(struct soap *soap, const char *tag, char ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingReference, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingReference(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingReference);
	if (soap_out_PointerTott__RecordingReference(soap, tag?tag:"byte", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTott__RecordingReference(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTott__SourceReference(struct soap *soap, tt__SourceReference **const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTott__SourceReference))
		soap_serialize_PointerTott__SourceReference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTott__SourceReference(struct soap *soap, const char *tag, int id, tt__SourceReference **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTott__SourceReference);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTott__SourceReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 tt__SourceReference *** SOAP_FMAC4 soap_in_PointerToPointerTott__SourceReference(struct soap *soap, const char *tag, tt__SourceReference ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SourceReference ***)soap_malloc(soap, sizeof(tt__SourceReference **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTott__SourceReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (tt__SourceReference ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTott__SourceReference, sizeof(tt__SourceReference *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTott__SourceReference(struct soap *soap, tt__SourceReference **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTott__SourceReference);
	if (soap_out_PointerToPointerTott__SourceReference(soap, tag?tag:"tt:SourceReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SourceReference *** SOAP_FMAC4 soap_get_PointerToPointerTott__SourceReference(struct soap *soap, tt__SourceReference ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTott__SourceReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SourceReference(struct soap *soap, tt__SourceReference *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SourceReference))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SourceReference(struct soap *soap, const char *tag, int id, tt__SourceReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SourceReference);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 tt__SourceReference ** SOAP_FMAC4 soap_in_PointerTott__SourceReference(struct soap *soap, const char *tag, tt__SourceReference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (tt__SourceReference **)soap_malloc(soap, sizeof(tt__SourceReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (tt__SourceReference *)soap_instantiate_tt__SourceReference(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	tt__SourceReference ** p = (tt__SourceReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SourceReference, sizeof(tt__SourceReference), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SourceReference(struct soap *soap, tt__SourceReference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SourceReference);
	if (soap_out_PointerTott__SourceReference(soap, tag?tag:"tt:SourceReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 tt__SourceReference ** SOAP_FMAC4 soap_get_PointerTott__SourceReference(struct soap *soap, tt__SourceReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SourceReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

