#include "soapH.h"


SOAP_FMAC1 tt__VideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoAnalyticsConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoAnalyticsConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoAnalyticsConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoAnalyticsConfiguration);
		if (size)
			*size = sizeof(tt__VideoAnalyticsConfiguration);
		((tt__VideoAnalyticsConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoAnalyticsConfiguration, n);
		if (size)
			*size = n * sizeof(tt__VideoAnalyticsConfiguration);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__VideoAnalyticsConfiguration*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__VideoAnalyticsConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoAnalyticsConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoAnalyticsConfiguration %p -> %p\n", q, p));
	*(tt__VideoAnalyticsConfiguration*)p = *(tt__VideoAnalyticsConfiguration*)q;
}

void tt__AudioEncoderConfigurationOption::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__AudioEncoding(soap, &this->tt__AudioEncoderConfigurationOption::Encoding);
	this->tt__AudioEncoderConfigurationOption::BitrateList = NULL;
	this->tt__AudioEncoderConfigurationOption::SampleRateList = NULL;
	this->tt__AudioEncoderConfigurationOption::__size = 0;
	this->tt__AudioEncoderConfigurationOption::__any = NULL;
	this->tt__AudioEncoderConfigurationOption::__anyAttribute = NULL;
}

void tt__AudioEncoderConfigurationOption::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IntList(soap, &this->tt__AudioEncoderConfigurationOption::BitrateList);
	soap_serialize_PointerTott__IntList(soap, &this->tt__AudioEncoderConfigurationOption::SampleRateList);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AudioEncoderConfigurationOption::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioEncoderConfigurationOption(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, int id, const tt__AudioEncoderConfigurationOption *a, const char *type)
{
	if (((tt__AudioEncoderConfigurationOption*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__AudioEncoderConfigurationOption*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOption), "tt:AudioEncoderConfigurationOption"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_tt__AudioEncoding(soap, "tt:Encoding", -1, &(a->tt__AudioEncoderConfigurationOption::Encoding), ""))
		return soap->error;
	if (a->tt__AudioEncoderConfigurationOption::BitrateList)
	{	if (soap_out_PointerTott__IntList(soap, "tt:BitrateList", -1, &a->tt__AudioEncoderConfigurationOption::BitrateList, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:BitrateList"))
		return soap->error;
	if (a->tt__AudioEncoderConfigurationOption::SampleRateList)
	{	if (soap_out_PointerTott__IntList(soap, "tt:SampleRateList", -1, &a->tt__AudioEncoderConfigurationOption::SampleRateList, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SampleRateList"))
		return soap->error;
	if (a->tt__AudioEncoderConfigurationOption::__any)
	{	int i;
		for (i = 0; i < a->tt__AudioEncoderConfigurationOption::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__AudioEncoderConfigurationOption::__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__AudioEncoderConfigurationOption::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AudioEncoderConfigurationOption(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOption * SOAP_FMAC4 soap_in_tt__AudioEncoderConfigurationOption(struct soap *soap, const char *tag, tt__AudioEncoderConfigurationOption *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioEncoderConfigurationOption *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOption, sizeof(tt__AudioEncoderConfigurationOption), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AudioEncoderConfigurationOption)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AudioEncoderConfigurationOption *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((tt__AudioEncoderConfigurationOption*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_BitrateList1 = 1;
	size_t soap_flag_SampleRateList1 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Encoding1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__AudioEncoding(soap, "tt:Encoding", &(a->tt__AudioEncoderConfigurationOption::Encoding), "tt:AudioEncoding"))
				{	soap_flag_Encoding1--;
					continue;
				}
			if (soap_flag_BitrateList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:BitrateList", &(a->tt__AudioEncoderConfigurationOption::BitrateList), "tt:IntList"))
				{	soap_flag_BitrateList1--;
					continue;
				}
			if (soap_flag_SampleRateList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:SampleRateList", &(a->tt__AudioEncoderConfigurationOption::SampleRateList), "tt:IntList"))
				{	soap_flag_SampleRateList1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__AudioEncoderConfigurationOption::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__AudioEncoderConfigurationOption::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__AudioEncoderConfigurationOption::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__AudioEncoderConfigurationOption::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__AudioEncoderConfigurationOption::__any, "xsd:byte"))
				{	a->tt__AudioEncoderConfigurationOption::__size++;
					a->tt__AudioEncoderConfigurationOption::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__AudioEncoderConfigurationOption::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__AudioEncoderConfigurationOption::__size)
			a->tt__AudioEncoderConfigurationOption::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__AudioEncoderConfigurationOption::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioEncoderConfigurationOption *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfigurationOption, 0, sizeof(tt__AudioEncoderConfigurationOption), 0, soap_copy_tt__AudioEncoderConfigurationOption);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Encoding1 > 0 || soap_flag_BitrateList1 > 0 || soap_flag_SampleRateList1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__AudioEncoderConfigurationOption::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AudioEncoderConfigurationOption);
	if (this->soap_out(soap, tag?tag:"tt:AudioEncoderConfigurationOption", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioEncoderConfigurationOption::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioEncoderConfigurationOption(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOption * SOAP_FMAC4 soap_get_tt__AudioEncoderConfigurationOption(struct soap *soap, tt__AudioEncoderConfigurationOption *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfigurationOption(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AudioEncoderConfigurationOption * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfigurationOption(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioEncoderConfigurationOption(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AudioEncoderConfigurationOption, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioEncoderConfigurationOption);
		if (size)
			*size = sizeof(tt__AudioEncoderConfigurationOption);
		((tt__AudioEncoderConfigurationOption*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__AudioEncoderConfigurationOption, n);
		if (size)
			*size = n * sizeof(tt__AudioEncoderConfigurationOption);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__AudioEncoderConfigurationOption*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__AudioEncoderConfigurationOption*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AudioEncoderConfigurationOption(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AudioEncoderConfigurationOption %p -> %p\n", q, p));
	*(tt__AudioEncoderConfigurationOption*)p = *(tt__AudioEncoderConfigurationOption*)q;
}

void tt__AudioEncoderConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__AudioEncoderConfigurationOptions::__sizeOptions = 0;
	this->tt__AudioEncoderConfigurationOptions::Options = NULL;
	this->tt__AudioEncoderConfigurationOptions::__anyAttribute = NULL;
}

void tt__AudioEncoderConfigurationOptions::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->tt__AudioEncoderConfigurationOptions::Options)
	{	int i;
		for (i = 0; i < this->tt__AudioEncoderConfigurationOptions::__sizeOptions; i++)
		{
			soap_serialize_PointerTott__AudioEncoderConfigurationOption(soap, this->tt__AudioEncoderConfigurationOptions::Options + i);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AudioEncoderConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioEncoderConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__AudioEncoderConfigurationOptions *a, const char *type)
{
	if (((tt__AudioEncoderConfigurationOptions*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__AudioEncoderConfigurationOptions*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions), "tt:AudioEncoderConfigurationOptions"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__AudioEncoderConfigurationOptions::Options)
	{	int i;
		for (i = 0; i < a->tt__AudioEncoderConfigurationOptions::__sizeOptions; i++)
			if (soap_out_PointerTott__AudioEncoderConfigurationOption(soap, "tt:Options", -1, a->tt__AudioEncoderConfigurationOptions::Options + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__AudioEncoderConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AudioEncoderConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioEncoderConfigurationOptions(struct soap *soap, const char *tag, tt__AudioEncoderConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioEncoderConfigurationOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, sizeof(tt__AudioEncoderConfigurationOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AudioEncoderConfigurationOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AudioEncoderConfigurationOptions *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((tt__AudioEncoderConfigurationOptions*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_Options1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Options", 1, NULL))
			{	if (a->tt__AudioEncoderConfigurationOptions::Options == NULL)
				{	if (soap_blist_Options1 == NULL)
						soap_blist_Options1 = soap_new_block(soap);
					a->tt__AudioEncoderConfigurationOptions::Options = (tt__AudioEncoderConfigurationOption **)soap_push_block(soap, soap_blist_Options1, sizeof(tt__AudioEncoderConfigurationOption *));
					if (a->tt__AudioEncoderConfigurationOptions::Options == NULL)
						return NULL;
					*a->tt__AudioEncoderConfigurationOptions::Options = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__AudioEncoderConfigurationOption(soap, "tt:Options", a->tt__AudioEncoderConfigurationOptions::Options, "tt:AudioEncoderConfigurationOption"))
				{	a->tt__AudioEncoderConfigurationOptions::__sizeOptions++;
					a->tt__AudioEncoderConfigurationOptions::Options = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__AudioEncoderConfigurationOptions::Options)
			soap_pop_block(soap, soap_blist_Options1);
		if (a->tt__AudioEncoderConfigurationOptions::__sizeOptions)
			a->tt__AudioEncoderConfigurationOptions::Options = (tt__AudioEncoderConfigurationOption **)soap_save_block(soap, soap_blist_Options1, NULL, 1);
		else
		{	a->tt__AudioEncoderConfigurationOptions::Options = NULL;
			if (soap_blist_Options1)
				soap_end_block(soap, soap_blist_Options1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, 0, sizeof(tt__AudioEncoderConfigurationOptions), 0, soap_copy_tt__AudioEncoderConfigurationOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__AudioEncoderConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AudioEncoderConfigurationOptions);
	if (this->soap_out(soap, tag?tag:"tt:AudioEncoderConfigurationOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioEncoderConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioEncoderConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioEncoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioEncoderConfigurationOptions(struct soap *soap, tt__AudioEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioEncoderConfigurationOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AudioEncoderConfigurationOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioEncoderConfigurationOptions);
		if (size)
			*size = sizeof(tt__AudioEncoderConfigurationOptions);
		((tt__AudioEncoderConfigurationOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__AudioEncoderConfigurationOptions, n);
		if (size)
			*size = n * sizeof(tt__AudioEncoderConfigurationOptions);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__AudioEncoderConfigurationOptions*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__AudioEncoderConfigurationOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AudioEncoderConfigurationOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AudioEncoderConfigurationOptions %p -> %p\n", q, p));
	*(tt__AudioEncoderConfigurationOptions*)p = *(tt__AudioEncoderConfigurationOptions*)q;
}

void tt__AudioEncoderConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__AudioEncoding(soap, &this->tt__AudioEncoderConfiguration::Encoding);
	soap_default_int(soap, &this->tt__AudioEncoderConfiguration::Bitrate);
	soap_default_int(soap, &this->tt__AudioEncoderConfiguration::SampleRate);
	this->tt__AudioEncoderConfiguration::Multicast = NULL;
	soap_default_xsd__duration(soap, &this->tt__AudioEncoderConfiguration::SessionTimeout);
	this->tt__AudioEncoderConfiguration::__size = 0;
	this->tt__AudioEncoderConfiguration::__any = NULL;
	this->tt__AudioEncoderConfiguration::__anyAttribute = NULL;
}

void tt__AudioEncoderConfiguration::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__AudioEncoderConfiguration::Bitrate, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__AudioEncoderConfiguration::SampleRate, SOAP_TYPE_int);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &this->tt__AudioEncoderConfiguration::Multicast);
	soap_embedded(soap, &this->tt__AudioEncoderConfiguration::SessionTimeout, SOAP_TYPE_xsd__duration);
	this->tt__ConfigurationEntity::soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AudioEncoderConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioEncoderConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const tt__AudioEncoderConfiguration *a, const char *type)
{
	if (((tt__AudioEncoderConfiguration*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__AudioEncoderConfiguration*)a)->__anyAttribute, 1);
	if (((tt__ConfigurationEntity*)a)->token)
		soap_set_attr(soap, "token", ((tt__ConfigurationEntity*)a)->token, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioEncoderConfiguration), "tt:AudioEncoderConfiguration"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__ConfigurationEntity::Name)
	{	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &(a->tt__ConfigurationEntity::UseCount), ""))
		return soap->error;
	if (soap_out_tt__AudioEncoding(soap, "tt:Encoding", -1, &(a->tt__AudioEncoderConfiguration::Encoding), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Bitrate", -1, &(a->tt__AudioEncoderConfiguration::Bitrate), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:SampleRate", -1, &(a->tt__AudioEncoderConfiguration::SampleRate), ""))
		return soap->error;
	if (a->tt__AudioEncoderConfiguration::Multicast)
	{	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->tt__AudioEncoderConfiguration::Multicast, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Multicast"))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &(a->tt__AudioEncoderConfiguration::SessionTimeout), ""))
		return soap->error;
	if (a->tt__AudioEncoderConfiguration::__any)
	{	int i;
		for (i = 0; i < a->tt__AudioEncoderConfiguration::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__AudioEncoderConfiguration::__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__AudioEncoderConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AudioEncoderConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioEncoderConfiguration * SOAP_FMAC4 soap_in_tt__AudioEncoderConfiguration(struct soap *soap, const char *tag, tt__AudioEncoderConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioEncoderConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioEncoderConfiguration, sizeof(tt__AudioEncoderConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AudioEncoderConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AudioEncoderConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((tt__AudioEncoderConfiguration*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &((tt__ConfigurationEntity*)a)->token, 0, 64))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_Bitrate1 = 1;
	size_t soap_flag_SampleRate1 = 1;
	size_t soap_flag_Multicast1 = 1;
	size_t soap_flag_SessionTimeout1 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &(a->tt__ConfigurationEntity::Name), "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &(a->tt__ConfigurationEntity::UseCount), "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			if (soap_flag_Encoding1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__AudioEncoding(soap, "tt:Encoding", &(a->tt__AudioEncoderConfiguration::Encoding), "tt:AudioEncoding"))
				{	soap_flag_Encoding1--;
					continue;
				}
			if (soap_flag_Bitrate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Bitrate", &(a->tt__AudioEncoderConfiguration::Bitrate), "xsd:int"))
				{	soap_flag_Bitrate1--;
					continue;
				}
			if (soap_flag_SampleRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:SampleRate", &(a->tt__AudioEncoderConfiguration::SampleRate), "xsd:int"))
				{	soap_flag_SampleRate1--;
					continue;
				}
			if (soap_flag_Multicast1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &(a->tt__AudioEncoderConfiguration::Multicast), "tt:MulticastConfiguration"))
				{	soap_flag_Multicast1--;
					continue;
				}
			if (soap_flag_SessionTimeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &(a->tt__AudioEncoderConfiguration::SessionTimeout), "xsd:duration"))
				{	soap_flag_SessionTimeout1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__AudioEncoderConfiguration::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__AudioEncoderConfiguration::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__AudioEncoderConfiguration::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__AudioEncoderConfiguration::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__AudioEncoderConfiguration::__any, "xsd:byte"))
				{	a->tt__AudioEncoderConfiguration::__size++;
					a->tt__AudioEncoderConfiguration::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__AudioEncoderConfiguration::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__AudioEncoderConfiguration::__size)
			a->tt__AudioEncoderConfiguration::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__AudioEncoderConfiguration::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioEncoderConfiguration, 0, sizeof(tt__AudioEncoderConfiguration), 0, soap_copy_tt__AudioEncoderConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_Encoding1 > 0 || soap_flag_Bitrate1 > 0 || soap_flag_SampleRate1 > 0 || soap_flag_Multicast1 > 0 || soap_flag_SessionTimeout1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__AudioEncoderConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AudioEncoderConfiguration);
	if (this->soap_out(soap, tag?tag:"tt:AudioEncoderConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioEncoderConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioEncoderConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioEncoderConfiguration * SOAP_FMAC4 soap_get_tt__AudioEncoderConfiguration(struct soap *soap, tt__AudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioEncoderConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AudioEncoderConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioEncoderConfiguration);
		if (size)
			*size = sizeof(tt__AudioEncoderConfiguration);
		((tt__AudioEncoderConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__AudioEncoderConfiguration, n);
		if (size)
			*size = n * sizeof(tt__AudioEncoderConfiguration);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__AudioEncoderConfiguration*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__AudioEncoderConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AudioEncoderConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AudioEncoderConfiguration %p -> %p\n", q, p));
	*(tt__AudioEncoderConfiguration*)p = *(tt__AudioEncoderConfiguration*)q;
}

void tt__AudioSourceOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__AudioSourceOptionsExtension::__size = 0;
	this->tt__AudioSourceOptionsExtension::__any = NULL;
}

void tt__AudioSourceOptionsExtension::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AudioSourceOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioSourceOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceOptionsExtension(struct soap *soap, const char *tag, int id, const tt__AudioSourceOptionsExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceOptionsExtension), "tt:AudioSourceOptionsExtension"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__AudioSourceOptionsExtension::__any)
	{	int i;
		for (i = 0; i < a->tt__AudioSourceOptionsExtension::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__AudioSourceOptionsExtension::__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__AudioSourceOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AudioSourceOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioSourceOptionsExtension * SOAP_FMAC4 soap_in_tt__AudioSourceOptionsExtension(struct soap *soap, const char *tag, tt__AudioSourceOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioSourceOptionsExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceOptionsExtension, sizeof(tt__AudioSourceOptionsExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AudioSourceOptionsExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AudioSourceOptionsExtension *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__AudioSourceOptionsExtension::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__AudioSourceOptionsExtension::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__AudioSourceOptionsExtension::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__AudioSourceOptionsExtension::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__AudioSourceOptionsExtension::__any, "xsd:byte"))
				{	a->tt__AudioSourceOptionsExtension::__size++;
					a->tt__AudioSourceOptionsExtension::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__AudioSourceOptionsExtension::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__AudioSourceOptionsExtension::__size)
			a->tt__AudioSourceOptionsExtension::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__AudioSourceOptionsExtension::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioSourceOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceOptionsExtension, 0, sizeof(tt__AudioSourceOptionsExtension), 0, soap_copy_tt__AudioSourceOptionsExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__AudioSourceOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AudioSourceOptionsExtension);
	if (this->soap_out(soap, tag?tag:"tt:AudioSourceOptionsExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioSourceOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioSourceOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioSourceOptionsExtension * SOAP_FMAC4 soap_get_tt__AudioSourceOptionsExtension(struct soap *soap, tt__AudioSourceOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AudioSourceOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__AudioSourceOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioSourceOptionsExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AudioSourceOptionsExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioSourceOptionsExtension);
		if (size)
			*size = sizeof(tt__AudioSourceOptionsExtension);
		((tt__AudioSourceOptionsExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__AudioSourceOptionsExtension, n);
		if (size)
			*size = n * sizeof(tt__AudioSourceOptionsExtension);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__AudioSourceOptionsExtension*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__AudioSourceOptionsExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AudioSourceOptionsExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AudioSourceOptionsExtension %p -> %p\n", q, p));
	*(tt__AudioSourceOptionsExtension*)p = *(tt__AudioSourceOptionsExtension*)q;
}

void tt__AudioSourceConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__AudioSourceConfigurationOptions::__sizeInputTokensAvailable = 0;
	this->tt__AudioSourceConfigurationOptions::InputTokensAvailable = NULL;
	this->tt__AudioSourceConfigurationOptions::Extension = NULL;
	this->tt__AudioSourceConfigurationOptions::__anyAttribute = NULL;
}

void tt__AudioSourceConfigurationOptions::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->tt__AudioSourceConfigurationOptions::InputTokensAvailable)
	{	int i;
		for (i = 0; i < this->tt__AudioSourceConfigurationOptions::__sizeInputTokensAvailable; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, this->tt__AudioSourceConfigurationOptions::InputTokensAvailable + i);
		}
	}
	soap_serialize_PointerTott__AudioSourceOptionsExtension(soap, &this->tt__AudioSourceConfigurationOptions::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AudioSourceConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioSourceConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__AudioSourceConfigurationOptions *a, const char *type)
{
	if (((tt__AudioSourceConfigurationOptions*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__AudioSourceConfigurationOptions*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceConfigurationOptions), "tt:AudioSourceConfigurationOptions"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__AudioSourceConfigurationOptions::InputTokensAvailable)
	{	int i;
		for (i = 0; i < a->tt__AudioSourceConfigurationOptions::__sizeInputTokensAvailable; i++)
			if (soap_out_tt__ReferenceToken(soap, "tt:InputTokensAvailable", -1, a->tt__AudioSourceConfigurationOptions::InputTokensAvailable + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__AudioSourceOptionsExtension(soap, "tt:Extension", -1, &(a->tt__AudioSourceConfigurationOptions::Extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__AudioSourceConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AudioSourceConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioSourceConfigurationOptions * SOAP_FMAC4 soap_in_tt__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, tt__AudioSourceConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioSourceConfigurationOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(tt__AudioSourceConfigurationOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AudioSourceConfigurationOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AudioSourceConfigurationOptions *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((tt__AudioSourceConfigurationOptions*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_InputTokensAvailable1 = NULL;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:InputTokensAvailable", 1, NULL))
			{	if (a->tt__AudioSourceConfigurationOptions::InputTokensAvailable == NULL)
				{	if (soap_blist_InputTokensAvailable1 == NULL)
						soap_blist_InputTokensAvailable1 = soap_new_block(soap);
					a->tt__AudioSourceConfigurationOptions::InputTokensAvailable = (char **)soap_push_block(soap, soap_blist_InputTokensAvailable1, sizeof(char *));
					if (a->tt__AudioSourceConfigurationOptions::InputTokensAvailable == NULL)
						return NULL;
					*a->tt__AudioSourceConfigurationOptions::InputTokensAvailable = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:InputTokensAvailable", a->tt__AudioSourceConfigurationOptions::InputTokensAvailable, "tt:ReferenceToken"))
				{	a->tt__AudioSourceConfigurationOptions::__sizeInputTokensAvailable++;
					a->tt__AudioSourceConfigurationOptions::InputTokensAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioSourceOptionsExtension(soap, "tt:Extension", &(a->tt__AudioSourceConfigurationOptions::Extension), "tt:AudioSourceOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__AudioSourceConfigurationOptions::InputTokensAvailable)
			soap_pop_block(soap, soap_blist_InputTokensAvailable1);
		if (a->tt__AudioSourceConfigurationOptions::__sizeInputTokensAvailable)
			a->tt__AudioSourceConfigurationOptions::InputTokensAvailable = (char **)soap_save_block(soap, soap_blist_InputTokensAvailable1, NULL, 1);
		else
		{	a->tt__AudioSourceConfigurationOptions::InputTokensAvailable = NULL;
			if (soap_blist_InputTokensAvailable1)
				soap_end_block(soap, soap_blist_InputTokensAvailable1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceConfigurationOptions, 0, sizeof(tt__AudioSourceConfigurationOptions), 0, soap_copy_tt__AudioSourceConfigurationOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__AudioSourceConfigurationOptions::__sizeInputTokensAvailable < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__AudioSourceConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AudioSourceConfigurationOptions);
	if (this->soap_out(soap, tag?tag:"tt:AudioSourceConfigurationOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioSourceConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioSourceConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioSourceConfigurationOptions * SOAP_FMAC4 soap_get_tt__AudioSourceConfigurationOptions(struct soap *soap, tt__AudioSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__AudioSourceConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioSourceConfigurationOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AudioSourceConfigurationOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioSourceConfigurationOptions);
		if (size)
			*size = sizeof(tt__AudioSourceConfigurationOptions);
		((tt__AudioSourceConfigurationOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__AudioSourceConfigurationOptions, n);
		if (size)
			*size = n * sizeof(tt__AudioSourceConfigurationOptions);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__AudioSourceConfigurationOptions*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__AudioSourceConfigurationOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AudioSourceConfigurationOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AudioSourceConfigurationOptions %p -> %p\n", q, p));
	*(tt__AudioSourceConfigurationOptions*)p = *(tt__AudioSourceConfigurationOptions*)q;
}

void tt__AudioSourceConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__AudioSourceConfiguration::SourceToken);
	this->tt__AudioSourceConfiguration::__size = 0;
	this->tt__AudioSourceConfiguration::__any = NULL;
	this->tt__AudioSourceConfiguration::__anyAttribute = NULL;
}

void tt__AudioSourceConfiguration::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &this->tt__AudioSourceConfiguration::SourceToken);
	this->tt__ConfigurationEntity::soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AudioSourceConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioSourceConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSourceConfiguration(struct soap *soap, const char *tag, int id, const tt__AudioSourceConfiguration *a, const char *type)
{
	if (((tt__AudioSourceConfiguration*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__AudioSourceConfiguration*)a)->__anyAttribute, 1);
	if (((tt__ConfigurationEntity*)a)->token)
		soap_set_attr(soap, "token", ((tt__ConfigurationEntity*)a)->token, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSourceConfiguration), "tt:AudioSourceConfiguration"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__ConfigurationEntity::Name)
	{	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &(a->tt__ConfigurationEntity::UseCount), ""))
		return soap->error;
	if (a->tt__AudioSourceConfiguration::SourceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tt:SourceToken", -1, &a->tt__AudioSourceConfiguration::SourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SourceToken"))
		return soap->error;
	if (a->tt__AudioSourceConfiguration::__any)
	{	int i;
		for (i = 0; i < a->tt__AudioSourceConfiguration::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__AudioSourceConfiguration::__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__AudioSourceConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AudioSourceConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioSourceConfiguration * SOAP_FMAC4 soap_in_tt__AudioSourceConfiguration(struct soap *soap, const char *tag, tt__AudioSourceConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioSourceConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSourceConfiguration, sizeof(tt__AudioSourceConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AudioSourceConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AudioSourceConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((tt__AudioSourceConfiguration*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &((tt__ConfigurationEntity*)a)->token, 0, 64))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_SourceToken1 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &(a->tt__ConfigurationEntity::Name), "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &(a->tt__ConfigurationEntity::UseCount), "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			if (soap_flag_SourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:SourceToken", &(a->tt__AudioSourceConfiguration::SourceToken), "tt:ReferenceToken"))
				{	soap_flag_SourceToken1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__AudioSourceConfiguration::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__AudioSourceConfiguration::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__AudioSourceConfiguration::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__AudioSourceConfiguration::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__AudioSourceConfiguration::__any, "xsd:byte"))
				{	a->tt__AudioSourceConfiguration::__size++;
					a->tt__AudioSourceConfiguration::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__AudioSourceConfiguration::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__AudioSourceConfiguration::__size)
			a->tt__AudioSourceConfiguration::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__AudioSourceConfiguration::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSourceConfiguration, 0, sizeof(tt__AudioSourceConfiguration), 0, soap_copy_tt__AudioSourceConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_SourceToken1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__AudioSourceConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AudioSourceConfiguration);
	if (this->soap_out(soap, tag?tag:"tt:AudioSourceConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioSourceConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioSourceConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioSourceConfiguration * SOAP_FMAC4 soap_get_tt__AudioSourceConfiguration(struct soap *soap, tt__AudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AudioSourceConfiguration * SOAP_FMAC2 soap_instantiate_tt__AudioSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioSourceConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AudioSourceConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioSourceConfiguration);
		if (size)
			*size = sizeof(tt__AudioSourceConfiguration);
		((tt__AudioSourceConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__AudioSourceConfiguration, n);
		if (size)
			*size = n * sizeof(tt__AudioSourceConfiguration);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__AudioSourceConfiguration*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__AudioSourceConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AudioSourceConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AudioSourceConfiguration %p -> %p\n", q, p));
	*(tt__AudioSourceConfiguration*)p = *(tt__AudioSourceConfiguration*)q;
}

void tt__H264Options2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__H264Options::soap_default(soap);
	this->xsd__anyType::soap_default(soap);
	this->tt__H264Options2::BitrateRange = NULL;
	this->tt__H264Options2::__size = 0;
	this->tt__H264Options2::__any = NULL;
	this->tt__H264Options2::__anyAttribute = NULL;
}

void tt__H264Options2::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IntRange(soap, &this->tt__H264Options2::BitrateRange);
	this->tt__H264Options::soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__H264Options2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__H264Options2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Options2(struct soap *soap, const char *tag, int id, const tt__H264Options2 *a, const char *type)
{
	if (((tt__H264Options2*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__H264Options2*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Options2), "tt:H264Options2"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__H264Options::ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->tt__H264Options::__sizeResolutionsAvailable; i++)
			if (soap_out_PointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->tt__H264Options::ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->tt__H264Options::GovLengthRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->tt__H264Options::GovLengthRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:GovLengthRange"))
		return soap->error;
	if (a->tt__H264Options::FrameRateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__H264Options::FrameRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
		return soap->error;
	if (a->tt__H264Options::EncodingIntervalRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__H264Options::EncodingIntervalRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
		return soap->error;
	if (a->tt__H264Options::H264ProfilesSupported)
	{	int i;
		for (i = 0; i < a->tt__H264Options::__sizeH264ProfilesSupported; i++)
			if (soap_out_tt__H264Profile(soap, "tt:H264ProfilesSupported", -1, a->tt__H264Options::H264ProfilesSupported + i, ""))
				return soap->error;
	}
	if (a->tt__H264Options2::BitrateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->tt__H264Options2::BitrateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:BitrateRange"))
		return soap->error;
	if (a->tt__H264Options2::__any)
	{	int i;
		for (i = 0; i < a->tt__H264Options2::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__H264Options2::__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__H264Options2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__H264Options2(soap, tag, this, type);
}

SOAP_FMAC3 tt__H264Options2 * SOAP_FMAC4 soap_in_tt__H264Options2(struct soap *soap, const char *tag, tt__H264Options2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__H264Options2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Options2, sizeof(tt__H264Options2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__H264Options2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__H264Options2 *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((tt__H264Options2*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag___item3 = 1;
	struct soap_blist *soap_blist_ResolutionsAvailable2 = NULL;
	size_t soap_flag_GovLengthRange2 = 1;
	size_t soap_flag_FrameRateRange2 = 1;
	size_t soap_flag_EncodingIntervalRange2 = 1;
	struct soap_blist *soap_blist_H264ProfilesSupported2 = NULL;
	size_t soap_flag_BitrateRange1 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->tt__H264Options::ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable2 == NULL)
						soap_blist_ResolutionsAvailable2 = soap_new_block(soap);
					a->tt__H264Options::ResolutionsAvailable = (tt__VideoResolution **)soap_push_block(soap, soap_blist_ResolutionsAvailable2, sizeof(tt__VideoResolution *));
					if (a->tt__H264Options::ResolutionsAvailable == NULL)
						return NULL;
					*a->tt__H264Options::ResolutionsAvailable = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", a->tt__H264Options::ResolutionsAvailable, "tt:VideoResolution"))
				{	a->tt__H264Options::__sizeResolutionsAvailable++;
					a->tt__H264Options::ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &(a->tt__H264Options::GovLengthRange), "tt:IntRange"))
				{	soap_flag_GovLengthRange2--;
					continue;
				}
			if (soap_flag_FrameRateRange2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &(a->tt__H264Options::FrameRateRange), "tt:IntRange"))
				{	soap_flag_FrameRateRange2--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &(a->tt__H264Options::EncodingIntervalRange), "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:H264ProfilesSupported", 1, NULL))
			{	if (a->tt__H264Options::H264ProfilesSupported == NULL)
				{	if (soap_blist_H264ProfilesSupported2 == NULL)
						soap_blist_H264ProfilesSupported2 = soap_new_block(soap);
					a->tt__H264Options::H264ProfilesSupported = (enum tt__H264Profile *)soap_push_block(soap, soap_blist_H264ProfilesSupported2, sizeof(enum tt__H264Profile));
					if (a->tt__H264Options::H264ProfilesSupported == NULL)
						return NULL;
					soap_default_tt__H264Profile(soap, a->tt__H264Options::H264ProfilesSupported);
				}
				soap_revert(soap);
				if (soap_in_tt__H264Profile(soap, "tt:H264ProfilesSupported", a->tt__H264Options::H264ProfilesSupported, "tt:H264Profile"))
				{	a->tt__H264Options::__sizeH264ProfilesSupported++;
					a->tt__H264Options::H264ProfilesSupported = NULL;
					continue;
				}
			}
			if (soap_flag_BitrateRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &(a->tt__H264Options2::BitrateRange), "tt:IntRange"))
				{	soap_flag_BitrateRange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__H264Options2::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__H264Options2::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__H264Options2::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__H264Options2::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__H264Options2::__any, "xsd:byte"))
				{	a->tt__H264Options2::__size++;
					a->tt__H264Options2::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__H264Options::ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable2);
		if (a->tt__H264Options::__sizeResolutionsAvailable)
			a->tt__H264Options::ResolutionsAvailable = (tt__VideoResolution **)soap_save_block(soap, soap_blist_ResolutionsAvailable2, NULL, 1);
		else
		{	a->tt__H264Options::ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable2)
				soap_end_block(soap, soap_blist_ResolutionsAvailable2);
		}
		if (a->tt__H264Options::H264ProfilesSupported)
			soap_pop_block(soap, soap_blist_H264ProfilesSupported2);
		if (a->tt__H264Options::__sizeH264ProfilesSupported)
			a->tt__H264Options::H264ProfilesSupported = (enum tt__H264Profile *)soap_save_block(soap, soap_blist_H264ProfilesSupported2, NULL, 1);
		else
		{	a->tt__H264Options::H264ProfilesSupported = NULL;
			if (soap_blist_H264ProfilesSupported2)
				soap_end_block(soap, soap_blist_H264ProfilesSupported2);
		}
		if (a->tt__H264Options2::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__H264Options2::__size)
			a->tt__H264Options2::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__H264Options2::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__H264Options2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Options2, 0, sizeof(tt__H264Options2), 0, soap_copy_tt__H264Options2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__H264Options::__sizeResolutionsAvailable < 1 || soap_flag_GovLengthRange2 > 0 || soap_flag_FrameRateRange2 > 0 || soap_flag_EncodingIntervalRange2 > 0 || a->tt__H264Options::__sizeH264ProfilesSupported < 1 || soap_flag_BitrateRange1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__H264Options2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__H264Options2);
	if (this->soap_out(soap, tag?tag:"tt:H264Options2", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__H264Options2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__H264Options2(soap, this, tag, type);
}

SOAP_FMAC3 tt__H264Options2 * SOAP_FMAC4 soap_get_tt__H264Options2(struct soap *soap, tt__H264Options2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__H264Options2 * SOAP_FMAC2 soap_instantiate_tt__H264Options2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__H264Options2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__H264Options2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__H264Options2);
		if (size)
			*size = sizeof(tt__H264Options2);
		((tt__H264Options2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__H264Options2, n);
		if (size)
			*size = n * sizeof(tt__H264Options2);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__H264Options2*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__H264Options2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__H264Options2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__H264Options2 %p -> %p\n", q, p));
	*(tt__H264Options2*)p = *(tt__H264Options2*)q;
}

void tt__H264Options::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__H264Options::__sizeResolutionsAvailable = 0;
	this->tt__H264Options::ResolutionsAvailable = NULL;
	this->tt__H264Options::GovLengthRange = NULL;
	this->tt__H264Options::FrameRateRange = NULL;
	this->tt__H264Options::EncodingIntervalRange = NULL;
	this->tt__H264Options::__sizeH264ProfilesSupported = 0;
	this->tt__H264Options::H264ProfilesSupported = NULL;
}

void tt__H264Options::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->tt__H264Options::ResolutionsAvailable)
	{	int i;
		for (i = 0; i < this->tt__H264Options::__sizeResolutionsAvailable; i++)
		{
			soap_serialize_PointerTott__VideoResolution(soap, this->tt__H264Options::ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &this->tt__H264Options::GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__H264Options::FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__H264Options::EncodingIntervalRange);
	if (this->tt__H264Options::H264ProfilesSupported)
	{	int i;
		for (i = 0; i < this->tt__H264Options::__sizeH264ProfilesSupported; i++)
		{
			soap_embedded(soap, this->tt__H264Options::H264ProfilesSupported + i, SOAP_TYPE_tt__H264Profile);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__H264Options::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__H264Options(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Options(struct soap *soap, const char *tag, int id, const tt__H264Options *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Options), "tt:H264Options"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__H264Options::ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->tt__H264Options::__sizeResolutionsAvailable; i++)
			if (soap_out_PointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->tt__H264Options::ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->tt__H264Options::GovLengthRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->tt__H264Options::GovLengthRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:GovLengthRange"))
		return soap->error;
	if (a->tt__H264Options::FrameRateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__H264Options::FrameRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
		return soap->error;
	if (a->tt__H264Options::EncodingIntervalRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__H264Options::EncodingIntervalRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
		return soap->error;
	if (a->tt__H264Options::H264ProfilesSupported)
	{	int i;
		for (i = 0; i < a->tt__H264Options::__sizeH264ProfilesSupported; i++)
			if (soap_out_tt__H264Profile(soap, "tt:H264ProfilesSupported", -1, a->tt__H264Options::H264ProfilesSupported + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__H264Options::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__H264Options(soap, tag, this, type);
}

SOAP_FMAC3 tt__H264Options * SOAP_FMAC4 soap_in_tt__H264Options(struct soap *soap, const char *tag, tt__H264Options *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__H264Options *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Options, sizeof(tt__H264Options), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__H264Options)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__H264Options *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_ResolutionsAvailable1 = NULL;
	size_t soap_flag_GovLengthRange1 = 1;
	size_t soap_flag_FrameRateRange1 = 1;
	size_t soap_flag_EncodingIntervalRange1 = 1;
	struct soap_blist *soap_blist_H264ProfilesSupported1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->tt__H264Options::ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable1 == NULL)
						soap_blist_ResolutionsAvailable1 = soap_new_block(soap);
					a->tt__H264Options::ResolutionsAvailable = (tt__VideoResolution **)soap_push_block(soap, soap_blist_ResolutionsAvailable1, sizeof(tt__VideoResolution *));
					if (a->tt__H264Options::ResolutionsAvailable == NULL)
						return NULL;
					*a->tt__H264Options::ResolutionsAvailable = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", a->tt__H264Options::ResolutionsAvailable, "tt:VideoResolution"))
				{	a->tt__H264Options::__sizeResolutionsAvailable++;
					a->tt__H264Options::ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &(a->tt__H264Options::GovLengthRange), "tt:IntRange"))
				{	soap_flag_GovLengthRange1--;
					continue;
				}
			if (soap_flag_FrameRateRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &(a->tt__H264Options::FrameRateRange), "tt:IntRange"))
				{	soap_flag_FrameRateRange1--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &(a->tt__H264Options::EncodingIntervalRange), "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:H264ProfilesSupported", 1, NULL))
			{	if (a->tt__H264Options::H264ProfilesSupported == NULL)
				{	if (soap_blist_H264ProfilesSupported1 == NULL)
						soap_blist_H264ProfilesSupported1 = soap_new_block(soap);
					a->tt__H264Options::H264ProfilesSupported = (enum tt__H264Profile *)soap_push_block(soap, soap_blist_H264ProfilesSupported1, sizeof(enum tt__H264Profile));
					if (a->tt__H264Options::H264ProfilesSupported == NULL)
						return NULL;
					soap_default_tt__H264Profile(soap, a->tt__H264Options::H264ProfilesSupported);
				}
				soap_revert(soap);
				if (soap_in_tt__H264Profile(soap, "tt:H264ProfilesSupported", a->tt__H264Options::H264ProfilesSupported, "tt:H264Profile"))
				{	a->tt__H264Options::__sizeH264ProfilesSupported++;
					a->tt__H264Options::H264ProfilesSupported = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__H264Options::ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable1);
		if (a->tt__H264Options::__sizeResolutionsAvailable)
			a->tt__H264Options::ResolutionsAvailable = (tt__VideoResolution **)soap_save_block(soap, soap_blist_ResolutionsAvailable1, NULL, 1);
		else
		{	a->tt__H264Options::ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable1)
				soap_end_block(soap, soap_blist_ResolutionsAvailable1);
		}
		if (a->tt__H264Options::H264ProfilesSupported)
			soap_pop_block(soap, soap_blist_H264ProfilesSupported1);
		if (a->tt__H264Options::__sizeH264ProfilesSupported)
			a->tt__H264Options::H264ProfilesSupported = (enum tt__H264Profile *)soap_save_block(soap, soap_blist_H264ProfilesSupported1, NULL, 1);
		else
		{	a->tt__H264Options::H264ProfilesSupported = NULL;
			if (soap_blist_H264ProfilesSupported1)
				soap_end_block(soap, soap_blist_H264ProfilesSupported1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__H264Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Options, 0, sizeof(tt__H264Options), 0, soap_copy_tt__H264Options);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__H264Options::__sizeResolutionsAvailable < 1 || soap_flag_GovLengthRange1 > 0 || soap_flag_FrameRateRange1 > 0 || soap_flag_EncodingIntervalRange1 > 0 || a->tt__H264Options::__sizeH264ProfilesSupported < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__H264Options::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__H264Options);
	if (this->soap_out(soap, tag?tag:"tt:H264Options", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__H264Options::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__H264Options(soap, this, tag, type);
}

SOAP_FMAC3 tt__H264Options * SOAP_FMAC4 soap_get_tt__H264Options(struct soap *soap, tt__H264Options *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__H264Options * SOAP_FMAC2 soap_instantiate_tt__H264Options(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__H264Options(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__H264Options, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "tt:H264Options2"))
	{	cp->type = SOAP_TYPE_tt__H264Options2;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__H264Options2);
			if (size)
				*size = sizeof(tt__H264Options2);
			((tt__H264Options2*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__H264Options2, n);
			if (size)
				*size = n * sizeof(tt__H264Options2);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__H264Options2*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__H264Options2*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__H264Options);
		if (size)
			*size = sizeof(tt__H264Options);
		((tt__H264Options*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__H264Options, n);
		if (size)
			*size = n * sizeof(tt__H264Options);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__H264Options*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__H264Options*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__H264Options(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__H264Options %p -> %p\n", q, p));
	*(tt__H264Options*)p = *(tt__H264Options*)q;
}

void tt__Mpeg4Options2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__Mpeg4Options::soap_default(soap);
	this->xsd__anyType::soap_default(soap);
	this->tt__Mpeg4Options2::BitrateRange = NULL;
	this->tt__Mpeg4Options2::__size = 0;
	this->tt__Mpeg4Options2::__any = NULL;
	this->tt__Mpeg4Options2::__anyAttribute = NULL;
}

void tt__Mpeg4Options2::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IntRange(soap, &this->tt__Mpeg4Options2::BitrateRange);
	this->tt__Mpeg4Options::soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Mpeg4Options2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Mpeg4Options2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Options2(struct soap *soap, const char *tag, int id, const tt__Mpeg4Options2 *a, const char *type)
{
	if (((tt__Mpeg4Options2*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__Mpeg4Options2*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Options2), "tt:Mpeg4Options2"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__Mpeg4Options::ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->tt__Mpeg4Options::__sizeResolutionsAvailable; i++)
			if (soap_out_PointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->tt__Mpeg4Options::ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->tt__Mpeg4Options::GovLengthRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->tt__Mpeg4Options::GovLengthRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:GovLengthRange"))
		return soap->error;
	if (a->tt__Mpeg4Options::FrameRateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__Mpeg4Options::FrameRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
		return soap->error;
	if (a->tt__Mpeg4Options::EncodingIntervalRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__Mpeg4Options::EncodingIntervalRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
		return soap->error;
	if (a->tt__Mpeg4Options::Mpeg4ProfilesSupported)
	{	int i;
		for (i = 0; i < a->tt__Mpeg4Options::__sizeMpeg4ProfilesSupported; i++)
			if (soap_out_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", -1, a->tt__Mpeg4Options::Mpeg4ProfilesSupported + i, ""))
				return soap->error;
	}
	if (a->tt__Mpeg4Options2::BitrateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->tt__Mpeg4Options2::BitrateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:BitrateRange"))
		return soap->error;
	if (a->tt__Mpeg4Options2::__any)
	{	int i;
		for (i = 0; i < a->tt__Mpeg4Options2::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__Mpeg4Options2::__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__Mpeg4Options2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Mpeg4Options2(soap, tag, this, type);
}

SOAP_FMAC3 tt__Mpeg4Options2 * SOAP_FMAC4 soap_in_tt__Mpeg4Options2(struct soap *soap, const char *tag, tt__Mpeg4Options2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Mpeg4Options2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Options2, sizeof(tt__Mpeg4Options2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Mpeg4Options2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Mpeg4Options2 *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((tt__Mpeg4Options2*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag___item3 = 1;
	struct soap_blist *soap_blist_ResolutionsAvailable2 = NULL;
	size_t soap_flag_GovLengthRange2 = 1;
	size_t soap_flag_FrameRateRange2 = 1;
	size_t soap_flag_EncodingIntervalRange2 = 1;
	struct soap_blist *soap_blist_Mpeg4ProfilesSupported2 = NULL;
	size_t soap_flag_BitrateRange1 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->tt__Mpeg4Options::ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable2 == NULL)
						soap_blist_ResolutionsAvailable2 = soap_new_block(soap);
					a->tt__Mpeg4Options::ResolutionsAvailable = (tt__VideoResolution **)soap_push_block(soap, soap_blist_ResolutionsAvailable2, sizeof(tt__VideoResolution *));
					if (a->tt__Mpeg4Options::ResolutionsAvailable == NULL)
						return NULL;
					*a->tt__Mpeg4Options::ResolutionsAvailable = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", a->tt__Mpeg4Options::ResolutionsAvailable, "tt:VideoResolution"))
				{	a->tt__Mpeg4Options::__sizeResolutionsAvailable++;
					a->tt__Mpeg4Options::ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &(a->tt__Mpeg4Options::GovLengthRange), "tt:IntRange"))
				{	soap_flag_GovLengthRange2--;
					continue;
				}
			if (soap_flag_FrameRateRange2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &(a->tt__Mpeg4Options::FrameRateRange), "tt:IntRange"))
				{	soap_flag_FrameRateRange2--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &(a->tt__Mpeg4Options::EncodingIntervalRange), "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mpeg4ProfilesSupported", 1, NULL))
			{	if (a->tt__Mpeg4Options::Mpeg4ProfilesSupported == NULL)
				{	if (soap_blist_Mpeg4ProfilesSupported2 == NULL)
						soap_blist_Mpeg4ProfilesSupported2 = soap_new_block(soap);
					a->tt__Mpeg4Options::Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_push_block(soap, soap_blist_Mpeg4ProfilesSupported2, sizeof(enum tt__Mpeg4Profile));
					if (a->tt__Mpeg4Options::Mpeg4ProfilesSupported == NULL)
						return NULL;
					soap_default_tt__Mpeg4Profile(soap, a->tt__Mpeg4Options::Mpeg4ProfilesSupported);
				}
				soap_revert(soap);
				if (soap_in_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", a->tt__Mpeg4Options::Mpeg4ProfilesSupported, "tt:Mpeg4Profile"))
				{	a->tt__Mpeg4Options::__sizeMpeg4ProfilesSupported++;
					a->tt__Mpeg4Options::Mpeg4ProfilesSupported = NULL;
					continue;
				}
			}
			if (soap_flag_BitrateRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &(a->tt__Mpeg4Options2::BitrateRange), "tt:IntRange"))
				{	soap_flag_BitrateRange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__Mpeg4Options2::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__Mpeg4Options2::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__Mpeg4Options2::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__Mpeg4Options2::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__Mpeg4Options2::__any, "xsd:byte"))
				{	a->tt__Mpeg4Options2::__size++;
					a->tt__Mpeg4Options2::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__Mpeg4Options::ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable2);
		if (a->tt__Mpeg4Options::__sizeResolutionsAvailable)
			a->tt__Mpeg4Options::ResolutionsAvailable = (tt__VideoResolution **)soap_save_block(soap, soap_blist_ResolutionsAvailable2, NULL, 1);
		else
		{	a->tt__Mpeg4Options::ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable2)
				soap_end_block(soap, soap_blist_ResolutionsAvailable2);
		}
		if (a->tt__Mpeg4Options::Mpeg4ProfilesSupported)
			soap_pop_block(soap, soap_blist_Mpeg4ProfilesSupported2);
		if (a->tt__Mpeg4Options::__sizeMpeg4ProfilesSupported)
			a->tt__Mpeg4Options::Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_save_block(soap, soap_blist_Mpeg4ProfilesSupported2, NULL, 1);
		else
		{	a->tt__Mpeg4Options::Mpeg4ProfilesSupported = NULL;
			if (soap_blist_Mpeg4ProfilesSupported2)
				soap_end_block(soap, soap_blist_Mpeg4ProfilesSupported2);
		}
		if (a->tt__Mpeg4Options2::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__Mpeg4Options2::__size)
			a->tt__Mpeg4Options2::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__Mpeg4Options2::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Mpeg4Options2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Options2, 0, sizeof(tt__Mpeg4Options2), 0, soap_copy_tt__Mpeg4Options2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__Mpeg4Options::__sizeResolutionsAvailable < 1 || soap_flag_GovLengthRange2 > 0 || soap_flag_FrameRateRange2 > 0 || soap_flag_EncodingIntervalRange2 > 0 || a->tt__Mpeg4Options::__sizeMpeg4ProfilesSupported < 1 || soap_flag_BitrateRange1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Mpeg4Options2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Mpeg4Options2);
	if (this->soap_out(soap, tag?tag:"tt:Mpeg4Options2", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Mpeg4Options2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Mpeg4Options2(soap, this, tag, type);
}

SOAP_FMAC3 tt__Mpeg4Options2 * SOAP_FMAC4 soap_get_tt__Mpeg4Options2(struct soap *soap, tt__Mpeg4Options2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Options2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Mpeg4Options2 * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Options2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Mpeg4Options2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Mpeg4Options2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Mpeg4Options2);
		if (size)
			*size = sizeof(tt__Mpeg4Options2);
		((tt__Mpeg4Options2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__Mpeg4Options2, n);
		if (size)
			*size = n * sizeof(tt__Mpeg4Options2);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__Mpeg4Options2*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__Mpeg4Options2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Mpeg4Options2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Mpeg4Options2 %p -> %p\n", q, p));
	*(tt__Mpeg4Options2*)p = *(tt__Mpeg4Options2*)q;
}

void tt__Mpeg4Options::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__Mpeg4Options::__sizeResolutionsAvailable = 0;
	this->tt__Mpeg4Options::ResolutionsAvailable = NULL;
	this->tt__Mpeg4Options::GovLengthRange = NULL;
	this->tt__Mpeg4Options::FrameRateRange = NULL;
	this->tt__Mpeg4Options::EncodingIntervalRange = NULL;
	this->tt__Mpeg4Options::__sizeMpeg4ProfilesSupported = 0;
	this->tt__Mpeg4Options::Mpeg4ProfilesSupported = NULL;
}

void tt__Mpeg4Options::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->tt__Mpeg4Options::ResolutionsAvailable)
	{	int i;
		for (i = 0; i < this->tt__Mpeg4Options::__sizeResolutionsAvailable; i++)
		{
			soap_serialize_PointerTott__VideoResolution(soap, this->tt__Mpeg4Options::ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &this->tt__Mpeg4Options::GovLengthRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__Mpeg4Options::FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__Mpeg4Options::EncodingIntervalRange);
	if (this->tt__Mpeg4Options::Mpeg4ProfilesSupported)
	{	int i;
		for (i = 0; i < this->tt__Mpeg4Options::__sizeMpeg4ProfilesSupported; i++)
		{
			soap_embedded(soap, this->tt__Mpeg4Options::Mpeg4ProfilesSupported + i, SOAP_TYPE_tt__Mpeg4Profile);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Mpeg4Options::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Mpeg4Options(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Options(struct soap *soap, const char *tag, int id, const tt__Mpeg4Options *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Options), "tt:Mpeg4Options"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__Mpeg4Options::ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->tt__Mpeg4Options::__sizeResolutionsAvailable; i++)
			if (soap_out_PointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->tt__Mpeg4Options::ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->tt__Mpeg4Options::GovLengthRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:GovLengthRange", -1, &a->tt__Mpeg4Options::GovLengthRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:GovLengthRange"))
		return soap->error;
	if (a->tt__Mpeg4Options::FrameRateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__Mpeg4Options::FrameRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
		return soap->error;
	if (a->tt__Mpeg4Options::EncodingIntervalRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__Mpeg4Options::EncodingIntervalRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
		return soap->error;
	if (a->tt__Mpeg4Options::Mpeg4ProfilesSupported)
	{	int i;
		for (i = 0; i < a->tt__Mpeg4Options::__sizeMpeg4ProfilesSupported; i++)
			if (soap_out_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", -1, a->tt__Mpeg4Options::Mpeg4ProfilesSupported + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__Mpeg4Options::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Mpeg4Options(soap, tag, this, type);
}

SOAP_FMAC3 tt__Mpeg4Options * SOAP_FMAC4 soap_in_tt__Mpeg4Options(struct soap *soap, const char *tag, tt__Mpeg4Options *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Mpeg4Options *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Options, sizeof(tt__Mpeg4Options), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Mpeg4Options)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Mpeg4Options *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_ResolutionsAvailable1 = NULL;
	size_t soap_flag_GovLengthRange1 = 1;
	size_t soap_flag_FrameRateRange1 = 1;
	size_t soap_flag_EncodingIntervalRange1 = 1;
	struct soap_blist *soap_blist_Mpeg4ProfilesSupported1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->tt__Mpeg4Options::ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable1 == NULL)
						soap_blist_ResolutionsAvailable1 = soap_new_block(soap);
					a->tt__Mpeg4Options::ResolutionsAvailable = (tt__VideoResolution **)soap_push_block(soap, soap_blist_ResolutionsAvailable1, sizeof(tt__VideoResolution *));
					if (a->tt__Mpeg4Options::ResolutionsAvailable == NULL)
						return NULL;
					*a->tt__Mpeg4Options::ResolutionsAvailable = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", a->tt__Mpeg4Options::ResolutionsAvailable, "tt:VideoResolution"))
				{	a->tt__Mpeg4Options::__sizeResolutionsAvailable++;
					a->tt__Mpeg4Options::ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_GovLengthRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:GovLengthRange", &(a->tt__Mpeg4Options::GovLengthRange), "tt:IntRange"))
				{	soap_flag_GovLengthRange1--;
					continue;
				}
			if (soap_flag_FrameRateRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &(a->tt__Mpeg4Options::FrameRateRange), "tt:IntRange"))
				{	soap_flag_FrameRateRange1--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &(a->tt__Mpeg4Options::EncodingIntervalRange), "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mpeg4ProfilesSupported", 1, NULL))
			{	if (a->tt__Mpeg4Options::Mpeg4ProfilesSupported == NULL)
				{	if (soap_blist_Mpeg4ProfilesSupported1 == NULL)
						soap_blist_Mpeg4ProfilesSupported1 = soap_new_block(soap);
					a->tt__Mpeg4Options::Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_push_block(soap, soap_blist_Mpeg4ProfilesSupported1, sizeof(enum tt__Mpeg4Profile));
					if (a->tt__Mpeg4Options::Mpeg4ProfilesSupported == NULL)
						return NULL;
					soap_default_tt__Mpeg4Profile(soap, a->tt__Mpeg4Options::Mpeg4ProfilesSupported);
				}
				soap_revert(soap);
				if (soap_in_tt__Mpeg4Profile(soap, "tt:Mpeg4ProfilesSupported", a->tt__Mpeg4Options::Mpeg4ProfilesSupported, "tt:Mpeg4Profile"))
				{	a->tt__Mpeg4Options::__sizeMpeg4ProfilesSupported++;
					a->tt__Mpeg4Options::Mpeg4ProfilesSupported = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__Mpeg4Options::ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable1);
		if (a->tt__Mpeg4Options::__sizeResolutionsAvailable)
			a->tt__Mpeg4Options::ResolutionsAvailable = (tt__VideoResolution **)soap_save_block(soap, soap_blist_ResolutionsAvailable1, NULL, 1);
		else
		{	a->tt__Mpeg4Options::ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable1)
				soap_end_block(soap, soap_blist_ResolutionsAvailable1);
		}
		if (a->tt__Mpeg4Options::Mpeg4ProfilesSupported)
			soap_pop_block(soap, soap_blist_Mpeg4ProfilesSupported1);
		if (a->tt__Mpeg4Options::__sizeMpeg4ProfilesSupported)
			a->tt__Mpeg4Options::Mpeg4ProfilesSupported = (enum tt__Mpeg4Profile *)soap_save_block(soap, soap_blist_Mpeg4ProfilesSupported1, NULL, 1);
		else
		{	a->tt__Mpeg4Options::Mpeg4ProfilesSupported = NULL;
			if (soap_blist_Mpeg4ProfilesSupported1)
				soap_end_block(soap, soap_blist_Mpeg4ProfilesSupported1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Mpeg4Options *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Options, 0, sizeof(tt__Mpeg4Options), 0, soap_copy_tt__Mpeg4Options);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__Mpeg4Options::__sizeResolutionsAvailable < 1 || soap_flag_GovLengthRange1 > 0 || soap_flag_FrameRateRange1 > 0 || soap_flag_EncodingIntervalRange1 > 0 || a->tt__Mpeg4Options::__sizeMpeg4ProfilesSupported < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Mpeg4Options::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Mpeg4Options);
	if (this->soap_out(soap, tag?tag:"tt:Mpeg4Options", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Mpeg4Options::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Mpeg4Options(soap, this, tag, type);
}

SOAP_FMAC3 tt__Mpeg4Options * SOAP_FMAC4 soap_get_tt__Mpeg4Options(struct soap *soap, tt__Mpeg4Options *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Options(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Mpeg4Options * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Options(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Mpeg4Options(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Mpeg4Options, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "tt:Mpeg4Options2"))
	{	cp->type = SOAP_TYPE_tt__Mpeg4Options2;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__Mpeg4Options2);
			if (size)
				*size = sizeof(tt__Mpeg4Options2);
			((tt__Mpeg4Options2*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__Mpeg4Options2, n);
			if (size)
				*size = n * sizeof(tt__Mpeg4Options2);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__Mpeg4Options2*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__Mpeg4Options2*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Mpeg4Options);
		if (size)
			*size = sizeof(tt__Mpeg4Options);
		((tt__Mpeg4Options*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__Mpeg4Options, n);
		if (size)
			*size = n * sizeof(tt__Mpeg4Options);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__Mpeg4Options*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__Mpeg4Options*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Mpeg4Options(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Mpeg4Options %p -> %p\n", q, p));
	*(tt__Mpeg4Options*)p = *(tt__Mpeg4Options*)q;
}

void tt__JpegOptions2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__JpegOptions::soap_default(soap);
	this->xsd__anyType::soap_default(soap);
	this->tt__JpegOptions2::BitrateRange = NULL;
	this->tt__JpegOptions2::__size = 0;
	this->tt__JpegOptions2::__any = NULL;
	this->tt__JpegOptions2::__anyAttribute = NULL;
}

void tt__JpegOptions2::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IntRange(soap, &this->tt__JpegOptions2::BitrateRange);
	this->tt__JpegOptions::soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__JpegOptions2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__JpegOptions2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__JpegOptions2(struct soap *soap, const char *tag, int id, const tt__JpegOptions2 *a, const char *type)
{
	if (((tt__JpegOptions2*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__JpegOptions2*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__JpegOptions2), "tt:JpegOptions2"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__JpegOptions::ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->tt__JpegOptions::__sizeResolutionsAvailable; i++)
			if (soap_out_PointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->tt__JpegOptions::ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->tt__JpegOptions::FrameRateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__JpegOptions::FrameRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
		return soap->error;
	if (a->tt__JpegOptions::EncodingIntervalRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__JpegOptions::EncodingIntervalRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
		return soap->error;
	if (a->tt__JpegOptions2::BitrateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:BitrateRange", -1, &a->tt__JpegOptions2::BitrateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:BitrateRange"))
		return soap->error;
	if (a->tt__JpegOptions2::__any)
	{	int i;
		for (i = 0; i < a->tt__JpegOptions2::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__JpegOptions2::__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__JpegOptions2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__JpegOptions2(soap, tag, this, type);
}

SOAP_FMAC3 tt__JpegOptions2 * SOAP_FMAC4 soap_in_tt__JpegOptions2(struct soap *soap, const char *tag, tt__JpegOptions2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__JpegOptions2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegOptions2, sizeof(tt__JpegOptions2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__JpegOptions2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__JpegOptions2 *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((tt__JpegOptions2*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag___item3 = 1;
	struct soap_blist *soap_blist_ResolutionsAvailable2 = NULL;
	size_t soap_flag_FrameRateRange2 = 1;
	size_t soap_flag_EncodingIntervalRange2 = 1;
	size_t soap_flag_BitrateRange1 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->tt__JpegOptions::ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable2 == NULL)
						soap_blist_ResolutionsAvailable2 = soap_new_block(soap);
					a->tt__JpegOptions::ResolutionsAvailable = (tt__VideoResolution **)soap_push_block(soap, soap_blist_ResolutionsAvailable2, sizeof(tt__VideoResolution *));
					if (a->tt__JpegOptions::ResolutionsAvailable == NULL)
						return NULL;
					*a->tt__JpegOptions::ResolutionsAvailable = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", a->tt__JpegOptions::ResolutionsAvailable, "tt:VideoResolution"))
				{	a->tt__JpegOptions::__sizeResolutionsAvailable++;
					a->tt__JpegOptions::ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_FrameRateRange2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &(a->tt__JpegOptions::FrameRateRange), "tt:IntRange"))
				{	soap_flag_FrameRateRange2--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &(a->tt__JpegOptions::EncodingIntervalRange), "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange2--;
					continue;
				}
			if (soap_flag_BitrateRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:BitrateRange", &(a->tt__JpegOptions2::BitrateRange), "tt:IntRange"))
				{	soap_flag_BitrateRange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__JpegOptions2::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__JpegOptions2::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__JpegOptions2::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__JpegOptions2::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__JpegOptions2::__any, "xsd:byte"))
				{	a->tt__JpegOptions2::__size++;
					a->tt__JpegOptions2::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__JpegOptions::ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable2);
		if (a->tt__JpegOptions::__sizeResolutionsAvailable)
			a->tt__JpegOptions::ResolutionsAvailable = (tt__VideoResolution **)soap_save_block(soap, soap_blist_ResolutionsAvailable2, NULL, 1);
		else
		{	a->tt__JpegOptions::ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable2)
				soap_end_block(soap, soap_blist_ResolutionsAvailable2);
		}
		if (a->tt__JpegOptions2::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__JpegOptions2::__size)
			a->tt__JpegOptions2::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__JpegOptions2::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__JpegOptions2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegOptions2, 0, sizeof(tt__JpegOptions2), 0, soap_copy_tt__JpegOptions2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__JpegOptions::__sizeResolutionsAvailable < 1 || soap_flag_FrameRateRange2 > 0 || soap_flag_EncodingIntervalRange2 > 0 || soap_flag_BitrateRange1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__JpegOptions2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__JpegOptions2);
	if (this->soap_out(soap, tag?tag:"tt:JpegOptions2", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__JpegOptions2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__JpegOptions2(soap, this, tag, type);
}

SOAP_FMAC3 tt__JpegOptions2 * SOAP_FMAC4 soap_get_tt__JpegOptions2(struct soap *soap, tt__JpegOptions2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__JpegOptions2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__JpegOptions2 * SOAP_FMAC2 soap_instantiate_tt__JpegOptions2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__JpegOptions2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__JpegOptions2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__JpegOptions2);
		if (size)
			*size = sizeof(tt__JpegOptions2);
		((tt__JpegOptions2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__JpegOptions2, n);
		if (size)
			*size = n * sizeof(tt__JpegOptions2);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__JpegOptions2*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__JpegOptions2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__JpegOptions2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__JpegOptions2 %p -> %p\n", q, p));
	*(tt__JpegOptions2*)p = *(tt__JpegOptions2*)q;
}

void tt__JpegOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__JpegOptions::__sizeResolutionsAvailable = 0;
	this->tt__JpegOptions::ResolutionsAvailable = NULL;
	this->tt__JpegOptions::FrameRateRange = NULL;
	this->tt__JpegOptions::EncodingIntervalRange = NULL;
}

void tt__JpegOptions::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->tt__JpegOptions::ResolutionsAvailable)
	{	int i;
		for (i = 0; i < this->tt__JpegOptions::__sizeResolutionsAvailable; i++)
		{
			soap_serialize_PointerTott__VideoResolution(soap, this->tt__JpegOptions::ResolutionsAvailable + i);
		}
	}
	soap_serialize_PointerTott__IntRange(soap, &this->tt__JpegOptions::FrameRateRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__JpegOptions::EncodingIntervalRange);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__JpegOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__JpegOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__JpegOptions(struct soap *soap, const char *tag, int id, const tt__JpegOptions *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__JpegOptions), "tt:JpegOptions"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__JpegOptions::ResolutionsAvailable)
	{	int i;
		for (i = 0; i < a->tt__JpegOptions::__sizeResolutionsAvailable; i++)
			if (soap_out_PointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", -1, a->tt__JpegOptions::ResolutionsAvailable + i, ""))
				return soap->error;
	}
	if (a->tt__JpegOptions::FrameRateRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:FrameRateRange", -1, &a->tt__JpegOptions::FrameRateRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:FrameRateRange"))
		return soap->error;
	if (a->tt__JpegOptions::EncodingIntervalRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", -1, &a->tt__JpegOptions::EncodingIntervalRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:EncodingIntervalRange"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__JpegOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__JpegOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__JpegOptions * SOAP_FMAC4 soap_in_tt__JpegOptions(struct soap *soap, const char *tag, tt__JpegOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__JpegOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__JpegOptions, sizeof(tt__JpegOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__JpegOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__JpegOptions *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_ResolutionsAvailable1 = NULL;
	size_t soap_flag_FrameRateRange1 = 1;
	size_t soap_flag_EncodingIntervalRange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:ResolutionsAvailable", 1, NULL))
			{	if (a->tt__JpegOptions::ResolutionsAvailable == NULL)
				{	if (soap_blist_ResolutionsAvailable1 == NULL)
						soap_blist_ResolutionsAvailable1 = soap_new_block(soap);
					a->tt__JpegOptions::ResolutionsAvailable = (tt__VideoResolution **)soap_push_block(soap, soap_blist_ResolutionsAvailable1, sizeof(tt__VideoResolution *));
					if (a->tt__JpegOptions::ResolutionsAvailable == NULL)
						return NULL;
					*a->tt__JpegOptions::ResolutionsAvailable = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__VideoResolution(soap, "tt:ResolutionsAvailable", a->tt__JpegOptions::ResolutionsAvailable, "tt:VideoResolution"))
				{	a->tt__JpegOptions::__sizeResolutionsAvailable++;
					a->tt__JpegOptions::ResolutionsAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_FrameRateRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:FrameRateRange", &(a->tt__JpegOptions::FrameRateRange), "tt:IntRange"))
				{	soap_flag_FrameRateRange1--;
					continue;
				}
			if (soap_flag_EncodingIntervalRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:EncodingIntervalRange", &(a->tt__JpegOptions::EncodingIntervalRange), "tt:IntRange"))
				{	soap_flag_EncodingIntervalRange1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__JpegOptions::ResolutionsAvailable)
			soap_pop_block(soap, soap_blist_ResolutionsAvailable1);
		if (a->tt__JpegOptions::__sizeResolutionsAvailable)
			a->tt__JpegOptions::ResolutionsAvailable = (tt__VideoResolution **)soap_save_block(soap, soap_blist_ResolutionsAvailable1, NULL, 1);
		else
		{	a->tt__JpegOptions::ResolutionsAvailable = NULL;
			if (soap_blist_ResolutionsAvailable1)
				soap_end_block(soap, soap_blist_ResolutionsAvailable1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__JpegOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__JpegOptions, 0, sizeof(tt__JpegOptions), 0, soap_copy_tt__JpegOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__JpegOptions::__sizeResolutionsAvailable < 1 || soap_flag_FrameRateRange1 > 0 || soap_flag_EncodingIntervalRange1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__JpegOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__JpegOptions);
	if (this->soap_out(soap, tag?tag:"tt:JpegOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__JpegOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__JpegOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__JpegOptions * SOAP_FMAC4 soap_get_tt__JpegOptions(struct soap *soap, tt__JpegOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__JpegOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__JpegOptions * SOAP_FMAC2 soap_instantiate_tt__JpegOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__JpegOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__JpegOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "tt:JpegOptions2"))
	{	cp->type = SOAP_TYPE_tt__JpegOptions2;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__JpegOptions2);
			if (size)
				*size = sizeof(tt__JpegOptions2);
			((tt__JpegOptions2*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__JpegOptions2, n);
			if (size)
				*size = n * sizeof(tt__JpegOptions2);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__JpegOptions2*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__JpegOptions2*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__JpegOptions);
		if (size)
			*size = sizeof(tt__JpegOptions);
		((tt__JpegOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__JpegOptions, n);
		if (size)
			*size = n * sizeof(tt__JpegOptions);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__JpegOptions*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__JpegOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__JpegOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__JpegOptions %p -> %p\n", q, p));
	*(tt__JpegOptions*)p = *(tt__JpegOptions*)q;
}

void tt__VideoEncoderOptionsExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__VideoEncoderOptionsExtension2::__size = 0;
	this->tt__VideoEncoderOptionsExtension2::__any = NULL;
}

void tt__VideoEncoderOptionsExtension2::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoEncoderOptionsExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoderOptionsExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, int id, const tt__VideoEncoderOptionsExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2), "tt:VideoEncoderOptionsExtension2"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__VideoEncoderOptionsExtension2::__any)
	{	int i;
		for (i = 0; i < a->tt__VideoEncoderOptionsExtension2::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__VideoEncoderOptionsExtension2::__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__VideoEncoderOptionsExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoEncoderOptionsExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension2 * SOAP_FMAC4 soap_in_tt__VideoEncoderOptionsExtension2(struct soap *soap, const char *tag, tt__VideoEncoderOptionsExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoEncoderOptionsExtension2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, sizeof(tt__VideoEncoderOptionsExtension2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoEncoderOptionsExtension2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoEncoderOptionsExtension2 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__VideoEncoderOptionsExtension2::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__VideoEncoderOptionsExtension2::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__VideoEncoderOptionsExtension2::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__VideoEncoderOptionsExtension2::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__VideoEncoderOptionsExtension2::__any, "xsd:byte"))
				{	a->tt__VideoEncoderOptionsExtension2::__size++;
					a->tt__VideoEncoderOptionsExtension2::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__VideoEncoderOptionsExtension2::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__VideoEncoderOptionsExtension2::__size)
			a->tt__VideoEncoderOptionsExtension2::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__VideoEncoderOptionsExtension2::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoEncoderOptionsExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, 0, sizeof(tt__VideoEncoderOptionsExtension2), 0, soap_copy_tt__VideoEncoderOptionsExtension2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__VideoEncoderOptionsExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoEncoderOptionsExtension2);
	if (this->soap_out(soap, tag?tag:"tt:VideoEncoderOptionsExtension2", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoderOptionsExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoderOptionsExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension2 * SOAP_FMAC4 soap_get_tt__VideoEncoderOptionsExtension2(struct soap *soap, tt__VideoEncoderOptionsExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoEncoderOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderOptionsExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncoderOptionsExtension2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoEncoderOptionsExtension2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoEncoderOptionsExtension2);
		if (size)
			*size = sizeof(tt__VideoEncoderOptionsExtension2);
		((tt__VideoEncoderOptionsExtension2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoEncoderOptionsExtension2, n);
		if (size)
			*size = n * sizeof(tt__VideoEncoderOptionsExtension2);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__VideoEncoderOptionsExtension2*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__VideoEncoderOptionsExtension2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoEncoderOptionsExtension2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoEncoderOptionsExtension2 %p -> %p\n", q, p));
	*(tt__VideoEncoderOptionsExtension2*)p = *(tt__VideoEncoderOptionsExtension2*)q;
}

void tt__VideoEncoderOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__VideoEncoderOptionsExtension::__size = 0;
	this->tt__VideoEncoderOptionsExtension::__any = NULL;
	this->tt__VideoEncoderOptionsExtension::JPEG = NULL;
	this->tt__VideoEncoderOptionsExtension::MPEG4 = NULL;
	this->tt__VideoEncoderOptionsExtension::H264 = NULL;
	this->tt__VideoEncoderOptionsExtension::Extension = NULL;
}

void tt__VideoEncoderOptionsExtension::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__JpegOptions2(soap, &this->tt__VideoEncoderOptionsExtension::JPEG);
	soap_serialize_PointerTott__Mpeg4Options2(soap, &this->tt__VideoEncoderOptionsExtension::MPEG4);
	soap_serialize_PointerTott__H264Options2(soap, &this->tt__VideoEncoderOptionsExtension::H264);
	soap_serialize_PointerTott__VideoEncoderOptionsExtension2(soap, &this->tt__VideoEncoderOptionsExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoEncoderOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoderOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, int id, const tt__VideoEncoderOptionsExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension), "tt:VideoEncoderOptionsExtension"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__VideoEncoderOptionsExtension::__any)
	{	int i;
		for (i = 0; i < a->tt__VideoEncoderOptionsExtension::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__VideoEncoderOptionsExtension::__any + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__JpegOptions2(soap, "tt:JPEG", -1, &(a->tt__VideoEncoderOptionsExtension::JPEG), ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Options2(soap, "tt:MPEG4", -1, &(a->tt__VideoEncoderOptionsExtension::MPEG4), ""))
		return soap->error;
	if (soap_out_PointerTott__H264Options2(soap, "tt:H264", -1, &(a->tt__VideoEncoderOptionsExtension::H264), ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderOptionsExtension2(soap, "tt:Extension", -1, &(a->tt__VideoEncoderOptionsExtension::Extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoEncoderOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoEncoderOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_in_tt__VideoEncoderOptionsExtension(struct soap *soap, const char *tag, tt__VideoEncoderOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoEncoderOptionsExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderOptionsExtension, sizeof(tt__VideoEncoderOptionsExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoEncoderOptionsExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoEncoderOptionsExtension *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	size_t soap_flag_JPEG1 = 1;
	size_t soap_flag_MPEG41 = 1;
	size_t soap_flag_H2641 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_JPEG1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__JpegOptions2(soap, "tt:JPEG", &(a->tt__VideoEncoderOptionsExtension::JPEG), "tt:JpegOptions2"))
				{	soap_flag_JPEG1--;
					continue;
				}
			if (soap_flag_MPEG41 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Mpeg4Options2(soap, "tt:MPEG4", &(a->tt__VideoEncoderOptionsExtension::MPEG4), "tt:Mpeg4Options2"))
				{	soap_flag_MPEG41--;
					continue;
				}
			if (soap_flag_H2641 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__H264Options2(soap, "tt:H264", &(a->tt__VideoEncoderOptionsExtension::H264), "tt:H264Options2"))
				{	soap_flag_H2641--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoEncoderOptionsExtension2(soap, "tt:Extension", &(a->tt__VideoEncoderOptionsExtension::Extension), "tt:VideoEncoderOptionsExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__VideoEncoderOptionsExtension::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__VideoEncoderOptionsExtension::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__VideoEncoderOptionsExtension::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__VideoEncoderOptionsExtension::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__VideoEncoderOptionsExtension::__any, "xsd:byte"))
				{	a->tt__VideoEncoderOptionsExtension::__size++;
					a->tt__VideoEncoderOptionsExtension::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__VideoEncoderOptionsExtension::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__VideoEncoderOptionsExtension::__size)
			a->tt__VideoEncoderOptionsExtension::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__VideoEncoderOptionsExtension::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoEncoderOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderOptionsExtension, 0, sizeof(tt__VideoEncoderOptionsExtension), 0, soap_copy_tt__VideoEncoderOptionsExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__VideoEncoderOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoEncoderOptionsExtension);
	if (this->soap_out(soap, tag?tag:"tt:VideoEncoderOptionsExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoderOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoderOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoderOptionsExtension * SOAP_FMAC4 soap_get_tt__VideoEncoderOptionsExtension(struct soap *soap, tt__VideoEncoderOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoEncoderOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncoderOptionsExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoEncoderOptionsExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoEncoderOptionsExtension);
		if (size)
			*size = sizeof(tt__VideoEncoderOptionsExtension);
		((tt__VideoEncoderOptionsExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoEncoderOptionsExtension, n);
		if (size)
			*size = n * sizeof(tt__VideoEncoderOptionsExtension);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__VideoEncoderOptionsExtension*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__VideoEncoderOptionsExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoEncoderOptionsExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoEncoderOptionsExtension %p -> %p\n", q, p));
	*(tt__VideoEncoderOptionsExtension*)p = *(tt__VideoEncoderOptionsExtension*)q;
}

void tt__VideoEncoderConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__VideoEncoderConfigurationOptions::QualityRange = NULL;
	this->tt__VideoEncoderConfigurationOptions::JPEG = NULL;
	this->tt__VideoEncoderConfigurationOptions::MPEG4 = NULL;
	this->tt__VideoEncoderConfigurationOptions::H264 = NULL;
	this->tt__VideoEncoderConfigurationOptions::Extension = NULL;
	this->tt__VideoEncoderConfigurationOptions::__anyAttribute = NULL;
}

void tt__VideoEncoderConfigurationOptions::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IntRange(soap, &this->tt__VideoEncoderConfigurationOptions::QualityRange);
	soap_serialize_PointerTott__JpegOptions(soap, &this->tt__VideoEncoderConfigurationOptions::JPEG);
	soap_serialize_PointerTott__Mpeg4Options(soap, &this->tt__VideoEncoderConfigurationOptions::MPEG4);
	soap_serialize_PointerTott__H264Options(soap, &this->tt__VideoEncoderConfigurationOptions::H264);
	soap_serialize_PointerTott__VideoEncoderOptionsExtension(soap, &this->tt__VideoEncoderConfigurationOptions::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoEncoderConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoderConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__VideoEncoderConfigurationOptions *a, const char *type)
{
	if (((tt__VideoEncoderConfigurationOptions*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__VideoEncoderConfigurationOptions*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions), "tt:VideoEncoderConfigurationOptions"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__VideoEncoderConfigurationOptions::QualityRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:QualityRange", -1, &a->tt__VideoEncoderConfigurationOptions::QualityRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:QualityRange"))
		return soap->error;
	if (soap_out_PointerTott__JpegOptions(soap, "tt:JPEG", -1, &(a->tt__VideoEncoderConfigurationOptions::JPEG), ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Options(soap, "tt:MPEG4", -1, &(a->tt__VideoEncoderConfigurationOptions::MPEG4), ""))
		return soap->error;
	if (soap_out_PointerTott__H264Options(soap, "tt:H264", -1, &(a->tt__VideoEncoderConfigurationOptions::H264), ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderOptionsExtension(soap, "tt:Extension", -1, &(a->tt__VideoEncoderConfigurationOptions::Extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoEncoderConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoEncoderConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, tt__VideoEncoderConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoEncoderConfigurationOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(tt__VideoEncoderConfigurationOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoEncoderConfigurationOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoEncoderConfigurationOptions *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((tt__VideoEncoderConfigurationOptions*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_QualityRange1 = 1;
	size_t soap_flag_JPEG1 = 1;
	size_t soap_flag_MPEG41 = 1;
	size_t soap_flag_H2641 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_QualityRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:QualityRange", &(a->tt__VideoEncoderConfigurationOptions::QualityRange), "tt:IntRange"))
				{	soap_flag_QualityRange1--;
					continue;
				}
			if (soap_flag_JPEG1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__JpegOptions(soap, "tt:JPEG", &(a->tt__VideoEncoderConfigurationOptions::JPEG), "tt:JpegOptions"))
				{	soap_flag_JPEG1--;
					continue;
				}
			if (soap_flag_MPEG41 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Mpeg4Options(soap, "tt:MPEG4", &(a->tt__VideoEncoderConfigurationOptions::MPEG4), "tt:Mpeg4Options"))
				{	soap_flag_MPEG41--;
					continue;
				}
			if (soap_flag_H2641 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__H264Options(soap, "tt:H264", &(a->tt__VideoEncoderConfigurationOptions::H264), "tt:H264Options"))
				{	soap_flag_H2641--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoEncoderOptionsExtension(soap, "tt:Extension", &(a->tt__VideoEncoderConfigurationOptions::Extension), "tt:VideoEncoderOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoEncoderConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, 0, sizeof(tt__VideoEncoderConfigurationOptions), 0, soap_copy_tt__VideoEncoderConfigurationOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_QualityRange1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__VideoEncoderConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoEncoderConfigurationOptions);
	if (this->soap_out(soap, tag?tag:"tt:VideoEncoderConfigurationOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoderConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoderConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoderConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoEncoderConfigurationOptions(struct soap *soap, tt__VideoEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncoderConfigurationOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoEncoderConfigurationOptions);
		if (size)
			*size = sizeof(tt__VideoEncoderConfigurationOptions);
		((tt__VideoEncoderConfigurationOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoEncoderConfigurationOptions, n);
		if (size)
			*size = n * sizeof(tt__VideoEncoderConfigurationOptions);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__VideoEncoderConfigurationOptions*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__VideoEncoderConfigurationOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoEncoderConfigurationOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoEncoderConfigurationOptions %p -> %p\n", q, p));
	*(tt__VideoEncoderConfigurationOptions*)p = *(tt__VideoEncoderConfigurationOptions*)q;
}

void tt__H264Configuration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__H264Configuration::GovLength);
	soap_default_tt__H264Profile(soap, &this->tt__H264Configuration::H264Profile);
}

void tt__H264Configuration::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__H264Configuration::GovLength, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__H264Configuration::H264Profile, SOAP_TYPE_tt__H264Profile);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__H264Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__H264Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__H264Configuration(struct soap *soap, const char *tag, int id, const tt__H264Configuration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__H264Configuration), "tt:H264Configuration"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_int(soap, "tt:GovLength", -1, &(a->tt__H264Configuration::GovLength), ""))
		return soap->error;
	if (soap_out_tt__H264Profile(soap, "tt:H264Profile", -1, &(a->tt__H264Configuration::H264Profile), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__H264Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__H264Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__H264Configuration * SOAP_FMAC4 soap_in_tt__H264Configuration(struct soap *soap, const char *tag, tt__H264Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__H264Configuration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__H264Configuration, sizeof(tt__H264Configuration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__H264Configuration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__H264Configuration *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_GovLength1 = 1;
	size_t soap_flag_H264Profile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_GovLength1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:GovLength", &(a->tt__H264Configuration::GovLength), "xsd:int"))
				{	soap_flag_GovLength1--;
					continue;
				}
			if (soap_flag_H264Profile1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__H264Profile(soap, "tt:H264Profile", &(a->tt__H264Configuration::H264Profile), "tt:H264Profile"))
				{	soap_flag_H264Profile1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__H264Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__H264Configuration, 0, sizeof(tt__H264Configuration), 0, soap_copy_tt__H264Configuration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength1 > 0 || soap_flag_H264Profile1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__H264Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__H264Configuration);
	if (this->soap_out(soap, tag?tag:"tt:H264Configuration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__H264Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__H264Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__H264Configuration * SOAP_FMAC4 soap_get_tt__H264Configuration(struct soap *soap, tt__H264Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__H264Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__H264Configuration * SOAP_FMAC2 soap_instantiate_tt__H264Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__H264Configuration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__H264Configuration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__H264Configuration);
		if (size)
			*size = sizeof(tt__H264Configuration);
		((tt__H264Configuration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__H264Configuration, n);
		if (size)
			*size = n * sizeof(tt__H264Configuration);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__H264Configuration*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__H264Configuration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__H264Configuration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__H264Configuration %p -> %p\n", q, p));
	*(tt__H264Configuration*)p = *(tt__H264Configuration*)q;
}

void tt__Mpeg4Configuration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__Mpeg4Configuration::GovLength);
	soap_default_tt__Mpeg4Profile(soap, &this->tt__Mpeg4Configuration::Mpeg4Profile);
}

void tt__Mpeg4Configuration::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__Mpeg4Configuration::GovLength, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__Mpeg4Configuration::Mpeg4Profile, SOAP_TYPE_tt__Mpeg4Profile);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Mpeg4Configuration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Mpeg4Configuration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Mpeg4Configuration(struct soap *soap, const char *tag, int id, const tt__Mpeg4Configuration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Mpeg4Configuration), "tt:Mpeg4Configuration"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_int(soap, "tt:GovLength", -1, &(a->tt__Mpeg4Configuration::GovLength), ""))
		return soap->error;
	if (soap_out_tt__Mpeg4Profile(soap, "tt:Mpeg4Profile", -1, &(a->tt__Mpeg4Configuration::Mpeg4Profile), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Mpeg4Configuration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Mpeg4Configuration(soap, tag, this, type);
}

SOAP_FMAC3 tt__Mpeg4Configuration * SOAP_FMAC4 soap_in_tt__Mpeg4Configuration(struct soap *soap, const char *tag, tt__Mpeg4Configuration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Mpeg4Configuration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(tt__Mpeg4Configuration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Mpeg4Configuration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Mpeg4Configuration *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_GovLength1 = 1;
	size_t soap_flag_Mpeg4Profile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_GovLength1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:GovLength", &(a->tt__Mpeg4Configuration::GovLength), "xsd:int"))
				{	soap_flag_GovLength1--;
					continue;
				}
			if (soap_flag_Mpeg4Profile1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__Mpeg4Profile(soap, "tt:Mpeg4Profile", &(a->tt__Mpeg4Configuration::Mpeg4Profile), "tt:Mpeg4Profile"))
				{	soap_flag_Mpeg4Profile1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Mpeg4Configuration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Mpeg4Configuration, 0, sizeof(tt__Mpeg4Configuration), 0, soap_copy_tt__Mpeg4Configuration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_GovLength1 > 0 || soap_flag_Mpeg4Profile1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Mpeg4Configuration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Mpeg4Configuration);
	if (this->soap_out(soap, tag?tag:"tt:Mpeg4Configuration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Mpeg4Configuration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Mpeg4Configuration(soap, this, tag, type);
}

SOAP_FMAC3 tt__Mpeg4Configuration * SOAP_FMAC4 soap_get_tt__Mpeg4Configuration(struct soap *soap, tt__Mpeg4Configuration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Mpeg4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Mpeg4Configuration * SOAP_FMAC2 soap_instantiate_tt__Mpeg4Configuration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Mpeg4Configuration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Mpeg4Configuration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Mpeg4Configuration);
		if (size)
			*size = sizeof(tt__Mpeg4Configuration);
		((tt__Mpeg4Configuration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__Mpeg4Configuration, n);
		if (size)
			*size = n * sizeof(tt__Mpeg4Configuration);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__Mpeg4Configuration*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__Mpeg4Configuration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Mpeg4Configuration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Mpeg4Configuration %p -> %p\n", q, p));
	*(tt__Mpeg4Configuration*)p = *(tt__Mpeg4Configuration*)q;
}

void tt__VideoRateControl::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__VideoRateControl::FrameRateLimit);
	soap_default_int(soap, &this->tt__VideoRateControl::EncodingInterval);
	soap_default_int(soap, &this->tt__VideoRateControl::BitrateLimit);
}

void tt__VideoRateControl::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__VideoRateControl::FrameRateLimit, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__VideoRateControl::EncodingInterval, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__VideoRateControl::BitrateLimit, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoRateControl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoRateControl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoRateControl(struct soap *soap, const char *tag, int id, const tt__VideoRateControl *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoRateControl), "tt:VideoRateControl"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_int(soap, "tt:FrameRateLimit", -1, &(a->tt__VideoRateControl::FrameRateLimit), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:EncodingInterval", -1, &(a->tt__VideoRateControl::EncodingInterval), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:BitrateLimit", -1, &(a->tt__VideoRateControl::BitrateLimit), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoRateControl::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoRateControl(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoRateControl * SOAP_FMAC4 soap_in_tt__VideoRateControl(struct soap *soap, const char *tag, tt__VideoRateControl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoRateControl *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoRateControl, sizeof(tt__VideoRateControl), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoRateControl)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoRateControl *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_FrameRateLimit1 = 1;
	size_t soap_flag_EncodingInterval1 = 1;
	size_t soap_flag_BitrateLimit1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_FrameRateLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:FrameRateLimit", &(a->tt__VideoRateControl::FrameRateLimit), "xsd:int"))
				{	soap_flag_FrameRateLimit1--;
					continue;
				}
			if (soap_flag_EncodingInterval1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:EncodingInterval", &(a->tt__VideoRateControl::EncodingInterval), "xsd:int"))
				{	soap_flag_EncodingInterval1--;
					continue;
				}
			if (soap_flag_BitrateLimit1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:BitrateLimit", &(a->tt__VideoRateControl::BitrateLimit), "xsd:int"))
				{	soap_flag_BitrateLimit1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoRateControl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoRateControl, 0, sizeof(tt__VideoRateControl), 0, soap_copy_tt__VideoRateControl);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FrameRateLimit1 > 0 || soap_flag_EncodingInterval1 > 0 || soap_flag_BitrateLimit1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__VideoRateControl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoRateControl);
	if (this->soap_out(soap, tag?tag:"tt:VideoRateControl", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoRateControl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoRateControl(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoRateControl * SOAP_FMAC4 soap_get_tt__VideoRateControl(struct soap *soap, tt__VideoRateControl *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoRateControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoRateControl * SOAP_FMAC2 soap_instantiate_tt__VideoRateControl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoRateControl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoRateControl, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoRateControl);
		if (size)
			*size = sizeof(tt__VideoRateControl);
		((tt__VideoRateControl*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoRateControl, n);
		if (size)
			*size = n * sizeof(tt__VideoRateControl);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__VideoRateControl*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__VideoRateControl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoRateControl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoRateControl %p -> %p\n", q, p));
	*(tt__VideoRateControl*)p = *(tt__VideoRateControl*)q;
}

void tt__VideoResolution::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__VideoResolution::Width);
	soap_default_int(soap, &this->tt__VideoResolution::Height);
}

void tt__VideoResolution::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__VideoResolution::Width, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__VideoResolution::Height, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoResolution::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoResolution(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoResolution(struct soap *soap, const char *tag, int id, const tt__VideoResolution *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoResolution), "tt:VideoResolution"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_int(soap, "tt:Width", -1, &(a->tt__VideoResolution::Width), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Height", -1, &(a->tt__VideoResolution::Height), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoResolution::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoResolution(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoResolution * SOAP_FMAC4 soap_in_tt__VideoResolution(struct soap *soap, const char *tag, tt__VideoResolution *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoResolution *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoResolution, sizeof(tt__VideoResolution), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoResolution)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoResolution *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Width1 = 1;
	size_t soap_flag_Height1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Width1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Width", &(a->tt__VideoResolution::Width), "xsd:int"))
				{	soap_flag_Width1--;
					continue;
				}
			if (soap_flag_Height1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Height", &(a->tt__VideoResolution::Height), "xsd:int"))
				{	soap_flag_Height1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoResolution *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoResolution, 0, sizeof(tt__VideoResolution), 0, soap_copy_tt__VideoResolution);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Width1 > 0 || soap_flag_Height1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__VideoResolution::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoResolution);
	if (this->soap_out(soap, tag?tag:"tt:VideoResolution", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoResolution::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoResolution(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoResolution * SOAP_FMAC4 soap_get_tt__VideoResolution(struct soap *soap, tt__VideoResolution *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoResolution(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoResolution * SOAP_FMAC2 soap_instantiate_tt__VideoResolution(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoResolution(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoResolution, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoResolution);
		if (size)
			*size = sizeof(tt__VideoResolution);
		((tt__VideoResolution*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoResolution, n);
		if (size)
			*size = n * sizeof(tt__VideoResolution);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__VideoResolution*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__VideoResolution*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoResolution(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoResolution %p -> %p\n", q, p));
	*(tt__VideoResolution*)p = *(tt__VideoResolution*)q;
}

void tt__VideoEncoderConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__VideoEncoding(soap, &this->tt__VideoEncoderConfiguration::Encoding);
	this->tt__VideoEncoderConfiguration::Resolution = NULL;
	soap_default_float(soap, &this->tt__VideoEncoderConfiguration::Quality);
	this->tt__VideoEncoderConfiguration::RateControl = NULL;
	this->tt__VideoEncoderConfiguration::MPEG4 = NULL;
	this->tt__VideoEncoderConfiguration::H264 = NULL;
	this->tt__VideoEncoderConfiguration::Multicast = NULL;
	soap_default_xsd__duration(soap, &this->tt__VideoEncoderConfiguration::SessionTimeout);
	this->tt__VideoEncoderConfiguration::__size = 0;
	this->tt__VideoEncoderConfiguration::__any = NULL;
	this->tt__VideoEncoderConfiguration::__anyAttribute = NULL;
}

void tt__VideoEncoderConfiguration::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__VideoResolution(soap, &this->tt__VideoEncoderConfiguration::Resolution);
	soap_embedded(soap, &this->tt__VideoEncoderConfiguration::Quality, SOAP_TYPE_float);
	soap_serialize_PointerTott__VideoRateControl(soap, &this->tt__VideoEncoderConfiguration::RateControl);
	soap_serialize_PointerTott__Mpeg4Configuration(soap, &this->tt__VideoEncoderConfiguration::MPEG4);
	soap_serialize_PointerTott__H264Configuration(soap, &this->tt__VideoEncoderConfiguration::H264);
	soap_serialize_PointerTott__MulticastConfiguration(soap, &this->tt__VideoEncoderConfiguration::Multicast);
	soap_embedded(soap, &this->tt__VideoEncoderConfiguration::SessionTimeout, SOAP_TYPE_xsd__duration);
	this->tt__ConfigurationEntity::soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoEncoderConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoEncoderConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const tt__VideoEncoderConfiguration *a, const char *type)
{
	if (((tt__VideoEncoderConfiguration*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__VideoEncoderConfiguration*)a)->__anyAttribute, 1);
	if (((tt__ConfigurationEntity*)a)->token)
		soap_set_attr(soap, "token", ((tt__ConfigurationEntity*)a)->token, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoEncoderConfiguration), "tt:VideoEncoderConfiguration"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__ConfigurationEntity::Name)
	{	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &(a->tt__ConfigurationEntity::UseCount), ""))
		return soap->error;
	if (soap_out_tt__VideoEncoding(soap, "tt:Encoding", -1, &(a->tt__VideoEncoderConfiguration::Encoding), ""))
		return soap->error;
	if (a->tt__VideoEncoderConfiguration::Resolution)
	{	if (soap_out_PointerTott__VideoResolution(soap, "tt:Resolution", -1, &a->tt__VideoEncoderConfiguration::Resolution, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Resolution"))
		return soap->error;
	if (soap_out_float(soap, "tt:Quality", -1, &(a->tt__VideoEncoderConfiguration::Quality), ""))
		return soap->error;
	if (soap_out_PointerTott__VideoRateControl(soap, "tt:RateControl", -1, &(a->tt__VideoEncoderConfiguration::RateControl), ""))
		return soap->error;
	if (soap_out_PointerTott__Mpeg4Configuration(soap, "tt:MPEG4", -1, &(a->tt__VideoEncoderConfiguration::MPEG4), ""))
		return soap->error;
	if (soap_out_PointerTott__H264Configuration(soap, "tt:H264", -1, &(a->tt__VideoEncoderConfiguration::H264), ""))
		return soap->error;
	if (a->tt__VideoEncoderConfiguration::Multicast)
	{	if (soap_out_PointerTott__MulticastConfiguration(soap, "tt:Multicast", -1, &a->tt__VideoEncoderConfiguration::Multicast, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Multicast"))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:SessionTimeout", -1, &(a->tt__VideoEncoderConfiguration::SessionTimeout), ""))
		return soap->error;
	if (a->tt__VideoEncoderConfiguration::__any)
	{	int i;
		for (i = 0; i < a->tt__VideoEncoderConfiguration::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__VideoEncoderConfiguration::__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__VideoEncoderConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoEncoderConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_in_tt__VideoEncoderConfiguration(struct soap *soap, const char *tag, tt__VideoEncoderConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoEncoderConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoEncoderConfiguration, sizeof(tt__VideoEncoderConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoEncoderConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoEncoderConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((tt__VideoEncoderConfiguration*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &((tt__ConfigurationEntity*)a)->token, 0, 64))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_Encoding1 = 1;
	size_t soap_flag_Resolution1 = 1;
	size_t soap_flag_Quality1 = 1;
	size_t soap_flag_RateControl1 = 1;
	size_t soap_flag_MPEG41 = 1;
	size_t soap_flag_H2641 = 1;
	size_t soap_flag_Multicast1 = 1;
	size_t soap_flag_SessionTimeout1 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &(a->tt__ConfigurationEntity::Name), "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &(a->tt__ConfigurationEntity::UseCount), "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			if (soap_flag_Encoding1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__VideoEncoding(soap, "tt:Encoding", &(a->tt__VideoEncoderConfiguration::Encoding), "tt:VideoEncoding"))
				{	soap_flag_Encoding1--;
					continue;
				}
			if (soap_flag_Resolution1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoResolution(soap, "tt:Resolution", &(a->tt__VideoEncoderConfiguration::Resolution), "tt:VideoResolution"))
				{	soap_flag_Resolution1--;
					continue;
				}
			if (soap_flag_Quality1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Quality", &(a->tt__VideoEncoderConfiguration::Quality), "xsd:float"))
				{	soap_flag_Quality1--;
					continue;
				}
			if (soap_flag_RateControl1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoRateControl(soap, "tt:RateControl", &(a->tt__VideoEncoderConfiguration::RateControl), "tt:VideoRateControl"))
				{	soap_flag_RateControl1--;
					continue;
				}
			if (soap_flag_MPEG41 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Mpeg4Configuration(soap, "tt:MPEG4", &(a->tt__VideoEncoderConfiguration::MPEG4), "tt:Mpeg4Configuration"))
				{	soap_flag_MPEG41--;
					continue;
				}
			if (soap_flag_H2641 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__H264Configuration(soap, "tt:H264", &(a->tt__VideoEncoderConfiguration::H264), "tt:H264Configuration"))
				{	soap_flag_H2641--;
					continue;
				}
			if (soap_flag_Multicast1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MulticastConfiguration(soap, "tt:Multicast", &(a->tt__VideoEncoderConfiguration::Multicast), "tt:MulticastConfiguration"))
				{	soap_flag_Multicast1--;
					continue;
				}
			if (soap_flag_SessionTimeout1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:SessionTimeout", &(a->tt__VideoEncoderConfiguration::SessionTimeout), "xsd:duration"))
				{	soap_flag_SessionTimeout1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__VideoEncoderConfiguration::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__VideoEncoderConfiguration::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__VideoEncoderConfiguration::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__VideoEncoderConfiguration::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__VideoEncoderConfiguration::__any, "xsd:byte"))
				{	a->tt__VideoEncoderConfiguration::__size++;
					a->tt__VideoEncoderConfiguration::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__VideoEncoderConfiguration::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__VideoEncoderConfiguration::__size)
			a->tt__VideoEncoderConfiguration::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__VideoEncoderConfiguration::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoEncoderConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoEncoderConfiguration, 0, sizeof(tt__VideoEncoderConfiguration), 0, soap_copy_tt__VideoEncoderConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_Encoding1 > 0 || soap_flag_Resolution1 > 0 || soap_flag_Quality1 > 0 || soap_flag_Multicast1 > 0 || soap_flag_SessionTimeout1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__VideoEncoderConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoEncoderConfiguration);
	if (this->soap_out(soap, tag?tag:"tt:VideoEncoderConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoEncoderConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoEncoderConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoEncoderConfiguration * SOAP_FMAC4 soap_get_tt__VideoEncoderConfiguration(struct soap *soap, tt__VideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoEncoderConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoEncoderConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoEncoderConfiguration);
		if (size)
			*size = sizeof(tt__VideoEncoderConfiguration);
		((tt__VideoEncoderConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoEncoderConfiguration, n);
		if (size)
			*size = n * sizeof(tt__VideoEncoderConfiguration);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__VideoEncoderConfiguration*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__VideoEncoderConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoEncoderConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoEncoderConfiguration %p -> %p\n", q, p));
	*(tt__VideoEncoderConfiguration*)p = *(tt__VideoEncoderConfiguration*)q;
}

void tt__RotateOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__RotateOptionsExtension::__size = 0;
	this->tt__RotateOptionsExtension::__any = NULL;
}

void tt__RotateOptionsExtension::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RotateOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RotateOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateOptionsExtension(struct soap *soap, const char *tag, int id, const tt__RotateOptionsExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RotateOptionsExtension), "tt:RotateOptionsExtension"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__RotateOptionsExtension::__any)
	{	int i;
		for (i = 0; i < a->tt__RotateOptionsExtension::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__RotateOptionsExtension::__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__RotateOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__RotateOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__RotateOptionsExtension * SOAP_FMAC4 soap_in_tt__RotateOptionsExtension(struct soap *soap, const char *tag, tt__RotateOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RotateOptionsExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateOptionsExtension, sizeof(tt__RotateOptionsExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__RotateOptionsExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__RotateOptionsExtension *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__RotateOptionsExtension::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__RotateOptionsExtension::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__RotateOptionsExtension::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__RotateOptionsExtension::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__RotateOptionsExtension::__any, "xsd:byte"))
				{	a->tt__RotateOptionsExtension::__size++;
					a->tt__RotateOptionsExtension::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__RotateOptionsExtension::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__RotateOptionsExtension::__size)
			a->tt__RotateOptionsExtension::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__RotateOptionsExtension::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RotateOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RotateOptionsExtension, 0, sizeof(tt__RotateOptionsExtension), 0, soap_copy_tt__RotateOptionsExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__RotateOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__RotateOptionsExtension);
	if (this->soap_out(soap, tag?tag:"tt:RotateOptionsExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RotateOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RotateOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__RotateOptionsExtension * SOAP_FMAC4 soap_get_tt__RotateOptionsExtension(struct soap *soap, tt__RotateOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RotateOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__RotateOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__RotateOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RotateOptionsExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__RotateOptionsExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__RotateOptionsExtension);
		if (size)
			*size = sizeof(tt__RotateOptionsExtension);
		((tt__RotateOptionsExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__RotateOptionsExtension, n);
		if (size)
			*size = n * sizeof(tt__RotateOptionsExtension);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__RotateOptionsExtension*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__RotateOptionsExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__RotateOptionsExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__RotateOptionsExtension %p -> %p\n", q, p));
	*(tt__RotateOptionsExtension*)p = *(tt__RotateOptionsExtension*)q;
}

void tt__RotateOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__RotateOptions::__sizeMode = 0;
	this->tt__RotateOptions::Mode = NULL;
	this->tt__RotateOptions::DegreeList = NULL;
	this->tt__RotateOptions::Extension = NULL;
	this->tt__RotateOptions::__anyAttribute = NULL;
}

void tt__RotateOptions::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->tt__RotateOptions::Mode)
	{	int i;
		for (i = 0; i < this->tt__RotateOptions::__sizeMode; i++)
		{
			soap_embedded(soap, this->tt__RotateOptions::Mode + i, SOAP_TYPE_tt__RotateMode);
		}
	}
	soap_serialize_PointerTott__IntList(soap, &this->tt__RotateOptions::DegreeList);
	soap_serialize_PointerTott__RotateOptionsExtension(soap, &this->tt__RotateOptions::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RotateOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RotateOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateOptions(struct soap *soap, const char *tag, int id, const tt__RotateOptions *a, const char *type)
{
	if (((tt__RotateOptions*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__RotateOptions*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RotateOptions), "tt:RotateOptions"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__RotateOptions::Mode)
	{	int i;
		for (i = 0; i < a->tt__RotateOptions::__sizeMode; i++)
			if (soap_out_tt__RotateMode(soap, "tt:Mode", -1, a->tt__RotateOptions::Mode + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__IntList(soap, "tt:DegreeList", -1, &(a->tt__RotateOptions::DegreeList), ""))
		return soap->error;
	if (soap_out_PointerTott__RotateOptionsExtension(soap, "tt:Extension", -1, &(a->tt__RotateOptions::Extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__RotateOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__RotateOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__RotateOptions * SOAP_FMAC4 soap_in_tt__RotateOptions(struct soap *soap, const char *tag, tt__RotateOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RotateOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateOptions, sizeof(tt__RotateOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__RotateOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__RotateOptions *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((tt__RotateOptions*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_Mode1 = NULL;
	size_t soap_flag_DegreeList1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Mode", 1, NULL))
			{	if (a->tt__RotateOptions::Mode == NULL)
				{	if (soap_blist_Mode1 == NULL)
						soap_blist_Mode1 = soap_new_block(soap);
					a->tt__RotateOptions::Mode = (enum tt__RotateMode *)soap_push_block(soap, soap_blist_Mode1, sizeof(enum tt__RotateMode));
					if (a->tt__RotateOptions::Mode == NULL)
						return NULL;
					soap_default_tt__RotateMode(soap, a->tt__RotateOptions::Mode);
				}
				soap_revert(soap);
				if (soap_in_tt__RotateMode(soap, "tt:Mode", a->tt__RotateOptions::Mode, "tt:RotateMode"))
				{	a->tt__RotateOptions::__sizeMode++;
					a->tt__RotateOptions::Mode = NULL;
					continue;
				}
			}
			if (soap_flag_DegreeList1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntList(soap, "tt:DegreeList", &(a->tt__RotateOptions::DegreeList), "tt:IntList"))
				{	soap_flag_DegreeList1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RotateOptionsExtension(soap, "tt:Extension", &(a->tt__RotateOptions::Extension), "tt:RotateOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__RotateOptions::Mode)
			soap_pop_block(soap, soap_blist_Mode1);
		if (a->tt__RotateOptions::__sizeMode)
			a->tt__RotateOptions::Mode = (enum tt__RotateMode *)soap_save_block(soap, soap_blist_Mode1, NULL, 1);
		else
		{	a->tt__RotateOptions::Mode = NULL;
			if (soap_blist_Mode1)
				soap_end_block(soap, soap_blist_Mode1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RotateOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RotateOptions, 0, sizeof(tt__RotateOptions), 0, soap_copy_tt__RotateOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->tt__RotateOptions::__sizeMode < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__RotateOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__RotateOptions);
	if (this->soap_out(soap, tag?tag:"tt:RotateOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RotateOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RotateOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__RotateOptions * SOAP_FMAC4 soap_get_tt__RotateOptions(struct soap *soap, tt__RotateOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RotateOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__RotateOptions * SOAP_FMAC2 soap_instantiate_tt__RotateOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RotateOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__RotateOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__RotateOptions);
		if (size)
			*size = sizeof(tt__RotateOptions);
		((tt__RotateOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__RotateOptions, n);
		if (size)
			*size = n * sizeof(tt__RotateOptions);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__RotateOptions*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__RotateOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__RotateOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__RotateOptions %p -> %p\n", q, p));
	*(tt__RotateOptions*)p = *(tt__RotateOptions*)q;
}

void tt__VideoSourceConfigurationOptionsExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__VideoSourceConfigurationOptionsExtension2::__size = 0;
	this->tt__VideoSourceConfigurationOptionsExtension2::__any = NULL;
}

void tt__VideoSourceConfigurationOptionsExtension2::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoSourceConfigurationOptionsExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfigurationOptionsExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfigurationOptionsExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2), "tt:VideoSourceConfigurationOptionsExtension2"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__VideoSourceConfigurationOptionsExtension2::__any)
	{	int i;
		for (i = 0; i < a->tt__VideoSourceConfigurationOptionsExtension2::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__VideoSourceConfigurationOptionsExtension2::__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfigurationOptionsExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoSourceConfigurationOptionsExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension2 * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, const char *tag, tt__VideoSourceConfigurationOptionsExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfigurationOptionsExtension2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, sizeof(tt__VideoSourceConfigurationOptionsExtension2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoSourceConfigurationOptionsExtension2 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__VideoSourceConfigurationOptionsExtension2::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__VideoSourceConfigurationOptionsExtension2::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__VideoSourceConfigurationOptionsExtension2::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__VideoSourceConfigurationOptionsExtension2::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__VideoSourceConfigurationOptionsExtension2::__any, "xsd:byte"))
				{	a->tt__VideoSourceConfigurationOptionsExtension2::__size++;
					a->tt__VideoSourceConfigurationOptionsExtension2::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__VideoSourceConfigurationOptionsExtension2::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__VideoSourceConfigurationOptionsExtension2::__size)
			a->tt__VideoSourceConfigurationOptionsExtension2::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__VideoSourceConfigurationOptionsExtension2::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfigurationOptionsExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, 0, sizeof(tt__VideoSourceConfigurationOptionsExtension2), 0, soap_copy_tt__VideoSourceConfigurationOptionsExtension2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__VideoSourceConfigurationOptionsExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2);
	if (this->soap_out(soap, tag?tag:"tt:VideoSourceConfigurationOptionsExtension2", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfigurationOptionsExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfigurationOptionsExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension2 * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationOptionsExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfigurationOptionsExtension2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoSourceConfigurationOptionsExtension2);
		if (size)
			*size = sizeof(tt__VideoSourceConfigurationOptionsExtension2);
		((tt__VideoSourceConfigurationOptionsExtension2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoSourceConfigurationOptionsExtension2, n);
		if (size)
			*size = n * sizeof(tt__VideoSourceConfigurationOptionsExtension2);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__VideoSourceConfigurationOptionsExtension2*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__VideoSourceConfigurationOptionsExtension2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoSourceConfigurationOptionsExtension2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoSourceConfigurationOptionsExtension2 %p -> %p\n", q, p));
	*(tt__VideoSourceConfigurationOptionsExtension2*)p = *(tt__VideoSourceConfigurationOptionsExtension2*)q;
}

void tt__VideoSourceConfigurationOptionsExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__VideoSourceConfigurationOptionsExtension::__size = 0;
	this->tt__VideoSourceConfigurationOptionsExtension::__any = NULL;
	this->tt__VideoSourceConfigurationOptionsExtension::Rotate = NULL;
	this->tt__VideoSourceConfigurationOptionsExtension::Extension = NULL;
}

void tt__VideoSourceConfigurationOptionsExtension::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__RotateOptions(soap, &this->tt__VideoSourceConfigurationOptionsExtension::Rotate);
	soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, &this->tt__VideoSourceConfigurationOptionsExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoSourceConfigurationOptionsExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfigurationOptionsExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfigurationOptionsExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension), "tt:VideoSourceConfigurationOptionsExtension"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__VideoSourceConfigurationOptionsExtension::__any)
	{	int i;
		for (i = 0; i < a->tt__VideoSourceConfigurationOptionsExtension::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__VideoSourceConfigurationOptionsExtension::__any + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__RotateOptions(soap, "tt:Rotate", -1, &(a->tt__VideoSourceConfigurationOptionsExtension::Rotate), ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, "tt:Extension", -1, &(a->tt__VideoSourceConfigurationOptionsExtension::Extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfigurationOptionsExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoSourceConfigurationOptionsExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, const char *tag, tt__VideoSourceConfigurationOptionsExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfigurationOptionsExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, sizeof(tt__VideoSourceConfigurationOptionsExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoSourceConfigurationOptionsExtension *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	size_t soap_flag_Rotate1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Rotate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RotateOptions(soap, "tt:Rotate", &(a->tt__VideoSourceConfigurationOptionsExtension::Rotate), "tt:RotateOptions"))
				{	soap_flag_Rotate1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceConfigurationOptionsExtension2(soap, "tt:Extension", &(a->tt__VideoSourceConfigurationOptionsExtension::Extension), "tt:VideoSourceConfigurationOptionsExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__VideoSourceConfigurationOptionsExtension::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__VideoSourceConfigurationOptionsExtension::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__VideoSourceConfigurationOptionsExtension::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__VideoSourceConfigurationOptionsExtension::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__VideoSourceConfigurationOptionsExtension::__any, "xsd:byte"))
				{	a->tt__VideoSourceConfigurationOptionsExtension::__size++;
					a->tt__VideoSourceConfigurationOptionsExtension::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__VideoSourceConfigurationOptionsExtension::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__VideoSourceConfigurationOptionsExtension::__size)
			a->tt__VideoSourceConfigurationOptionsExtension::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__VideoSourceConfigurationOptionsExtension::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfigurationOptionsExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, 0, sizeof(tt__VideoSourceConfigurationOptionsExtension), 0, soap_copy_tt__VideoSourceConfigurationOptionsExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__VideoSourceConfigurationOptionsExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension);
	if (this->soap_out(soap, tag?tag:"tt:VideoSourceConfigurationOptionsExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfigurationOptionsExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfigurationOptionsExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, tt__VideoSourceConfigurationOptionsExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationOptionsExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoSourceConfigurationOptionsExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfigurationOptionsExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoSourceConfigurationOptionsExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoSourceConfigurationOptionsExtension);
		if (size)
			*size = sizeof(tt__VideoSourceConfigurationOptionsExtension);
		((tt__VideoSourceConfigurationOptionsExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoSourceConfigurationOptionsExtension, n);
		if (size)
			*size = n * sizeof(tt__VideoSourceConfigurationOptionsExtension);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__VideoSourceConfigurationOptionsExtension*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__VideoSourceConfigurationOptionsExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoSourceConfigurationOptionsExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoSourceConfigurationOptionsExtension %p -> %p\n", q, p));
	*(tt__VideoSourceConfigurationOptionsExtension*)p = *(tt__VideoSourceConfigurationOptionsExtension*)q;
}

void tt__VideoSourceConfigurationOptions::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__VideoSourceConfigurationOptions::BoundsRange = NULL;
	this->tt__VideoSourceConfigurationOptions::__sizeVideoSourceTokensAvailable = 0;
	this->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable = NULL;
	this->tt__VideoSourceConfigurationOptions::Extension = NULL;
	this->tt__VideoSourceConfigurationOptions::__anyAttribute = NULL;
}

void tt__VideoSourceConfigurationOptions::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IntRectangleRange(soap, &this->tt__VideoSourceConfigurationOptions::BoundsRange);
	if (this->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable)
	{	int i;
		for (i = 0; i < this->tt__VideoSourceConfigurationOptions::__sizeVideoSourceTokensAvailable; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, this->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable + i);
		}
	}
	soap_serialize_PointerTott__VideoSourceConfigurationOptionsExtension(soap, &this->tt__VideoSourceConfigurationOptions::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoSourceConfigurationOptions::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfigurationOptions(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfigurationOptions *a, const char *type)
{
	if (((tt__VideoSourceConfigurationOptions*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__VideoSourceConfigurationOptions*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptions), "tt:VideoSourceConfigurationOptions"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__VideoSourceConfigurationOptions::BoundsRange)
	{	if (soap_out_PointerTott__IntRectangleRange(soap, "tt:BoundsRange", -1, &a->tt__VideoSourceConfigurationOptions::BoundsRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:BoundsRange"))
		return soap->error;
	if (a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable)
	{	int i;
		for (i = 0; i < a->tt__VideoSourceConfigurationOptions::__sizeVideoSourceTokensAvailable; i++)
			if (soap_out_tt__ReferenceToken(soap, "tt:VideoSourceTokensAvailable", -1, a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__VideoSourceConfigurationOptionsExtension(soap, "tt:Extension", -1, &(a->tt__VideoSourceConfigurationOptions::Extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfigurationOptions::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoSourceConfigurationOptions(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptions * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, tt__VideoSourceConfigurationOptions *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfigurationOptions *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(tt__VideoSourceConfigurationOptions), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoSourceConfigurationOptions)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoSourceConfigurationOptions *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((tt__VideoSourceConfigurationOptions*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_BoundsRange1 = 1;
	struct soap_blist *soap_blist_VideoSourceTokensAvailable1 = NULL;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_BoundsRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRectangleRange(soap, "tt:BoundsRange", &(a->tt__VideoSourceConfigurationOptions::BoundsRange), "tt:IntRectangleRange"))
				{	soap_flag_BoundsRange1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:VideoSourceTokensAvailable", 1, NULL))
			{	if (a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable == NULL)
				{	if (soap_blist_VideoSourceTokensAvailable1 == NULL)
						soap_blist_VideoSourceTokensAvailable1 = soap_new_block(soap);
					a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable = (char **)soap_push_block(soap, soap_blist_VideoSourceTokensAvailable1, sizeof(char *));
					if (a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable == NULL)
						return NULL;
					*a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tt:VideoSourceTokensAvailable", a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable, "tt:ReferenceToken"))
				{	a->tt__VideoSourceConfigurationOptions::__sizeVideoSourceTokensAvailable++;
					a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable = NULL;
					continue;
				}
			}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceConfigurationOptionsExtension(soap, "tt:Extension", &(a->tt__VideoSourceConfigurationOptions::Extension), "tt:VideoSourceConfigurationOptionsExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable)
			soap_pop_block(soap, soap_blist_VideoSourceTokensAvailable1);
		if (a->tt__VideoSourceConfigurationOptions::__sizeVideoSourceTokensAvailable)
			a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable = (char **)soap_save_block(soap, soap_blist_VideoSourceTokensAvailable1, NULL, 1);
		else
		{	a->tt__VideoSourceConfigurationOptions::VideoSourceTokensAvailable = NULL;
			if (soap_blist_VideoSourceTokensAvailable1)
				soap_end_block(soap, soap_blist_VideoSourceTokensAvailable1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationOptions, 0, sizeof(tt__VideoSourceConfigurationOptions), 0, soap_copy_tt__VideoSourceConfigurationOptions);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_BoundsRange1 > 0 || a->tt__VideoSourceConfigurationOptions::__sizeVideoSourceTokensAvailable < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__VideoSourceConfigurationOptions::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoSourceConfigurationOptions);
	if (this->soap_out(soap, tag?tag:"tt:VideoSourceConfigurationOptions", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfigurationOptions::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfigurationOptions(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationOptions * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationOptions(struct soap *soap, tt__VideoSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfigurationOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoSourceConfigurationOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoSourceConfigurationOptions);
		if (size)
			*size = sizeof(tt__VideoSourceConfigurationOptions);
		((tt__VideoSourceConfigurationOptions*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoSourceConfigurationOptions, n);
		if (size)
			*size = n * sizeof(tt__VideoSourceConfigurationOptions);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__VideoSourceConfigurationOptions*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__VideoSourceConfigurationOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoSourceConfigurationOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoSourceConfigurationOptions %p -> %p\n", q, p));
	*(tt__VideoSourceConfigurationOptions*)p = *(tt__VideoSourceConfigurationOptions*)q;
}

void tt__RotateExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__RotateExtension::__size = 0;
	this->tt__RotateExtension::__any = NULL;
}

void tt__RotateExtension::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__RotateExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__RotateExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__RotateExtension(struct soap *soap, const char *tag, int id, const tt__RotateExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__RotateExtension), "tt:RotateExtension"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__RotateExtension::__any)
	{	int i;
		for (i = 0; i < a->tt__RotateExtension::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__RotateExtension::__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__RotateExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__RotateExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__RotateExtension * SOAP_FMAC4 soap_in_tt__RotateExtension(struct soap *soap, const char *tag, tt__RotateExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__RotateExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__RotateExtension, sizeof(tt__RotateExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__RotateExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__RotateExtension *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__RotateExtension::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__RotateExtension::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__RotateExtension::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__RotateExtension::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__RotateExtension::__any, "xsd:byte"))
				{	a->tt__RotateExtension::__size++;
					a->tt__RotateExtension::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__RotateExtension::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__RotateExtension::__size)
			a->tt__RotateExtension::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__RotateExtension::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__RotateExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__RotateExtension, 0, sizeof(tt__RotateExtension), 0, soap_copy_tt__RotateExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__RotateExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__RotateExtension);
	if (this->soap_out(soap, tag?tag:"tt:RotateExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__RotateExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__RotateExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__RotateExtension * SOAP_FMAC4 soap_get_tt__RotateExtension(struct soap *soap, tt__RotateExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__RotateExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__RotateExtension * SOAP_FMAC2 soap_instantiate_tt__RotateExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__RotateExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__RotateExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__RotateExtension);
		if (size)
			*size = sizeof(tt__RotateExtension);
		((tt__RotateExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__RotateExtension, n);
		if (size)
			*size = n * sizeof(tt__RotateExtension);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__RotateExtension*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__RotateExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__RotateExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__RotateExtension %p -> %p\n", q, p));
	*(tt__RotateExtension*)p = *(tt__RotateExtension*)q;
}

void tt__Rotate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__RotateMode(soap, &this->tt__Rotate::Mode);
	this->tt__Rotate::Degree = NULL;
	this->tt__Rotate::Extension = NULL;
	this->tt__Rotate::__anyAttribute = NULL;
}

void tt__Rotate::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__Rotate::Mode, SOAP_TYPE_tt__RotateMode);
	soap_serialize_PointerToint(soap, &this->tt__Rotate::Degree);
	soap_serialize_PointerTott__RotateExtension(soap, &this->tt__Rotate::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Rotate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Rotate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Rotate(struct soap *soap, const char *tag, int id, const tt__Rotate *a, const char *type)
{
	if (((tt__Rotate*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__Rotate*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Rotate), "tt:Rotate"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_tt__RotateMode(soap, "tt:Mode", -1, &(a->tt__Rotate::Mode), ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tt:Degree", -1, &(a->tt__Rotate::Degree), ""))
		return soap->error;
	if (soap_out_PointerTott__RotateExtension(soap, "tt:Extension", -1, &(a->tt__Rotate::Extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Rotate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Rotate(soap, tag, this, type);
}

SOAP_FMAC3 tt__Rotate * SOAP_FMAC4 soap_in_tt__Rotate(struct soap *soap, const char *tag, tt__Rotate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Rotate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Rotate, sizeof(tt__Rotate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Rotate)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Rotate *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((tt__Rotate*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Mode1 = 1;
	size_t soap_flag_Degree1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Mode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__RotateMode(soap, "tt:Mode", &(a->tt__Rotate::Mode), "tt:RotateMode"))
				{	soap_flag_Mode1--;
					continue;
				}
			if (soap_flag_Degree1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tt:Degree", &(a->tt__Rotate::Degree), "xsd:int"))
				{	soap_flag_Degree1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RotateExtension(soap, "tt:Extension", &(a->tt__Rotate::Extension), "tt:RotateExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Rotate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Rotate, 0, sizeof(tt__Rotate), 0, soap_copy_tt__Rotate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Mode1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Rotate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Rotate);
	if (this->soap_out(soap, tag?tag:"tt:Rotate", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Rotate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Rotate(soap, this, tag, type);
}

SOAP_FMAC3 tt__Rotate * SOAP_FMAC4 soap_get_tt__Rotate(struct soap *soap, tt__Rotate *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Rotate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Rotate * SOAP_FMAC2 soap_instantiate_tt__Rotate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Rotate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Rotate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Rotate);
		if (size)
			*size = sizeof(tt__Rotate);
		((tt__Rotate*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__Rotate, n);
		if (size)
			*size = n * sizeof(tt__Rotate);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__Rotate*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__Rotate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Rotate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Rotate %p -> %p\n", q, p));
	*(tt__Rotate*)p = *(tt__Rotate*)q;
}

void tt__VideoSourceConfigurationExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__VideoSourceConfigurationExtension2::__size = 0;
	this->tt__VideoSourceConfigurationExtension2::__any = NULL;
}

void tt__VideoSourceConfigurationExtension2::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoSourceConfigurationExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfigurationExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfigurationExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2), "tt:VideoSourceConfigurationExtension2"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__VideoSourceConfigurationExtension2::__any)
	{	int i;
		for (i = 0; i < a->tt__VideoSourceConfigurationExtension2::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__VideoSourceConfigurationExtension2::__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfigurationExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoSourceConfigurationExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationExtension2(struct soap *soap, const char *tag, tt__VideoSourceConfigurationExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfigurationExtension2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, sizeof(tt__VideoSourceConfigurationExtension2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoSourceConfigurationExtension2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoSourceConfigurationExtension2 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__VideoSourceConfigurationExtension2::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__VideoSourceConfigurationExtension2::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__VideoSourceConfigurationExtension2::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__VideoSourceConfigurationExtension2::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__VideoSourceConfigurationExtension2::__any, "xsd:byte"))
				{	a->tt__VideoSourceConfigurationExtension2::__size++;
					a->tt__VideoSourceConfigurationExtension2::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__VideoSourceConfigurationExtension2::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__VideoSourceConfigurationExtension2::__size)
			a->tt__VideoSourceConfigurationExtension2::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__VideoSourceConfigurationExtension2::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfigurationExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, 0, sizeof(tt__VideoSourceConfigurationExtension2), 0, soap_copy_tt__VideoSourceConfigurationExtension2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__VideoSourceConfigurationExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoSourceConfigurationExtension2);
	if (this->soap_out(soap, tag?tag:"tt:VideoSourceConfigurationExtension2", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfigurationExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfigurationExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationExtension2(struct soap *soap, tt__VideoSourceConfigurationExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoSourceConfigurationExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfigurationExtension2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoSourceConfigurationExtension2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoSourceConfigurationExtension2);
		if (size)
			*size = sizeof(tt__VideoSourceConfigurationExtension2);
		((tt__VideoSourceConfigurationExtension2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoSourceConfigurationExtension2, n);
		if (size)
			*size = n * sizeof(tt__VideoSourceConfigurationExtension2);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__VideoSourceConfigurationExtension2*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__VideoSourceConfigurationExtension2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoSourceConfigurationExtension2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoSourceConfigurationExtension2 %p -> %p\n", q, p));
	*(tt__VideoSourceConfigurationExtension2*)p = *(tt__VideoSourceConfigurationExtension2*)q;
}

void tt__VideoSourceConfigurationExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__VideoSourceConfigurationExtension::Rotate = NULL;
	this->tt__VideoSourceConfigurationExtension::Extension = NULL;
}

void tt__VideoSourceConfigurationExtension::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Rotate(soap, &this->tt__VideoSourceConfigurationExtension::Rotate);
	soap_serialize_PointerTott__VideoSourceConfigurationExtension2(soap, &this->tt__VideoSourceConfigurationExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoSourceConfigurationExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfigurationExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfigurationExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension), "tt:VideoSourceConfigurationExtension"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_PointerTott__Rotate(soap, "tt:Rotate", -1, &(a->tt__VideoSourceConfigurationExtension::Rotate), ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfigurationExtension2(soap, "tt:Extension", -1, &(a->tt__VideoSourceConfigurationExtension::Extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfigurationExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoSourceConfigurationExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension * SOAP_FMAC4 soap_in_tt__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, tt__VideoSourceConfigurationExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfigurationExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfigurationExtension, sizeof(tt__VideoSourceConfigurationExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoSourceConfigurationExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoSourceConfigurationExtension *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Rotate1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Rotate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Rotate(soap, "tt:Rotate", &(a->tt__VideoSourceConfigurationExtension::Rotate), "tt:Rotate"))
				{	soap_flag_Rotate1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceConfigurationExtension2(soap, "tt:Extension", &(a->tt__VideoSourceConfigurationExtension::Extension), "tt:VideoSourceConfigurationExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfigurationExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfigurationExtension, 0, sizeof(tt__VideoSourceConfigurationExtension), 0, soap_copy_tt__VideoSourceConfigurationExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__VideoSourceConfigurationExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoSourceConfigurationExtension);
	if (this->soap_out(soap, tag?tag:"tt:VideoSourceConfigurationExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfigurationExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfigurationExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfigurationExtension * SOAP_FMAC4 soap_get_tt__VideoSourceConfigurationExtension(struct soap *soap, tt__VideoSourceConfigurationExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoSourceConfigurationExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfigurationExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfigurationExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoSourceConfigurationExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoSourceConfigurationExtension);
		if (size)
			*size = sizeof(tt__VideoSourceConfigurationExtension);
		((tt__VideoSourceConfigurationExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoSourceConfigurationExtension, n);
		if (size)
			*size = n * sizeof(tt__VideoSourceConfigurationExtension);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__VideoSourceConfigurationExtension*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__VideoSourceConfigurationExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoSourceConfigurationExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoSourceConfigurationExtension %p -> %p\n", q, p));
	*(tt__VideoSourceConfigurationExtension*)p = *(tt__VideoSourceConfigurationExtension*)q;
}

void tt__VideoSourceConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__ConfigurationEntity::soap_default(soap);
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__VideoSourceConfiguration::SourceToken);
	this->tt__VideoSourceConfiguration::Bounds = NULL;
	this->tt__VideoSourceConfiguration::__size = 0;
	this->tt__VideoSourceConfiguration::__any = NULL;
	this->tt__VideoSourceConfiguration::Extension = NULL;
	this->tt__VideoSourceConfiguration::__anyAttribute = NULL;
}

void tt__VideoSourceConfiguration::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &this->tt__VideoSourceConfiguration::SourceToken);
	soap_serialize_PointerTott__IntRectangle(soap, &this->tt__VideoSourceConfiguration::Bounds);
	soap_serialize_PointerTott__VideoSourceConfigurationExtension(soap, &this->tt__VideoSourceConfiguration::Extension);
	this->tt__ConfigurationEntity::soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoSourceConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceConfiguration(struct soap *soap, const char *tag, int id, const tt__VideoSourceConfiguration *a, const char *type)
{
	if (((tt__VideoSourceConfiguration*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__VideoSourceConfiguration*)a)->__anyAttribute, 1);
	if (((tt__ConfigurationEntity*)a)->token)
		soap_set_attr(soap, "token", ((tt__ConfigurationEntity*)a)->token, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceConfiguration), "tt:VideoSourceConfiguration"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__ConfigurationEntity::Name)
	{	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &(a->tt__ConfigurationEntity::UseCount), ""))
		return soap->error;
	if (a->tt__VideoSourceConfiguration::SourceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tt:SourceToken", -1, &a->tt__VideoSourceConfiguration::SourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SourceToken"))
		return soap->error;
	if (a->tt__VideoSourceConfiguration::Bounds)
	{	if (soap_out_PointerTott__IntRectangle(soap, "tt:Bounds", -1, &a->tt__VideoSourceConfiguration::Bounds, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Bounds"))
		return soap->error;
	if (a->tt__VideoSourceConfiguration::__any)
	{	int i;
		for (i = 0; i < a->tt__VideoSourceConfiguration::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__VideoSourceConfiguration::__any + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__VideoSourceConfigurationExtension(soap, "tt:Extension", -1, &(a->tt__VideoSourceConfiguration::Extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoSourceConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceConfiguration * SOAP_FMAC4 soap_in_tt__VideoSourceConfiguration(struct soap *soap, const char *tag, tt__VideoSourceConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceConfiguration, sizeof(tt__VideoSourceConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoSourceConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoSourceConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((tt__VideoSourceConfiguration*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &((tt__ConfigurationEntity*)a)->token, 0, 64))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Name2 = 1;
	size_t soap_flag_UseCount2 = 1;
	size_t soap_flag_SourceToken1 = 1;
	size_t soap_flag_Bounds1 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Name2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &(a->tt__ConfigurationEntity::Name), "tt:Name"))
				{	soap_flag_Name2--;
					continue;
				}
			if (soap_flag_UseCount2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &(a->tt__ConfigurationEntity::UseCount), "xsd:int"))
				{	soap_flag_UseCount2--;
					continue;
				}
			if (soap_flag_SourceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tt:SourceToken", &(a->tt__VideoSourceConfiguration::SourceToken), "tt:ReferenceToken"))
				{	soap_flag_SourceToken1--;
					continue;
				}
			if (soap_flag_Bounds1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRectangle(soap, "tt:Bounds", &(a->tt__VideoSourceConfiguration::Bounds), "tt:IntRectangle"))
				{	soap_flag_Bounds1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceConfigurationExtension(soap, "tt:Extension", &(a->tt__VideoSourceConfiguration::Extension), "tt:VideoSourceConfigurationExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__VideoSourceConfiguration::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__VideoSourceConfiguration::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__VideoSourceConfiguration::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__VideoSourceConfiguration::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__VideoSourceConfiguration::__any, "xsd:byte"))
				{	a->tt__VideoSourceConfiguration::__size++;
					a->tt__VideoSourceConfiguration::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__VideoSourceConfiguration::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__VideoSourceConfiguration::__size)
			a->tt__VideoSourceConfiguration::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__VideoSourceConfiguration::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceConfiguration, 0, sizeof(tt__VideoSourceConfiguration), 0, soap_copy_tt__VideoSourceConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name2 > 0 || soap_flag_UseCount2 > 0 || soap_flag_SourceToken1 > 0 || soap_flag_Bounds1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__VideoSourceConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoSourceConfiguration);
	if (this->soap_out(soap, tag?tag:"tt:VideoSourceConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceConfiguration * SOAP_FMAC4 soap_get_tt__VideoSourceConfiguration(struct soap *soap, tt__VideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoSourceConfiguration * SOAP_FMAC2 soap_instantiate_tt__VideoSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoSourceConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoSourceConfiguration);
		if (size)
			*size = sizeof(tt__VideoSourceConfiguration);
		((tt__VideoSourceConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoSourceConfiguration, n);
		if (size)
			*size = n * sizeof(tt__VideoSourceConfiguration);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__VideoSourceConfiguration*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__VideoSourceConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoSourceConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoSourceConfiguration %p -> %p\n", q, p));
	*(tt__VideoSourceConfiguration*)p = *(tt__VideoSourceConfiguration*)q;
}

void tt__ConfigurationEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_default_int(soap, &this->tt__ConfigurationEntity::UseCount);
	soap_default_tt__ReferenceToken(soap, &this->tt__ConfigurationEntity::token);
}

void tt__ConfigurationEntity::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &this->tt__ConfigurationEntity::Name);
	soap_embedded(soap, &this->tt__ConfigurationEntity::UseCount, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ConfigurationEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ConfigurationEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ConfigurationEntity(struct soap *soap, const char *tag, int id, const tt__ConfigurationEntity *a, const char *type)
{
	if (((tt__ConfigurationEntity*)a)->token)
		soap_set_attr(soap, "token", ((tt__ConfigurationEntity*)a)->token, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ConfigurationEntity), "tt:ConfigurationEntity"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__ConfigurationEntity::Name)
	{	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__ConfigurationEntity::Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (soap_out_int(soap, "tt:UseCount", -1, &(a->tt__ConfigurationEntity::UseCount), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ConfigurationEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ConfigurationEntity(soap, tag, this, type);
}

SOAP_FMAC3 tt__ConfigurationEntity * SOAP_FMAC4 soap_in_tt__ConfigurationEntity(struct soap *soap, const char *tag, tt__ConfigurationEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ConfigurationEntity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ConfigurationEntity, sizeof(tt__ConfigurationEntity), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ConfigurationEntity)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ConfigurationEntity *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &((tt__ConfigurationEntity*)a)->token, 0, 64))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_UseCount1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &(a->tt__ConfigurationEntity::Name), "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_UseCount1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:UseCount", &(a->tt__ConfigurationEntity::UseCount), "xsd:int"))
				{	soap_flag_UseCount1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ConfigurationEntity *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ConfigurationEntity, 0, sizeof(tt__ConfigurationEntity), 0, soap_copy_tt__ConfigurationEntity);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0 || soap_flag_UseCount1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__ConfigurationEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ConfigurationEntity);
	if (this->soap_out(soap, tag?tag:"tt:ConfigurationEntity", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ConfigurationEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ConfigurationEntity(soap, this, tag, type);
}

SOAP_FMAC3 tt__ConfigurationEntity * SOAP_FMAC4 soap_get_tt__ConfigurationEntity(struct soap *soap, tt__ConfigurationEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ConfigurationEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ConfigurationEntity * SOAP_FMAC2 soap_instantiate_tt__ConfigurationEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ConfigurationEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ConfigurationEntity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "tt:VideoSourceConfiguration"))
	{	cp->type = SOAP_TYPE_tt__VideoSourceConfiguration;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__VideoSourceConfiguration);
			if (size)
				*size = sizeof(tt__VideoSourceConfiguration);
			((tt__VideoSourceConfiguration*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoSourceConfiguration, n);
			if (size)
				*size = n * sizeof(tt__VideoSourceConfiguration);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__VideoSourceConfiguration*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__VideoSourceConfiguration*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:VideoEncoderConfiguration"))
	{	cp->type = SOAP_TYPE_tt__VideoEncoderConfiguration;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__VideoEncoderConfiguration);
			if (size)
				*size = sizeof(tt__VideoEncoderConfiguration);
			((tt__VideoEncoderConfiguration*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoEncoderConfiguration, n);
			if (size)
				*size = n * sizeof(tt__VideoEncoderConfiguration);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__VideoEncoderConfiguration*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__VideoEncoderConfiguration*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:AudioSourceConfiguration"))
	{	cp->type = SOAP_TYPE_tt__AudioSourceConfiguration;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__AudioSourceConfiguration);
			if (size)
				*size = sizeof(tt__AudioSourceConfiguration);
			((tt__AudioSourceConfiguration*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__AudioSourceConfiguration, n);
			if (size)
				*size = n * sizeof(tt__AudioSourceConfiguration);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__AudioSourceConfiguration*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__AudioSourceConfiguration*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:AudioEncoderConfiguration"))
	{	cp->type = SOAP_TYPE_tt__AudioEncoderConfiguration;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__AudioEncoderConfiguration);
			if (size)
				*size = sizeof(tt__AudioEncoderConfiguration);
			((tt__AudioEncoderConfiguration*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__AudioEncoderConfiguration, n);
			if (size)
				*size = n * sizeof(tt__AudioEncoderConfiguration);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__AudioEncoderConfiguration*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__AudioEncoderConfiguration*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:VideoAnalyticsConfiguration"))
	{	cp->type = SOAP_TYPE_tt__VideoAnalyticsConfiguration;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__VideoAnalyticsConfiguration);
			if (size)
				*size = sizeof(tt__VideoAnalyticsConfiguration);
			((tt__VideoAnalyticsConfiguration*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoAnalyticsConfiguration, n);
			if (size)
				*size = n * sizeof(tt__VideoAnalyticsConfiguration);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__VideoAnalyticsConfiguration*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__VideoAnalyticsConfiguration*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:MetadataConfiguration"))
	{	cp->type = SOAP_TYPE_tt__MetadataConfiguration;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__MetadataConfiguration);
			if (size)
				*size = sizeof(tt__MetadataConfiguration);
			((tt__MetadataConfiguration*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__MetadataConfiguration, n);
			if (size)
				*size = n * sizeof(tt__MetadataConfiguration);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__MetadataConfiguration*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__MetadataConfiguration*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:VideoOutputConfiguration"))
	{	cp->type = SOAP_TYPE_tt__VideoOutputConfiguration;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__VideoOutputConfiguration);
			if (size)
				*size = sizeof(tt__VideoOutputConfiguration);
			((tt__VideoOutputConfiguration*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoOutputConfiguration, n);
			if (size)
				*size = n * sizeof(tt__VideoOutputConfiguration);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__VideoOutputConfiguration*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__VideoOutputConfiguration*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:AudioOutputConfiguration"))
	{	cp->type = SOAP_TYPE_tt__AudioOutputConfiguration;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__AudioOutputConfiguration);
			if (size)
				*size = sizeof(tt__AudioOutputConfiguration);
			((tt__AudioOutputConfiguration*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__AudioOutputConfiguration, n);
			if (size)
				*size = n * sizeof(tt__AudioOutputConfiguration);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__AudioOutputConfiguration*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__AudioOutputConfiguration*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:AudioDecoderConfiguration"))
	{	cp->type = SOAP_TYPE_tt__AudioDecoderConfiguration;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__AudioDecoderConfiguration);
			if (size)
				*size = sizeof(tt__AudioDecoderConfiguration);
			((tt__AudioDecoderConfiguration*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__AudioDecoderConfiguration, n);
			if (size)
				*size = n * sizeof(tt__AudioDecoderConfiguration);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__AudioDecoderConfiguration*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__AudioDecoderConfiguration*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:PTZConfiguration"))
	{	cp->type = SOAP_TYPE_tt__PTZConfiguration;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__PTZConfiguration);
			if (size)
				*size = sizeof(tt__PTZConfiguration);
			((tt__PTZConfiguration*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__PTZConfiguration, n);
			if (size)
				*size = n * sizeof(tt__PTZConfiguration);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__PTZConfiguration*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__PTZConfiguration*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:AnalyticsEngine"))
	{	cp->type = SOAP_TYPE_tt__AnalyticsEngine;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__AnalyticsEngine);
			if (size)
				*size = sizeof(tt__AnalyticsEngine);
			((tt__AnalyticsEngine*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__AnalyticsEngine, n);
			if (size)
				*size = n * sizeof(tt__AnalyticsEngine);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__AnalyticsEngine*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__AnalyticsEngine*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:AnalyticsEngineInput"))
	{	cp->type = SOAP_TYPE_tt__AnalyticsEngineInput;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__AnalyticsEngineInput);
			if (size)
				*size = sizeof(tt__AnalyticsEngineInput);
			((tt__AnalyticsEngineInput*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__AnalyticsEngineInput, n);
			if (size)
				*size = n * sizeof(tt__AnalyticsEngineInput);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__AnalyticsEngineInput*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__AnalyticsEngineInput*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:AnalyticsEngineControl"))
	{	cp->type = SOAP_TYPE_tt__AnalyticsEngineControl;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__AnalyticsEngineControl);
			if (size)
				*size = sizeof(tt__AnalyticsEngineControl);
			((tt__AnalyticsEngineControl*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__AnalyticsEngineControl, n);
			if (size)
				*size = n * sizeof(tt__AnalyticsEngineControl);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__AnalyticsEngineControl*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__AnalyticsEngineControl*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ConfigurationEntity);
		if (size)
			*size = sizeof(tt__ConfigurationEntity);
		((tt__ConfigurationEntity*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__ConfigurationEntity, n);
		if (size)
			*size = n * sizeof(tt__ConfigurationEntity);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__ConfigurationEntity*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__ConfigurationEntity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ConfigurationEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ConfigurationEntity %p -> %p\n", q, p));
	*(tt__ConfigurationEntity*)p = *(tt__ConfigurationEntity*)q;
}

void tt__ProfileExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ProfileExtension2::__size = 0;
	this->tt__ProfileExtension2::__any = NULL;
}

void tt__ProfileExtension2::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ProfileExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ProfileExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileExtension2(struct soap *soap, const char *tag, int id, const tt__ProfileExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileExtension2), "tt:ProfileExtension2"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__ProfileExtension2::__any)
	{	int i;
		for (i = 0; i < a->tt__ProfileExtension2::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__ProfileExtension2::__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__ProfileExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ProfileExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__ProfileExtension2 * SOAP_FMAC4 soap_in_tt__ProfileExtension2(struct soap *soap, const char *tag, tt__ProfileExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ProfileExtension2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileExtension2, sizeof(tt__ProfileExtension2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ProfileExtension2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ProfileExtension2 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__ProfileExtension2::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__ProfileExtension2::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__ProfileExtension2::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__ProfileExtension2::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__ProfileExtension2::__any, "xsd:byte"))
				{	a->tt__ProfileExtension2::__size++;
					a->tt__ProfileExtension2::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__ProfileExtension2::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__ProfileExtension2::__size)
			a->tt__ProfileExtension2::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__ProfileExtension2::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ProfileExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileExtension2, 0, sizeof(tt__ProfileExtension2), 0, soap_copy_tt__ProfileExtension2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ProfileExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ProfileExtension2);
	if (this->soap_out(soap, tag?tag:"tt:ProfileExtension2", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ProfileExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ProfileExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__ProfileExtension2 * SOAP_FMAC4 soap_get_tt__ProfileExtension2(struct soap *soap, tt__ProfileExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ProfileExtension2 * SOAP_FMAC2 soap_instantiate_tt__ProfileExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ProfileExtension2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ProfileExtension2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ProfileExtension2);
		if (size)
			*size = sizeof(tt__ProfileExtension2);
		((tt__ProfileExtension2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__ProfileExtension2, n);
		if (size)
			*size = n * sizeof(tt__ProfileExtension2);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__ProfileExtension2*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__ProfileExtension2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ProfileExtension2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ProfileExtension2 %p -> %p\n", q, p));
	*(tt__ProfileExtension2*)p = *(tt__ProfileExtension2*)q;
}

void tt__ProfileExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__ProfileExtension::__size = 0;
	this->tt__ProfileExtension::__any = NULL;
	this->tt__ProfileExtension::AudioOutputConfiguration = NULL;
	this->tt__ProfileExtension::AudioDecoderConfiguration = NULL;
	this->tt__ProfileExtension::Extension = NULL;
	this->tt__ProfileExtension::__anyAttribute = NULL;
}

void tt__ProfileExtension::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__AudioOutputConfiguration(soap, &this->tt__ProfileExtension::AudioOutputConfiguration);
	soap_serialize_PointerTott__AudioDecoderConfiguration(soap, &this->tt__ProfileExtension::AudioDecoderConfiguration);
	soap_serialize_PointerTott__ProfileExtension2(soap, &this->tt__ProfileExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__ProfileExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__ProfileExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__ProfileExtension(struct soap *soap, const char *tag, int id, const tt__ProfileExtension *a, const char *type)
{
	if (((tt__ProfileExtension*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__ProfileExtension*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__ProfileExtension), "tt:ProfileExtension"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__ProfileExtension::__any)
	{	int i;
		for (i = 0; i < a->tt__ProfileExtension::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__ProfileExtension::__any + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__AudioOutputConfiguration(soap, "tt:AudioOutputConfiguration", -1, &(a->tt__ProfileExtension::AudioOutputConfiguration), ""))
		return soap->error;
	if (soap_out_PointerTott__AudioDecoderConfiguration(soap, "tt:AudioDecoderConfiguration", -1, &(a->tt__ProfileExtension::AudioDecoderConfiguration), ""))
		return soap->error;
	if (soap_out_PointerTott__ProfileExtension2(soap, "tt:Extension", -1, &(a->tt__ProfileExtension::Extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__ProfileExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__ProfileExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__ProfileExtension * SOAP_FMAC4 soap_in_tt__ProfileExtension(struct soap *soap, const char *tag, tt__ProfileExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__ProfileExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__ProfileExtension, sizeof(tt__ProfileExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__ProfileExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__ProfileExtension *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((tt__ProfileExtension*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	size_t soap_flag_AudioOutputConfiguration1 = 1;
	size_t soap_flag_AudioDecoderConfiguration1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_AudioOutputConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioOutputConfiguration(soap, "tt:AudioOutputConfiguration", &(a->tt__ProfileExtension::AudioOutputConfiguration), "tt:AudioOutputConfiguration"))
				{	soap_flag_AudioOutputConfiguration1--;
					continue;
				}
			if (soap_flag_AudioDecoderConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioDecoderConfiguration(soap, "tt:AudioDecoderConfiguration", &(a->tt__ProfileExtension::AudioDecoderConfiguration), "tt:AudioDecoderConfiguration"))
				{	soap_flag_AudioDecoderConfiguration1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ProfileExtension2(soap, "tt:Extension", &(a->tt__ProfileExtension::Extension), "tt:ProfileExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__ProfileExtension::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__ProfileExtension::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__ProfileExtension::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__ProfileExtension::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__ProfileExtension::__any, "xsd:byte"))
				{	a->tt__ProfileExtension::__size++;
					a->tt__ProfileExtension::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__ProfileExtension::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__ProfileExtension::__size)
			a->tt__ProfileExtension::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__ProfileExtension::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__ProfileExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__ProfileExtension, 0, sizeof(tt__ProfileExtension), 0, soap_copy_tt__ProfileExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__ProfileExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__ProfileExtension);
	if (this->soap_out(soap, tag?tag:"tt:ProfileExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__ProfileExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__ProfileExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__ProfileExtension * SOAP_FMAC4 soap_get_tt__ProfileExtension(struct soap *soap, tt__ProfileExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__ProfileExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__ProfileExtension * SOAP_FMAC2 soap_instantiate_tt__ProfileExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__ProfileExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__ProfileExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__ProfileExtension);
		if (size)
			*size = sizeof(tt__ProfileExtension);
		((tt__ProfileExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__ProfileExtension, n);
		if (size)
			*size = n * sizeof(tt__ProfileExtension);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__ProfileExtension*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__ProfileExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__ProfileExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__ProfileExtension %p -> %p\n", q, p));
	*(tt__ProfileExtension*)p = *(tt__ProfileExtension*)q;
}

void tt__Profile::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__Name(soap, &this->tt__Profile::Name);
	this->tt__Profile::VideoSourceConfiguration = NULL;
	this->tt__Profile::AudioSourceConfiguration = NULL;
	this->tt__Profile::VideoEncoderConfiguration = NULL;
	this->tt__Profile::AudioEncoderConfiguration = NULL;
	this->tt__Profile::VideoAnalyticsConfiguration = NULL;
	this->tt__Profile::PTZConfiguration = NULL;
	this->tt__Profile::MetadataConfiguration = NULL;
	this->tt__Profile::Extension = NULL;
	soap_default_tt__ReferenceToken(soap, &this->tt__Profile::token);
	this->tt__Profile::fixed = NULL;
	this->tt__Profile::__anyAttribute = NULL;
}

void tt__Profile::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &this->tt__Profile::Name);
	soap_serialize_PointerTott__VideoSourceConfiguration(soap, &this->tt__Profile::VideoSourceConfiguration);
	soap_serialize_PointerTott__AudioSourceConfiguration(soap, &this->tt__Profile::AudioSourceConfiguration);
	soap_serialize_PointerTott__VideoEncoderConfiguration(soap, &this->tt__Profile::VideoEncoderConfiguration);
	soap_serialize_PointerTott__AudioEncoderConfiguration(soap, &this->tt__Profile::AudioEncoderConfiguration);
	soap_serialize_PointerTott__VideoAnalyticsConfiguration(soap, &this->tt__Profile::VideoAnalyticsConfiguration);
	soap_serialize_PointerTott__PTZConfiguration(soap, &this->tt__Profile::PTZConfiguration);
	soap_serialize_PointerTott__MetadataConfiguration(soap, &this->tt__Profile::MetadataConfiguration);
	soap_serialize_PointerTott__ProfileExtension(soap, &this->tt__Profile::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__Profile::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__Profile(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__Profile(struct soap *soap, const char *tag, int id, const tt__Profile *a, const char *type)
{
	if (((tt__Profile*)a)->token)
		soap_set_attr(soap, "token", ((tt__Profile*)a)->token, 1);
	if (((tt__Profile*)a)->fixed)
		soap_set_attr(soap, "fixed", soap_bool2s(soap, *((tt__Profile*)a)->fixed), 1);
	if (((tt__Profile*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__Profile*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__Profile), "tt:Profile"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__Profile::Name)
	{	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->tt__Profile::Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Name"))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceConfiguration(soap, "tt:VideoSourceConfiguration", -1, &(a->tt__Profile::VideoSourceConfiguration), ""))
		return soap->error;
	if (soap_out_PointerTott__AudioSourceConfiguration(soap, "tt:AudioSourceConfiguration", -1, &(a->tt__Profile::AudioSourceConfiguration), ""))
		return soap->error;
	if (soap_out_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoEncoderConfiguration", -1, &(a->tt__Profile::VideoEncoderConfiguration), ""))
		return soap->error;
	if (soap_out_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", -1, &(a->tt__Profile::AudioEncoderConfiguration), ""))
		return soap->error;
	if (soap_out_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", -1, &(a->tt__Profile::VideoAnalyticsConfiguration), ""))
		return soap->error;
	if (soap_out_PointerTott__PTZConfiguration(soap, "tt:PTZConfiguration", -1, &(a->tt__Profile::PTZConfiguration), ""))
		return soap->error;
	if (soap_out_PointerTott__MetadataConfiguration(soap, "tt:MetadataConfiguration", -1, &(a->tt__Profile::MetadataConfiguration), ""))
		return soap->error;
	if (soap_out_PointerTott__ProfileExtension(soap, "tt:Extension", -1, &(a->tt__Profile::Extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__Profile::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__Profile(soap, tag, this, type);
}

SOAP_FMAC3 tt__Profile * SOAP_FMAC4 soap_in_tt__Profile(struct soap *soap, const char *tag, tt__Profile *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__Profile *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__Profile, sizeof(tt__Profile), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__Profile)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__Profile *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &((tt__Profile*)a)->token, 0, 64))
		return NULL;
	{	const char *t = soap_attr_value(soap, "fixed", 0);
		if (t)
		{
			if (!(((tt__Profile*)a)->fixed = (bool *)soap_malloc(soap, sizeof(bool))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2bool(soap, t, ((tt__Profile*)a)->fixed))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((tt__Profile*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_VideoSourceConfiguration1 = 1;
	size_t soap_flag_AudioSourceConfiguration1 = 1;
	size_t soap_flag_VideoEncoderConfiguration1 = 1;
	size_t soap_flag_AudioEncoderConfiguration1 = 1;
	size_t soap_flag_VideoAnalyticsConfiguration1 = 1;
	size_t soap_flag_PTZConfiguration1 = 1;
	size_t soap_flag_MetadataConfiguration1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &(a->tt__Profile::Name), "tt:Name"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_VideoSourceConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceConfiguration(soap, "tt:VideoSourceConfiguration", &(a->tt__Profile::VideoSourceConfiguration), "tt:VideoSourceConfiguration"))
				{	soap_flag_VideoSourceConfiguration1--;
					continue;
				}
			if (soap_flag_AudioSourceConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioSourceConfiguration(soap, "tt:AudioSourceConfiguration", &(a->tt__Profile::AudioSourceConfiguration), "tt:AudioSourceConfiguration"))
				{	soap_flag_AudioSourceConfiguration1--;
					continue;
				}
			if (soap_flag_VideoEncoderConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoEncoderConfiguration(soap, "tt:VideoEncoderConfiguration", &(a->tt__Profile::VideoEncoderConfiguration), "tt:VideoEncoderConfiguration"))
				{	soap_flag_VideoEncoderConfiguration1--;
					continue;
				}
			if (soap_flag_AudioEncoderConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__AudioEncoderConfiguration(soap, "tt:AudioEncoderConfiguration", &(a->tt__Profile::AudioEncoderConfiguration), "tt:AudioEncoderConfiguration"))
				{	soap_flag_AudioEncoderConfiguration1--;
					continue;
				}
			if (soap_flag_VideoAnalyticsConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoAnalyticsConfiguration(soap, "tt:VideoAnalyticsConfiguration", &(a->tt__Profile::VideoAnalyticsConfiguration), "tt:VideoAnalyticsConfiguration"))
				{	soap_flag_VideoAnalyticsConfiguration1--;
					continue;
				}
			if (soap_flag_PTZConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZConfiguration(soap, "tt:PTZConfiguration", &(a->tt__Profile::PTZConfiguration), "tt:PTZConfiguration"))
				{	soap_flag_PTZConfiguration1--;
					continue;
				}
			if (soap_flag_MetadataConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataConfiguration(soap, "tt:MetadataConfiguration", &(a->tt__Profile::MetadataConfiguration), "tt:MetadataConfiguration"))
				{	soap_flag_MetadataConfiguration1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ProfileExtension(soap, "tt:Extension", &(a->tt__Profile::Extension), "tt:ProfileExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__Profile *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__Profile, 0, sizeof(tt__Profile), 0, soap_copy_tt__Profile);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__Profile::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__Profile);
	if (this->soap_out(soap, tag?tag:"tt:Profile", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__Profile::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__Profile(soap, this, tag, type);
}

SOAP_FMAC3 tt__Profile * SOAP_FMAC4 soap_get_tt__Profile(struct soap *soap, tt__Profile *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__Profile * SOAP_FMAC2 soap_instantiate_tt__Profile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__Profile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__Profile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__Profile);
		if (size)
			*size = sizeof(tt__Profile);
		((tt__Profile*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__Profile, n);
		if (size)
			*size = n * sizeof(tt__Profile);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__Profile*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__Profile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__Profile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__Profile %p -> %p\n", q, p));
	*(tt__Profile*)p = *(tt__Profile*)q;
}

void tt__AudioSource::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__DeviceEntity::soap_default(soap);
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__AudioSource::Channels);
	this->tt__AudioSource::__size = 0;
	this->tt__AudioSource::__any = NULL;
	this->tt__AudioSource::__anyAttribute = NULL;
}

void tt__AudioSource::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__AudioSource::Channels, SOAP_TYPE_int);
	this->tt__DeviceEntity::soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AudioSource::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AudioSource(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AudioSource(struct soap *soap, const char *tag, int id, const tt__AudioSource *a, const char *type)
{
	if (((tt__AudioSource*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__AudioSource*)a)->__anyAttribute, 1);
	if (((tt__DeviceEntity*)a)->token)
		soap_set_attr(soap, "token", ((tt__DeviceEntity*)a)->token, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AudioSource), "tt:AudioSource"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_int(soap, "tt:Channels", -1, &(a->tt__AudioSource::Channels), ""))
		return soap->error;
	if (a->tt__AudioSource::__any)
	{	int i;
		for (i = 0; i < a->tt__AudioSource::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__AudioSource::__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__AudioSource::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AudioSource(soap, tag, this, type);
}

SOAP_FMAC3 tt__AudioSource * SOAP_FMAC4 soap_in_tt__AudioSource(struct soap *soap, const char *tag, tt__AudioSource *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AudioSource *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AudioSource, sizeof(tt__AudioSource), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AudioSource)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AudioSource *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((tt__AudioSource*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &((tt__DeviceEntity*)a)->token, 0, 64))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Channels1 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Channels1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Channels", &(a->tt__AudioSource::Channels), "xsd:int"))
				{	soap_flag_Channels1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__AudioSource::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__AudioSource::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__AudioSource::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__AudioSource::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__AudioSource::__any, "xsd:byte"))
				{	a->tt__AudioSource::__size++;
					a->tt__AudioSource::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__AudioSource::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__AudioSource::__size)
			a->tt__AudioSource::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__AudioSource::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AudioSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AudioSource, 0, sizeof(tt__AudioSource), 0, soap_copy_tt__AudioSource);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Channels1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__AudioSource::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AudioSource);
	if (this->soap_out(soap, tag?tag:"tt:AudioSource", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AudioSource::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AudioSource(soap, this, tag, type);
}

SOAP_FMAC3 tt__AudioSource * SOAP_FMAC4 soap_get_tt__AudioSource(struct soap *soap, tt__AudioSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AudioSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AudioSource * SOAP_FMAC2 soap_instantiate_tt__AudioSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AudioSource(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AudioSource, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AudioSource);
		if (size)
			*size = sizeof(tt__AudioSource);
		((tt__AudioSource*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__AudioSource, n);
		if (size)
			*size = n * sizeof(tt__AudioSource);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__AudioSource*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__AudioSource*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AudioSource(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AudioSource %p -> %p\n", q, p));
	*(tt__AudioSource*)p = *(tt__AudioSource*)q;
}

void tt__VideoSourceExtension2::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__VideoSourceExtension2::__size = 0;
	this->tt__VideoSourceExtension2::__any = NULL;
}

void tt__VideoSourceExtension2::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoSourceExtension2::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceExtension2(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceExtension2(struct soap *soap, const char *tag, int id, const tt__VideoSourceExtension2 *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceExtension2), "tt:VideoSourceExtension2"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__VideoSourceExtension2::__any)
	{	int i;
		for (i = 0; i < a->tt__VideoSourceExtension2::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__VideoSourceExtension2::__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceExtension2::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoSourceExtension2(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceExtension2 * SOAP_FMAC4 soap_in_tt__VideoSourceExtension2(struct soap *soap, const char *tag, tt__VideoSourceExtension2 *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceExtension2 *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceExtension2, sizeof(tt__VideoSourceExtension2), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoSourceExtension2)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoSourceExtension2 *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__VideoSourceExtension2::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__VideoSourceExtension2::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__VideoSourceExtension2::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__VideoSourceExtension2::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__VideoSourceExtension2::__any, "xsd:byte"))
				{	a->tt__VideoSourceExtension2::__size++;
					a->tt__VideoSourceExtension2::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__VideoSourceExtension2::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__VideoSourceExtension2::__size)
			a->tt__VideoSourceExtension2::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__VideoSourceExtension2::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceExtension2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceExtension2, 0, sizeof(tt__VideoSourceExtension2), 0, soap_copy_tt__VideoSourceExtension2);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__VideoSourceExtension2::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoSourceExtension2);
	if (this->soap_out(soap, tag?tag:"tt:VideoSourceExtension2", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceExtension2::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceExtension2(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceExtension2 * SOAP_FMAC4 soap_get_tt__VideoSourceExtension2(struct soap *soap, tt__VideoSourceExtension2 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceExtension2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoSourceExtension2 * SOAP_FMAC2 soap_instantiate_tt__VideoSourceExtension2(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceExtension2(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoSourceExtension2, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoSourceExtension2);
		if (size)
			*size = sizeof(tt__VideoSourceExtension2);
		((tt__VideoSourceExtension2*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoSourceExtension2, n);
		if (size)
			*size = n * sizeof(tt__VideoSourceExtension2);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__VideoSourceExtension2*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__VideoSourceExtension2*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoSourceExtension2(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoSourceExtension2 %p -> %p\n", q, p));
	*(tt__VideoSourceExtension2*)p = *(tt__VideoSourceExtension2*)q;
}

void tt__VideoSourceExtension::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__VideoSourceExtension::__size = 0;
	this->tt__VideoSourceExtension::__any = NULL;
	this->tt__VideoSourceExtension::Imaging = NULL;
	this->tt__VideoSourceExtension::Extension = NULL;
}

void tt__VideoSourceExtension::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ImagingSettings20(soap, &this->tt__VideoSourceExtension::Imaging);
	soap_serialize_PointerTott__VideoSourceExtension2(soap, &this->tt__VideoSourceExtension::Extension);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoSourceExtension::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSourceExtension(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSourceExtension(struct soap *soap, const char *tag, int id, const tt__VideoSourceExtension *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSourceExtension), "tt:VideoSourceExtension"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__VideoSourceExtension::__any)
	{	int i;
		for (i = 0; i < a->tt__VideoSourceExtension::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__VideoSourceExtension::__any + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__ImagingSettings20(soap, "tt:Imaging", -1, &(a->tt__VideoSourceExtension::Imaging), ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceExtension2(soap, "tt:Extension", -1, &(a->tt__VideoSourceExtension::Extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSourceExtension::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoSourceExtension(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSourceExtension * SOAP_FMAC4 soap_in_tt__VideoSourceExtension(struct soap *soap, const char *tag, tt__VideoSourceExtension *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSourceExtension *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSourceExtension, sizeof(tt__VideoSourceExtension), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoSourceExtension)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoSourceExtension *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	size_t soap_flag_Imaging1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Imaging1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingSettings20(soap, "tt:Imaging", &(a->tt__VideoSourceExtension::Imaging), "tt:ImagingSettings20"))
				{	soap_flag_Imaging1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceExtension2(soap, "tt:Extension", &(a->tt__VideoSourceExtension::Extension), "tt:VideoSourceExtension2"))
				{	soap_flag_Extension1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__VideoSourceExtension::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__VideoSourceExtension::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__VideoSourceExtension::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__VideoSourceExtension::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__VideoSourceExtension::__any, "xsd:byte"))
				{	a->tt__VideoSourceExtension::__size++;
					a->tt__VideoSourceExtension::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__VideoSourceExtension::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__VideoSourceExtension::__size)
			a->tt__VideoSourceExtension::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__VideoSourceExtension::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSourceExtension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSourceExtension, 0, sizeof(tt__VideoSourceExtension), 0, soap_copy_tt__VideoSourceExtension);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__VideoSourceExtension::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoSourceExtension);
	if (this->soap_out(soap, tag?tag:"tt:VideoSourceExtension", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSourceExtension::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSourceExtension(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSourceExtension * SOAP_FMAC4 soap_get_tt__VideoSourceExtension(struct soap *soap, tt__VideoSourceExtension *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoSourceExtension * SOAP_FMAC2 soap_instantiate_tt__VideoSourceExtension(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSourceExtension(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoSourceExtension, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoSourceExtension);
		if (size)
			*size = sizeof(tt__VideoSourceExtension);
		((tt__VideoSourceExtension*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoSourceExtension, n);
		if (size)
			*size = n * sizeof(tt__VideoSourceExtension);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__VideoSourceExtension*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__VideoSourceExtension*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoSourceExtension(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoSourceExtension %p -> %p\n", q, p));
	*(tt__VideoSourceExtension*)p = *(tt__VideoSourceExtension*)q;
}

void tt__VideoSource::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->tt__DeviceEntity::soap_default(soap);
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__VideoSource::Framerate);
	this->tt__VideoSource::Resolution = NULL;
	this->tt__VideoSource::Imaging = NULL;
	this->tt__VideoSource::Extension = NULL;
	this->tt__VideoSource::__anyAttribute = NULL;
}

void tt__VideoSource::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__VideoSource::Framerate, SOAP_TYPE_float);
	soap_serialize_PointerTott__VideoResolution(soap, &this->tt__VideoSource::Resolution);
	soap_serialize_PointerTott__ImagingSettings(soap, &this->tt__VideoSource::Imaging);
	soap_serialize_PointerTott__VideoSourceExtension(soap, &this->tt__VideoSource::Extension);
	this->tt__DeviceEntity::soap_serialize(soap);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__VideoSource::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__VideoSource(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__VideoSource(struct soap *soap, const char *tag, int id, const tt__VideoSource *a, const char *type)
{
	if (((tt__VideoSource*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__VideoSource*)a)->__anyAttribute, 1);
	if (((tt__DeviceEntity*)a)->token)
		soap_set_attr(soap, "token", ((tt__DeviceEntity*)a)->token, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__VideoSource), "tt:VideoSource"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_float(soap, "tt:Framerate", -1, &(a->tt__VideoSource::Framerate), ""))
		return soap->error;
	if (a->tt__VideoSource::Resolution)
	{	if (soap_out_PointerTott__VideoResolution(soap, "tt:Resolution", -1, &a->tt__VideoSource::Resolution, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:Resolution"))
		return soap->error;
	if (soap_out_PointerTott__ImagingSettings(soap, "tt:Imaging", -1, &(a->tt__VideoSource::Imaging), ""))
		return soap->error;
	if (soap_out_PointerTott__VideoSourceExtension(soap, "tt:Extension", -1, &(a->tt__VideoSource::Extension), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__VideoSource::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__VideoSource(soap, tag, this, type);
}

SOAP_FMAC3 tt__VideoSource * SOAP_FMAC4 soap_in_tt__VideoSource(struct soap *soap, const char *tag, tt__VideoSource *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__VideoSource *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__VideoSource, sizeof(tt__VideoSource), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__VideoSource)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__VideoSource *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((tt__VideoSource*)a)->__anyAttribute, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &((tt__DeviceEntity*)a)->token, 0, 64))
		return NULL;
	size_t soap_flag___item3 = 1;
	size_t soap_flag_Framerate1 = 1;
	size_t soap_flag_Resolution1 = 1;
	size_t soap_flag_Imaging1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Framerate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Framerate", &(a->tt__VideoSource::Framerate), "xsd:float"))
				{	soap_flag_Framerate1--;
					continue;
				}
			if (soap_flag_Resolution1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoResolution(soap, "tt:Resolution", &(a->tt__VideoSource::Resolution), "tt:VideoResolution"))
				{	soap_flag_Resolution1--;
					continue;
				}
			if (soap_flag_Imaging1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingSettings(soap, "tt:Imaging", &(a->tt__VideoSource::Imaging), "tt:ImagingSettings"))
				{	soap_flag_Imaging1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__VideoSourceExtension(soap, "tt:Extension", &(a->tt__VideoSource::Extension), "tt:VideoSourceExtension"))
				{	soap_flag_Extension1--;
					continue;
				}
			if (soap_flag___item3 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item3--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__VideoSource *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__VideoSource, 0, sizeof(tt__VideoSource), 0, soap_copy_tt__VideoSource);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Framerate1 > 0 || soap_flag_Resolution1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__VideoSource::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__VideoSource);
	if (this->soap_out(soap, tag?tag:"tt:VideoSource", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__VideoSource::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__VideoSource(soap, this, tag, type);
}

SOAP_FMAC3 tt__VideoSource * SOAP_FMAC4 soap_get_tt__VideoSource(struct soap *soap, tt__VideoSource *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__VideoSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__VideoSource * SOAP_FMAC2 soap_instantiate_tt__VideoSource(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__VideoSource(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__VideoSource, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__VideoSource);
		if (size)
			*size = sizeof(tt__VideoSource);
		((tt__VideoSource*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoSource, n);
		if (size)
			*size = n * sizeof(tt__VideoSource);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__VideoSource*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__VideoSource*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__VideoSource(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__VideoSource %p -> %p\n", q, p));
	*(tt__VideoSource*)p = *(tt__VideoSource*)q;
}

void tt__AnyHolder::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__AnyHolder::__size = 0;
	this->tt__AnyHolder::__any = NULL;
	this->tt__AnyHolder::__anyAttribute = NULL;
}

void tt__AnyHolder::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__AnyHolder::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__AnyHolder(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__AnyHolder(struct soap *soap, const char *tag, int id, const tt__AnyHolder *a, const char *type)
{
	if (((tt__AnyHolder*)a)->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", ((tt__AnyHolder*)a)->__anyAttribute, 1);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__AnyHolder), "tt:AnyHolder"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__AnyHolder::__any)
	{	int i;
		for (i = 0; i < a->tt__AnyHolder::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->tt__AnyHolder::__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__AnyHolder::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__AnyHolder(soap, tag, this, type);
}

SOAP_FMAC3 tt__AnyHolder * SOAP_FMAC4 soap_in_tt__AnyHolder(struct soap *soap, const char *tag, tt__AnyHolder *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__AnyHolder *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__AnyHolder, sizeof(tt__AnyHolder), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__AnyHolder)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__AnyHolder *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &((tt__AnyHolder*)a)->__anyAttribute, 0, -1))
		return NULL;
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist___any1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->tt__AnyHolder::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->tt__AnyHolder::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->tt__AnyHolder::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->tt__AnyHolder::__any);
				}
				if (soap_in_byte(soap, "-any", a->tt__AnyHolder::__any, "xsd:byte"))
				{	a->tt__AnyHolder::__size++;
					a->tt__AnyHolder::__any = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__AnyHolder::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->tt__AnyHolder::__size)
			a->tt__AnyHolder::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->tt__AnyHolder::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__AnyHolder *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__AnyHolder, 0, sizeof(tt__AnyHolder), 0, soap_copy_tt__AnyHolder);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__AnyHolder::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__AnyHolder);
	if (this->soap_out(soap, tag?tag:"tt:AnyHolder", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__AnyHolder::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__AnyHolder(soap, this, tag, type);
}

SOAP_FMAC3 tt__AnyHolder * SOAP_FMAC4 soap_get_tt__AnyHolder(struct soap *soap, tt__AnyHolder *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__AnyHolder(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__AnyHolder * SOAP_FMAC2 soap_instantiate_tt__AnyHolder(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__AnyHolder(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__AnyHolder, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__AnyHolder);
		if (size)
			*size = sizeof(tt__AnyHolder);
		((tt__AnyHolder*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__AnyHolder, n);
		if (size)
			*size = n * sizeof(tt__AnyHolder);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__AnyHolder*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__AnyHolder*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__AnyHolder(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__AnyHolder %p -> %p\n", q, p));
	*(tt__AnyHolder*)p = *(tt__AnyHolder*)q;
}

void tt__FloatList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__FloatList::__sizeItems = 0;
	this->tt__FloatList::Items = NULL;
}

void tt__FloatList::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->tt__FloatList::Items)
	{	int i;
		for (i = 0; i < this->tt__FloatList::__sizeItems; i++)
		{
			soap_embedded(soap, this->tt__FloatList::Items + i, SOAP_TYPE_float);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__FloatList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FloatList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatList(struct soap *soap, const char *tag, int id, const tt__FloatList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FloatList), "tt:FloatList"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__FloatList::Items)
	{	int i;
		for (i = 0; i < a->tt__FloatList::__sizeItems; i++)
			if (soap_out_float(soap, "tt:Items", -1, a->tt__FloatList::Items + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__FloatList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__FloatList(soap, tag, this, type);
}

SOAP_FMAC3 tt__FloatList * SOAP_FMAC4 soap_in_tt__FloatList(struct soap *soap, const char *tag, tt__FloatList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FloatList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FloatList, sizeof(tt__FloatList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__FloatList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__FloatList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_Items1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Items", 1, NULL))
			{	if (a->tt__FloatList::Items == NULL)
				{	if (soap_blist_Items1 == NULL)
						soap_blist_Items1 = soap_new_block(soap);
					a->tt__FloatList::Items = (float *)soap_push_block(soap, soap_blist_Items1, sizeof(float));
					if (a->tt__FloatList::Items == NULL)
						return NULL;
					soap_default_float(soap, a->tt__FloatList::Items);
				}
				soap_revert(soap);
				if (soap_in_float(soap, "tt:Items", a->tt__FloatList::Items, "xsd:float"))
				{	a->tt__FloatList::__sizeItems++;
					a->tt__FloatList::Items = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__FloatList::Items)
			soap_pop_block(soap, soap_blist_Items1);
		if (a->tt__FloatList::__sizeItems)
			a->tt__FloatList::Items = (float *)soap_save_block(soap, soap_blist_Items1, NULL, 1);
		else
		{	a->tt__FloatList::Items = NULL;
			if (soap_blist_Items1)
				soap_end_block(soap, soap_blist_Items1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FloatList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FloatList, 0, sizeof(tt__FloatList), 0, soap_copy_tt__FloatList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__FloatList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__FloatList);
	if (this->soap_out(soap, tag?tag:"tt:FloatList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FloatList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FloatList(soap, this, tag, type);
}

SOAP_FMAC3 tt__FloatList * SOAP_FMAC4 soap_get_tt__FloatList(struct soap *soap, tt__FloatList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__FloatList * SOAP_FMAC2 soap_instantiate_tt__FloatList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FloatList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__FloatList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__FloatList);
		if (size)
			*size = sizeof(tt__FloatList);
		((tt__FloatList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__FloatList, n);
		if (size)
			*size = n * sizeof(tt__FloatList);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__FloatList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__FloatList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__FloatList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__FloatList %p -> %p\n", q, p));
	*(tt__FloatList*)p = *(tt__FloatList*)q;
}

void tt__IntList::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__IntList::__sizeItems = 0;
	this->tt__IntList::Items = NULL;
}

void tt__IntList::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->tt__IntList::Items)
	{	int i;
		for (i = 0; i < this->tt__IntList::__sizeItems; i++)
		{
			soap_embedded(soap, this->tt__IntList::Items + i, SOAP_TYPE_int);
		}
	}
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IntList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntList(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntList(struct soap *soap, const char *tag, int id, const tt__IntList *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntList), "tt:IntList"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__IntList::Items)
	{	int i;
		for (i = 0; i < a->tt__IntList::__sizeItems; i++)
			if (soap_out_int(soap, "tt:Items", -1, a->tt__IntList::Items + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

void *tt__IntList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IntList(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntList * SOAP_FMAC4 soap_in_tt__IntList(struct soap *soap, const char *tag, tt__IntList *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IntList *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntList, sizeof(tt__IntList), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IntList)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__IntList *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	struct soap_blist *soap_blist_Items1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:Items", 1, NULL))
			{	if (a->tt__IntList::Items == NULL)
				{	if (soap_blist_Items1 == NULL)
						soap_blist_Items1 = soap_new_block(soap);
					a->tt__IntList::Items = (int *)soap_push_block(soap, soap_blist_Items1, sizeof(int));
					if (a->tt__IntList::Items == NULL)
						return NULL;
					soap_default_int(soap, a->tt__IntList::Items);
				}
				soap_revert(soap);
				if (soap_in_int(soap, "tt:Items", a->tt__IntList::Items, "xsd:int"))
				{	a->tt__IntList::__sizeItems++;
					a->tt__IntList::Items = NULL;
					continue;
				}
			}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->tt__IntList::Items)
			soap_pop_block(soap, soap_blist_Items1);
		if (a->tt__IntList::__sizeItems)
			a->tt__IntList::Items = (int *)soap_save_block(soap, soap_blist_Items1, NULL, 1);
		else
		{	a->tt__IntList::Items = NULL;
			if (soap_blist_Items1)
				soap_end_block(soap, soap_blist_Items1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IntList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntList, 0, sizeof(tt__IntList), 0, soap_copy_tt__IntList);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int tt__IntList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IntList);
	if (this->soap_out(soap, tag?tag:"tt:IntList", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntList(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntList * SOAP_FMAC4 soap_get_tt__IntList(struct soap *soap, tt__IntList *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IntList * SOAP_FMAC2 soap_instantiate_tt__IntList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IntList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IntList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IntList);
		if (size)
			*size = sizeof(tt__IntList);
		((tt__IntList*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__IntList, n);
		if (size)
			*size = n * sizeof(tt__IntList);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__IntList*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__IntList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IntList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IntList %p -> %p\n", q, p));
	*(tt__IntList*)p = *(tt__IntList*)q;
}

void tt__DurationRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_xsd__duration(soap, &this->tt__DurationRange::Min);
	soap_default_xsd__duration(soap, &this->tt__DurationRange::Max);
}

void tt__DurationRange::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__DurationRange::Min, SOAP_TYPE_xsd__duration);
	soap_embedded(soap, &this->tt__DurationRange::Max, SOAP_TYPE_xsd__duration);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DurationRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DurationRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DurationRange(struct soap *soap, const char *tag, int id, const tt__DurationRange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__DurationRange), "tt:DurationRange"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_xsd__duration(soap, "tt:Min", -1, &(a->tt__DurationRange::Min), ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tt:Max", -1, &(a->tt__DurationRange::Max), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__DurationRange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__DurationRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__DurationRange * SOAP_FMAC4 soap_in_tt__DurationRange(struct soap *soap, const char *tag, tt__DurationRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__DurationRange *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DurationRange, sizeof(tt__DurationRange), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__DurationRange)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__DurationRange *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Min1 = 1;
	size_t soap_flag_Max1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Min1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:Min", &(a->tt__DurationRange::Min), "xsd:duration"))
				{	soap_flag_Min1--;
					continue;
				}
			if (soap_flag_Max1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tt:Max", &(a->tt__DurationRange::Max), "xsd:duration"))
				{	soap_flag_Max1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__DurationRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__DurationRange, 0, sizeof(tt__DurationRange), 0, soap_copy_tt__DurationRange);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min1 > 0 || soap_flag_Max1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__DurationRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__DurationRange);
	if (this->soap_out(soap, tag?tag:"tt:DurationRange", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DurationRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DurationRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__DurationRange * SOAP_FMAC4 soap_get_tt__DurationRange(struct soap *soap, tt__DurationRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DurationRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__DurationRange * SOAP_FMAC2 soap_instantiate_tt__DurationRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DurationRange(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__DurationRange, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__DurationRange);
		if (size)
			*size = sizeof(tt__DurationRange);
		((tt__DurationRange*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__DurationRange, n);
		if (size)
			*size = n * sizeof(tt__DurationRange);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__DurationRange*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__DurationRange*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__DurationRange(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__DurationRange %p -> %p\n", q, p));
	*(tt__DurationRange*)p = *(tt__DurationRange*)q;
}

void tt__FloatRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_float(soap, &this->tt__FloatRange::Min);
	soap_default_float(soap, &this->tt__FloatRange::Max);
}

void tt__FloatRange::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__FloatRange::Min, SOAP_TYPE_float);
	soap_embedded(soap, &this->tt__FloatRange::Max, SOAP_TYPE_float);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__FloatRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__FloatRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__FloatRange(struct soap *soap, const char *tag, int id, const tt__FloatRange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__FloatRange), "tt:FloatRange"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_float(soap, "tt:Min", -1, &(a->tt__FloatRange::Min), ""))
		return soap->error;
	if (soap_out_float(soap, "tt:Max", -1, &(a->tt__FloatRange::Max), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__FloatRange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__FloatRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__FloatRange * SOAP_FMAC4 soap_in_tt__FloatRange(struct soap *soap, const char *tag, tt__FloatRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__FloatRange *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__FloatRange, sizeof(tt__FloatRange), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__FloatRange)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__FloatRange *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Min1 = 1;
	size_t soap_flag_Max1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Min1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Min", &(a->tt__FloatRange::Min), "xsd:float"))
				{	soap_flag_Min1--;
					continue;
				}
			if (soap_flag_Max1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_float(soap, "tt:Max", &(a->tt__FloatRange::Max), "xsd:float"))
				{	soap_flag_Max1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__FloatRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__FloatRange, 0, sizeof(tt__FloatRange), 0, soap_copy_tt__FloatRange);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min1 > 0 || soap_flag_Max1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__FloatRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__FloatRange);
	if (this->soap_out(soap, tag?tag:"tt:FloatRange", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__FloatRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__FloatRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__FloatRange * SOAP_FMAC4 soap_get_tt__FloatRange(struct soap *soap, tt__FloatRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__FloatRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__FloatRange * SOAP_FMAC2 soap_instantiate_tt__FloatRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__FloatRange(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__FloatRange, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__FloatRange);
		if (size)
			*size = sizeof(tt__FloatRange);
		((tt__FloatRange*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__FloatRange, n);
		if (size)
			*size = n * sizeof(tt__FloatRange);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__FloatRange*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__FloatRange*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__FloatRange(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__FloatRange %p -> %p\n", q, p));
	*(tt__FloatRange*)p = *(tt__FloatRange*)q;
}

void tt__IntRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__IntRange::Min);
	soap_default_int(soap, &this->tt__IntRange::Max);
}

void tt__IntRange::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->tt__IntRange::Min, SOAP_TYPE_int);
	soap_embedded(soap, &this->tt__IntRange::Max, SOAP_TYPE_int);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IntRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRange(struct soap *soap, const char *tag, int id, const tt__IntRange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRange), "tt:IntRange"))
		return soap->error;
	/* transient soap skipped */
	if (soap_out_int(soap, "tt:Min", -1, &(a->tt__IntRange::Min), ""))
		return soap->error;
	if (soap_out_int(soap, "tt:Max", -1, &(a->tt__IntRange::Max), ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IntRange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IntRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntRange * SOAP_FMAC4 soap_in_tt__IntRange(struct soap *soap, const char *tag, tt__IntRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IntRange *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRange, sizeof(tt__IntRange), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IntRange)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__IntRange *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_Min1 = 1;
	size_t soap_flag_Max1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_Min1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Min", &(a->tt__IntRange::Min), "xsd:int"))
				{	soap_flag_Min1--;
					continue;
				}
			if (soap_flag_Max1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:Max", &(a->tt__IntRange::Max), "xsd:int"))
				{	soap_flag_Max1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IntRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRange, 0, sizeof(tt__IntRange), 0, soap_copy_tt__IntRange);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Min1 > 0 || soap_flag_Max1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__IntRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IntRange);
	if (this->soap_out(soap, tag?tag:"tt:IntRange", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntRange * SOAP_FMAC4 soap_get_tt__IntRange(struct soap *soap, tt__IntRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IntRange * SOAP_FMAC2 soap_instantiate_tt__IntRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IntRange(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IntRange, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IntRange);
		if (size)
			*size = sizeof(tt__IntRange);
		((tt__IntRange*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__IntRange, n);
		if (size)
			*size = n * sizeof(tt__IntRange);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__IntRange*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__IntRange*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IntRange(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IntRange %p -> %p\n", q, p));
	*(tt__IntRange*)p = *(tt__IntRange*)q;
}

void tt__IntRectangleRange::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	this->tt__IntRectangleRange::XRange = NULL;
	this->tt__IntRectangleRange::YRange = NULL;
	this->tt__IntRectangleRange::WidthRange = NULL;
	this->tt__IntRectangleRange::HeightRange = NULL;
}

void tt__IntRectangleRange::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::XRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::YRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::WidthRange);
	soap_serialize_PointerTott__IntRange(soap, &this->tt__IntRectangleRange::HeightRange);
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IntRectangleRange::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntRectangleRange(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRectangleRange(struct soap *soap, const char *tag, int id, const tt__IntRectangleRange *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__IntRectangleRange), "tt:IntRectangleRange"))
		return soap->error;
	/* transient soap skipped */
	if (a->tt__IntRectangleRange::XRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:XRange", -1, &a->tt__IntRectangleRange::XRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:XRange"))
		return soap->error;
	if (a->tt__IntRectangleRange::YRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:YRange", -1, &a->tt__IntRectangleRange::YRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:YRange"))
		return soap->error;
	if (a->tt__IntRectangleRange::WidthRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:WidthRange", -1, &a->tt__IntRectangleRange::WidthRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:WidthRange"))
		return soap->error;
	if (a->tt__IntRectangleRange::HeightRange)
	{	if (soap_out_PointerTott__IntRange(soap, "tt:HeightRange", -1, &a->tt__IntRectangleRange::HeightRange, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:HeightRange"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

void *tt__IntRectangleRange::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IntRectangleRange(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntRectangleRange * SOAP_FMAC4 soap_in_tt__IntRectangleRange(struct soap *soap, const char *tag, tt__IntRectangleRange *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (tt__IntRectangleRange *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRectangleRange, sizeof(tt__IntRectangleRange), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IntRectangleRange)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (tt__IntRectangleRange *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag___item2 = 1;
	size_t soap_flag_XRange1 = 1;
	size_t soap_flag_YRange1 = 1;
	size_t soap_flag_WidthRange1 = 1;
	size_t soap_flag_HeightRange1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap_flag_XRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:XRange", &(a->tt__IntRectangleRange::XRange), "tt:IntRange"))
				{	soap_flag_XRange1--;
					continue;
				}
			if (soap_flag_YRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:YRange", &(a->tt__IntRectangleRange::YRange), "tt:IntRange"))
				{	soap_flag_YRange1--;
					continue;
				}
			if (soap_flag_WidthRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:WidthRange", &(a->tt__IntRectangleRange::WidthRange), "tt:IntRange"))
				{	soap_flag_WidthRange1--;
					continue;
				}
			if (soap_flag_HeightRange1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IntRange(soap, "tt:HeightRange", &(a->tt__IntRectangleRange::HeightRange), "tt:IntRange"))
				{	soap_flag_HeightRange1--;
					continue;
				}
			if (soap_flag___item2 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-item", &(a->xsd__anyType::__item)))
				{	soap_flag___item2--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (tt__IntRectangleRange *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__IntRectangleRange, 0, sizeof(tt__IntRectangleRange), 0, soap_copy_tt__IntRectangleRange);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_XRange1 > 0 || soap_flag_YRange1 > 0 || soap_flag_WidthRange1 > 0 || soap_flag_HeightRange1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int tt__IntRectangleRange::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IntRectangleRange);
	if (this->soap_out(soap, tag?tag:"tt:IntRectangleRange", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntRectangleRange::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntRectangleRange(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntRectangleRange * SOAP_FMAC4 soap_get_tt__IntRectangleRange(struct soap *soap, tt__IntRectangleRange *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRectangleRange(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IntRectangleRange * SOAP_FMAC2 soap_instantiate_tt__IntRectangleRange(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IntRectangleRange(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IntRectangleRange, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IntRectangleRange);
		if (size)
			*size = sizeof(tt__IntRectangleRange);
		((tt__IntRectangleRange*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__IntRectangleRange, n);
		if (size)
			*size = n * sizeof(tt__IntRectangleRange);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__IntRectangleRange*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__IntRectangleRange*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IntRectangleRange(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IntRectangleRange %p -> %p\n", q, p));
	*(tt__IntRectangleRange*)p = *(tt__IntRectangleRange*)q;
}

void tt__IntRectangle::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_int(soap, &this->tt__IntRectangle::x);
	soap_default_int(soap, &this->tt__IntRectangle::y);
	soap_default_int(soap, &this->tt__IntRectangle::width);
	soap_default_int(soap, &this->tt__IntRectangle::height);
}

void tt__IntRectangle::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__IntRectangle::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__IntRectangle(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__IntRectangle(struct soap *soap, const char *tag, int id, const tt__IntRectangle *a, const char *type)
{
	soap_set_attr(soap, "x", soap_int2s(soap, ((tt__IntRectangle*)a)->x), 1);
	soap_set_attr(soap, "y", soap_int2s(soap, ((tt__IntRectangle*)a)->y), 1);
	soap_set_attr(soap, "width", soap_int2s(soap, ((tt__IntRectangle*)a)->width), 1);
	soap_set_attr(soap, "height", soap_int2s(soap, ((tt__IntRectangle*)a)->height), 1);
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "tt:IntRectangle");
}

void *tt__IntRectangle::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__IntRectangle(soap, tag, this, type);
}

SOAP_FMAC3 tt__IntRectangle * SOAP_FMAC4 soap_in_tt__IntRectangle(struct soap *soap, const char *tag, tt__IntRectangle *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__IntRectangle *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__IntRectangle, sizeof(tt__IntRectangle), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__IntRectangle)
			return (tt__IntRectangle *)a->soap_in(soap, tag, type);
	}
	if (soap_s2int(soap, soap_attr_value(soap, "x", 1), &((tt__IntRectangle*)a)->x))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "y", 1), &((tt__IntRectangle*)a)->y))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "width", 1), &((tt__IntRectangle*)a)->width))
		return NULL;
	if (soap_s2int(soap, soap_attr_value(soap, "height", 1), &((tt__IntRectangle*)a)->height))
		return NULL;
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int tt__IntRectangle::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__IntRectangle);
	if (this->soap_out(soap, tag?tag:"tt:IntRectangle", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__IntRectangle::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__IntRectangle(soap, this, tag, type);
}

SOAP_FMAC3 tt__IntRectangle * SOAP_FMAC4 soap_get_tt__IntRectangle(struct soap *soap, tt__IntRectangle *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__IntRectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__IntRectangle * SOAP_FMAC2 soap_instantiate_tt__IntRectangle(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__IntRectangle(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__IntRectangle, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__IntRectangle);
		if (size)
			*size = sizeof(tt__IntRectangle);
		((tt__IntRectangle*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__IntRectangle, n);
		if (size)
			*size = n * sizeof(tt__IntRectangle);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__IntRectangle*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__IntRectangle*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__IntRectangle(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__IntRectangle %p -> %p\n", q, p));
	*(tt__IntRectangle*)p = *(tt__IntRectangle*)q;
}

void tt__DeviceEntity::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->xsd__anyType::soap_default(soap);
	soap_default_tt__ReferenceToken(soap, &this->tt__DeviceEntity::token);
}

void tt__DeviceEntity::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	this->xsd__anyType::soap_serialize(soap);
#endif
}

int tt__DeviceEntity::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tt__DeviceEntity(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__DeviceEntity(struct soap *soap, const char *tag, int id, const tt__DeviceEntity *a, const char *type)
{
	if (((tt__DeviceEntity*)a)->token)
		soap_set_attr(soap, "token", ((tt__DeviceEntity*)a)->token, 1);
	return soap_outliteral(soap, tag, &(a->xsd__anyType::__item), "tt:DeviceEntity");
}

void *tt__DeviceEntity::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tt__DeviceEntity(soap, tag, this, type);
}

SOAP_FMAC3 tt__DeviceEntity * SOAP_FMAC4 soap_in_tt__DeviceEntity(struct soap *soap, const char *tag, tt__DeviceEntity *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (tt__DeviceEntity *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tt__DeviceEntity, sizeof(tt__DeviceEntity), soap->type, soap->arrayType)))
	{	soap->error = SOAP_TAG_MISMATCH;
		return NULL;
	}
	soap_revert(soap);
	*soap->id = '\0';
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_tt__DeviceEntity)
			return (tt__DeviceEntity *)a->soap_in(soap, tag, type);
	}
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &((tt__DeviceEntity*)a)->token, 0, 64))
		return NULL;
	if (!soap_inliteral(soap, tag, &(a->xsd__anyType::__item)))
		return NULL;
	return a;
}

int tt__DeviceEntity::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_tt__DeviceEntity);
	if (this->soap_out(soap, tag?tag:"tt:DeviceEntity", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *tt__DeviceEntity::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tt__DeviceEntity(soap, this, tag, type);
}

SOAP_FMAC3 tt__DeviceEntity * SOAP_FMAC4 soap_get_tt__DeviceEntity(struct soap *soap, tt__DeviceEntity *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__DeviceEntity(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 tt__DeviceEntity * SOAP_FMAC2 soap_instantiate_tt__DeviceEntity(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tt__DeviceEntity(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_tt__DeviceEntity, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (type && !soap_match_tag(soap, type, "tt:VideoSource"))
	{	cp->type = SOAP_TYPE_tt__VideoSource;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__VideoSource);
			if (size)
				*size = sizeof(tt__VideoSource);
			((tt__VideoSource*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoSource, n);
			if (size)
				*size = n * sizeof(tt__VideoSource);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__VideoSource*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__VideoSource*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:AudioSource"))
	{	cp->type = SOAP_TYPE_tt__AudioSource;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__AudioSource);
			if (size)
				*size = sizeof(tt__AudioSource);
			((tt__AudioSource*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__AudioSource, n);
			if (size)
				*size = n * sizeof(tt__AudioSource);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__AudioSource*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__AudioSource*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:VideoOutput"))
	{	cp->type = SOAP_TYPE_tt__VideoOutput;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__VideoOutput);
			if (size)
				*size = sizeof(tt__VideoOutput);
			((tt__VideoOutput*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__VideoOutput, n);
			if (size)
				*size = n * sizeof(tt__VideoOutput);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__VideoOutput*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__VideoOutput*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:AudioOutput"))
	{	cp->type = SOAP_TYPE_tt__AudioOutput;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__AudioOutput);
			if (size)
				*size = sizeof(tt__AudioOutput);
			((tt__AudioOutput*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__AudioOutput, n);
			if (size)
				*size = n * sizeof(tt__AudioOutput);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__AudioOutput*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__AudioOutput*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:NetworkInterface"))
	{	cp->type = SOAP_TYPE_tt__NetworkInterface;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__NetworkInterface);
			if (size)
				*size = sizeof(tt__NetworkInterface);
			((tt__NetworkInterface*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__NetworkInterface, n);
			if (size)
				*size = n * sizeof(tt__NetworkInterface);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__NetworkInterface*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__NetworkInterface*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:RelayOutput"))
	{	cp->type = SOAP_TYPE_tt__RelayOutput;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__RelayOutput);
			if (size)
				*size = sizeof(tt__RelayOutput);
			((tt__RelayOutput*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__RelayOutput, n);
			if (size)
				*size = n * sizeof(tt__RelayOutput);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__RelayOutput*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__RelayOutput*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:DigitalInput"))
	{	cp->type = SOAP_TYPE_tt__DigitalInput;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__DigitalInput);
			if (size)
				*size = sizeof(tt__DigitalInput);
			((tt__DigitalInput*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__DigitalInput, n);
			if (size)
				*size = n * sizeof(tt__DigitalInput);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__DigitalInput*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__DigitalInput*)cp->ptr;
	}
	if (type && !soap_match_tag(soap, type, "tt:PTZNode"))
	{	cp->type = SOAP_TYPE_tt__PTZNode;
		if (n < 0)
		{	cp->ptr = (void*)SOAP_NEW(tt__PTZNode);
			if (size)
				*size = sizeof(tt__PTZNode);
			((tt__PTZNode*)cp->ptr)->soap = soap;
		}
		else
		{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__PTZNode, n);
			if (size)
				*size = n * sizeof(tt__PTZNode);
			if (cp->ptr)
				for (int i = 0; i < n; i++)
					((tt__PTZNode*)cp->ptr)[i].soap = soap;
		}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
		if (!cp->ptr)
			soap->error = SOAP_EOM;
		return (tt__PTZNode*)cp->ptr;
	}
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(tt__DeviceEntity);
		if (size)
			*size = sizeof(tt__DeviceEntity);
		((tt__DeviceEntity*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(tt__DeviceEntity, n);
		if (size)
			*size = n * sizeof(tt__DeviceEntity);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((tt__DeviceEntity*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (tt__DeviceEntity*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_tt__DeviceEntity(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying tt__DeviceEntity %p -> %p\n", q, p));
	*(tt__DeviceEntity*)p = *(tt__DeviceEntity*)q;
}

void _tds__StartSystemRestoreResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->_tds__StartSystemRestoreResponse::UploadUri);
	soap_default_xsd__duration(soap, &this->_tds__StartSystemRestoreResponse::ExpectedDownTime);
	/* transient soap skipped */
}

void _tds__StartSystemRestoreResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &this->_tds__StartSystemRestoreResponse::UploadUri);
	soap_embedded(soap, &this->_tds__StartSystemRestoreResponse::ExpectedDownTime, SOAP_TYPE_xsd__duration);
	/* transient soap skipped */
#endif
}

int _tds__StartSystemRestoreResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__StartSystemRestoreResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, int id, const _tds__StartSystemRestoreResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartSystemRestoreResponse), type))
		return soap->error;
	if (a->UploadUri)
		soap_element_result(soap, "tds:UploadUri");
	if (a->_tds__StartSystemRestoreResponse::UploadUri)
	{	if (soap_out_xsd__anyURI(soap, "tds:UploadUri", -1, &a->_tds__StartSystemRestoreResponse::UploadUri, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:UploadUri"))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tds:ExpectedDownTime", -1, &(a->_tds__StartSystemRestoreResponse::ExpectedDownTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__StartSystemRestoreResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__StartSystemRestoreResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__StartSystemRestoreResponse * SOAP_FMAC4 soap_in__tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, _tds__StartSystemRestoreResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__StartSystemRestoreResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartSystemRestoreResponse, sizeof(_tds__StartSystemRestoreResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__StartSystemRestoreResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__StartSystemRestoreResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UploadUri1 = 1;
	size_t soap_flag_ExpectedDownTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tds:UploadUri", &(a->_tds__StartSystemRestoreResponse::UploadUri), "xsd:anyURI"))
				{	soap_flag_UploadUri1--;
					continue;
				}
			if (soap_flag_ExpectedDownTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tds:ExpectedDownTime", &(a->_tds__StartSystemRestoreResponse::ExpectedDownTime), "xsd:duration"))
				{	soap_flag_ExpectedDownTime1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:UploadUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__StartSystemRestoreResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartSystemRestoreResponse, 0, sizeof(_tds__StartSystemRestoreResponse), 0, soap_copy__tds__StartSystemRestoreResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UploadUri1 > 0 || soap_flag_ExpectedDownTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__StartSystemRestoreResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__StartSystemRestoreResponse);
	if (this->soap_out(soap, tag?tag:"tds:StartSystemRestoreResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__StartSystemRestoreResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__StartSystemRestoreResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__StartSystemRestoreResponse * SOAP_FMAC4 soap_get__tds__StartSystemRestoreResponse(struct soap *soap, _tds__StartSystemRestoreResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartSystemRestoreResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__StartSystemRestoreResponse * SOAP_FMAC2 soap_instantiate__tds__StartSystemRestoreResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__StartSystemRestoreResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__StartSystemRestoreResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__StartSystemRestoreResponse);
		if (size)
			*size = sizeof(_tds__StartSystemRestoreResponse);
		((_tds__StartSystemRestoreResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__StartSystemRestoreResponse, n);
		if (size)
			*size = n * sizeof(_tds__StartSystemRestoreResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__StartSystemRestoreResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__StartSystemRestoreResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__StartSystemRestoreResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__StartSystemRestoreResponse %p -> %p\n", q, p));
	*(_tds__StartSystemRestoreResponse*)p = *(_tds__StartSystemRestoreResponse*)q;
}

void _tds__StartSystemRestore::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__StartSystemRestore::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__StartSystemRestore::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__StartSystemRestore(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartSystemRestore(struct soap *soap, const char *tag, int id, const _tds__StartSystemRestore *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartSystemRestore), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__StartSystemRestore::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__StartSystemRestore(soap, tag, this, type);
}

SOAP_FMAC3 _tds__StartSystemRestore * SOAP_FMAC4 soap_in__tds__StartSystemRestore(struct soap *soap, const char *tag, _tds__StartSystemRestore *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__StartSystemRestore *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartSystemRestore, sizeof(_tds__StartSystemRestore), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__StartSystemRestore)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__StartSystemRestore *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__StartSystemRestore *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartSystemRestore, 0, sizeof(_tds__StartSystemRestore), 0, soap_copy__tds__StartSystemRestore);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__StartSystemRestore::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__StartSystemRestore);
	if (this->soap_out(soap, tag?tag:"tds:StartSystemRestore", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__StartSystemRestore::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__StartSystemRestore(soap, this, tag, type);
}

SOAP_FMAC3 _tds__StartSystemRestore * SOAP_FMAC4 soap_get__tds__StartSystemRestore(struct soap *soap, _tds__StartSystemRestore *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartSystemRestore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__StartSystemRestore * SOAP_FMAC2 soap_instantiate__tds__StartSystemRestore(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__StartSystemRestore(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__StartSystemRestore, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__StartSystemRestore);
		if (size)
			*size = sizeof(_tds__StartSystemRestore);
		((_tds__StartSystemRestore*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__StartSystemRestore, n);
		if (size)
			*size = n * sizeof(_tds__StartSystemRestore);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__StartSystemRestore*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__StartSystemRestore*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__StartSystemRestore(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__StartSystemRestore %p -> %p\n", q, p));
	*(_tds__StartSystemRestore*)p = *(_tds__StartSystemRestore*)q;
}

void _tds__StartFirmwareUpgradeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadUri);
	soap_default_xsd__duration(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadDelay);
	soap_default_xsd__duration(soap, &this->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime);
	/* transient soap skipped */
}

void _tds__StartFirmwareUpgradeResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadUri);
	soap_embedded(soap, &this->_tds__StartFirmwareUpgradeResponse::UploadDelay, SOAP_TYPE_xsd__duration);
	soap_embedded(soap, &this->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime, SOAP_TYPE_xsd__duration);
	/* transient soap skipped */
#endif
}

int _tds__StartFirmwareUpgradeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__StartFirmwareUpgradeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, int id, const _tds__StartFirmwareUpgradeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse), type))
		return soap->error;
	if (a->UploadUri)
		soap_element_result(soap, "tds:UploadUri");
	if (a->_tds__StartFirmwareUpgradeResponse::UploadUri)
	{	if (soap_out_xsd__anyURI(soap, "tds:UploadUri", -1, &a->_tds__StartFirmwareUpgradeResponse::UploadUri, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:UploadUri"))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tds:UploadDelay", -1, &(a->_tds__StartFirmwareUpgradeResponse::UploadDelay), ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tds:ExpectedDownTime", -1, &(a->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__StartFirmwareUpgradeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__StartFirmwareUpgradeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__StartFirmwareUpgradeResponse * SOAP_FMAC4 soap_in__tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, _tds__StartFirmwareUpgradeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__StartFirmwareUpgradeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, sizeof(_tds__StartFirmwareUpgradeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__StartFirmwareUpgradeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__StartFirmwareUpgradeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_UploadUri1 = 1;
	size_t soap_flag_UploadDelay1 = 1;
	size_t soap_flag_ExpectedDownTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tds:UploadUri", &(a->_tds__StartFirmwareUpgradeResponse::UploadUri), "xsd:anyURI"))
				{	soap_flag_UploadUri1--;
					continue;
				}
			if (soap_flag_UploadDelay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tds:UploadDelay", &(a->_tds__StartFirmwareUpgradeResponse::UploadDelay), "xsd:duration"))
				{	soap_flag_UploadDelay1--;
					continue;
				}
			if (soap_flag_ExpectedDownTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tds:ExpectedDownTime", &(a->_tds__StartFirmwareUpgradeResponse::ExpectedDownTime), "xsd:duration"))
				{	soap_flag_ExpectedDownTime1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:UploadUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__StartFirmwareUpgradeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, 0, sizeof(_tds__StartFirmwareUpgradeResponse), 0, soap_copy__tds__StartFirmwareUpgradeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UploadUri1 > 0 || soap_flag_UploadDelay1 > 0 || soap_flag_ExpectedDownTime1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__StartFirmwareUpgradeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__StartFirmwareUpgradeResponse);
	if (this->soap_out(soap, tag?tag:"tds:StartFirmwareUpgradeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__StartFirmwareUpgradeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__StartFirmwareUpgradeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__StartFirmwareUpgradeResponse * SOAP_FMAC4 soap_get__tds__StartFirmwareUpgradeResponse(struct soap *soap, _tds__StartFirmwareUpgradeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartFirmwareUpgradeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__StartFirmwareUpgradeResponse * SOAP_FMAC2 soap_instantiate__tds__StartFirmwareUpgradeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__StartFirmwareUpgradeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__StartFirmwareUpgradeResponse);
		if (size)
			*size = sizeof(_tds__StartFirmwareUpgradeResponse);
		((_tds__StartFirmwareUpgradeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__StartFirmwareUpgradeResponse, n);
		if (size)
			*size = n * sizeof(_tds__StartFirmwareUpgradeResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__StartFirmwareUpgradeResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__StartFirmwareUpgradeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__StartFirmwareUpgradeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__StartFirmwareUpgradeResponse %p -> %p\n", q, p));
	*(_tds__StartFirmwareUpgradeResponse*)p = *(_tds__StartFirmwareUpgradeResponse*)q;
}

void _tds__StartFirmwareUpgrade::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__StartFirmwareUpgrade::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__StartFirmwareUpgrade::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__StartFirmwareUpgrade(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, int id, const _tds__StartFirmwareUpgrade *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartFirmwareUpgrade), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__StartFirmwareUpgrade::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__StartFirmwareUpgrade(soap, tag, this, type);
}

SOAP_FMAC3 _tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_in__tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, _tds__StartFirmwareUpgrade *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__StartFirmwareUpgrade *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(_tds__StartFirmwareUpgrade), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__StartFirmwareUpgrade)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__StartFirmwareUpgrade *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__StartFirmwareUpgrade *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartFirmwareUpgrade, 0, sizeof(_tds__StartFirmwareUpgrade), 0, soap_copy__tds__StartFirmwareUpgrade);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__StartFirmwareUpgrade::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__StartFirmwareUpgrade);
	if (this->soap_out(soap, tag?tag:"tds:StartFirmwareUpgrade", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__StartFirmwareUpgrade::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__StartFirmwareUpgrade(soap, this, tag, type);
}

SOAP_FMAC3 _tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_get__tds__StartFirmwareUpgrade(struct soap *soap, _tds__StartFirmwareUpgrade *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartFirmwareUpgrade(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__StartFirmwareUpgrade * SOAP_FMAC2 soap_instantiate__tds__StartFirmwareUpgrade(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__StartFirmwareUpgrade(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__StartFirmwareUpgrade, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__StartFirmwareUpgrade);
		if (size)
			*size = sizeof(_tds__StartFirmwareUpgrade);
		((_tds__StartFirmwareUpgrade*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__StartFirmwareUpgrade, n);
		if (size)
			*size = n * sizeof(_tds__StartFirmwareUpgrade);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__StartFirmwareUpgrade*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__StartFirmwareUpgrade*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__StartFirmwareUpgrade(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__StartFirmwareUpgrade %p -> %p\n", q, p));
	*(_tds__StartFirmwareUpgrade*)p = *(_tds__StartFirmwareUpgrade*)q;
}

void _tds__GetSystemUrisResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetSystemUrisResponse::SystemLogUris = NULL;
	soap_default_xsd__anyURI(soap, &this->_tds__GetSystemUrisResponse::SupportInfoUri);
	soap_default_xsd__anyURI(soap, &this->_tds__GetSystemUrisResponse::SystemBackupUri);
	this->_tds__GetSystemUrisResponse::Extension = NULL;
	/* transient soap skipped */
}

void _tds__GetSystemUrisResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__SystemLogUriList(soap, &this->_tds__GetSystemUrisResponse::SystemLogUris);
	soap_serialize_xsd__anyURI(soap, &this->_tds__GetSystemUrisResponse::SupportInfoUri);
	soap_serialize_xsd__anyURI(soap, &this->_tds__GetSystemUrisResponse::SystemBackupUri);
	soap_serialize_PointerTo_tds__GetSystemUrisResponse_Extension(soap, &this->_tds__GetSystemUrisResponse::Extension);
	/* transient soap skipped */
#endif
}

int _tds__GetSystemUrisResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemUrisResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUrisResponse(struct soap *soap, const char *tag, int id, const _tds__GetSystemUrisResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUrisResponse), type))
		return soap->error;
	if (a->SystemLogUris)
		soap_element_result(soap, "tds:SystemLogUris");
	if (soap_out_PointerTott__SystemLogUriList(soap, "tds:SystemLogUris", -1, &(a->_tds__GetSystemUrisResponse::SystemLogUris), ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tds:SupportInfoUri", -1, &(a->_tds__GetSystemUrisResponse::SupportInfoUri), ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tds:SystemBackupUri", -1, &(a->_tds__GetSystemUrisResponse::SystemBackupUri), ""))
		return soap->error;
	if (soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(soap, "tds:Extension", -1, &(a->_tds__GetSystemUrisResponse::Extension), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemUrisResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetSystemUrisResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemUrisResponse * SOAP_FMAC4 soap_in__tds__GetSystemUrisResponse(struct soap *soap, const char *tag, _tds__GetSystemUrisResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemUrisResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUrisResponse, sizeof(_tds__GetSystemUrisResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetSystemUrisResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetSystemUrisResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_SystemLogUris1 = 1;
	size_t soap_flag_SupportInfoUri1 = 1;
	size_t soap_flag_SystemBackupUri1 = 1;
	size_t soap_flag_Extension1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemLogUris1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemLogUriList(soap, "tds:SystemLogUris", &(a->_tds__GetSystemUrisResponse::SystemLogUris), "tt:SystemLogUriList"))
				{	soap_flag_SystemLogUris1--;
					continue;
				}
			if (soap_flag_SupportInfoUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tds:SupportInfoUri", &(a->_tds__GetSystemUrisResponse::SupportInfoUri), "xsd:anyURI"))
				{	soap_flag_SupportInfoUri1--;
					continue;
				}
			if (soap_flag_SystemBackupUri1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tds:SystemBackupUri", &(a->_tds__GetSystemUrisResponse::SystemBackupUri), "xsd:anyURI"))
				{	soap_flag_SystemBackupUri1--;
					continue;
				}
			if (soap_flag_Extension1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(soap, "tds:Extension", &(a->_tds__GetSystemUrisResponse::Extension), ""))
				{	soap_flag_Extension1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:SystemLogUris");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetSystemUrisResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUrisResponse, 0, sizeof(_tds__GetSystemUrisResponse), 0, soap_copy__tds__GetSystemUrisResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetSystemUrisResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetSystemUrisResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetSystemUrisResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemUrisResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemUrisResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemUrisResponse * SOAP_FMAC4 soap_get__tds__GetSystemUrisResponse(struct soap *soap, _tds__GetSystemUrisResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUrisResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetSystemUrisResponse * SOAP_FMAC2 soap_instantiate__tds__GetSystemUrisResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemUrisResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetSystemUrisResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetSystemUrisResponse);
		if (size)
			*size = sizeof(_tds__GetSystemUrisResponse);
		((_tds__GetSystemUrisResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetSystemUrisResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetSystemUrisResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetSystemUrisResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetSystemUrisResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetSystemUrisResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetSystemUrisResponse %p -> %p\n", q, p));
	*(_tds__GetSystemUrisResponse*)p = *(_tds__GetSystemUrisResponse*)q;
}

void _tds__GetSystemUris::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__GetSystemUris::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__GetSystemUris::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetSystemUris(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUris(struct soap *soap, const char *tag, int id, const _tds__GetSystemUris *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUris), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetSystemUris::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetSystemUris(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetSystemUris * SOAP_FMAC4 soap_in__tds__GetSystemUris(struct soap *soap, const char *tag, _tds__GetSystemUris *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetSystemUris *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUris, sizeof(_tds__GetSystemUris), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetSystemUris)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetSystemUris *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetSystemUris *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUris, 0, sizeof(_tds__GetSystemUris), 0, soap_copy__tds__GetSystemUris);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetSystemUris::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetSystemUris);
	if (this->soap_out(soap, tag?tag:"tds:GetSystemUris", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetSystemUris::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetSystemUris(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetSystemUris * SOAP_FMAC4 soap_get__tds__GetSystemUris(struct soap *soap, _tds__GetSystemUris *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUris(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetSystemUris * SOAP_FMAC2 soap_instantiate__tds__GetSystemUris(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetSystemUris(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetSystemUris, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetSystemUris);
		if (size)
			*size = sizeof(_tds__GetSystemUris);
		((_tds__GetSystemUris*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetSystemUris, n);
		if (size)
			*size = n * sizeof(_tds__GetSystemUris);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetSystemUris*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetSystemUris*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetSystemUris(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetSystemUris %p -> %p\n", q, p));
	*(_tds__GetSystemUris*)p = *(_tds__GetSystemUris*)q;
}

void _tds__ScanAvailableDot11NetworksResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__ScanAvailableDot11NetworksResponse::__sizeNetworks = 0;
	this->_tds__ScanAvailableDot11NetworksResponse::Networks = NULL;
	/* transient soap skipped */
}

void _tds__ScanAvailableDot11NetworksResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__ScanAvailableDot11NetworksResponse::Networks)
	{	int i;
		for (i = 0; i < this->_tds__ScanAvailableDot11NetworksResponse::__sizeNetworks; i++)
		{
			soap_serialize_PointerTott__Dot11AvailableNetworks(soap, this->_tds__ScanAvailableDot11NetworksResponse::Networks + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__ScanAvailableDot11NetworksResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__ScanAvailableDot11NetworksResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, int id, const _tds__ScanAvailableDot11NetworksResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNetworks");
	if (a->_tds__ScanAvailableDot11NetworksResponse::Networks)
	{	int i;
		for (i = 0; i < a->_tds__ScanAvailableDot11NetworksResponse::__sizeNetworks; i++)
			if (soap_out_PointerTott__Dot11AvailableNetworks(soap, "tds:Networks", -1, a->_tds__ScanAvailableDot11NetworksResponse::Networks + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__ScanAvailableDot11NetworksResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__ScanAvailableDot11NetworksResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC4 soap_in__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, _tds__ScanAvailableDot11NetworksResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__ScanAvailableDot11NetworksResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, sizeof(_tds__ScanAvailableDot11NetworksResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__ScanAvailableDot11NetworksResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_Networks1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Networks", 1, NULL))
			{	if (a->_tds__ScanAvailableDot11NetworksResponse::Networks == NULL)
				{	if (soap_blist_Networks1 == NULL)
						soap_blist_Networks1 = soap_new_block(soap);
					a->_tds__ScanAvailableDot11NetworksResponse::Networks = (tt__Dot11AvailableNetworks **)soap_push_block(soap, soap_blist_Networks1, sizeof(tt__Dot11AvailableNetworks *));
					if (a->_tds__ScanAvailableDot11NetworksResponse::Networks == NULL)
						return NULL;
					*a->_tds__ScanAvailableDot11NetworksResponse::Networks = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__Dot11AvailableNetworks(soap, "tds:Networks", a->_tds__ScanAvailableDot11NetworksResponse::Networks, "tt:Dot11AvailableNetworks"))
				{	a->_tds__ScanAvailableDot11NetworksResponse::__sizeNetworks++;
					a->_tds__ScanAvailableDot11NetworksResponse::Networks = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			soap_check_result(soap, "-sizeNetworks");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__ScanAvailableDot11NetworksResponse::Networks)
			soap_pop_block(soap, soap_blist_Networks1);
		if (a->_tds__ScanAvailableDot11NetworksResponse::__sizeNetworks)
			a->_tds__ScanAvailableDot11NetworksResponse::Networks = (tt__Dot11AvailableNetworks **)soap_save_block(soap, soap_blist_Networks1, NULL, 1);
		else
		{	a->_tds__ScanAvailableDot11NetworksResponse::Networks = NULL;
			if (soap_blist_Networks1)
				soap_end_block(soap, soap_blist_Networks1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__ScanAvailableDot11NetworksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, 0, sizeof(_tds__ScanAvailableDot11NetworksResponse), 0, soap_copy__tds__ScanAvailableDot11NetworksResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__ScanAvailableDot11NetworksResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse);
	if (this->soap_out(soap, tag?tag:"tds:ScanAvailableDot11NetworksResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__ScanAvailableDot11NetworksResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__ScanAvailableDot11NetworksResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC4 soap_get__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, _tds__ScanAvailableDot11NetworksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__ScanAvailableDot11NetworksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC2 soap_instantiate__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__ScanAvailableDot11NetworksResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__ScanAvailableDot11NetworksResponse);
		if (size)
			*size = sizeof(_tds__ScanAvailableDot11NetworksResponse);
		((_tds__ScanAvailableDot11NetworksResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__ScanAvailableDot11NetworksResponse, n);
		if (size)
			*size = n * sizeof(_tds__ScanAvailableDot11NetworksResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__ScanAvailableDot11NetworksResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__ScanAvailableDot11NetworksResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__ScanAvailableDot11NetworksResponse %p -> %p\n", q, p));
	*(_tds__ScanAvailableDot11NetworksResponse*)p = *(_tds__ScanAvailableDot11NetworksResponse*)q;
}

void _tds__ScanAvailableDot11Networks::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__ScanAvailableDot11Networks::InterfaceToken);
	/* transient soap skipped */
}

void _tds__ScanAvailableDot11Networks::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__ScanAvailableDot11Networks::InterfaceToken);
	/* transient soap skipped */
#endif
}

int _tds__ScanAvailableDot11Networks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__ScanAvailableDot11Networks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, int id, const _tds__ScanAvailableDot11Networks *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__ScanAvailableDot11Networks), type))
		return soap->error;
	if (a->_tds__ScanAvailableDot11Networks::InterfaceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->_tds__ScanAvailableDot11Networks::InterfaceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:InterfaceToken"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__ScanAvailableDot11Networks::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__ScanAvailableDot11Networks(soap, tag, this, type);
}

SOAP_FMAC3 _tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_in__tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, _tds__ScanAvailableDot11Networks *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__ScanAvailableDot11Networks *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(_tds__ScanAvailableDot11Networks), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__ScanAvailableDot11Networks)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__ScanAvailableDot11Networks *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_InterfaceToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &(a->_tds__ScanAvailableDot11Networks::InterfaceToken), "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__ScanAvailableDot11Networks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__ScanAvailableDot11Networks, 0, sizeof(_tds__ScanAvailableDot11Networks), 0, soap_copy__tds__ScanAvailableDot11Networks);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__ScanAvailableDot11Networks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__ScanAvailableDot11Networks);
	if (this->soap_out(soap, tag?tag:"tds:ScanAvailableDot11Networks", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__ScanAvailableDot11Networks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__ScanAvailableDot11Networks(soap, this, tag, type);
}

SOAP_FMAC3 _tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_get__tds__ScanAvailableDot11Networks(struct soap *soap, _tds__ScanAvailableDot11Networks *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__ScanAvailableDot11Networks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__ScanAvailableDot11Networks * SOAP_FMAC2 soap_instantiate__tds__ScanAvailableDot11Networks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__ScanAvailableDot11Networks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__ScanAvailableDot11Networks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__ScanAvailableDot11Networks);
		if (size)
			*size = sizeof(_tds__ScanAvailableDot11Networks);
		((_tds__ScanAvailableDot11Networks*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__ScanAvailableDot11Networks, n);
		if (size)
			*size = n * sizeof(_tds__ScanAvailableDot11Networks);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__ScanAvailableDot11Networks*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__ScanAvailableDot11Networks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__ScanAvailableDot11Networks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__ScanAvailableDot11Networks %p -> %p\n", q, p));
	*(_tds__ScanAvailableDot11Networks*)p = *(_tds__ScanAvailableDot11Networks*)q;
}

void _tds__GetDot11StatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDot11StatusResponse::Status = NULL;
	/* transient soap skipped */
}

void _tds__GetDot11StatusResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Dot11Status(soap, &this->_tds__GetDot11StatusResponse::Status);
	/* transient soap skipped */
#endif
}

int _tds__GetDot11StatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot11StatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11StatusResponse(struct soap *soap, const char *tag, int id, const _tds__GetDot11StatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11StatusResponse), type))
		return soap->error;
	if (a->Status)
		soap_element_result(soap, "tds:Status");
	if (a->_tds__GetDot11StatusResponse::Status)
	{	if (soap_out_PointerTott__Dot11Status(soap, "tds:Status", -1, &a->_tds__GetDot11StatusResponse::Status, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Status"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot11StatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetDot11StatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot11StatusResponse * SOAP_FMAC4 soap_in__tds__GetDot11StatusResponse(struct soap *soap, const char *tag, _tds__GetDot11StatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot11StatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11StatusResponse, sizeof(_tds__GetDot11StatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetDot11StatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetDot11StatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11Status(soap, "tds:Status", &(a->_tds__GetDot11StatusResponse::Status), "tt:Dot11Status"))
				{	soap_flag_Status1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:Status");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDot11StatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11StatusResponse, 0, sizeof(_tds__GetDot11StatusResponse), 0, soap_copy__tds__GetDot11StatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetDot11StatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetDot11StatusResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetDot11StatusResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot11StatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot11StatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot11StatusResponse * SOAP_FMAC4 soap_get__tds__GetDot11StatusResponse(struct soap *soap, _tds__GetDot11StatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11StatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetDot11StatusResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot11StatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot11StatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetDot11StatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetDot11StatusResponse);
		if (size)
			*size = sizeof(_tds__GetDot11StatusResponse);
		((_tds__GetDot11StatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetDot11StatusResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetDot11StatusResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetDot11StatusResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetDot11StatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetDot11StatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetDot11StatusResponse %p -> %p\n", q, p));
	*(_tds__GetDot11StatusResponse*)p = *(_tds__GetDot11StatusResponse*)q;
}

void _tds__GetDot11Status::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__GetDot11Status::InterfaceToken);
	/* transient soap skipped */
}

void _tds__GetDot11Status::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__GetDot11Status::InterfaceToken);
	/* transient soap skipped */
#endif
}

int _tds__GetDot11Status::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot11Status(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11Status(struct soap *soap, const char *tag, int id, const _tds__GetDot11Status *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11Status), type))
		return soap->error;
	if (a->_tds__GetDot11Status::InterfaceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->_tds__GetDot11Status::InterfaceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:InterfaceToken"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot11Status::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetDot11Status(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot11Status * SOAP_FMAC4 soap_in__tds__GetDot11Status(struct soap *soap, const char *tag, _tds__GetDot11Status *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot11Status *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11Status, sizeof(_tds__GetDot11Status), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetDot11Status)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetDot11Status *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_InterfaceToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &(a->_tds__GetDot11Status::InterfaceToken), "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDot11Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11Status, 0, sizeof(_tds__GetDot11Status), 0, soap_copy__tds__GetDot11Status);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetDot11Status::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetDot11Status);
	if (this->soap_out(soap, tag?tag:"tds:GetDot11Status", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot11Status::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot11Status(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot11Status * SOAP_FMAC4 soap_get__tds__GetDot11Status(struct soap *soap, _tds__GetDot11Status *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetDot11Status * SOAP_FMAC2 soap_instantiate__tds__GetDot11Status(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot11Status(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetDot11Status, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetDot11Status);
		if (size)
			*size = sizeof(_tds__GetDot11Status);
		((_tds__GetDot11Status*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetDot11Status, n);
		if (size)
			*size = n * sizeof(_tds__GetDot11Status);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetDot11Status*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetDot11Status*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetDot11Status(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetDot11Status %p -> %p\n", q, p));
	*(_tds__GetDot11Status*)p = *(_tds__GetDot11Status*)q;
}

void _tds__GetDot11CapabilitiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDot11CapabilitiesResponse::Capabilities = NULL;
	/* transient soap skipped */
}

void _tds__GetDot11CapabilitiesResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Dot11Capabilities(soap, &this->_tds__GetDot11CapabilitiesResponse::Capabilities);
	/* transient soap skipped */
#endif
}

int _tds__GetDot11CapabilitiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot11CapabilitiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, int id, const _tds__GetDot11CapabilitiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (a->_tds__GetDot11CapabilitiesResponse::Capabilities)
	{	if (soap_out_PointerTott__Dot11Capabilities(soap, "tds:Capabilities", -1, &a->_tds__GetDot11CapabilitiesResponse::Capabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Capabilities"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot11CapabilitiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetDot11CapabilitiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot11CapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, _tds__GetDot11CapabilitiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot11CapabilitiesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, sizeof(_tds__GetDot11CapabilitiesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetDot11CapabilitiesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetDot11CapabilitiesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Capabilities1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11Capabilities(soap, "tds:Capabilities", &(a->_tds__GetDot11CapabilitiesResponse::Capabilities), "tt:Dot11Capabilities"))
				{	soap_flag_Capabilities1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDot11CapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, 0, sizeof(_tds__GetDot11CapabilitiesResponse), 0, soap_copy__tds__GetDot11CapabilitiesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetDot11CapabilitiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetDot11CapabilitiesResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetDot11CapabilitiesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot11CapabilitiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot11CapabilitiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot11CapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetDot11CapabilitiesResponse(struct soap *soap, _tds__GetDot11CapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11CapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetDot11CapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot11CapabilitiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot11CapabilitiesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetDot11CapabilitiesResponse);
		if (size)
			*size = sizeof(_tds__GetDot11CapabilitiesResponse);
		((_tds__GetDot11CapabilitiesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetDot11CapabilitiesResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetDot11CapabilitiesResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetDot11CapabilitiesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetDot11CapabilitiesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetDot11CapabilitiesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetDot11CapabilitiesResponse %p -> %p\n", q, p));
	*(_tds__GetDot11CapabilitiesResponse*)p = *(_tds__GetDot11CapabilitiesResponse*)q;
}

void _tds__GetDot11Capabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDot11Capabilities::__size = 0;
	this->_tds__GetDot11Capabilities::__any = NULL;
	/* transient soap skipped */
}

void _tds__GetDot11Capabilities::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__GetDot11Capabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot11Capabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11Capabilities(struct soap *soap, const char *tag, int id, const _tds__GetDot11Capabilities *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11Capabilities), type))
		return soap->error;
	if (a->_tds__GetDot11Capabilities::__any)
	{	int i;
		for (i = 0; i < a->_tds__GetDot11Capabilities::__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->_tds__GetDot11Capabilities::__any + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot11Capabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetDot11Capabilities(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot11Capabilities * SOAP_FMAC4 soap_in__tds__GetDot11Capabilities(struct soap *soap, const char *tag, _tds__GetDot11Capabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot11Capabilities *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(_tds__GetDot11Capabilities), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetDot11Capabilities)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetDot11Capabilities *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist___any1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->_tds__GetDot11Capabilities::__any == NULL)
				{	if (soap_blist___any1 == NULL)
						soap_blist___any1 = soap_new_block(soap);
					a->_tds__GetDot11Capabilities::__any = (char *)soap_push_block(soap, soap_blist___any1, sizeof(char));
					if (a->_tds__GetDot11Capabilities::__any == NULL)
						return NULL;
					soap_default_byte(soap, a->_tds__GetDot11Capabilities::__any);
				}
				if (soap_in_byte(soap, "-any", a->_tds__GetDot11Capabilities::__any, "xsd:byte"))
				{	a->_tds__GetDot11Capabilities::__size++;
					a->_tds__GetDot11Capabilities::__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__GetDot11Capabilities::__any)
			soap_pop_block(soap, soap_blist___any1);
		if (a->_tds__GetDot11Capabilities::__size)
			a->_tds__GetDot11Capabilities::__any = (char *)soap_save_block(soap, soap_blist___any1, NULL, 1);
		else
		{	a->_tds__GetDot11Capabilities::__any = NULL;
			if (soap_blist___any1)
				soap_end_block(soap, soap_blist___any1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDot11Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11Capabilities, 0, sizeof(_tds__GetDot11Capabilities), 0, soap_copy__tds__GetDot11Capabilities);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetDot11Capabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetDot11Capabilities);
	if (this->soap_out(soap, tag?tag:"tds:GetDot11Capabilities", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot11Capabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot11Capabilities(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot11Capabilities * SOAP_FMAC4 soap_get__tds__GetDot11Capabilities(struct soap *soap, _tds__GetDot11Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetDot11Capabilities * SOAP_FMAC2 soap_instantiate__tds__GetDot11Capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot11Capabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetDot11Capabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetDot11Capabilities);
		if (size)
			*size = sizeof(_tds__GetDot11Capabilities);
		((_tds__GetDot11Capabilities*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetDot11Capabilities, n);
		if (size)
			*size = n * sizeof(_tds__GetDot11Capabilities);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetDot11Capabilities*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetDot11Capabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetDot11Capabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetDot11Capabilities %p -> %p\n", q, p));
	*(_tds__GetDot11Capabilities*)p = *(_tds__GetDot11Capabilities*)q;
}

void _tds__SendAuxiliaryCommandResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__AuxiliaryData(soap, &this->_tds__SendAuxiliaryCommandResponse::AuxiliaryCommandResponse);
	/* transient soap skipped */
}

void _tds__SendAuxiliaryCommandResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_tt__AuxiliaryData(soap, &this->_tds__SendAuxiliaryCommandResponse::AuxiliaryCommandResponse);
	/* transient soap skipped */
#endif
}

int _tds__SendAuxiliaryCommandResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SendAuxiliaryCommandResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, const _tds__SendAuxiliaryCommandResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse), type))
		return soap->error;
	if (a->AuxiliaryCommandResponse)
		soap_element_result(soap, "tds:AuxiliaryCommandResponse");
	if (soap_out_tt__AuxiliaryData(soap, "tds:AuxiliaryCommandResponse", -1, &(a->_tds__SendAuxiliaryCommandResponse::AuxiliaryCommandResponse), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SendAuxiliaryCommandResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SendAuxiliaryCommandResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_in__tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, _tds__SendAuxiliaryCommandResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SendAuxiliaryCommandResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(_tds__SendAuxiliaryCommandResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SendAuxiliaryCommandResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SendAuxiliaryCommandResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AuxiliaryCommandResponse1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryCommandResponse1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__AuxiliaryData(soap, "tds:AuxiliaryCommandResponse", &(a->_tds__SendAuxiliaryCommandResponse::AuxiliaryCommandResponse), "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryCommandResponse1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:AuxiliaryCommandResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SendAuxiliaryCommandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, 0, sizeof(_tds__SendAuxiliaryCommandResponse), 0, soap_copy__tds__SendAuxiliaryCommandResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__SendAuxiliaryCommandResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SendAuxiliaryCommandResponse);
	if (this->soap_out(soap, tag?tag:"tds:SendAuxiliaryCommandResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SendAuxiliaryCommandResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SendAuxiliaryCommandResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_get__tds__SendAuxiliaryCommandResponse(struct soap *soap, _tds__SendAuxiliaryCommandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SendAuxiliaryCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SendAuxiliaryCommandResponse * SOAP_FMAC2 soap_instantiate__tds__SendAuxiliaryCommandResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SendAuxiliaryCommandResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SendAuxiliaryCommandResponse);
		if (size)
			*size = sizeof(_tds__SendAuxiliaryCommandResponse);
		((_tds__SendAuxiliaryCommandResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SendAuxiliaryCommandResponse, n);
		if (size)
			*size = n * sizeof(_tds__SendAuxiliaryCommandResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SendAuxiliaryCommandResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SendAuxiliaryCommandResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SendAuxiliaryCommandResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SendAuxiliaryCommandResponse %p -> %p\n", q, p));
	*(_tds__SendAuxiliaryCommandResponse*)p = *(_tds__SendAuxiliaryCommandResponse*)q;
}

void _tds__SendAuxiliaryCommand::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__AuxiliaryData(soap, &this->_tds__SendAuxiliaryCommand::AuxiliaryCommand);
	/* transient soap skipped */
}

void _tds__SendAuxiliaryCommand::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_tt__AuxiliaryData(soap, &this->_tds__SendAuxiliaryCommand::AuxiliaryCommand);
	/* transient soap skipped */
#endif
}

int _tds__SendAuxiliaryCommand::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SendAuxiliaryCommand(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, const _tds__SendAuxiliaryCommand *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SendAuxiliaryCommand), type))
		return soap->error;
	if (a->_tds__SendAuxiliaryCommand::AuxiliaryCommand)
	{	if (soap_out_tt__AuxiliaryData(soap, "tds:AuxiliaryCommand", -1, &a->_tds__SendAuxiliaryCommand::AuxiliaryCommand, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:AuxiliaryCommand"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SendAuxiliaryCommand::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SendAuxiliaryCommand(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_in__tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, _tds__SendAuxiliaryCommand *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SendAuxiliaryCommand *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(_tds__SendAuxiliaryCommand), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SendAuxiliaryCommand)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SendAuxiliaryCommand *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_AuxiliaryCommand1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryCommand1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__AuxiliaryData(soap, "tds:AuxiliaryCommand", &(a->_tds__SendAuxiliaryCommand::AuxiliaryCommand), "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryCommand1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SendAuxiliaryCommand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommand, 0, sizeof(_tds__SendAuxiliaryCommand), 0, soap_copy__tds__SendAuxiliaryCommand);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AuxiliaryCommand1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__SendAuxiliaryCommand::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SendAuxiliaryCommand);
	if (this->soap_out(soap, tag?tag:"tds:SendAuxiliaryCommand", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SendAuxiliaryCommand::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SendAuxiliaryCommand(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_get__tds__SendAuxiliaryCommand(struct soap *soap, _tds__SendAuxiliaryCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate__tds__SendAuxiliaryCommand(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SendAuxiliaryCommand(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SendAuxiliaryCommand, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SendAuxiliaryCommand);
		if (size)
			*size = sizeof(_tds__SendAuxiliaryCommand);
		((_tds__SendAuxiliaryCommand*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SendAuxiliaryCommand, n);
		if (size)
			*size = n * sizeof(_tds__SendAuxiliaryCommand);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SendAuxiliaryCommand*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SendAuxiliaryCommand*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SendAuxiliaryCommand(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SendAuxiliaryCommand %p -> %p\n", q, p));
	*(_tds__SendAuxiliaryCommand*)p = *(_tds__SendAuxiliaryCommand*)q;
}

void _tds__SetRelayOutputStateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__SetRelayOutputStateResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__SetRelayOutputStateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRelayOutputStateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, int id, const _tds__SetRelayOutputStateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputStateResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRelayOutputStateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetRelayOutputStateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_in__tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, _tds__SetRelayOutputStateResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRelayOutputStateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(_tds__SetRelayOutputStateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetRelayOutputStateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetRelayOutputStateResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetRelayOutputStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputStateResponse, 0, sizeof(_tds__SetRelayOutputStateResponse), 0, soap_copy__tds__SetRelayOutputStateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__SetRelayOutputStateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetRelayOutputStateResponse);
	if (this->soap_out(soap, tag?tag:"tds:SetRelayOutputStateResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRelayOutputStateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRelayOutputStateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_get__tds__SetRelayOutputStateResponse(struct soap *soap, _tds__SetRelayOutputStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetRelayOutputStateResponse * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputStateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRelayOutputStateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetRelayOutputStateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetRelayOutputStateResponse);
		if (size)
			*size = sizeof(_tds__SetRelayOutputStateResponse);
		((_tds__SetRelayOutputStateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetRelayOutputStateResponse, n);
		if (size)
			*size = n * sizeof(_tds__SetRelayOutputStateResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetRelayOutputStateResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetRelayOutputStateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetRelayOutputStateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetRelayOutputStateResponse %p -> %p\n", q, p));
	*(_tds__SetRelayOutputStateResponse*)p = *(_tds__SetRelayOutputStateResponse*)q;
}

void _tds__SetRelayOutputState::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__SetRelayOutputState::RelayOutputToken);
	soap_default_tt__RelayLogicalState(soap, &this->_tds__SetRelayOutputState::LogicalState);
	/* transient soap skipped */
}

void _tds__SetRelayOutputState::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__SetRelayOutputState::RelayOutputToken);
	/* transient soap skipped */
#endif
}

int _tds__SetRelayOutputState::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRelayOutputState(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputState(struct soap *soap, const char *tag, int id, const _tds__SetRelayOutputState *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputState), type))
		return soap->error;
	if (a->_tds__SetRelayOutputState::RelayOutputToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tds:RelayOutputToken", -1, &a->_tds__SetRelayOutputState::RelayOutputToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:RelayOutputToken"))
		return soap->error;
	if (soap_out_tt__RelayLogicalState(soap, "tds:LogicalState", -1, &(a->_tds__SetRelayOutputState::LogicalState), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRelayOutputState::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetRelayOutputState(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRelayOutputState * SOAP_FMAC4 soap_in__tds__SetRelayOutputState(struct soap *soap, const char *tag, _tds__SetRelayOutputState *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRelayOutputState *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputState, sizeof(_tds__SetRelayOutputState), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetRelayOutputState)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetRelayOutputState *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RelayOutputToken1 = 1;
	size_t soap_flag_LogicalState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutputToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:RelayOutputToken", &(a->_tds__SetRelayOutputState::RelayOutputToken), "tt:ReferenceToken"))
				{	soap_flag_RelayOutputToken1--;
					continue;
				}
			if (soap_flag_LogicalState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__RelayLogicalState(soap, "tds:LogicalState", &(a->_tds__SetRelayOutputState::LogicalState), "tt:RelayLogicalState"))
				{	soap_flag_LogicalState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetRelayOutputState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputState, 0, sizeof(_tds__SetRelayOutputState), 0, soap_copy__tds__SetRelayOutputState);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RelayOutputToken1 > 0 || soap_flag_LogicalState1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__SetRelayOutputState::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetRelayOutputState);
	if (this->soap_out(soap, tag?tag:"tds:SetRelayOutputState", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRelayOutputState::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRelayOutputState(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRelayOutputState * SOAP_FMAC4 soap_get__tds__SetRelayOutputState(struct soap *soap, _tds__SetRelayOutputState *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetRelayOutputState * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRelayOutputState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetRelayOutputState, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetRelayOutputState);
		if (size)
			*size = sizeof(_tds__SetRelayOutputState);
		((_tds__SetRelayOutputState*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetRelayOutputState, n);
		if (size)
			*size = n * sizeof(_tds__SetRelayOutputState);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetRelayOutputState*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetRelayOutputState*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetRelayOutputState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetRelayOutputState %p -> %p\n", q, p));
	*(_tds__SetRelayOutputState*)p = *(_tds__SetRelayOutputState*)q;
}

void _tds__SetRelayOutputSettingsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__SetRelayOutputSettingsResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__SetRelayOutputSettingsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRelayOutputSettingsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, int id, const _tds__SetRelayOutputSettingsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRelayOutputSettingsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetRelayOutputSettingsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_in__tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, _tds__SetRelayOutputSettingsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRelayOutputSettingsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(_tds__SetRelayOutputSettingsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetRelayOutputSettingsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetRelayOutputSettingsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetRelayOutputSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, 0, sizeof(_tds__SetRelayOutputSettingsResponse), 0, soap_copy__tds__SetRelayOutputSettingsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__SetRelayOutputSettingsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetRelayOutputSettingsResponse);
	if (this->soap_out(soap, tag?tag:"tds:SetRelayOutputSettingsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRelayOutputSettingsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRelayOutputSettingsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_get__tds__SetRelayOutputSettingsResponse(struct soap *soap, _tds__SetRelayOutputSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetRelayOutputSettingsResponse * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputSettingsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRelayOutputSettingsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetRelayOutputSettingsResponse);
		if (size)
			*size = sizeof(_tds__SetRelayOutputSettingsResponse);
		((_tds__SetRelayOutputSettingsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetRelayOutputSettingsResponse, n);
		if (size)
			*size = n * sizeof(_tds__SetRelayOutputSettingsResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetRelayOutputSettingsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetRelayOutputSettingsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetRelayOutputSettingsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetRelayOutputSettingsResponse %p -> %p\n", q, p));
	*(_tds__SetRelayOutputSettingsResponse*)p = *(_tds__SetRelayOutputSettingsResponse*)q;
}

void _tds__SetRelayOutputSettings::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__SetRelayOutputSettings::RelayOutputToken);
	this->_tds__SetRelayOutputSettings::Properties = NULL;
	/* transient soap skipped */
}

void _tds__SetRelayOutputSettings::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__SetRelayOutputSettings::RelayOutputToken);
	soap_serialize_PointerTott__RelayOutputSettings(soap, &this->_tds__SetRelayOutputSettings::Properties);
	/* transient soap skipped */
#endif
}

int _tds__SetRelayOutputSettings::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetRelayOutputSettings(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, const _tds__SetRelayOutputSettings *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputSettings), type))
		return soap->error;
	if (a->_tds__SetRelayOutputSettings::RelayOutputToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tds:RelayOutputToken", -1, &a->_tds__SetRelayOutputSettings::RelayOutputToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:RelayOutputToken"))
		return soap->error;
	if (a->_tds__SetRelayOutputSettings::Properties)
	{	if (soap_out_PointerTott__RelayOutputSettings(soap, "tds:Properties", -1, &a->_tds__SetRelayOutputSettings::Properties, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Properties"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetRelayOutputSettings::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetRelayOutputSettings(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_in__tds__SetRelayOutputSettings(struct soap *soap, const char *tag, _tds__SetRelayOutputSettings *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetRelayOutputSettings *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(_tds__SetRelayOutputSettings), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetRelayOutputSettings)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetRelayOutputSettings *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RelayOutputToken1 = 1;
	size_t soap_flag_Properties1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutputToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:RelayOutputToken", &(a->_tds__SetRelayOutputSettings::RelayOutputToken), "tt:ReferenceToken"))
				{	soap_flag_RelayOutputToken1--;
					continue;
				}
			if (soap_flag_Properties1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RelayOutputSettings(soap, "tds:Properties", &(a->_tds__SetRelayOutputSettings::Properties), "tt:RelayOutputSettings"))
				{	soap_flag_Properties1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetRelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettings, 0, sizeof(_tds__SetRelayOutputSettings), 0, soap_copy__tds__SetRelayOutputSettings);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RelayOutputToken1 > 0 || soap_flag_Properties1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__SetRelayOutputSettings::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetRelayOutputSettings);
	if (this->soap_out(soap, tag?tag:"tds:SetRelayOutputSettings", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetRelayOutputSettings::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetRelayOutputSettings(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_get__tds__SetRelayOutputSettings(struct soap *soap, _tds__SetRelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate__tds__SetRelayOutputSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetRelayOutputSettings(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetRelayOutputSettings, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetRelayOutputSettings);
		if (size)
			*size = sizeof(_tds__SetRelayOutputSettings);
		((_tds__SetRelayOutputSettings*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetRelayOutputSettings, n);
		if (size)
			*size = n * sizeof(_tds__SetRelayOutputSettings);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetRelayOutputSettings*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetRelayOutputSettings*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetRelayOutputSettings(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetRelayOutputSettings %p -> %p\n", q, p));
	*(_tds__SetRelayOutputSettings*)p = *(_tds__SetRelayOutputSettings*)q;
}

void _tds__GetRelayOutputsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetRelayOutputsResponse::__sizeRelayOutputs = 0;
	this->_tds__GetRelayOutputsResponse::RelayOutputs = NULL;
	/* transient soap skipped */
}

void _tds__GetRelayOutputsResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__GetRelayOutputsResponse::RelayOutputs)
	{	int i;
		for (i = 0; i < this->_tds__GetRelayOutputsResponse::__sizeRelayOutputs; i++)
		{
			soap_serialize_PointerTott__RelayOutput(soap, this->_tds__GetRelayOutputsResponse::RelayOutputs + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__GetRelayOutputsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetRelayOutputsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, int id, const _tds__GetRelayOutputsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRelayOutputsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeRelayOutputs");
	if (a->_tds__GetRelayOutputsResponse::RelayOutputs)
	{	int i;
		for (i = 0; i < a->_tds__GetRelayOutputsResponse::__sizeRelayOutputs; i++)
			if (soap_out_PointerTott__RelayOutput(soap, "tds:RelayOutputs", -1, a->_tds__GetRelayOutputsResponse::RelayOutputs + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetRelayOutputsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetRelayOutputsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_in__tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, _tds__GetRelayOutputsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetRelayOutputsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(_tds__GetRelayOutputsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetRelayOutputsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetRelayOutputsResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_RelayOutputs1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:RelayOutputs", 1, NULL))
			{	if (a->_tds__GetRelayOutputsResponse::RelayOutputs == NULL)
				{	if (soap_blist_RelayOutputs1 == NULL)
						soap_blist_RelayOutputs1 = soap_new_block(soap);
					a->_tds__GetRelayOutputsResponse::RelayOutputs = (tt__RelayOutput **)soap_push_block(soap, soap_blist_RelayOutputs1, sizeof(tt__RelayOutput *));
					if (a->_tds__GetRelayOutputsResponse::RelayOutputs == NULL)
						return NULL;
					*a->_tds__GetRelayOutputsResponse::RelayOutputs = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__RelayOutput(soap, "tds:RelayOutputs", a->_tds__GetRelayOutputsResponse::RelayOutputs, "tt:RelayOutput"))
				{	a->_tds__GetRelayOutputsResponse::__sizeRelayOutputs++;
					a->_tds__GetRelayOutputsResponse::RelayOutputs = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			soap_check_result(soap, "-sizeRelayOutputs");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__GetRelayOutputsResponse::RelayOutputs)
			soap_pop_block(soap, soap_blist_RelayOutputs1);
		if (a->_tds__GetRelayOutputsResponse::__sizeRelayOutputs)
			a->_tds__GetRelayOutputsResponse::RelayOutputs = (tt__RelayOutput **)soap_save_block(soap, soap_blist_RelayOutputs1, NULL, 1);
		else
		{	a->_tds__GetRelayOutputsResponse::RelayOutputs = NULL;
			if (soap_blist_RelayOutputs1)
				soap_end_block(soap, soap_blist_RelayOutputs1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetRelayOutputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputsResponse, 0, sizeof(_tds__GetRelayOutputsResponse), 0, soap_copy__tds__GetRelayOutputsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetRelayOutputsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetRelayOutputsResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetRelayOutputsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetRelayOutputsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetRelayOutputsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_get__tds__GetRelayOutputsResponse(struct soap *soap, _tds__GetRelayOutputsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRelayOutputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetRelayOutputsResponse * SOAP_FMAC2 soap_instantiate__tds__GetRelayOutputsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetRelayOutputsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetRelayOutputsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetRelayOutputsResponse);
		if (size)
			*size = sizeof(_tds__GetRelayOutputsResponse);
		((_tds__GetRelayOutputsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetRelayOutputsResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetRelayOutputsResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetRelayOutputsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetRelayOutputsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetRelayOutputsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetRelayOutputsResponse %p -> %p\n", q, p));
	*(_tds__GetRelayOutputsResponse*)p = *(_tds__GetRelayOutputsResponse*)q;
}

void _tds__GetRelayOutputs::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__GetRelayOutputs::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__GetRelayOutputs::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetRelayOutputs(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRelayOutputs(struct soap *soap, const char *tag, int id, const _tds__GetRelayOutputs *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRelayOutputs), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetRelayOutputs::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetRelayOutputs(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetRelayOutputs * SOAP_FMAC4 soap_in__tds__GetRelayOutputs(struct soap *soap, const char *tag, _tds__GetRelayOutputs *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetRelayOutputs *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputs, sizeof(_tds__GetRelayOutputs), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetRelayOutputs)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetRelayOutputs *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetRelayOutputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputs, 0, sizeof(_tds__GetRelayOutputs), 0, soap_copy__tds__GetRelayOutputs);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetRelayOutputs::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetRelayOutputs);
	if (this->soap_out(soap, tag?tag:"tds:GetRelayOutputs", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetRelayOutputs::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetRelayOutputs(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetRelayOutputs * SOAP_FMAC4 soap_get__tds__GetRelayOutputs(struct soap *soap, _tds__GetRelayOutputs *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRelayOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetRelayOutputs * SOAP_FMAC2 soap_instantiate__tds__GetRelayOutputs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetRelayOutputs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetRelayOutputs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetRelayOutputs);
		if (size)
			*size = sizeof(_tds__GetRelayOutputs);
		((_tds__GetRelayOutputs*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetRelayOutputs, n);
		if (size)
			*size = n * sizeof(_tds__GetRelayOutputs);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetRelayOutputs*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetRelayOutputs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetRelayOutputs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetRelayOutputs %p -> %p\n", q, p));
	*(_tds__GetRelayOutputs*)p = *(_tds__GetRelayOutputs*)q;
}

void _tds__DeleteDot1XConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__DeleteDot1XConfigurationResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__DeleteDot1XConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteDot1XConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__DeleteDot1XConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteDot1XConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__DeleteDot1XConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__DeleteDot1XConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteDot1XConfigurationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, sizeof(_tds__DeleteDot1XConfigurationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__DeleteDot1XConfigurationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__DeleteDot1XConfigurationResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, 0, sizeof(_tds__DeleteDot1XConfigurationResponse), 0, soap_copy__tds__DeleteDot1XConfigurationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__DeleteDot1XConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse);
	if (this->soap_out(soap, tag?tag:"tds:DeleteDot1XConfigurationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteDot1XConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteDot1XConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__DeleteDot1XConfigurationResponse(struct soap *soap, _tds__DeleteDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteDot1XConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteDot1XConfigurationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__DeleteDot1XConfigurationResponse);
		if (size)
			*size = sizeof(_tds__DeleteDot1XConfigurationResponse);
		((_tds__DeleteDot1XConfigurationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__DeleteDot1XConfigurationResponse, n);
		if (size)
			*size = n * sizeof(_tds__DeleteDot1XConfigurationResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__DeleteDot1XConfigurationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__DeleteDot1XConfigurationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__DeleteDot1XConfigurationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__DeleteDot1XConfigurationResponse %p -> %p\n", q, p));
	*(_tds__DeleteDot1XConfigurationResponse*)p = *(_tds__DeleteDot1XConfigurationResponse*)q;
}

void _tds__DeleteDot1XConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__DeleteDot1XConfiguration::__sizeDot1XConfigurationToken = 0;
	this->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken = NULL;
	/* transient soap skipped */
}

void _tds__DeleteDot1XConfiguration::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken)
	{	int i;
		for (i = 0; i < this->_tds__DeleteDot1XConfiguration::__sizeDot1XConfigurationToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, this->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__DeleteDot1XConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteDot1XConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, int id, const _tds__DeleteDot1XConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteDot1XConfiguration), type))
		return soap->error;
	if (a->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken)
	{	int i;
		for (i = 0; i < a->_tds__DeleteDot1XConfiguration::__sizeDot1XConfigurationToken; i++)
			if (soap_out_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", -1, a->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteDot1XConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__DeleteDot1XConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_in__tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, _tds__DeleteDot1XConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteDot1XConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(_tds__DeleteDot1XConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__DeleteDot1XConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__DeleteDot1XConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_Dot1XConfigurationToken1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Dot1XConfigurationToken", 1, NULL))
			{	if (a->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken == NULL)
				{	if (soap_blist_Dot1XConfigurationToken1 == NULL)
						soap_blist_Dot1XConfigurationToken1 = soap_new_block(soap);
					a->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken = (char **)soap_push_block(soap, soap_blist_Dot1XConfigurationToken1, sizeof(char *));
					if (a->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken == NULL)
						return NULL;
					*a->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", a->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken, "tt:ReferenceToken"))
				{	a->_tds__DeleteDot1XConfiguration::__sizeDot1XConfigurationToken++;
					a->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken)
			soap_pop_block(soap, soap_blist_Dot1XConfigurationToken1);
		if (a->_tds__DeleteDot1XConfiguration::__sizeDot1XConfigurationToken)
			a->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken = (char **)soap_save_block(soap, soap_blist_Dot1XConfigurationToken1, NULL, 1);
		else
		{	a->_tds__DeleteDot1XConfiguration::Dot1XConfigurationToken = NULL;
			if (soap_blist_Dot1XConfigurationToken1)
				soap_end_block(soap, soap_blist_Dot1XConfigurationToken1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteDot1XConfiguration, 0, sizeof(_tds__DeleteDot1XConfiguration), 0, soap_copy__tds__DeleteDot1XConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__DeleteDot1XConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__DeleteDot1XConfiguration);
	if (this->soap_out(soap, tag?tag:"tds:DeleteDot1XConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteDot1XConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteDot1XConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_get__tds__DeleteDot1XConfiguration(struct soap *soap, _tds__DeleteDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__DeleteDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteDot1XConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__DeleteDot1XConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__DeleteDot1XConfiguration);
		if (size)
			*size = sizeof(_tds__DeleteDot1XConfiguration);
		((_tds__DeleteDot1XConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__DeleteDot1XConfiguration, n);
		if (size)
			*size = n * sizeof(_tds__DeleteDot1XConfiguration);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__DeleteDot1XConfiguration*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__DeleteDot1XConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__DeleteDot1XConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__DeleteDot1XConfiguration %p -> %p\n", q, p));
	*(_tds__DeleteDot1XConfiguration*)p = *(_tds__DeleteDot1XConfiguration*)q;
}

void _tds__GetDot1XConfigurationsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDot1XConfigurationsResponse::__sizeDot1XConfiguration = 0;
	this->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration = NULL;
	/* transient soap skipped */
}

void _tds__GetDot1XConfigurationsResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration)
	{	int i;
		for (i = 0; i < this->_tds__GetDot1XConfigurationsResponse::__sizeDot1XConfiguration; i++)
		{
			soap_serialize_PointerTott__Dot1XConfiguration(soap, this->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__GetDot1XConfigurationsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot1XConfigurationsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, int id, const _tds__GetDot1XConfigurationsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeDot1XConfiguration");
	if (a->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration)
	{	int i;
		for (i = 0; i < a->_tds__GetDot1XConfigurationsResponse::__sizeDot1XConfiguration; i++)
			if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, a->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot1XConfigurationsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetDot1XConfigurationsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationsResponse * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, _tds__GetDot1XConfigurationsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot1XConfigurationsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, sizeof(_tds__GetDot1XConfigurationsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetDot1XConfigurationsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetDot1XConfigurationsResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_Dot1XConfiguration1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Dot1XConfiguration", 1, NULL))
			{	if (a->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration == NULL)
				{	if (soap_blist_Dot1XConfiguration1 == NULL)
						soap_blist_Dot1XConfiguration1 = soap_new_block(soap);
					a->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration = (tt__Dot1XConfiguration **)soap_push_block(soap, soap_blist_Dot1XConfiguration1, sizeof(tt__Dot1XConfiguration *));
					if (a->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration == NULL)
						return NULL;
					*a->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", a->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	a->_tds__GetDot1XConfigurationsResponse::__sizeDot1XConfiguration++;
					a->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			soap_check_result(soap, "-sizeDot1XConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration)
			soap_pop_block(soap, soap_blist_Dot1XConfiguration1);
		if (a->_tds__GetDot1XConfigurationsResponse::__sizeDot1XConfiguration)
			a->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration = (tt__Dot1XConfiguration **)soap_save_block(soap, soap_blist_Dot1XConfiguration1, NULL, 1);
		else
		{	a->_tds__GetDot1XConfigurationsResponse::Dot1XConfiguration = NULL;
			if (soap_blist_Dot1XConfiguration1)
				soap_end_block(soap, soap_blist_Dot1XConfiguration1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDot1XConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, 0, sizeof(_tds__GetDot1XConfigurationsResponse), 0, soap_copy__tds__GetDot1XConfigurationsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetDot1XConfigurationsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetDot1XConfigurationsResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetDot1XConfigurationsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot1XConfigurationsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot1XConfigurationsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationsResponse * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurationsResponse(struct soap *soap, _tds__GetDot1XConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetDot1XConfigurationsResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurationsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot1XConfigurationsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetDot1XConfigurationsResponse);
		if (size)
			*size = sizeof(_tds__GetDot1XConfigurationsResponse);
		((_tds__GetDot1XConfigurationsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetDot1XConfigurationsResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetDot1XConfigurationsResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetDot1XConfigurationsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetDot1XConfigurationsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetDot1XConfigurationsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetDot1XConfigurationsResponse %p -> %p\n", q, p));
	*(_tds__GetDot1XConfigurationsResponse*)p = *(_tds__GetDot1XConfigurationsResponse*)q;
}

void _tds__GetDot1XConfigurations::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__GetDot1XConfigurations::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__GetDot1XConfigurations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot1XConfigurations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurations(struct soap *soap, const char *tag, int id, const _tds__GetDot1XConfigurations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurations), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot1XConfigurations::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetDot1XConfigurations(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurations * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurations(struct soap *soap, const char *tag, _tds__GetDot1XConfigurations *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot1XConfigurations *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurations, sizeof(_tds__GetDot1XConfigurations), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetDot1XConfigurations)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetDot1XConfigurations *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDot1XConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurations, 0, sizeof(_tds__GetDot1XConfigurations), 0, soap_copy__tds__GetDot1XConfigurations);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetDot1XConfigurations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetDot1XConfigurations);
	if (this->soap_out(soap, tag?tag:"tds:GetDot1XConfigurations", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot1XConfigurations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot1XConfigurations(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurations * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurations(struct soap *soap, _tds__GetDot1XConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetDot1XConfigurations * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot1XConfigurations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetDot1XConfigurations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetDot1XConfigurations);
		if (size)
			*size = sizeof(_tds__GetDot1XConfigurations);
		((_tds__GetDot1XConfigurations*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetDot1XConfigurations, n);
		if (size)
			*size = n * sizeof(_tds__GetDot1XConfigurations);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetDot1XConfigurations*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetDot1XConfigurations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetDot1XConfigurations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetDot1XConfigurations %p -> %p\n", q, p));
	*(_tds__GetDot1XConfigurations*)p = *(_tds__GetDot1XConfigurations*)q;
}

void _tds__GetDot1XConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration = NULL;
	/* transient soap skipped */
}

void _tds__GetDot1XConfigurationResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &this->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration);
	/* transient soap skipped */
#endif
}

int _tds__GetDot1XConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot1XConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__GetDot1XConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurationResponse), type))
		return soap->error;
	if (a->Dot1XConfiguration)
		soap_element_result(soap, "tds:Dot1XConfiguration");
	if (a->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration)
	{	if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Dot1XConfiguration"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot1XConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetDot1XConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__GetDot1XConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot1XConfigurationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurationResponse, sizeof(_tds__GetDot1XConfigurationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetDot1XConfigurationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetDot1XConfigurationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Dot1XConfiguration1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &(a->_tds__GetDot1XConfigurationResponse::Dot1XConfiguration), "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:Dot1XConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurationResponse, 0, sizeof(_tds__GetDot1XConfigurationResponse), 0, soap_copy__tds__GetDot1XConfigurationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1XConfiguration1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetDot1XConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetDot1XConfigurationResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetDot1XConfigurationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot1XConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot1XConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurationResponse(struct soap *soap, _tds__GetDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot1XConfigurationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetDot1XConfigurationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetDot1XConfigurationResponse);
		if (size)
			*size = sizeof(_tds__GetDot1XConfigurationResponse);
		((_tds__GetDot1XConfigurationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetDot1XConfigurationResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetDot1XConfigurationResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetDot1XConfigurationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetDot1XConfigurationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetDot1XConfigurationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetDot1XConfigurationResponse %p -> %p\n", q, p));
	*(_tds__GetDot1XConfigurationResponse*)p = *(_tds__GetDot1XConfigurationResponse*)q;
}

void _tds__GetDot1XConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__GetDot1XConfiguration::Dot1XConfigurationToken);
	/* transient soap skipped */
}

void _tds__GetDot1XConfiguration::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__GetDot1XConfiguration::Dot1XConfigurationToken);
	/* transient soap skipped */
#endif
}

int _tds__GetDot1XConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDot1XConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfiguration(struct soap *soap, const char *tag, int id, const _tds__GetDot1XConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfiguration), type))
		return soap->error;
	if (a->_tds__GetDot1XConfiguration::Dot1XConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", -1, &a->_tds__GetDot1XConfiguration::Dot1XConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Dot1XConfigurationToken"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDot1XConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetDot1XConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDot1XConfiguration * SOAP_FMAC4 soap_in__tds__GetDot1XConfiguration(struct soap *soap, const char *tag, _tds__GetDot1XConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDot1XConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfiguration, sizeof(_tds__GetDot1XConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetDot1XConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetDot1XConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Dot1XConfigurationToken1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfigurationToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", &(a->_tds__GetDot1XConfiguration::Dot1XConfigurationToken), "tt:ReferenceToken"))
				{	soap_flag_Dot1XConfigurationToken1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfiguration, 0, sizeof(_tds__GetDot1XConfiguration), 0, soap_copy__tds__GetDot1XConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1XConfigurationToken1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetDot1XConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetDot1XConfiguration);
	if (this->soap_out(soap, tag?tag:"tds:GetDot1XConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDot1XConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDot1XConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDot1XConfiguration * SOAP_FMAC4 soap_get__tds__GetDot1XConfiguration(struct soap *soap, _tds__GetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDot1XConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetDot1XConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetDot1XConfiguration);
		if (size)
			*size = sizeof(_tds__GetDot1XConfiguration);
		((_tds__GetDot1XConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetDot1XConfiguration, n);
		if (size)
			*size = n * sizeof(_tds__GetDot1XConfiguration);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetDot1XConfiguration*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetDot1XConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetDot1XConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetDot1XConfiguration %p -> %p\n", q, p));
	*(_tds__GetDot1XConfiguration*)p = *(_tds__GetDot1XConfiguration*)q;
}

void _tds__SetDot1XConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__SetDot1XConfigurationResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__SetDot1XConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDot1XConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__SetDot1XConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDot1XConfigurationResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDot1XConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetDot1XConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__SetDot1XConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDot1XConfigurationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDot1XConfigurationResponse, sizeof(_tds__SetDot1XConfigurationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetDot1XConfigurationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetDot1XConfigurationResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDot1XConfigurationResponse, 0, sizeof(_tds__SetDot1XConfigurationResponse), 0, soap_copy__tds__SetDot1XConfigurationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__SetDot1XConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetDot1XConfigurationResponse);
	if (this->soap_out(soap, tag?tag:"tds:SetDot1XConfigurationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDot1XConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDot1XConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetDot1XConfigurationResponse(struct soap *soap, _tds__SetDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetDot1XConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDot1XConfigurationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetDot1XConfigurationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetDot1XConfigurationResponse);
		if (size)
			*size = sizeof(_tds__SetDot1XConfigurationResponse);
		((_tds__SetDot1XConfigurationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetDot1XConfigurationResponse, n);
		if (size)
			*size = n * sizeof(_tds__SetDot1XConfigurationResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetDot1XConfigurationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetDot1XConfigurationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetDot1XConfigurationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetDot1XConfigurationResponse %p -> %p\n", q, p));
	*(_tds__SetDot1XConfigurationResponse*)p = *(_tds__SetDot1XConfigurationResponse*)q;
}

void _tds__SetDot1XConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetDot1XConfiguration::Dot1XConfiguration = NULL;
	/* transient soap skipped */
}

void _tds__SetDot1XConfiguration::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &this->_tds__SetDot1XConfiguration::Dot1XConfiguration);
	/* transient soap skipped */
#endif
}

int _tds__SetDot1XConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDot1XConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDot1XConfiguration(struct soap *soap, const char *tag, int id, const _tds__SetDot1XConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDot1XConfiguration), type))
		return soap->error;
	if (a->_tds__SetDot1XConfiguration::Dot1XConfiguration)
	{	if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->_tds__SetDot1XConfiguration::Dot1XConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Dot1XConfiguration"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDot1XConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetDot1XConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDot1XConfiguration * SOAP_FMAC4 soap_in__tds__SetDot1XConfiguration(struct soap *soap, const char *tag, _tds__SetDot1XConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDot1XConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDot1XConfiguration, sizeof(_tds__SetDot1XConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetDot1XConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetDot1XConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Dot1XConfiguration1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &(a->_tds__SetDot1XConfiguration::Dot1XConfiguration), "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDot1XConfiguration, 0, sizeof(_tds__SetDot1XConfiguration), 0, soap_copy__tds__SetDot1XConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1XConfiguration1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__SetDot1XConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetDot1XConfiguration);
	if (this->soap_out(soap, tag?tag:"tds:SetDot1XConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDot1XConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDot1XConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDot1XConfiguration * SOAP_FMAC4 soap_get__tds__SetDot1XConfiguration(struct soap *soap, _tds__SetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDot1XConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetDot1XConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetDot1XConfiguration);
		if (size)
			*size = sizeof(_tds__SetDot1XConfiguration);
		((_tds__SetDot1XConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetDot1XConfiguration, n);
		if (size)
			*size = n * sizeof(_tds__SetDot1XConfiguration);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetDot1XConfiguration*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetDot1XConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetDot1XConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetDot1XConfiguration %p -> %p\n", q, p));
	*(_tds__SetDot1XConfiguration*)p = *(_tds__SetDot1XConfiguration*)q;
}

void _tds__CreateDot1XConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__CreateDot1XConfigurationResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__CreateDot1XConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateDot1XConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__CreateDot1XConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateDot1XConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__CreateDot1XConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, _tds__CreateDot1XConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateDot1XConfigurationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, sizeof(_tds__CreateDot1XConfigurationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__CreateDot1XConfigurationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__CreateDot1XConfigurationResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__CreateDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, 0, sizeof(_tds__CreateDot1XConfigurationResponse), 0, soap_copy__tds__CreateDot1XConfigurationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__CreateDot1XConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__CreateDot1XConfigurationResponse);
	if (this->soap_out(soap, tag?tag:"tds:CreateDot1XConfigurationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateDot1XConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateDot1XConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__CreateDot1XConfigurationResponse(struct soap *soap, _tds__CreateDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__CreateDot1XConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__CreateDot1XConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateDot1XConfigurationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__CreateDot1XConfigurationResponse);
		if (size)
			*size = sizeof(_tds__CreateDot1XConfigurationResponse);
		((_tds__CreateDot1XConfigurationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__CreateDot1XConfigurationResponse, n);
		if (size)
			*size = n * sizeof(_tds__CreateDot1XConfigurationResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__CreateDot1XConfigurationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__CreateDot1XConfigurationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__CreateDot1XConfigurationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__CreateDot1XConfigurationResponse %p -> %p\n", q, p));
	*(_tds__CreateDot1XConfigurationResponse*)p = *(_tds__CreateDot1XConfigurationResponse*)q;
}

void _tds__CreateDot1XConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__CreateDot1XConfiguration::Dot1XConfiguration = NULL;
	/* transient soap skipped */
}

void _tds__CreateDot1XConfiguration::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &this->_tds__CreateDot1XConfiguration::Dot1XConfiguration);
	/* transient soap skipped */
#endif
}

int _tds__CreateDot1XConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateDot1XConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, int id, const _tds__CreateDot1XConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateDot1XConfiguration), type))
		return soap->error;
	if (a->_tds__CreateDot1XConfiguration::Dot1XConfiguration)
	{	if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->_tds__CreateDot1XConfiguration::Dot1XConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Dot1XConfiguration"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateDot1XConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__CreateDot1XConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_in__tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, _tds__CreateDot1XConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateDot1XConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateDot1XConfiguration, sizeof(_tds__CreateDot1XConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__CreateDot1XConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__CreateDot1XConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Dot1XConfiguration1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &(a->_tds__CreateDot1XConfiguration::Dot1XConfiguration), "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__CreateDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateDot1XConfiguration, 0, sizeof(_tds__CreateDot1XConfiguration), 0, soap_copy__tds__CreateDot1XConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1XConfiguration1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__CreateDot1XConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__CreateDot1XConfiguration);
	if (this->soap_out(soap, tag?tag:"tds:CreateDot1XConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateDot1XConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateDot1XConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_get__tds__CreateDot1XConfiguration(struct soap *soap, _tds__CreateDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__CreateDot1XConfiguration * SOAP_FMAC2 soap_instantiate__tds__CreateDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateDot1XConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__CreateDot1XConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__CreateDot1XConfiguration);
		if (size)
			*size = sizeof(_tds__CreateDot1XConfiguration);
		((_tds__CreateDot1XConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__CreateDot1XConfiguration, n);
		if (size)
			*size = n * sizeof(_tds__CreateDot1XConfiguration);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__CreateDot1XConfiguration*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__CreateDot1XConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__CreateDot1XConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__CreateDot1XConfiguration %p -> %p\n", q, p));
	*(_tds__CreateDot1XConfiguration*)p = *(_tds__CreateDot1XConfiguration*)q;
}

void _tds__LoadCACertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__LoadCACertificatesResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__LoadCACertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCACertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__LoadCACertificatesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCACertificatesResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCACertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__LoadCACertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCACertificatesResponse * SOAP_FMAC4 soap_in__tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, _tds__LoadCACertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCACertificatesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCACertificatesResponse, sizeof(_tds__LoadCACertificatesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__LoadCACertificatesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__LoadCACertificatesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__LoadCACertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCACertificatesResponse, 0, sizeof(_tds__LoadCACertificatesResponse), 0, soap_copy__tds__LoadCACertificatesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__LoadCACertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__LoadCACertificatesResponse);
	if (this->soap_out(soap, tag?tag:"tds:LoadCACertificatesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCACertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCACertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCACertificatesResponse * SOAP_FMAC4 soap_get__tds__LoadCACertificatesResponse(struct soap *soap, _tds__LoadCACertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__LoadCACertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCACertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCACertificatesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__LoadCACertificatesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__LoadCACertificatesResponse);
		if (size)
			*size = sizeof(_tds__LoadCACertificatesResponse);
		((_tds__LoadCACertificatesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__LoadCACertificatesResponse, n);
		if (size)
			*size = n * sizeof(_tds__LoadCACertificatesResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__LoadCACertificatesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__LoadCACertificatesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__LoadCACertificatesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__LoadCACertificatesResponse %p -> %p\n", q, p));
	*(_tds__LoadCACertificatesResponse*)p = *(_tds__LoadCACertificatesResponse*)q;
}

void _tds__LoadCACertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__LoadCACertificates::__sizeCACertificate = 0;
	this->_tds__LoadCACertificates::CACertificate = NULL;
	/* transient soap skipped */
}

void _tds__LoadCACertificates::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__LoadCACertificates::CACertificate)
	{	int i;
		for (i = 0; i < this->_tds__LoadCACertificates::__sizeCACertificate; i++)
		{
			soap_serialize_PointerTott__Certificate(soap, this->_tds__LoadCACertificates::CACertificate + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__LoadCACertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCACertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCACertificates(struct soap *soap, const char *tag, int id, const _tds__LoadCACertificates *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCACertificates), type))
		return soap->error;
	if (a->_tds__LoadCACertificates::CACertificate)
	{	int i;
		for (i = 0; i < a->_tds__LoadCACertificates::__sizeCACertificate; i++)
			if (soap_out_PointerTott__Certificate(soap, "tds:CACertificate", -1, a->_tds__LoadCACertificates::CACertificate + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCACertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__LoadCACertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCACertificates * SOAP_FMAC4 soap_in__tds__LoadCACertificates(struct soap *soap, const char *tag, _tds__LoadCACertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCACertificates *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCACertificates, sizeof(_tds__LoadCACertificates), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__LoadCACertificates)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__LoadCACertificates *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_CACertificate1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CACertificate", 1, NULL))
			{	if (a->_tds__LoadCACertificates::CACertificate == NULL)
				{	if (soap_blist_CACertificate1 == NULL)
						soap_blist_CACertificate1 = soap_new_block(soap);
					a->_tds__LoadCACertificates::CACertificate = (tt__Certificate **)soap_push_block(soap, soap_blist_CACertificate1, sizeof(tt__Certificate *));
					if (a->_tds__LoadCACertificates::CACertificate == NULL)
						return NULL;
					*a->_tds__LoadCACertificates::CACertificate = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__Certificate(soap, "tds:CACertificate", a->_tds__LoadCACertificates::CACertificate, "tt:Certificate"))
				{	a->_tds__LoadCACertificates::__sizeCACertificate++;
					a->_tds__LoadCACertificates::CACertificate = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__LoadCACertificates::CACertificate)
			soap_pop_block(soap, soap_blist_CACertificate1);
		if (a->_tds__LoadCACertificates::__sizeCACertificate)
			a->_tds__LoadCACertificates::CACertificate = (tt__Certificate **)soap_save_block(soap, soap_blist_CACertificate1, NULL, 1);
		else
		{	a->_tds__LoadCACertificates::CACertificate = NULL;
			if (soap_blist_CACertificate1)
				soap_end_block(soap, soap_blist_CACertificate1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__LoadCACertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCACertificates, 0, sizeof(_tds__LoadCACertificates), 0, soap_copy__tds__LoadCACertificates);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__LoadCACertificates::__sizeCACertificate < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__LoadCACertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__LoadCACertificates);
	if (this->soap_out(soap, tag?tag:"tds:LoadCACertificates", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCACertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCACertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCACertificates * SOAP_FMAC4 soap_get__tds__LoadCACertificates(struct soap *soap, _tds__LoadCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__LoadCACertificates * SOAP_FMAC2 soap_instantiate__tds__LoadCACertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCACertificates(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__LoadCACertificates, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__LoadCACertificates);
		if (size)
			*size = sizeof(_tds__LoadCACertificates);
		((_tds__LoadCACertificates*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__LoadCACertificates, n);
		if (size)
			*size = n * sizeof(_tds__LoadCACertificates);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__LoadCACertificates*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__LoadCACertificates*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__LoadCACertificates(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__LoadCACertificates %p -> %p\n", q, p));
	*(_tds__LoadCACertificates*)p = *(_tds__LoadCACertificates*)q;
}

void _tds__GetCertificateInformationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetCertificateInformationResponse::CertificateInformation = NULL;
	/* transient soap skipped */
}

void _tds__GetCertificateInformationResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__CertificateInformation(soap, &this->_tds__GetCertificateInformationResponse::CertificateInformation);
	/* transient soap skipped */
#endif
}

int _tds__GetCertificateInformationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificateInformationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, int id, const _tds__GetCertificateInformationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificateInformationResponse), type))
		return soap->error;
	if (a->CertificateInformation)
		soap_element_result(soap, "tds:CertificateInformation");
	if (a->_tds__GetCertificateInformationResponse::CertificateInformation)
	{	if (soap_out_PointerTott__CertificateInformation(soap, "tds:CertificateInformation", -1, &a->_tds__GetCertificateInformationResponse::CertificateInformation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:CertificateInformation"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificateInformationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetCertificateInformationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificateInformationResponse * SOAP_FMAC4 soap_in__tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, _tds__GetCertificateInformationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificateInformationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificateInformationResponse, sizeof(_tds__GetCertificateInformationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetCertificateInformationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetCertificateInformationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CertificateInformation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateInformation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__CertificateInformation(soap, "tds:CertificateInformation", &(a->_tds__GetCertificateInformationResponse::CertificateInformation), "tt:CertificateInformation"))
				{	soap_flag_CertificateInformation1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:CertificateInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCertificateInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificateInformationResponse, 0, sizeof(_tds__GetCertificateInformationResponse), 0, soap_copy__tds__GetCertificateInformationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateInformation1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetCertificateInformationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetCertificateInformationResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetCertificateInformationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificateInformationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificateInformationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificateInformationResponse * SOAP_FMAC4 soap_get__tds__GetCertificateInformationResponse(struct soap *soap, _tds__GetCertificateInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificateInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetCertificateInformationResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificateInformationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificateInformationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetCertificateInformationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetCertificateInformationResponse);
		if (size)
			*size = sizeof(_tds__GetCertificateInformationResponse);
		((_tds__GetCertificateInformationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetCertificateInformationResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetCertificateInformationResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetCertificateInformationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetCertificateInformationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetCertificateInformationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetCertificateInformationResponse %p -> %p\n", q, p));
	*(_tds__GetCertificateInformationResponse*)p = *(_tds__GetCertificateInformationResponse*)q;
}

void _tds__GetCertificateInformation::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->_tds__GetCertificateInformation::CertificateID);
	/* transient soap skipped */
}

void _tds__GetCertificateInformation::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &this->_tds__GetCertificateInformation::CertificateID);
	/* transient soap skipped */
#endif
}

int _tds__GetCertificateInformation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificateInformation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificateInformation(struct soap *soap, const char *tag, int id, const _tds__GetCertificateInformation *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificateInformation), type))
		return soap->error;
	if (a->_tds__GetCertificateInformation::CertificateID)
	{	if (soap_out_xsd__token(soap, "tds:CertificateID", -1, &a->_tds__GetCertificateInformation::CertificateID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:CertificateID"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificateInformation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetCertificateInformation(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificateInformation * SOAP_FMAC4 soap_in__tds__GetCertificateInformation(struct soap *soap, const char *tag, _tds__GetCertificateInformation *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificateInformation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificateInformation, sizeof(_tds__GetCertificateInformation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetCertificateInformation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetCertificateInformation *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CertificateID1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tds:CertificateID", &(a->_tds__GetCertificateInformation::CertificateID), "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCertificateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificateInformation, 0, sizeof(_tds__GetCertificateInformation), 0, soap_copy__tds__GetCertificateInformation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetCertificateInformation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetCertificateInformation);
	if (this->soap_out(soap, tag?tag:"tds:GetCertificateInformation", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificateInformation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificateInformation(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificateInformation * SOAP_FMAC4 soap_get__tds__GetCertificateInformation(struct soap *soap, _tds__GetCertificateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetCertificateInformation * SOAP_FMAC2 soap_instantiate__tds__GetCertificateInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificateInformation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetCertificateInformation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetCertificateInformation);
		if (size)
			*size = sizeof(_tds__GetCertificateInformation);
		((_tds__GetCertificateInformation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetCertificateInformation, n);
		if (size)
			*size = n * sizeof(_tds__GetCertificateInformation);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetCertificateInformation*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetCertificateInformation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetCertificateInformation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetCertificateInformation %p -> %p\n", q, p));
	*(_tds__GetCertificateInformation*)p = *(_tds__GetCertificateInformation*)q;
}

void _tds__LoadCertificateWithPrivateKeyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__LoadCertificateWithPrivateKeyResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__LoadCertificateWithPrivateKeyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCertificateWithPrivateKeyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, int id, const _tds__LoadCertificateWithPrivateKeyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCertificateWithPrivateKeyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__LoadCertificateWithPrivateKeyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC4 soap_in__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, _tds__LoadCertificateWithPrivateKeyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCertificateWithPrivateKeyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, sizeof(_tds__LoadCertificateWithPrivateKeyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__LoadCertificateWithPrivateKeyResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__LoadCertificateWithPrivateKeyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, 0, sizeof(_tds__LoadCertificateWithPrivateKeyResponse), 0, soap_copy__tds__LoadCertificateWithPrivateKeyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__LoadCertificateWithPrivateKeyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse);
	if (this->soap_out(soap, tag?tag:"tds:LoadCertificateWithPrivateKeyResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCertificateWithPrivateKeyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCertificateWithPrivateKeyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC4 soap_get__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, _tds__LoadCertificateWithPrivateKeyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificateWithPrivateKeyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCertificateWithPrivateKeyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__LoadCertificateWithPrivateKeyResponse);
		if (size)
			*size = sizeof(_tds__LoadCertificateWithPrivateKeyResponse);
		((_tds__LoadCertificateWithPrivateKeyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__LoadCertificateWithPrivateKeyResponse, n);
		if (size)
			*size = n * sizeof(_tds__LoadCertificateWithPrivateKeyResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__LoadCertificateWithPrivateKeyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__LoadCertificateWithPrivateKeyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__LoadCertificateWithPrivateKeyResponse %p -> %p\n", q, p));
	*(_tds__LoadCertificateWithPrivateKeyResponse*)p = *(_tds__LoadCertificateWithPrivateKeyResponse*)q;
}

void _tds__LoadCertificateWithPrivateKey::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__LoadCertificateWithPrivateKey::__sizeCertificateWithPrivateKey = 0;
	this->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey = NULL;
	/* transient soap skipped */
}

void _tds__LoadCertificateWithPrivateKey::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey)
	{	int i;
		for (i = 0; i < this->_tds__LoadCertificateWithPrivateKey::__sizeCertificateWithPrivateKey; i++)
		{
			soap_serialize_PointerTott__CertificateWithPrivateKey(soap, this->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__LoadCertificateWithPrivateKey::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCertificateWithPrivateKey(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const _tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey), type))
		return soap->error;
	if (a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey)
	{	int i;
		for (i = 0; i < a->_tds__LoadCertificateWithPrivateKey::__sizeCertificateWithPrivateKey; i++)
			if (soap_out_PointerTott__CertificateWithPrivateKey(soap, "tds:CertificateWithPrivateKey", -1, a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCertificateWithPrivateKey::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__LoadCertificateWithPrivateKey(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_in__tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, _tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCertificateWithPrivateKey *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, sizeof(_tds__LoadCertificateWithPrivateKey), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__LoadCertificateWithPrivateKey)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__LoadCertificateWithPrivateKey *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_CertificateWithPrivateKey1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateWithPrivateKey", 1, NULL))
			{	if (a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey == NULL)
				{	if (soap_blist_CertificateWithPrivateKey1 == NULL)
						soap_blist_CertificateWithPrivateKey1 = soap_new_block(soap);
					a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey = (tt__CertificateWithPrivateKey **)soap_push_block(soap, soap_blist_CertificateWithPrivateKey1, sizeof(tt__CertificateWithPrivateKey *));
					if (a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey == NULL)
						return NULL;
					*a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__CertificateWithPrivateKey(soap, "tds:CertificateWithPrivateKey", a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey, "tt:CertificateWithPrivateKey"))
				{	a->_tds__LoadCertificateWithPrivateKey::__sizeCertificateWithPrivateKey++;
					a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey)
			soap_pop_block(soap, soap_blist_CertificateWithPrivateKey1);
		if (a->_tds__LoadCertificateWithPrivateKey::__sizeCertificateWithPrivateKey)
			a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey = (tt__CertificateWithPrivateKey **)soap_save_block(soap, soap_blist_CertificateWithPrivateKey1, NULL, 1);
		else
		{	a->_tds__LoadCertificateWithPrivateKey::CertificateWithPrivateKey = NULL;
			if (soap_blist_CertificateWithPrivateKey1)
				soap_end_block(soap, soap_blist_CertificateWithPrivateKey1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__LoadCertificateWithPrivateKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, 0, sizeof(_tds__LoadCertificateWithPrivateKey), 0, soap_copy__tds__LoadCertificateWithPrivateKey);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__LoadCertificateWithPrivateKey::__sizeCertificateWithPrivateKey < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__LoadCertificateWithPrivateKey::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__LoadCertificateWithPrivateKey);
	if (this->soap_out(soap, tag?tag:"tds:LoadCertificateWithPrivateKey", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCertificateWithPrivateKey::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCertificateWithPrivateKey(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_get__tds__LoadCertificateWithPrivateKey(struct soap *soap, _tds__LoadCertificateWithPrivateKey *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate__tds__LoadCertificateWithPrivateKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCertificateWithPrivateKey(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__LoadCertificateWithPrivateKey);
		if (size)
			*size = sizeof(_tds__LoadCertificateWithPrivateKey);
		((_tds__LoadCertificateWithPrivateKey*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__LoadCertificateWithPrivateKey, n);
		if (size)
			*size = n * sizeof(_tds__LoadCertificateWithPrivateKey);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__LoadCertificateWithPrivateKey*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__LoadCertificateWithPrivateKey*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__LoadCertificateWithPrivateKey(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__LoadCertificateWithPrivateKey %p -> %p\n", q, p));
	*(_tds__LoadCertificateWithPrivateKey*)p = *(_tds__LoadCertificateWithPrivateKey*)q;
}

void _tds__GetCACertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetCACertificatesResponse::__sizeCACertificate = 0;
	this->_tds__GetCACertificatesResponse::CACertificate = NULL;
	/* transient soap skipped */
}

void _tds__GetCACertificatesResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__GetCACertificatesResponse::CACertificate)
	{	int i;
		for (i = 0; i < this->_tds__GetCACertificatesResponse::__sizeCACertificate; i++)
		{
			soap_serialize_PointerTott__Certificate(soap, this->_tds__GetCACertificatesResponse::CACertificate + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__GetCACertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCACertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCACertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__GetCACertificatesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCACertificatesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeCACertificate");
	if (a->_tds__GetCACertificatesResponse::CACertificate)
	{	int i;
		for (i = 0; i < a->_tds__GetCACertificatesResponse::__sizeCACertificate; i++)
			if (soap_out_PointerTott__Certificate(soap, "tds:CACertificate", -1, a->_tds__GetCACertificatesResponse::CACertificate + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCACertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetCACertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCACertificatesResponse * SOAP_FMAC4 soap_in__tds__GetCACertificatesResponse(struct soap *soap, const char *tag, _tds__GetCACertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCACertificatesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCACertificatesResponse, sizeof(_tds__GetCACertificatesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetCACertificatesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetCACertificatesResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_CACertificate1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CACertificate", 1, NULL))
			{	if (a->_tds__GetCACertificatesResponse::CACertificate == NULL)
				{	if (soap_blist_CACertificate1 == NULL)
						soap_blist_CACertificate1 = soap_new_block(soap);
					a->_tds__GetCACertificatesResponse::CACertificate = (tt__Certificate **)soap_push_block(soap, soap_blist_CACertificate1, sizeof(tt__Certificate *));
					if (a->_tds__GetCACertificatesResponse::CACertificate == NULL)
						return NULL;
					*a->_tds__GetCACertificatesResponse::CACertificate = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__Certificate(soap, "tds:CACertificate", a->_tds__GetCACertificatesResponse::CACertificate, "tt:Certificate"))
				{	a->_tds__GetCACertificatesResponse::__sizeCACertificate++;
					a->_tds__GetCACertificatesResponse::CACertificate = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			soap_check_result(soap, "-sizeCACertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__GetCACertificatesResponse::CACertificate)
			soap_pop_block(soap, soap_blist_CACertificate1);
		if (a->_tds__GetCACertificatesResponse::__sizeCACertificate)
			a->_tds__GetCACertificatesResponse::CACertificate = (tt__Certificate **)soap_save_block(soap, soap_blist_CACertificate1, NULL, 1);
		else
		{	a->_tds__GetCACertificatesResponse::CACertificate = NULL;
			if (soap_blist_CACertificate1)
				soap_end_block(soap, soap_blist_CACertificate1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCACertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCACertificatesResponse, 0, sizeof(_tds__GetCACertificatesResponse), 0, soap_copy__tds__GetCACertificatesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetCACertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetCACertificatesResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetCACertificatesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCACertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCACertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCACertificatesResponse * SOAP_FMAC4 soap_get__tds__GetCACertificatesResponse(struct soap *soap, _tds__GetCACertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetCACertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCACertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCACertificatesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetCACertificatesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetCACertificatesResponse);
		if (size)
			*size = sizeof(_tds__GetCACertificatesResponse);
		((_tds__GetCACertificatesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetCACertificatesResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetCACertificatesResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetCACertificatesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetCACertificatesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetCACertificatesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetCACertificatesResponse %p -> %p\n", q, p));
	*(_tds__GetCACertificatesResponse*)p = *(_tds__GetCACertificatesResponse*)q;
}

void _tds__GetCACertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__GetCACertificates::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__GetCACertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCACertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCACertificates(struct soap *soap, const char *tag, int id, const _tds__GetCACertificates *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCACertificates), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCACertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetCACertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCACertificates * SOAP_FMAC4 soap_in__tds__GetCACertificates(struct soap *soap, const char *tag, _tds__GetCACertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCACertificates *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCACertificates, sizeof(_tds__GetCACertificates), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetCACertificates)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetCACertificates *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCACertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCACertificates, 0, sizeof(_tds__GetCACertificates), 0, soap_copy__tds__GetCACertificates);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetCACertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetCACertificates);
	if (this->soap_out(soap, tag?tag:"tds:GetCACertificates", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCACertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCACertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCACertificates * SOAP_FMAC4 soap_get__tds__GetCACertificates(struct soap *soap, _tds__GetCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetCACertificates * SOAP_FMAC2 soap_instantiate__tds__GetCACertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCACertificates(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetCACertificates, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetCACertificates);
		if (size)
			*size = sizeof(_tds__GetCACertificates);
		((_tds__GetCACertificates*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetCACertificates, n);
		if (size)
			*size = n * sizeof(_tds__GetCACertificates);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetCACertificates*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetCACertificates*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetCACertificates(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetCACertificates %p -> %p\n", q, p));
	*(_tds__GetCACertificates*)p = *(_tds__GetCACertificates*)q;
}

void _tds__SetClientCertificateModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__SetClientCertificateModeResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__SetClientCertificateModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetClientCertificateModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, const _tds__SetClientCertificateModeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetClientCertificateModeResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetClientCertificateModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetClientCertificateModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetClientCertificateModeResponse * SOAP_FMAC4 soap_in__tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, _tds__SetClientCertificateModeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetClientCertificateModeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetClientCertificateModeResponse, sizeof(_tds__SetClientCertificateModeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetClientCertificateModeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetClientCertificateModeResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetClientCertificateModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetClientCertificateModeResponse, 0, sizeof(_tds__SetClientCertificateModeResponse), 0, soap_copy__tds__SetClientCertificateModeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__SetClientCertificateModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetClientCertificateModeResponse);
	if (this->soap_out(soap, tag?tag:"tds:SetClientCertificateModeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetClientCertificateModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetClientCertificateModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetClientCertificateModeResponse * SOAP_FMAC4 soap_get__tds__SetClientCertificateModeResponse(struct soap *soap, _tds__SetClientCertificateModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__tds__SetClientCertificateModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetClientCertificateModeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetClientCertificateModeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetClientCertificateModeResponse);
		if (size)
			*size = sizeof(_tds__SetClientCertificateModeResponse);
		((_tds__SetClientCertificateModeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetClientCertificateModeResponse, n);
		if (size)
			*size = n * sizeof(_tds__SetClientCertificateModeResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetClientCertificateModeResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetClientCertificateModeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetClientCertificateModeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetClientCertificateModeResponse %p -> %p\n", q, p));
	*(_tds__SetClientCertificateModeResponse*)p = *(_tds__SetClientCertificateModeResponse*)q;
}

void _tds__SetClientCertificateMode::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetClientCertificateMode::Enabled);
	/* transient soap skipped */
}

void _tds__SetClientCertificateMode::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_tds__SetClientCertificateMode::Enabled, SOAP_TYPE_bool);
	/* transient soap skipped */
#endif
}

int _tds__SetClientCertificateMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetClientCertificateMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetClientCertificateMode(struct soap *soap, const char *tag, int id, const _tds__SetClientCertificateMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetClientCertificateMode), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:Enabled", -1, &(a->_tds__SetClientCertificateMode::Enabled), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetClientCertificateMode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetClientCertificateMode(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetClientCertificateMode * SOAP_FMAC4 soap_in__tds__SetClientCertificateMode(struct soap *soap, const char *tag, _tds__SetClientCertificateMode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetClientCertificateMode *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetClientCertificateMode, sizeof(_tds__SetClientCertificateMode), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetClientCertificateMode)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetClientCertificateMode *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Enabled1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tds:Enabled", &(a->_tds__SetClientCertificateMode::Enabled), "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetClientCertificateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetClientCertificateMode, 0, sizeof(_tds__SetClientCertificateMode), 0, soap_copy__tds__SetClientCertificateMode);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__SetClientCertificateMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetClientCertificateMode);
	if (this->soap_out(soap, tag?tag:"tds:SetClientCertificateMode", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetClientCertificateMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetClientCertificateMode(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetClientCertificateMode * SOAP_FMAC4 soap_get__tds__SetClientCertificateMode(struct soap *soap, _tds__SetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetClientCertificateMode * SOAP_FMAC2 soap_instantiate__tds__SetClientCertificateMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetClientCertificateMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetClientCertificateMode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetClientCertificateMode);
		if (size)
			*size = sizeof(_tds__SetClientCertificateMode);
		((_tds__SetClientCertificateMode*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetClientCertificateMode, n);
		if (size)
			*size = n * sizeof(_tds__SetClientCertificateMode);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetClientCertificateMode*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetClientCertificateMode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetClientCertificateMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetClientCertificateMode %p -> %p\n", q, p));
	*(_tds__SetClientCertificateMode*)p = *(_tds__SetClientCertificateMode*)q;
}

void _tds__GetClientCertificateModeResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__GetClientCertificateModeResponse::Enabled);
	/* transient soap skipped */
}

void _tds__GetClientCertificateModeResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_tds__GetClientCertificateModeResponse::Enabled, SOAP_TYPE_bool);
	/* transient soap skipped */
#endif
}

int _tds__GetClientCertificateModeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetClientCertificateModeResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, const _tds__GetClientCertificateModeResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetClientCertificateModeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Enabled");
	if (soap_out_bool(soap, "tds:Enabled", -1, &(a->_tds__GetClientCertificateModeResponse::Enabled), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetClientCertificateModeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetClientCertificateModeResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetClientCertificateModeResponse * SOAP_FMAC4 soap_in__tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, _tds__GetClientCertificateModeResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetClientCertificateModeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetClientCertificateModeResponse, sizeof(_tds__GetClientCertificateModeResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetClientCertificateModeResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetClientCertificateModeResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Enabled1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tds:Enabled", &(a->_tds__GetClientCertificateModeResponse::Enabled), "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:Enabled");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetClientCertificateModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetClientCertificateModeResponse, 0, sizeof(_tds__GetClientCertificateModeResponse), 0, soap_copy__tds__GetClientCertificateModeResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetClientCertificateModeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetClientCertificateModeResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetClientCertificateModeResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetClientCertificateModeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetClientCertificateModeResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetClientCertificateModeResponse * SOAP_FMAC4 soap_get__tds__GetClientCertificateModeResponse(struct soap *soap, _tds__GetClientCertificateModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetClientCertificateModeResponse * SOAP_FMAC2 soap_instantiate__tds__GetClientCertificateModeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetClientCertificateModeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetClientCertificateModeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetClientCertificateModeResponse);
		if (size)
			*size = sizeof(_tds__GetClientCertificateModeResponse);
		((_tds__GetClientCertificateModeResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetClientCertificateModeResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetClientCertificateModeResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetClientCertificateModeResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetClientCertificateModeResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetClientCertificateModeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetClientCertificateModeResponse %p -> %p\n", q, p));
	*(_tds__GetClientCertificateModeResponse*)p = *(_tds__GetClientCertificateModeResponse*)q;
}

void _tds__GetClientCertificateMode::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__GetClientCertificateMode::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__GetClientCertificateMode::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetClientCertificateMode(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetClientCertificateMode(struct soap *soap, const char *tag, int id, const _tds__GetClientCertificateMode *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetClientCertificateMode), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetClientCertificateMode::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetClientCertificateMode(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetClientCertificateMode * SOAP_FMAC4 soap_in__tds__GetClientCertificateMode(struct soap *soap, const char *tag, _tds__GetClientCertificateMode *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetClientCertificateMode *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetClientCertificateMode, sizeof(_tds__GetClientCertificateMode), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetClientCertificateMode)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetClientCertificateMode *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetClientCertificateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetClientCertificateMode, 0, sizeof(_tds__GetClientCertificateMode), 0, soap_copy__tds__GetClientCertificateMode);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetClientCertificateMode::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetClientCertificateMode);
	if (this->soap_out(soap, tag?tag:"tds:GetClientCertificateMode", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetClientCertificateMode::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetClientCertificateMode(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetClientCertificateMode * SOAP_FMAC4 soap_get__tds__GetClientCertificateMode(struct soap *soap, _tds__GetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetClientCertificateMode * SOAP_FMAC2 soap_instantiate__tds__GetClientCertificateMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetClientCertificateMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetClientCertificateMode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetClientCertificateMode);
		if (size)
			*size = sizeof(_tds__GetClientCertificateMode);
		((_tds__GetClientCertificateMode*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetClientCertificateMode, n);
		if (size)
			*size = n * sizeof(_tds__GetClientCertificateMode);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetClientCertificateMode*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetClientCertificateMode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetClientCertificateMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetClientCertificateMode %p -> %p\n", q, p));
	*(_tds__GetClientCertificateMode*)p = *(_tds__GetClientCertificateMode*)q;
}

void _tds__LoadCertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__LoadCertificatesResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__LoadCertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__LoadCertificatesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificatesResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__LoadCertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCertificatesResponse * SOAP_FMAC4 soap_in__tds__LoadCertificatesResponse(struct soap *soap, const char *tag, _tds__LoadCertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCertificatesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificatesResponse, sizeof(_tds__LoadCertificatesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__LoadCertificatesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__LoadCertificatesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__LoadCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificatesResponse, 0, sizeof(_tds__LoadCertificatesResponse), 0, soap_copy__tds__LoadCertificatesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__LoadCertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__LoadCertificatesResponse);
	if (this->soap_out(soap, tag?tag:"tds:LoadCertificatesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCertificatesResponse * SOAP_FMAC4 soap_get__tds__LoadCertificatesResponse(struct soap *soap, _tds__LoadCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__LoadCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__LoadCertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCertificatesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__LoadCertificatesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__LoadCertificatesResponse);
		if (size)
			*size = sizeof(_tds__LoadCertificatesResponse);
		((_tds__LoadCertificatesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__LoadCertificatesResponse, n);
		if (size)
			*size = n * sizeof(_tds__LoadCertificatesResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__LoadCertificatesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__LoadCertificatesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__LoadCertificatesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__LoadCertificatesResponse %p -> %p\n", q, p));
	*(_tds__LoadCertificatesResponse*)p = *(_tds__LoadCertificatesResponse*)q;
}

void _tds__LoadCertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__LoadCertificates::__sizeNVTCertificate = 0;
	this->_tds__LoadCertificates::NVTCertificate = NULL;
	/* transient soap skipped */
}

void _tds__LoadCertificates::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__LoadCertificates::NVTCertificate)
	{	int i;
		for (i = 0; i < this->_tds__LoadCertificates::__sizeNVTCertificate; i++)
		{
			soap_serialize_PointerTott__Certificate(soap, this->_tds__LoadCertificates::NVTCertificate + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__LoadCertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__LoadCertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificates(struct soap *soap, const char *tag, int id, const _tds__LoadCertificates *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificates), type))
		return soap->error;
	if (a->_tds__LoadCertificates::NVTCertificate)
	{	int i;
		for (i = 0; i < a->_tds__LoadCertificates::__sizeNVTCertificate; i++)
			if (soap_out_PointerTott__Certificate(soap, "tds:NVTCertificate", -1, a->_tds__LoadCertificates::NVTCertificate + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__LoadCertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__LoadCertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__LoadCertificates * SOAP_FMAC4 soap_in__tds__LoadCertificates(struct soap *soap, const char *tag, _tds__LoadCertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__LoadCertificates *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificates, sizeof(_tds__LoadCertificates), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__LoadCertificates)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__LoadCertificates *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_NVTCertificate1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NVTCertificate", 1, NULL))
			{	if (a->_tds__LoadCertificates::NVTCertificate == NULL)
				{	if (soap_blist_NVTCertificate1 == NULL)
						soap_blist_NVTCertificate1 = soap_new_block(soap);
					a->_tds__LoadCertificates::NVTCertificate = (tt__Certificate **)soap_push_block(soap, soap_blist_NVTCertificate1, sizeof(tt__Certificate *));
					if (a->_tds__LoadCertificates::NVTCertificate == NULL)
						return NULL;
					*a->_tds__LoadCertificates::NVTCertificate = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__Certificate(soap, "tds:NVTCertificate", a->_tds__LoadCertificates::NVTCertificate, "tt:Certificate"))
				{	a->_tds__LoadCertificates::__sizeNVTCertificate++;
					a->_tds__LoadCertificates::NVTCertificate = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__LoadCertificates::NVTCertificate)
			soap_pop_block(soap, soap_blist_NVTCertificate1);
		if (a->_tds__LoadCertificates::__sizeNVTCertificate)
			a->_tds__LoadCertificates::NVTCertificate = (tt__Certificate **)soap_save_block(soap, soap_blist_NVTCertificate1, NULL, 1);
		else
		{	a->_tds__LoadCertificates::NVTCertificate = NULL;
			if (soap_blist_NVTCertificate1)
				soap_end_block(soap, soap_blist_NVTCertificate1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__LoadCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificates, 0, sizeof(_tds__LoadCertificates), 0, soap_copy__tds__LoadCertificates);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__LoadCertificates::__sizeNVTCertificate < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__LoadCertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__LoadCertificates);
	if (this->soap_out(soap, tag?tag:"tds:LoadCertificates", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__LoadCertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__LoadCertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__LoadCertificates * SOAP_FMAC4 soap_get__tds__LoadCertificates(struct soap *soap, _tds__LoadCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__LoadCertificates * SOAP_FMAC2 soap_instantiate__tds__LoadCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__LoadCertificates(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__LoadCertificates, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__LoadCertificates);
		if (size)
			*size = sizeof(_tds__LoadCertificates);
		((_tds__LoadCertificates*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__LoadCertificates, n);
		if (size)
			*size = n * sizeof(_tds__LoadCertificates);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__LoadCertificates*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__LoadCertificates*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__LoadCertificates(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__LoadCertificates %p -> %p\n", q, p));
	*(_tds__LoadCertificates*)p = *(_tds__LoadCertificates*)q;
}

void _tds__GetPkcs10RequestResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetPkcs10RequestResponse::Pkcs10Request = NULL;
	/* transient soap skipped */
}

void _tds__GetPkcs10RequestResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__BinaryData(soap, &this->_tds__GetPkcs10RequestResponse::Pkcs10Request);
	/* transient soap skipped */
#endif
}

int _tds__GetPkcs10RequestResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPkcs10RequestResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, int id, const _tds__GetPkcs10RequestResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPkcs10RequestResponse), type))
		return soap->error;
	if (a->Pkcs10Request)
		soap_element_result(soap, "tds:Pkcs10Request");
	if (a->_tds__GetPkcs10RequestResponse::Pkcs10Request)
	{	if (soap_out_PointerTott__BinaryData(soap, "tds:Pkcs10Request", -1, &a->_tds__GetPkcs10RequestResponse::Pkcs10Request, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Pkcs10Request"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPkcs10RequestResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetPkcs10RequestResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPkcs10RequestResponse * SOAP_FMAC4 soap_in__tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, _tds__GetPkcs10RequestResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPkcs10RequestResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPkcs10RequestResponse, sizeof(_tds__GetPkcs10RequestResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetPkcs10RequestResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetPkcs10RequestResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Pkcs10Request1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Pkcs10Request1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BinaryData(soap, "tds:Pkcs10Request", &(a->_tds__GetPkcs10RequestResponse::Pkcs10Request), "tt:BinaryData"))
				{	soap_flag_Pkcs10Request1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:Pkcs10Request");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetPkcs10RequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPkcs10RequestResponse, 0, sizeof(_tds__GetPkcs10RequestResponse), 0, soap_copy__tds__GetPkcs10RequestResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Pkcs10Request1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetPkcs10RequestResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetPkcs10RequestResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetPkcs10RequestResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPkcs10RequestResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPkcs10RequestResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPkcs10RequestResponse * SOAP_FMAC4 soap_get__tds__GetPkcs10RequestResponse(struct soap *soap, _tds__GetPkcs10RequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPkcs10RequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetPkcs10RequestResponse * SOAP_FMAC2 soap_instantiate__tds__GetPkcs10RequestResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPkcs10RequestResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetPkcs10RequestResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetPkcs10RequestResponse);
		if (size)
			*size = sizeof(_tds__GetPkcs10RequestResponse);
		((_tds__GetPkcs10RequestResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetPkcs10RequestResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetPkcs10RequestResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetPkcs10RequestResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetPkcs10RequestResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetPkcs10RequestResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetPkcs10RequestResponse %p -> %p\n", q, p));
	*(_tds__GetPkcs10RequestResponse*)p = *(_tds__GetPkcs10RequestResponse*)q;
}

void _tds__GetPkcs10Request::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->_tds__GetPkcs10Request::CertificateID);
	soap_default_string(soap, &this->_tds__GetPkcs10Request::Subject);
	this->_tds__GetPkcs10Request::Attributes = NULL;
	/* transient soap skipped */
}

void _tds__GetPkcs10Request::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &this->_tds__GetPkcs10Request::CertificateID);
	soap_serialize_string(soap, &this->_tds__GetPkcs10Request::Subject);
	soap_serialize_PointerTott__BinaryData(soap, &this->_tds__GetPkcs10Request::Attributes);
	/* transient soap skipped */
#endif
}

int _tds__GetPkcs10Request::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetPkcs10Request(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPkcs10Request(struct soap *soap, const char *tag, int id, const _tds__GetPkcs10Request *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPkcs10Request), type))
		return soap->error;
	if (a->_tds__GetPkcs10Request::CertificateID)
	{	if (soap_out_xsd__token(soap, "tds:CertificateID", -1, &a->_tds__GetPkcs10Request::CertificateID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:CertificateID"))
		return soap->error;
	if (soap_out_string(soap, "tds:Subject", -1, &(a->_tds__GetPkcs10Request::Subject), ""))
		return soap->error;
	if (soap_out_PointerTott__BinaryData(soap, "tds:Attributes", -1, &(a->_tds__GetPkcs10Request::Attributes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetPkcs10Request::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetPkcs10Request(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetPkcs10Request * SOAP_FMAC4 soap_in__tds__GetPkcs10Request(struct soap *soap, const char *tag, _tds__GetPkcs10Request *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetPkcs10Request *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPkcs10Request, sizeof(_tds__GetPkcs10Request), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetPkcs10Request)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetPkcs10Request *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Subject1 = 1;
	size_t soap_flag_Attributes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tds:CertificateID", &(a->_tds__GetPkcs10Request::CertificateID), "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			if (soap_flag_Subject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:Subject", &(a->_tds__GetPkcs10Request::Subject), "xsd:string"))
				{	soap_flag_Subject1--;
					continue;
				}
			if (soap_flag_Attributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BinaryData(soap, "tds:Attributes", &(a->_tds__GetPkcs10Request::Attributes), "tt:BinaryData"))
				{	soap_flag_Attributes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetPkcs10Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPkcs10Request, 0, sizeof(_tds__GetPkcs10Request), 0, soap_copy__tds__GetPkcs10Request);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetPkcs10Request::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetPkcs10Request);
	if (this->soap_out(soap, tag?tag:"tds:GetPkcs10Request", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetPkcs10Request::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetPkcs10Request(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetPkcs10Request * SOAP_FMAC4 soap_get__tds__GetPkcs10Request(struct soap *soap, _tds__GetPkcs10Request *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPkcs10Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetPkcs10Request * SOAP_FMAC2 soap_instantiate__tds__GetPkcs10Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetPkcs10Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetPkcs10Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetPkcs10Request);
		if (size)
			*size = sizeof(_tds__GetPkcs10Request);
		((_tds__GetPkcs10Request*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetPkcs10Request, n);
		if (size)
			*size = n * sizeof(_tds__GetPkcs10Request);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetPkcs10Request*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetPkcs10Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetPkcs10Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetPkcs10Request %p -> %p\n", q, p));
	*(_tds__GetPkcs10Request*)p = *(_tds__GetPkcs10Request*)q;
}

void _tds__DeleteCertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__DeleteCertificatesResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__DeleteCertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteCertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__DeleteCertificatesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteCertificatesResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteCertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__DeleteCertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteCertificatesResponse * SOAP_FMAC4 soap_in__tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, _tds__DeleteCertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteCertificatesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteCertificatesResponse, sizeof(_tds__DeleteCertificatesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__DeleteCertificatesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__DeleteCertificatesResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteCertificatesResponse, 0, sizeof(_tds__DeleteCertificatesResponse), 0, soap_copy__tds__DeleteCertificatesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__DeleteCertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__DeleteCertificatesResponse);
	if (this->soap_out(soap, tag?tag:"tds:DeleteCertificatesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteCertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteCertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteCertificatesResponse * SOAP_FMAC4 soap_get__tds__DeleteCertificatesResponse(struct soap *soap, _tds__DeleteCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__DeleteCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteCertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteCertificatesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__DeleteCertificatesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__DeleteCertificatesResponse);
		if (size)
			*size = sizeof(_tds__DeleteCertificatesResponse);
		((_tds__DeleteCertificatesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__DeleteCertificatesResponse, n);
		if (size)
			*size = n * sizeof(_tds__DeleteCertificatesResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__DeleteCertificatesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__DeleteCertificatesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__DeleteCertificatesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__DeleteCertificatesResponse %p -> %p\n", q, p));
	*(_tds__DeleteCertificatesResponse*)p = *(_tds__DeleteCertificatesResponse*)q;
}

void _tds__DeleteCertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__DeleteCertificates::__sizeCertificateID = 0;
	this->_tds__DeleteCertificates::CertificateID = NULL;
	/* transient soap skipped */
}

void _tds__DeleteCertificates::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__DeleteCertificates::CertificateID)
	{	int i;
		for (i = 0; i < this->_tds__DeleteCertificates::__sizeCertificateID; i++)
		{
			soap_serialize_xsd__token(soap, this->_tds__DeleteCertificates::CertificateID + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__DeleteCertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteCertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteCertificates(struct soap *soap, const char *tag, int id, const _tds__DeleteCertificates *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteCertificates), type))
		return soap->error;
	if (a->_tds__DeleteCertificates::CertificateID)
	{	int i;
		for (i = 0; i < a->_tds__DeleteCertificates::__sizeCertificateID; i++)
			if (soap_out_xsd__token(soap, "tds:CertificateID", -1, a->_tds__DeleteCertificates::CertificateID + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteCertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__DeleteCertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteCertificates * SOAP_FMAC4 soap_in__tds__DeleteCertificates(struct soap *soap, const char *tag, _tds__DeleteCertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteCertificates *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteCertificates, sizeof(_tds__DeleteCertificates), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__DeleteCertificates)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__DeleteCertificates *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_CertificateID1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateID", 1, NULL))
			{	if (a->_tds__DeleteCertificates::CertificateID == NULL)
				{	if (soap_blist_CertificateID1 == NULL)
						soap_blist_CertificateID1 = soap_new_block(soap);
					a->_tds__DeleteCertificates::CertificateID = (char **)soap_push_block(soap, soap_blist_CertificateID1, sizeof(char *));
					if (a->_tds__DeleteCertificates::CertificateID == NULL)
						return NULL;
					*a->_tds__DeleteCertificates::CertificateID = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__token(soap, "tds:CertificateID", a->_tds__DeleteCertificates::CertificateID, "xsd:token"))
				{	a->_tds__DeleteCertificates::__sizeCertificateID++;
					a->_tds__DeleteCertificates::CertificateID = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__DeleteCertificates::CertificateID)
			soap_pop_block(soap, soap_blist_CertificateID1);
		if (a->_tds__DeleteCertificates::__sizeCertificateID)
			a->_tds__DeleteCertificates::CertificateID = (char **)soap_save_block(soap, soap_blist_CertificateID1, NULL, 1);
		else
		{	a->_tds__DeleteCertificates::CertificateID = NULL;
			if (soap_blist_CertificateID1)
				soap_end_block(soap, soap_blist_CertificateID1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteCertificates, 0, sizeof(_tds__DeleteCertificates), 0, soap_copy__tds__DeleteCertificates);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__DeleteCertificates::__sizeCertificateID < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__DeleteCertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__DeleteCertificates);
	if (this->soap_out(soap, tag?tag:"tds:DeleteCertificates", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteCertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteCertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteCertificates * SOAP_FMAC4 soap_get__tds__DeleteCertificates(struct soap *soap, _tds__DeleteCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__DeleteCertificates * SOAP_FMAC2 soap_instantiate__tds__DeleteCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteCertificates(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__DeleteCertificates, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__DeleteCertificates);
		if (size)
			*size = sizeof(_tds__DeleteCertificates);
		((_tds__DeleteCertificates*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__DeleteCertificates, n);
		if (size)
			*size = n * sizeof(_tds__DeleteCertificates);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__DeleteCertificates*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__DeleteCertificates*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__DeleteCertificates(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__DeleteCertificates %p -> %p\n", q, p));
	*(_tds__DeleteCertificates*)p = *(_tds__DeleteCertificates*)q;
}

void _tds__SetCertificatesStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__SetCertificatesStatusResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__SetCertificatesStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetCertificatesStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, const _tds__SetCertificatesStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetCertificatesStatusResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetCertificatesStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetCertificatesStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetCertificatesStatusResponse * SOAP_FMAC4 soap_in__tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, _tds__SetCertificatesStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetCertificatesStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetCertificatesStatusResponse, sizeof(_tds__SetCertificatesStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetCertificatesStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetCertificatesStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetCertificatesStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetCertificatesStatusResponse, 0, sizeof(_tds__SetCertificatesStatusResponse), 0, soap_copy__tds__SetCertificatesStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__SetCertificatesStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetCertificatesStatusResponse);
	if (this->soap_out(soap, tag?tag:"tds:SetCertificatesStatusResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetCertificatesStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetCertificatesStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetCertificatesStatusResponse * SOAP_FMAC4 soap_get__tds__SetCertificatesStatusResponse(struct soap *soap, _tds__SetCertificatesStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__tds__SetCertificatesStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetCertificatesStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetCertificatesStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetCertificatesStatusResponse);
		if (size)
			*size = sizeof(_tds__SetCertificatesStatusResponse);
		((_tds__SetCertificatesStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetCertificatesStatusResponse, n);
		if (size)
			*size = n * sizeof(_tds__SetCertificatesStatusResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetCertificatesStatusResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetCertificatesStatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetCertificatesStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetCertificatesStatusResponse %p -> %p\n", q, p));
	*(_tds__SetCertificatesStatusResponse*)p = *(_tds__SetCertificatesStatusResponse*)q;
}

void _tds__SetCertificatesStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetCertificatesStatus::__sizeCertificateStatus = 0;
	this->_tds__SetCertificatesStatus::CertificateStatus = NULL;
	/* transient soap skipped */
}

void _tds__SetCertificatesStatus::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__SetCertificatesStatus::CertificateStatus)
	{	int i;
		for (i = 0; i < this->_tds__SetCertificatesStatus::__sizeCertificateStatus; i++)
		{
			soap_serialize_PointerTott__CertificateStatus(soap, this->_tds__SetCertificatesStatus::CertificateStatus + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__SetCertificatesStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetCertificatesStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetCertificatesStatus(struct soap *soap, const char *tag, int id, const _tds__SetCertificatesStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetCertificatesStatus), type))
		return soap->error;
	if (a->_tds__SetCertificatesStatus::CertificateStatus)
	{	int i;
		for (i = 0; i < a->_tds__SetCertificatesStatus::__sizeCertificateStatus; i++)
			if (soap_out_PointerTott__CertificateStatus(soap, "tds:CertificateStatus", -1, a->_tds__SetCertificatesStatus::CertificateStatus + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetCertificatesStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetCertificatesStatus(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetCertificatesStatus * SOAP_FMAC4 soap_in__tds__SetCertificatesStatus(struct soap *soap, const char *tag, _tds__SetCertificatesStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetCertificatesStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetCertificatesStatus, sizeof(_tds__SetCertificatesStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetCertificatesStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetCertificatesStatus *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_CertificateStatus1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateStatus", 1, NULL))
			{	if (a->_tds__SetCertificatesStatus::CertificateStatus == NULL)
				{	if (soap_blist_CertificateStatus1 == NULL)
						soap_blist_CertificateStatus1 = soap_new_block(soap);
					a->_tds__SetCertificatesStatus::CertificateStatus = (tt__CertificateStatus **)soap_push_block(soap, soap_blist_CertificateStatus1, sizeof(tt__CertificateStatus *));
					if (a->_tds__SetCertificatesStatus::CertificateStatus == NULL)
						return NULL;
					*a->_tds__SetCertificatesStatus::CertificateStatus = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__CertificateStatus(soap, "tds:CertificateStatus", a->_tds__SetCertificatesStatus::CertificateStatus, "tt:CertificateStatus"))
				{	a->_tds__SetCertificatesStatus::__sizeCertificateStatus++;
					a->_tds__SetCertificatesStatus::CertificateStatus = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__SetCertificatesStatus::CertificateStatus)
			soap_pop_block(soap, soap_blist_CertificateStatus1);
		if (a->_tds__SetCertificatesStatus::__sizeCertificateStatus)
			a->_tds__SetCertificatesStatus::CertificateStatus = (tt__CertificateStatus **)soap_save_block(soap, soap_blist_CertificateStatus1, NULL, 1);
		else
		{	a->_tds__SetCertificatesStatus::CertificateStatus = NULL;
			if (soap_blist_CertificateStatus1)
				soap_end_block(soap, soap_blist_CertificateStatus1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetCertificatesStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetCertificatesStatus, 0, sizeof(_tds__SetCertificatesStatus), 0, soap_copy__tds__SetCertificatesStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__SetCertificatesStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetCertificatesStatus);
	if (this->soap_out(soap, tag?tag:"tds:SetCertificatesStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetCertificatesStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetCertificatesStatus(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetCertificatesStatus * SOAP_FMAC4 soap_get__tds__SetCertificatesStatus(struct soap *soap, _tds__SetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetCertificatesStatus * SOAP_FMAC2 soap_instantiate__tds__SetCertificatesStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetCertificatesStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetCertificatesStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetCertificatesStatus);
		if (size)
			*size = sizeof(_tds__SetCertificatesStatus);
		((_tds__SetCertificatesStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetCertificatesStatus, n);
		if (size)
			*size = n * sizeof(_tds__SetCertificatesStatus);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetCertificatesStatus*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetCertificatesStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetCertificatesStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetCertificatesStatus %p -> %p\n", q, p));
	*(_tds__SetCertificatesStatus*)p = *(_tds__SetCertificatesStatus*)q;
}

void _tds__GetCertificatesStatusResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetCertificatesStatusResponse::__sizeCertificateStatus = 0;
	this->_tds__GetCertificatesStatusResponse::CertificateStatus = NULL;
	/* transient soap skipped */
}

void _tds__GetCertificatesStatusResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__GetCertificatesStatusResponse::CertificateStatus)
	{	int i;
		for (i = 0; i < this->_tds__GetCertificatesStatusResponse::__sizeCertificateStatus; i++)
		{
			soap_serialize_PointerTott__CertificateStatus(soap, this->_tds__GetCertificatesStatusResponse::CertificateStatus + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__GetCertificatesStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificatesStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, const _tds__GetCertificatesStatusResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesStatusResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeCertificateStatus");
	if (a->_tds__GetCertificatesStatusResponse::CertificateStatus)
	{	int i;
		for (i = 0; i < a->_tds__GetCertificatesStatusResponse::__sizeCertificateStatus; i++)
			if (soap_out_PointerTott__CertificateStatus(soap, "tds:CertificateStatus", -1, a->_tds__GetCertificatesStatusResponse::CertificateStatus + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificatesStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetCertificatesStatusResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificatesStatusResponse * SOAP_FMAC4 soap_in__tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, _tds__GetCertificatesStatusResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificatesStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesStatusResponse, sizeof(_tds__GetCertificatesStatusResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetCertificatesStatusResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetCertificatesStatusResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_CertificateStatus1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateStatus", 1, NULL))
			{	if (a->_tds__GetCertificatesStatusResponse::CertificateStatus == NULL)
				{	if (soap_blist_CertificateStatus1 == NULL)
						soap_blist_CertificateStatus1 = soap_new_block(soap);
					a->_tds__GetCertificatesStatusResponse::CertificateStatus = (tt__CertificateStatus **)soap_push_block(soap, soap_blist_CertificateStatus1, sizeof(tt__CertificateStatus *));
					if (a->_tds__GetCertificatesStatusResponse::CertificateStatus == NULL)
						return NULL;
					*a->_tds__GetCertificatesStatusResponse::CertificateStatus = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__CertificateStatus(soap, "tds:CertificateStatus", a->_tds__GetCertificatesStatusResponse::CertificateStatus, "tt:CertificateStatus"))
				{	a->_tds__GetCertificatesStatusResponse::__sizeCertificateStatus++;
					a->_tds__GetCertificatesStatusResponse::CertificateStatus = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			soap_check_result(soap, "-sizeCertificateStatus");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__GetCertificatesStatusResponse::CertificateStatus)
			soap_pop_block(soap, soap_blist_CertificateStatus1);
		if (a->_tds__GetCertificatesStatusResponse::__sizeCertificateStatus)
			a->_tds__GetCertificatesStatusResponse::CertificateStatus = (tt__CertificateStatus **)soap_save_block(soap, soap_blist_CertificateStatus1, NULL, 1);
		else
		{	a->_tds__GetCertificatesStatusResponse::CertificateStatus = NULL;
			if (soap_blist_CertificateStatus1)
				soap_end_block(soap, soap_blist_CertificateStatus1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCertificatesStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesStatusResponse, 0, sizeof(_tds__GetCertificatesStatusResponse), 0, soap_copy__tds__GetCertificatesStatusResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetCertificatesStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetCertificatesStatusResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetCertificatesStatusResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificatesStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificatesStatusResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificatesStatusResponse * SOAP_FMAC4 soap_get__tds__GetCertificatesStatusResponse(struct soap *soap, _tds__GetCertificatesStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetCertificatesStatusResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificatesStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetCertificatesStatusResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetCertificatesStatusResponse);
		if (size)
			*size = sizeof(_tds__GetCertificatesStatusResponse);
		((_tds__GetCertificatesStatusResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetCertificatesStatusResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetCertificatesStatusResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetCertificatesStatusResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetCertificatesStatusResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetCertificatesStatusResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetCertificatesStatusResponse %p -> %p\n", q, p));
	*(_tds__GetCertificatesStatusResponse*)p = *(_tds__GetCertificatesStatusResponse*)q;
}

void _tds__GetCertificatesStatus::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__GetCertificatesStatus::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__GetCertificatesStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificatesStatus(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesStatus(struct soap *soap, const char *tag, int id, const _tds__GetCertificatesStatus *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesStatus), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificatesStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetCertificatesStatus(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificatesStatus * SOAP_FMAC4 soap_in__tds__GetCertificatesStatus(struct soap *soap, const char *tag, _tds__GetCertificatesStatus *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificatesStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesStatus, sizeof(_tds__GetCertificatesStatus), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetCertificatesStatus)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetCertificatesStatus *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCertificatesStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesStatus, 0, sizeof(_tds__GetCertificatesStatus), 0, soap_copy__tds__GetCertificatesStatus);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetCertificatesStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetCertificatesStatus);
	if (this->soap_out(soap, tag?tag:"tds:GetCertificatesStatus", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificatesStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificatesStatus(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificatesStatus * SOAP_FMAC4 soap_get__tds__GetCertificatesStatus(struct soap *soap, _tds__GetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetCertificatesStatus * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificatesStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetCertificatesStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetCertificatesStatus);
		if (size)
			*size = sizeof(_tds__GetCertificatesStatus);
		((_tds__GetCertificatesStatus*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetCertificatesStatus, n);
		if (size)
			*size = n * sizeof(_tds__GetCertificatesStatus);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetCertificatesStatus*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetCertificatesStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetCertificatesStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetCertificatesStatus %p -> %p\n", q, p));
	*(_tds__GetCertificatesStatus*)p = *(_tds__GetCertificatesStatus*)q;
}

void _tds__GetCertificatesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetCertificatesResponse::__sizeNvtCertificate = 0;
	this->_tds__GetCertificatesResponse::NvtCertificate = NULL;
	/* transient soap skipped */
}

void _tds__GetCertificatesResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__GetCertificatesResponse::NvtCertificate)
	{	int i;
		for (i = 0; i < this->_tds__GetCertificatesResponse::__sizeNvtCertificate; i++)
		{
			soap_serialize_PointerTott__Certificate(soap, this->_tds__GetCertificatesResponse::NvtCertificate + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__GetCertificatesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificatesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesResponse(struct soap *soap, const char *tag, int id, const _tds__GetCertificatesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNvtCertificate");
	if (a->_tds__GetCertificatesResponse::NvtCertificate)
	{	int i;
		for (i = 0; i < a->_tds__GetCertificatesResponse::__sizeNvtCertificate; i++)
			if (soap_out_PointerTott__Certificate(soap, "tds:NvtCertificate", -1, a->_tds__GetCertificatesResponse::NvtCertificate + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificatesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetCertificatesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificatesResponse * SOAP_FMAC4 soap_in__tds__GetCertificatesResponse(struct soap *soap, const char *tag, _tds__GetCertificatesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificatesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesResponse, sizeof(_tds__GetCertificatesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetCertificatesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetCertificatesResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_NvtCertificate1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NvtCertificate", 1, NULL))
			{	if (a->_tds__GetCertificatesResponse::NvtCertificate == NULL)
				{	if (soap_blist_NvtCertificate1 == NULL)
						soap_blist_NvtCertificate1 = soap_new_block(soap);
					a->_tds__GetCertificatesResponse::NvtCertificate = (tt__Certificate **)soap_push_block(soap, soap_blist_NvtCertificate1, sizeof(tt__Certificate *));
					if (a->_tds__GetCertificatesResponse::NvtCertificate == NULL)
						return NULL;
					*a->_tds__GetCertificatesResponse::NvtCertificate = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__Certificate(soap, "tds:NvtCertificate", a->_tds__GetCertificatesResponse::NvtCertificate, "tt:Certificate"))
				{	a->_tds__GetCertificatesResponse::__sizeNvtCertificate++;
					a->_tds__GetCertificatesResponse::NvtCertificate = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			soap_check_result(soap, "-sizeNvtCertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__GetCertificatesResponse::NvtCertificate)
			soap_pop_block(soap, soap_blist_NvtCertificate1);
		if (a->_tds__GetCertificatesResponse::__sizeNvtCertificate)
			a->_tds__GetCertificatesResponse::NvtCertificate = (tt__Certificate **)soap_save_block(soap, soap_blist_NvtCertificate1, NULL, 1);
		else
		{	a->_tds__GetCertificatesResponse::NvtCertificate = NULL;
			if (soap_blist_NvtCertificate1)
				soap_end_block(soap, soap_blist_NvtCertificate1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesResponse, 0, sizeof(_tds__GetCertificatesResponse), 0, soap_copy__tds__GetCertificatesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetCertificatesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetCertificatesResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetCertificatesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificatesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificatesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificatesResponse * SOAP_FMAC4 soap_get__tds__GetCertificatesResponse(struct soap *soap, _tds__GetCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetCertificatesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCertificatesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificatesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetCertificatesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetCertificatesResponse);
		if (size)
			*size = sizeof(_tds__GetCertificatesResponse);
		((_tds__GetCertificatesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetCertificatesResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetCertificatesResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetCertificatesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetCertificatesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetCertificatesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetCertificatesResponse %p -> %p\n", q, p));
	*(_tds__GetCertificatesResponse*)p = *(_tds__GetCertificatesResponse*)q;
}

void _tds__GetCertificates::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__GetCertificates::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__GetCertificates::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCertificates(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificates(struct soap *soap, const char *tag, int id, const _tds__GetCertificates *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificates), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCertificates::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetCertificates(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCertificates * SOAP_FMAC4 soap_in__tds__GetCertificates(struct soap *soap, const char *tag, _tds__GetCertificates *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCertificates *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificates, sizeof(_tds__GetCertificates), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetCertificates)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetCertificates *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificates, 0, sizeof(_tds__GetCertificates), 0, soap_copy__tds__GetCertificates);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetCertificates::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetCertificates);
	if (this->soap_out(soap, tag?tag:"tds:GetCertificates", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCertificates::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCertificates(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCertificates * SOAP_FMAC4 soap_get__tds__GetCertificates(struct soap *soap, _tds__GetCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetCertificates * SOAP_FMAC2 soap_instantiate__tds__GetCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCertificates(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetCertificates, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetCertificates);
		if (size)
			*size = sizeof(_tds__GetCertificates);
		((_tds__GetCertificates*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetCertificates, n);
		if (size)
			*size = n * sizeof(_tds__GetCertificates);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetCertificates*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetCertificates*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetCertificates(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetCertificates %p -> %p\n", q, p));
	*(_tds__GetCertificates*)p = *(_tds__GetCertificates*)q;
}

void _tds__CreateCertificateResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__CreateCertificateResponse::NvtCertificate = NULL;
	/* transient soap skipped */
}

void _tds__CreateCertificateResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Certificate(soap, &this->_tds__CreateCertificateResponse::NvtCertificate);
	/* transient soap skipped */
#endif
}

int _tds__CreateCertificateResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateCertificateResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateCertificateResponse(struct soap *soap, const char *tag, int id, const _tds__CreateCertificateResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateCertificateResponse), type))
		return soap->error;
	if (a->NvtCertificate)
		soap_element_result(soap, "tds:NvtCertificate");
	if (a->_tds__CreateCertificateResponse::NvtCertificate)
	{	if (soap_out_PointerTott__Certificate(soap, "tds:NvtCertificate", -1, &a->_tds__CreateCertificateResponse::NvtCertificate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:NvtCertificate"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateCertificateResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__CreateCertificateResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateCertificateResponse * SOAP_FMAC4 soap_in__tds__CreateCertificateResponse(struct soap *soap, const char *tag, _tds__CreateCertificateResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateCertificateResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateCertificateResponse, sizeof(_tds__CreateCertificateResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__CreateCertificateResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__CreateCertificateResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_NvtCertificate1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NvtCertificate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Certificate(soap, "tds:NvtCertificate", &(a->_tds__CreateCertificateResponse::NvtCertificate), "tt:Certificate"))
				{	soap_flag_NvtCertificate1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:NvtCertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__CreateCertificateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateCertificateResponse, 0, sizeof(_tds__CreateCertificateResponse), 0, soap_copy__tds__CreateCertificateResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NvtCertificate1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__CreateCertificateResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__CreateCertificateResponse);
	if (this->soap_out(soap, tag?tag:"tds:CreateCertificateResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateCertificateResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateCertificateResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateCertificateResponse * SOAP_FMAC4 soap_get__tds__CreateCertificateResponse(struct soap *soap, _tds__CreateCertificateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateCertificateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__CreateCertificateResponse * SOAP_FMAC2 soap_instantiate__tds__CreateCertificateResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateCertificateResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__CreateCertificateResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__CreateCertificateResponse);
		if (size)
			*size = sizeof(_tds__CreateCertificateResponse);
		((_tds__CreateCertificateResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__CreateCertificateResponse, n);
		if (size)
			*size = n * sizeof(_tds__CreateCertificateResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__CreateCertificateResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__CreateCertificateResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__CreateCertificateResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__CreateCertificateResponse %p -> %p\n", q, p));
	*(_tds__CreateCertificateResponse*)p = *(_tds__CreateCertificateResponse*)q;
}

void _tds__CreateCertificate::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->_tds__CreateCertificate::CertificateID);
	soap_default_string(soap, &this->_tds__CreateCertificate::Subject);
	this->_tds__CreateCertificate::ValidNotBefore = NULL;
	this->_tds__CreateCertificate::ValidNotAfter = NULL;
	/* transient soap skipped */
}

void _tds__CreateCertificate::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &this->_tds__CreateCertificate::CertificateID);
	soap_serialize_string(soap, &this->_tds__CreateCertificate::Subject);
	soap_serialize_PointerTotime(soap, &this->_tds__CreateCertificate::ValidNotBefore);
	soap_serialize_PointerTotime(soap, &this->_tds__CreateCertificate::ValidNotAfter);
	/* transient soap skipped */
#endif
}

int _tds__CreateCertificate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateCertificate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateCertificate(struct soap *soap, const char *tag, int id, const _tds__CreateCertificate *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateCertificate), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tds:CertificateID", -1, &(a->_tds__CreateCertificate::CertificateID), ""))
		return soap->error;
	if (soap_out_string(soap, "tds:Subject", -1, &(a->_tds__CreateCertificate::Subject), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "tds:ValidNotBefore", -1, &(a->_tds__CreateCertificate::ValidNotBefore), ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "tds:ValidNotAfter", -1, &(a->_tds__CreateCertificate::ValidNotAfter), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateCertificate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__CreateCertificate(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateCertificate * SOAP_FMAC4 soap_in__tds__CreateCertificate(struct soap *soap, const char *tag, _tds__CreateCertificate *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateCertificate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateCertificate, sizeof(_tds__CreateCertificate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__CreateCertificate)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__CreateCertificate *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_CertificateID1 = 1;
	size_t soap_flag_Subject1 = 1;
	size_t soap_flag_ValidNotBefore1 = 1;
	size_t soap_flag_ValidNotAfter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tds:CertificateID", &(a->_tds__CreateCertificate::CertificateID), "xsd:token"))
				{	soap_flag_CertificateID1--;
					continue;
				}
			if (soap_flag_Subject1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:Subject", &(a->_tds__CreateCertificate::Subject), "xsd:string"))
				{	soap_flag_Subject1--;
					continue;
				}
			if (soap_flag_ValidNotBefore1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "tds:ValidNotBefore", &(a->_tds__CreateCertificate::ValidNotBefore), "xsd:dateTime"))
				{	soap_flag_ValidNotBefore1--;
					continue;
				}
			if (soap_flag_ValidNotAfter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "tds:ValidNotAfter", &(a->_tds__CreateCertificate::ValidNotAfter), "xsd:dateTime"))
				{	soap_flag_ValidNotAfter1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__CreateCertificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateCertificate, 0, sizeof(_tds__CreateCertificate), 0, soap_copy__tds__CreateCertificate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__CreateCertificate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__CreateCertificate);
	if (this->soap_out(soap, tag?tag:"tds:CreateCertificate", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateCertificate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateCertificate(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateCertificate * SOAP_FMAC4 soap_get__tds__CreateCertificate(struct soap *soap, _tds__CreateCertificate *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__CreateCertificate * SOAP_FMAC2 soap_instantiate__tds__CreateCertificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateCertificate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__CreateCertificate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__CreateCertificate);
		if (size)
			*size = sizeof(_tds__CreateCertificate);
		((_tds__CreateCertificate*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__CreateCertificate, n);
		if (size)
			*size = n * sizeof(_tds__CreateCertificate);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__CreateCertificate*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__CreateCertificate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__CreateCertificate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__CreateCertificate %p -> %p\n", q, p));
	*(_tds__CreateCertificate*)p = *(_tds__CreateCertificate*)q;
}

void _tds__SetAccessPolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__SetAccessPolicyResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__SetAccessPolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetAccessPolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, int id, const _tds__SetAccessPolicyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetAccessPolicyResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetAccessPolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetAccessPolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetAccessPolicyResponse * SOAP_FMAC4 soap_in__tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, _tds__SetAccessPolicyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetAccessPolicyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAccessPolicyResponse, sizeof(_tds__SetAccessPolicyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetAccessPolicyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetAccessPolicyResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetAccessPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAccessPolicyResponse, 0, sizeof(_tds__SetAccessPolicyResponse), 0, soap_copy__tds__SetAccessPolicyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__SetAccessPolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetAccessPolicyResponse);
	if (this->soap_out(soap, tag?tag:"tds:SetAccessPolicyResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetAccessPolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetAccessPolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetAccessPolicyResponse * SOAP_FMAC4 soap_get__tds__SetAccessPolicyResponse(struct soap *soap, _tds__SetAccessPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetAccessPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__tds__SetAccessPolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetAccessPolicyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetAccessPolicyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetAccessPolicyResponse);
		if (size)
			*size = sizeof(_tds__SetAccessPolicyResponse);
		((_tds__SetAccessPolicyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetAccessPolicyResponse, n);
		if (size)
			*size = n * sizeof(_tds__SetAccessPolicyResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetAccessPolicyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetAccessPolicyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetAccessPolicyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetAccessPolicyResponse %p -> %p\n", q, p));
	*(_tds__SetAccessPolicyResponse*)p = *(_tds__SetAccessPolicyResponse*)q;
}

void _tds__SetAccessPolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetAccessPolicy::PolicyFile = NULL;
	/* transient soap skipped */
}

void _tds__SetAccessPolicy::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__BinaryData(soap, &this->_tds__SetAccessPolicy::PolicyFile);
	/* transient soap skipped */
#endif
}

int _tds__SetAccessPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetAccessPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetAccessPolicy(struct soap *soap, const char *tag, int id, const _tds__SetAccessPolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetAccessPolicy), type))
		return soap->error;
	if (a->_tds__SetAccessPolicy::PolicyFile)
	{	if (soap_out_PointerTott__BinaryData(soap, "tds:PolicyFile", -1, &a->_tds__SetAccessPolicy::PolicyFile, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:PolicyFile"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetAccessPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetAccessPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetAccessPolicy * SOAP_FMAC4 soap_in__tds__SetAccessPolicy(struct soap *soap, const char *tag, _tds__SetAccessPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetAccessPolicy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAccessPolicy, sizeof(_tds__SetAccessPolicy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetAccessPolicy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetAccessPolicy *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PolicyFile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PolicyFile1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BinaryData(soap, "tds:PolicyFile", &(a->_tds__SetAccessPolicy::PolicyFile), "tt:BinaryData"))
				{	soap_flag_PolicyFile1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetAccessPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAccessPolicy, 0, sizeof(_tds__SetAccessPolicy), 0, soap_copy__tds__SetAccessPolicy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PolicyFile1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__SetAccessPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetAccessPolicy);
	if (this->soap_out(soap, tag?tag:"tds:SetAccessPolicy", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetAccessPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetAccessPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetAccessPolicy * SOAP_FMAC4 soap_get__tds__SetAccessPolicy(struct soap *soap, _tds__SetAccessPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetAccessPolicy * SOAP_FMAC2 soap_instantiate__tds__SetAccessPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetAccessPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetAccessPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetAccessPolicy);
		if (size)
			*size = sizeof(_tds__SetAccessPolicy);
		((_tds__SetAccessPolicy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetAccessPolicy, n);
		if (size)
			*size = n * sizeof(_tds__SetAccessPolicy);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetAccessPolicy*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetAccessPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetAccessPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetAccessPolicy %p -> %p\n", q, p));
	*(_tds__SetAccessPolicy*)p = *(_tds__SetAccessPolicy*)q;
}

void _tds__GetAccessPolicyResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetAccessPolicyResponse::PolicyFile = NULL;
	/* transient soap skipped */
}

void _tds__GetAccessPolicyResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__BinaryData(soap, &this->_tds__GetAccessPolicyResponse::PolicyFile);
	/* transient soap skipped */
#endif
}

int _tds__GetAccessPolicyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetAccessPolicyResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAccessPolicyResponse(struct soap *soap, const char *tag, int id, const _tds__GetAccessPolicyResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAccessPolicyResponse), type))
		return soap->error;
	if (a->PolicyFile)
		soap_element_result(soap, "tds:PolicyFile");
	if (a->_tds__GetAccessPolicyResponse::PolicyFile)
	{	if (soap_out_PointerTott__BinaryData(soap, "tds:PolicyFile", -1, &a->_tds__GetAccessPolicyResponse::PolicyFile, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:PolicyFile"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetAccessPolicyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetAccessPolicyResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetAccessPolicyResponse * SOAP_FMAC4 soap_in__tds__GetAccessPolicyResponse(struct soap *soap, const char *tag, _tds__GetAccessPolicyResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetAccessPolicyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAccessPolicyResponse, sizeof(_tds__GetAccessPolicyResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetAccessPolicyResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetAccessPolicyResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_PolicyFile1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PolicyFile1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BinaryData(soap, "tds:PolicyFile", &(a->_tds__GetAccessPolicyResponse::PolicyFile), "tt:BinaryData"))
				{	soap_flag_PolicyFile1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:PolicyFile");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetAccessPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAccessPolicyResponse, 0, sizeof(_tds__GetAccessPolicyResponse), 0, soap_copy__tds__GetAccessPolicyResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PolicyFile1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetAccessPolicyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetAccessPolicyResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetAccessPolicyResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetAccessPolicyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetAccessPolicyResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetAccessPolicyResponse * SOAP_FMAC4 soap_get__tds__GetAccessPolicyResponse(struct soap *soap, _tds__GetAccessPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAccessPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetAccessPolicyResponse * SOAP_FMAC2 soap_instantiate__tds__GetAccessPolicyResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetAccessPolicyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetAccessPolicyResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetAccessPolicyResponse);
		if (size)
			*size = sizeof(_tds__GetAccessPolicyResponse);
		((_tds__GetAccessPolicyResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetAccessPolicyResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetAccessPolicyResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetAccessPolicyResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetAccessPolicyResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetAccessPolicyResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetAccessPolicyResponse %p -> %p\n", q, p));
	*(_tds__GetAccessPolicyResponse*)p = *(_tds__GetAccessPolicyResponse*)q;
}

void _tds__GetAccessPolicy::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__GetAccessPolicy::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__GetAccessPolicy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetAccessPolicy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetAccessPolicy(struct soap *soap, const char *tag, int id, const _tds__GetAccessPolicy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetAccessPolicy), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetAccessPolicy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetAccessPolicy(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetAccessPolicy * SOAP_FMAC4 soap_in__tds__GetAccessPolicy(struct soap *soap, const char *tag, _tds__GetAccessPolicy *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetAccessPolicy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetAccessPolicy, sizeof(_tds__GetAccessPolicy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetAccessPolicy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetAccessPolicy *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetAccessPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetAccessPolicy, 0, sizeof(_tds__GetAccessPolicy), 0, soap_copy__tds__GetAccessPolicy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetAccessPolicy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetAccessPolicy);
	if (this->soap_out(soap, tag?tag:"tds:GetAccessPolicy", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetAccessPolicy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetAccessPolicy(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetAccessPolicy * SOAP_FMAC4 soap_get__tds__GetAccessPolicy(struct soap *soap, _tds__GetAccessPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetAccessPolicy * SOAP_FMAC2 soap_instantiate__tds__GetAccessPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetAccessPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetAccessPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetAccessPolicy);
		if (size)
			*size = sizeof(_tds__GetAccessPolicy);
		((_tds__GetAccessPolicy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetAccessPolicy, n);
		if (size)
			*size = n * sizeof(_tds__GetAccessPolicy);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetAccessPolicy*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetAccessPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetAccessPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetAccessPolicy %p -> %p\n", q, p));
	*(_tds__GetAccessPolicy*)p = *(_tds__GetAccessPolicy*)q;
}

void _tds__RemoveIPAddressFilterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__RemoveIPAddressFilterResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__RemoveIPAddressFilterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__RemoveIPAddressFilterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const _tds__RemoveIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__RemoveIPAddressFilterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__RemoveIPAddressFilterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__RemoveIPAddressFilterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__RemoveIPAddressFilterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, sizeof(_tds__RemoveIPAddressFilterResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__RemoveIPAddressFilterResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__RemoveIPAddressFilterResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__RemoveIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, 0, sizeof(_tds__RemoveIPAddressFilterResponse), 0, soap_copy__tds__RemoveIPAddressFilterResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__RemoveIPAddressFilterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__RemoveIPAddressFilterResponse);
	if (this->soap_out(soap, tag?tag:"tds:RemoveIPAddressFilterResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__RemoveIPAddressFilterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__RemoveIPAddressFilterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__RemoveIPAddressFilterResponse(struct soap *soap, _tds__RemoveIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__RemoveIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__RemoveIPAddressFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__RemoveIPAddressFilterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__RemoveIPAddressFilterResponse);
		if (size)
			*size = sizeof(_tds__RemoveIPAddressFilterResponse);
		((_tds__RemoveIPAddressFilterResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__RemoveIPAddressFilterResponse, n);
		if (size)
			*size = n * sizeof(_tds__RemoveIPAddressFilterResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__RemoveIPAddressFilterResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__RemoveIPAddressFilterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__RemoveIPAddressFilterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__RemoveIPAddressFilterResponse %p -> %p\n", q, p));
	*(_tds__RemoveIPAddressFilterResponse*)p = *(_tds__RemoveIPAddressFilterResponse*)q;
}

void _tds__RemoveIPAddressFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__RemoveIPAddressFilter::IPAddressFilter = NULL;
	/* transient soap skipped */
}

void _tds__RemoveIPAddressFilter::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPAddressFilter(soap, &this->_tds__RemoveIPAddressFilter::IPAddressFilter);
	/* transient soap skipped */
#endif
}

int _tds__RemoveIPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__RemoveIPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, int id, const _tds__RemoveIPAddressFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__RemoveIPAddressFilter), type))
		return soap->error;
	if (a->_tds__RemoveIPAddressFilter::IPAddressFilter)
	{	if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->_tds__RemoveIPAddressFilter::IPAddressFilter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:IPAddressFilter"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__RemoveIPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__RemoveIPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_in__tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, _tds__RemoveIPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__RemoveIPAddressFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(_tds__RemoveIPAddressFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__RemoveIPAddressFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__RemoveIPAddressFilter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_IPAddressFilter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &(a->_tds__RemoveIPAddressFilter::IPAddressFilter), "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__RemoveIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__RemoveIPAddressFilter, 0, sizeof(_tds__RemoveIPAddressFilter), 0, soap_copy__tds__RemoveIPAddressFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IPAddressFilter1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__RemoveIPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__RemoveIPAddressFilter);
	if (this->soap_out(soap, tag?tag:"tds:RemoveIPAddressFilter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__RemoveIPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__RemoveIPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 _tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_get__tds__RemoveIPAddressFilter(struct soap *soap, _tds__RemoveIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__RemoveIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__RemoveIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__RemoveIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__RemoveIPAddressFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__RemoveIPAddressFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__RemoveIPAddressFilter);
		if (size)
			*size = sizeof(_tds__RemoveIPAddressFilter);
		((_tds__RemoveIPAddressFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__RemoveIPAddressFilter, n);
		if (size)
			*size = n * sizeof(_tds__RemoveIPAddressFilter);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__RemoveIPAddressFilter*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__RemoveIPAddressFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__RemoveIPAddressFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__RemoveIPAddressFilter %p -> %p\n", q, p));
	*(_tds__RemoveIPAddressFilter*)p = *(_tds__RemoveIPAddressFilter*)q;
}

void _tds__AddIPAddressFilterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__AddIPAddressFilterResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__AddIPAddressFilterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__AddIPAddressFilterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const _tds__AddIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddIPAddressFilterResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__AddIPAddressFilterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__AddIPAddressFilterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__AddIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__AddIPAddressFilterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__AddIPAddressFilterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddIPAddressFilterResponse, sizeof(_tds__AddIPAddressFilterResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__AddIPAddressFilterResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__AddIPAddressFilterResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__AddIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddIPAddressFilterResponse, 0, sizeof(_tds__AddIPAddressFilterResponse), 0, soap_copy__tds__AddIPAddressFilterResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__AddIPAddressFilterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__AddIPAddressFilterResponse);
	if (this->soap_out(soap, tag?tag:"tds:AddIPAddressFilterResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__AddIPAddressFilterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__AddIPAddressFilterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__AddIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__AddIPAddressFilterResponse(struct soap *soap, _tds__AddIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__AddIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__AddIPAddressFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__AddIPAddressFilterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__AddIPAddressFilterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__AddIPAddressFilterResponse);
		if (size)
			*size = sizeof(_tds__AddIPAddressFilterResponse);
		((_tds__AddIPAddressFilterResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__AddIPAddressFilterResponse, n);
		if (size)
			*size = n * sizeof(_tds__AddIPAddressFilterResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__AddIPAddressFilterResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__AddIPAddressFilterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__AddIPAddressFilterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__AddIPAddressFilterResponse %p -> %p\n", q, p));
	*(_tds__AddIPAddressFilterResponse*)p = *(_tds__AddIPAddressFilterResponse*)q;
}

void _tds__AddIPAddressFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__AddIPAddressFilter::IPAddressFilter = NULL;
	/* transient soap skipped */
}

void _tds__AddIPAddressFilter::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPAddressFilter(soap, &this->_tds__AddIPAddressFilter::IPAddressFilter);
	/* transient soap skipped */
#endif
}

int _tds__AddIPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__AddIPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__AddIPAddressFilter(struct soap *soap, const char *tag, int id, const _tds__AddIPAddressFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__AddIPAddressFilter), type))
		return soap->error;
	if (a->_tds__AddIPAddressFilter::IPAddressFilter)
	{	if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->_tds__AddIPAddressFilter::IPAddressFilter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:IPAddressFilter"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__AddIPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__AddIPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 _tds__AddIPAddressFilter * SOAP_FMAC4 soap_in__tds__AddIPAddressFilter(struct soap *soap, const char *tag, _tds__AddIPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__AddIPAddressFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(_tds__AddIPAddressFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__AddIPAddressFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__AddIPAddressFilter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_IPAddressFilter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &(a->_tds__AddIPAddressFilter::IPAddressFilter), "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__AddIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__AddIPAddressFilter, 0, sizeof(_tds__AddIPAddressFilter), 0, soap_copy__tds__AddIPAddressFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IPAddressFilter1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__AddIPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__AddIPAddressFilter);
	if (this->soap_out(soap, tag?tag:"tds:AddIPAddressFilter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__AddIPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__AddIPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 _tds__AddIPAddressFilter * SOAP_FMAC4 soap_get__tds__AddIPAddressFilter(struct soap *soap, _tds__AddIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__AddIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__AddIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__AddIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__AddIPAddressFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__AddIPAddressFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__AddIPAddressFilter);
		if (size)
			*size = sizeof(_tds__AddIPAddressFilter);
		((_tds__AddIPAddressFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__AddIPAddressFilter, n);
		if (size)
			*size = n * sizeof(_tds__AddIPAddressFilter);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__AddIPAddressFilter*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__AddIPAddressFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__AddIPAddressFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__AddIPAddressFilter %p -> %p\n", q, p));
	*(_tds__AddIPAddressFilter*)p = *(_tds__AddIPAddressFilter*)q;
}

void _tds__SetIPAddressFilterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__SetIPAddressFilterResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__SetIPAddressFilterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetIPAddressFilterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const _tds__SetIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetIPAddressFilterResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetIPAddressFilterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetIPAddressFilterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__SetIPAddressFilterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetIPAddressFilterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetIPAddressFilterResponse, sizeof(_tds__SetIPAddressFilterResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetIPAddressFilterResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetIPAddressFilterResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetIPAddressFilterResponse, 0, sizeof(_tds__SetIPAddressFilterResponse), 0, soap_copy__tds__SetIPAddressFilterResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__SetIPAddressFilterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetIPAddressFilterResponse);
	if (this->soap_out(soap, tag?tag:"tds:SetIPAddressFilterResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetIPAddressFilterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetIPAddressFilterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__SetIPAddressFilterResponse(struct soap *soap, _tds__SetIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__SetIPAddressFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetIPAddressFilterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetIPAddressFilterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetIPAddressFilterResponse);
		if (size)
			*size = sizeof(_tds__SetIPAddressFilterResponse);
		((_tds__SetIPAddressFilterResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetIPAddressFilterResponse, n);
		if (size)
			*size = n * sizeof(_tds__SetIPAddressFilterResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetIPAddressFilterResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetIPAddressFilterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetIPAddressFilterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetIPAddressFilterResponse %p -> %p\n", q, p));
	*(_tds__SetIPAddressFilterResponse*)p = *(_tds__SetIPAddressFilterResponse*)q;
}

void _tds__SetIPAddressFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetIPAddressFilter::IPAddressFilter = NULL;
	/* transient soap skipped */
}

void _tds__SetIPAddressFilter::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPAddressFilter(soap, &this->_tds__SetIPAddressFilter::IPAddressFilter);
	/* transient soap skipped */
#endif
}

int _tds__SetIPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetIPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetIPAddressFilter(struct soap *soap, const char *tag, int id, const _tds__SetIPAddressFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetIPAddressFilter), type))
		return soap->error;
	if (a->_tds__SetIPAddressFilter::IPAddressFilter)
	{	if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->_tds__SetIPAddressFilter::IPAddressFilter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:IPAddressFilter"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetIPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetIPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetIPAddressFilter * SOAP_FMAC4 soap_in__tds__SetIPAddressFilter(struct soap *soap, const char *tag, _tds__SetIPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetIPAddressFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(_tds__SetIPAddressFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetIPAddressFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetIPAddressFilter *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_IPAddressFilter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &(a->_tds__SetIPAddressFilter::IPAddressFilter), "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetIPAddressFilter, 0, sizeof(_tds__SetIPAddressFilter), 0, soap_copy__tds__SetIPAddressFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IPAddressFilter1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__SetIPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetIPAddressFilter);
	if (this->soap_out(soap, tag?tag:"tds:SetIPAddressFilter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetIPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetIPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetIPAddressFilter * SOAP_FMAC4 soap_get__tds__SetIPAddressFilter(struct soap *soap, _tds__SetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__SetIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetIPAddressFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetIPAddressFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetIPAddressFilter);
		if (size)
			*size = sizeof(_tds__SetIPAddressFilter);
		((_tds__SetIPAddressFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetIPAddressFilter, n);
		if (size)
			*size = n * sizeof(_tds__SetIPAddressFilter);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetIPAddressFilter*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetIPAddressFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetIPAddressFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetIPAddressFilter %p -> %p\n", q, p));
	*(_tds__SetIPAddressFilter*)p = *(_tds__SetIPAddressFilter*)q;
}

void _tds__GetIPAddressFilterResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetIPAddressFilterResponse::IPAddressFilter = NULL;
	/* transient soap skipped */
}

void _tds__GetIPAddressFilterResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__IPAddressFilter(soap, &this->_tds__GetIPAddressFilterResponse::IPAddressFilter);
	/* transient soap skipped */
#endif
}

int _tds__GetIPAddressFilterResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetIPAddressFilterResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, const _tds__GetIPAddressFilterResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetIPAddressFilterResponse), type))
		return soap->error;
	if (a->IPAddressFilter)
		soap_element_result(soap, "tds:IPAddressFilter");
	if (a->_tds__GetIPAddressFilterResponse::IPAddressFilter)
	{	if (soap_out_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", -1, &a->_tds__GetIPAddressFilterResponse::IPAddressFilter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:IPAddressFilter"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetIPAddressFilterResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetIPAddressFilterResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetIPAddressFilterResponse * SOAP_FMAC4 soap_in__tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, _tds__GetIPAddressFilterResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetIPAddressFilterResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetIPAddressFilterResponse, sizeof(_tds__GetIPAddressFilterResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetIPAddressFilterResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetIPAddressFilterResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_IPAddressFilter1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_IPAddressFilter1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__IPAddressFilter(soap, "tds:IPAddressFilter", &(a->_tds__GetIPAddressFilterResponse::IPAddressFilter), "tt:IPAddressFilter"))
				{	soap_flag_IPAddressFilter1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:IPAddressFilter");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetIPAddressFilterResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetIPAddressFilterResponse, 0, sizeof(_tds__GetIPAddressFilterResponse), 0, soap_copy__tds__GetIPAddressFilterResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_IPAddressFilter1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetIPAddressFilterResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetIPAddressFilterResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetIPAddressFilterResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetIPAddressFilterResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetIPAddressFilterResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetIPAddressFilterResponse * SOAP_FMAC4 soap_get__tds__GetIPAddressFilterResponse(struct soap *soap, _tds__GetIPAddressFilterResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetIPAddressFilterResponse * SOAP_FMAC2 soap_instantiate__tds__GetIPAddressFilterResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetIPAddressFilterResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetIPAddressFilterResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetIPAddressFilterResponse);
		if (size)
			*size = sizeof(_tds__GetIPAddressFilterResponse);
		((_tds__GetIPAddressFilterResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetIPAddressFilterResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetIPAddressFilterResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetIPAddressFilterResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetIPAddressFilterResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetIPAddressFilterResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetIPAddressFilterResponse %p -> %p\n", q, p));
	*(_tds__GetIPAddressFilterResponse*)p = *(_tds__GetIPAddressFilterResponse*)q;
}

void _tds__GetIPAddressFilter::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__GetIPAddressFilter::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__GetIPAddressFilter::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetIPAddressFilter(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetIPAddressFilter(struct soap *soap, const char *tag, int id, const _tds__GetIPAddressFilter *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetIPAddressFilter), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetIPAddressFilter::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetIPAddressFilter(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetIPAddressFilter * SOAP_FMAC4 soap_in__tds__GetIPAddressFilter(struct soap *soap, const char *tag, _tds__GetIPAddressFilter *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetIPAddressFilter *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(_tds__GetIPAddressFilter), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetIPAddressFilter)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetIPAddressFilter *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetIPAddressFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetIPAddressFilter, 0, sizeof(_tds__GetIPAddressFilter), 0, soap_copy__tds__GetIPAddressFilter);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetIPAddressFilter::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetIPAddressFilter);
	if (this->soap_out(soap, tag?tag:"tds:GetIPAddressFilter", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetIPAddressFilter::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetIPAddressFilter(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetIPAddressFilter * SOAP_FMAC4 soap_get__tds__GetIPAddressFilter(struct soap *soap, _tds__GetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetIPAddressFilter * SOAP_FMAC2 soap_instantiate__tds__GetIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetIPAddressFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetIPAddressFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetIPAddressFilter);
		if (size)
			*size = sizeof(_tds__GetIPAddressFilter);
		((_tds__GetIPAddressFilter*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetIPAddressFilter, n);
		if (size)
			*size = n * sizeof(_tds__GetIPAddressFilter);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetIPAddressFilter*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetIPAddressFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetIPAddressFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetIPAddressFilter %p -> %p\n", q, p));
	*(_tds__GetIPAddressFilter*)p = *(_tds__GetIPAddressFilter*)q;
}

void _tds__SetZeroConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__SetZeroConfigurationResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__SetZeroConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetZeroConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetZeroConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__SetZeroConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetZeroConfigurationResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetZeroConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetZeroConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetZeroConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetZeroConfigurationResponse(struct soap *soap, const char *tag, _tds__SetZeroConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetZeroConfigurationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetZeroConfigurationResponse, sizeof(_tds__SetZeroConfigurationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetZeroConfigurationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetZeroConfigurationResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetZeroConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetZeroConfigurationResponse, 0, sizeof(_tds__SetZeroConfigurationResponse), 0, soap_copy__tds__SetZeroConfigurationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__SetZeroConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetZeroConfigurationResponse);
	if (this->soap_out(soap, tag?tag:"tds:SetZeroConfigurationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetZeroConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetZeroConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetZeroConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetZeroConfigurationResponse(struct soap *soap, _tds__SetZeroConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetZeroConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__SetZeroConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetZeroConfigurationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetZeroConfigurationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetZeroConfigurationResponse);
		if (size)
			*size = sizeof(_tds__SetZeroConfigurationResponse);
		((_tds__SetZeroConfigurationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetZeroConfigurationResponse, n);
		if (size)
			*size = n * sizeof(_tds__SetZeroConfigurationResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetZeroConfigurationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetZeroConfigurationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetZeroConfigurationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetZeroConfigurationResponse %p -> %p\n", q, p));
	*(_tds__SetZeroConfigurationResponse*)p = *(_tds__SetZeroConfigurationResponse*)q;
}

void _tds__SetZeroConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__SetZeroConfiguration::InterfaceToken);
	soap_default_bool(soap, &this->_tds__SetZeroConfiguration::Enabled);
	/* transient soap skipped */
}

void _tds__SetZeroConfiguration::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__SetZeroConfiguration::InterfaceToken);
	soap_embedded(soap, &this->_tds__SetZeroConfiguration::Enabled, SOAP_TYPE_bool);
	/* transient soap skipped */
#endif
}

int _tds__SetZeroConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetZeroConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetZeroConfiguration(struct soap *soap, const char *tag, int id, const _tds__SetZeroConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetZeroConfiguration), type))
		return soap->error;
	if (a->_tds__SetZeroConfiguration::InterfaceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->_tds__SetZeroConfiguration::InterfaceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:InterfaceToken"))
		return soap->error;
	if (soap_out_bool(soap, "tds:Enabled", -1, &(a->_tds__SetZeroConfiguration::Enabled), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetZeroConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetZeroConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetZeroConfiguration * SOAP_FMAC4 soap_in__tds__SetZeroConfiguration(struct soap *soap, const char *tag, _tds__SetZeroConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetZeroConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetZeroConfiguration, sizeof(_tds__SetZeroConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetZeroConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetZeroConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_InterfaceToken1 = 1;
	size_t soap_flag_Enabled1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &(a->_tds__SetZeroConfiguration::InterfaceToken), "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			if (soap_flag_Enabled1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tds:Enabled", &(a->_tds__SetZeroConfiguration::Enabled), "xsd:boolean"))
				{	soap_flag_Enabled1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetZeroConfiguration, 0, sizeof(_tds__SetZeroConfiguration), 0, soap_copy__tds__SetZeroConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken1 > 0 || soap_flag_Enabled1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__SetZeroConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetZeroConfiguration);
	if (this->soap_out(soap, tag?tag:"tds:SetZeroConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetZeroConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetZeroConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetZeroConfiguration * SOAP_FMAC4 soap_get__tds__SetZeroConfiguration(struct soap *soap, _tds__SetZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetZeroConfiguration * SOAP_FMAC2 soap_instantiate__tds__SetZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetZeroConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetZeroConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetZeroConfiguration);
		if (size)
			*size = sizeof(_tds__SetZeroConfiguration);
		((_tds__SetZeroConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetZeroConfiguration, n);
		if (size)
			*size = n * sizeof(_tds__SetZeroConfiguration);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetZeroConfiguration*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetZeroConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetZeroConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetZeroConfiguration %p -> %p\n", q, p));
	*(_tds__SetZeroConfiguration*)p = *(_tds__SetZeroConfiguration*)q;
}

void _tds__GetZeroConfigurationResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetZeroConfigurationResponse::ZeroConfiguration = NULL;
	/* transient soap skipped */
}

void _tds__GetZeroConfigurationResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__NetworkZeroConfiguration(soap, &this->_tds__GetZeroConfigurationResponse::ZeroConfiguration);
	/* transient soap skipped */
#endif
}

int _tds__GetZeroConfigurationResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetZeroConfigurationResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetZeroConfigurationResponse(struct soap *soap, const char *tag, int id, const _tds__GetZeroConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetZeroConfigurationResponse), type))
		return soap->error;
	if (a->ZeroConfiguration)
		soap_element_result(soap, "tds:ZeroConfiguration");
	if (a->_tds__GetZeroConfigurationResponse::ZeroConfiguration)
	{	if (soap_out_PointerTott__NetworkZeroConfiguration(soap, "tds:ZeroConfiguration", -1, &a->_tds__GetZeroConfigurationResponse::ZeroConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:ZeroConfiguration"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetZeroConfigurationResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetZeroConfigurationResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetZeroConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetZeroConfigurationResponse(struct soap *soap, const char *tag, _tds__GetZeroConfigurationResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetZeroConfigurationResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetZeroConfigurationResponse, sizeof(_tds__GetZeroConfigurationResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetZeroConfigurationResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetZeroConfigurationResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_ZeroConfiguration1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ZeroConfiguration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkZeroConfiguration(soap, "tds:ZeroConfiguration", &(a->_tds__GetZeroConfigurationResponse::ZeroConfiguration), "tt:NetworkZeroConfiguration"))
				{	soap_flag_ZeroConfiguration1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:ZeroConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetZeroConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetZeroConfigurationResponse, 0, sizeof(_tds__GetZeroConfigurationResponse), 0, soap_copy__tds__GetZeroConfigurationResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ZeroConfiguration1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetZeroConfigurationResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetZeroConfigurationResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetZeroConfigurationResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetZeroConfigurationResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetZeroConfigurationResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetZeroConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetZeroConfigurationResponse(struct soap *soap, _tds__GetZeroConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetZeroConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetZeroConfigurationResponse * SOAP_FMAC2 soap_instantiate__tds__GetZeroConfigurationResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetZeroConfigurationResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetZeroConfigurationResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetZeroConfigurationResponse);
		if (size)
			*size = sizeof(_tds__GetZeroConfigurationResponse);
		((_tds__GetZeroConfigurationResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetZeroConfigurationResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetZeroConfigurationResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetZeroConfigurationResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetZeroConfigurationResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetZeroConfigurationResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetZeroConfigurationResponse %p -> %p\n", q, p));
	*(_tds__GetZeroConfigurationResponse*)p = *(_tds__GetZeroConfigurationResponse*)q;
}

void _tds__GetZeroConfiguration::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__GetZeroConfiguration::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__GetZeroConfiguration::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetZeroConfiguration(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetZeroConfiguration(struct soap *soap, const char *tag, int id, const _tds__GetZeroConfiguration *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetZeroConfiguration), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetZeroConfiguration::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetZeroConfiguration(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetZeroConfiguration * SOAP_FMAC4 soap_in__tds__GetZeroConfiguration(struct soap *soap, const char *tag, _tds__GetZeroConfiguration *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetZeroConfiguration *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetZeroConfiguration, sizeof(_tds__GetZeroConfiguration), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetZeroConfiguration)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetZeroConfiguration *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetZeroConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetZeroConfiguration, 0, sizeof(_tds__GetZeroConfiguration), 0, soap_copy__tds__GetZeroConfiguration);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetZeroConfiguration::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetZeroConfiguration);
	if (this->soap_out(soap, tag?tag:"tds:GetZeroConfiguration", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetZeroConfiguration::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetZeroConfiguration(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetZeroConfiguration * SOAP_FMAC4 soap_get__tds__GetZeroConfiguration(struct soap *soap, _tds__GetZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetZeroConfiguration * SOAP_FMAC2 soap_instantiate__tds__GetZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetZeroConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetZeroConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetZeroConfiguration);
		if (size)
			*size = sizeof(_tds__GetZeroConfiguration);
		((_tds__GetZeroConfiguration*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetZeroConfiguration, n);
		if (size)
			*size = n * sizeof(_tds__GetZeroConfiguration);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetZeroConfiguration*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetZeroConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetZeroConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetZeroConfiguration %p -> %p\n", q, p));
	*(_tds__GetZeroConfiguration*)p = *(_tds__GetZeroConfiguration*)q;
}

void _tds__SetNetworkDefaultGatewayResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__SetNetworkDefaultGatewayResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__SetNetworkDefaultGatewayResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkDefaultGatewayResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, const _tds__SetNetworkDefaultGatewayResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkDefaultGatewayResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetNetworkDefaultGatewayResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_in__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, _tds__SetNetworkDefaultGatewayResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkDefaultGatewayResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(_tds__SetNetworkDefaultGatewayResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetNetworkDefaultGatewayResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNetworkDefaultGatewayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, 0, sizeof(_tds__SetNetworkDefaultGatewayResponse), 0, soap_copy__tds__SetNetworkDefaultGatewayResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__SetNetworkDefaultGatewayResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse);
	if (this->soap_out(soap, tag?tag:"tds:SetNetworkDefaultGatewayResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkDefaultGatewayResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkDefaultGatewayResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_get__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, _tds__SetNetworkDefaultGatewayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkDefaultGatewayResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetNetworkDefaultGatewayResponse);
		if (size)
			*size = sizeof(_tds__SetNetworkDefaultGatewayResponse);
		((_tds__SetNetworkDefaultGatewayResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetNetworkDefaultGatewayResponse, n);
		if (size)
			*size = n * sizeof(_tds__SetNetworkDefaultGatewayResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetNetworkDefaultGatewayResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetNetworkDefaultGatewayResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetNetworkDefaultGatewayResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetNetworkDefaultGatewayResponse %p -> %p\n", q, p));
	*(_tds__SetNetworkDefaultGatewayResponse*)p = *(_tds__SetNetworkDefaultGatewayResponse*)q;
}

void _tds__SetNetworkDefaultGateway::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetNetworkDefaultGateway::__sizeIPv4Address = 0;
	this->_tds__SetNetworkDefaultGateway::IPv4Address = NULL;
	this->_tds__SetNetworkDefaultGateway::__sizeIPv6Address = 0;
	this->_tds__SetNetworkDefaultGateway::IPv6Address = NULL;
	/* transient soap skipped */
}

void _tds__SetNetworkDefaultGateway::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__SetNetworkDefaultGateway::IPv4Address)
	{	int i;
		for (i = 0; i < this->_tds__SetNetworkDefaultGateway::__sizeIPv4Address; i++)
		{
			soap_serialize_tt__IPv4Address(soap, this->_tds__SetNetworkDefaultGateway::IPv4Address + i);
		}
	}
	if (this->_tds__SetNetworkDefaultGateway::IPv6Address)
	{	int i;
		for (i = 0; i < this->_tds__SetNetworkDefaultGateway::__sizeIPv6Address; i++)
		{
			soap_serialize_tt__IPv6Address(soap, this->_tds__SetNetworkDefaultGateway::IPv6Address + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__SetNetworkDefaultGateway::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkDefaultGateway(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const _tds__SetNetworkDefaultGateway *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkDefaultGateway), type))
		return soap->error;
	if (a->_tds__SetNetworkDefaultGateway::IPv4Address)
	{	int i;
		for (i = 0; i < a->_tds__SetNetworkDefaultGateway::__sizeIPv4Address; i++)
			if (soap_out_tt__IPv4Address(soap, "tds:IPv4Address", -1, a->_tds__SetNetworkDefaultGateway::IPv4Address + i, ""))
				return soap->error;
	}
	if (a->_tds__SetNetworkDefaultGateway::IPv6Address)
	{	int i;
		for (i = 0; i < a->_tds__SetNetworkDefaultGateway::__sizeIPv6Address; i++)
			if (soap_out_tt__IPv6Address(soap, "tds:IPv6Address", -1, a->_tds__SetNetworkDefaultGateway::IPv6Address + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkDefaultGateway::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetNetworkDefaultGateway(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_in__tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, _tds__SetNetworkDefaultGateway *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkDefaultGateway *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(_tds__SetNetworkDefaultGateway), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetNetworkDefaultGateway)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetNetworkDefaultGateway *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_IPv4Address1 = NULL;
	struct soap_blist *soap_blist_IPv6Address1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:IPv4Address", 1, NULL))
			{	if (a->_tds__SetNetworkDefaultGateway::IPv4Address == NULL)
				{	if (soap_blist_IPv4Address1 == NULL)
						soap_blist_IPv4Address1 = soap_new_block(soap);
					a->_tds__SetNetworkDefaultGateway::IPv4Address = (char **)soap_push_block(soap, soap_blist_IPv4Address1, sizeof(char *));
					if (a->_tds__SetNetworkDefaultGateway::IPv4Address == NULL)
						return NULL;
					*a->_tds__SetNetworkDefaultGateway::IPv4Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv4Address(soap, "tds:IPv4Address", a->_tds__SetNetworkDefaultGateway::IPv4Address, "tt:IPv4Address"))
				{	a->_tds__SetNetworkDefaultGateway::__sizeIPv4Address++;
					a->_tds__SetNetworkDefaultGateway::IPv4Address = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:IPv6Address", 1, NULL))
			{	if (a->_tds__SetNetworkDefaultGateway::IPv6Address == NULL)
				{	if (soap_blist_IPv6Address1 == NULL)
						soap_blist_IPv6Address1 = soap_new_block(soap);
					a->_tds__SetNetworkDefaultGateway::IPv6Address = (char **)soap_push_block(soap, soap_blist_IPv6Address1, sizeof(char *));
					if (a->_tds__SetNetworkDefaultGateway::IPv6Address == NULL)
						return NULL;
					*a->_tds__SetNetworkDefaultGateway::IPv6Address = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__IPv6Address(soap, "tds:IPv6Address", a->_tds__SetNetworkDefaultGateway::IPv6Address, "tt:IPv6Address"))
				{	a->_tds__SetNetworkDefaultGateway::__sizeIPv6Address++;
					a->_tds__SetNetworkDefaultGateway::IPv6Address = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__SetNetworkDefaultGateway::IPv4Address)
			soap_pop_block(soap, soap_blist_IPv4Address1);
		if (a->_tds__SetNetworkDefaultGateway::__sizeIPv4Address)
			a->_tds__SetNetworkDefaultGateway::IPv4Address = (char **)soap_save_block(soap, soap_blist_IPv4Address1, NULL, 1);
		else
		{	a->_tds__SetNetworkDefaultGateway::IPv4Address = NULL;
			if (soap_blist_IPv4Address1)
				soap_end_block(soap, soap_blist_IPv4Address1);
		}
		if (a->_tds__SetNetworkDefaultGateway::IPv6Address)
			soap_pop_block(soap, soap_blist_IPv6Address1);
		if (a->_tds__SetNetworkDefaultGateway::__sizeIPv6Address)
			a->_tds__SetNetworkDefaultGateway::IPv6Address = (char **)soap_save_block(soap, soap_blist_IPv6Address1, NULL, 1);
		else
		{	a->_tds__SetNetworkDefaultGateway::IPv6Address = NULL;
			if (soap_blist_IPv6Address1)
				soap_end_block(soap, soap_blist_IPv6Address1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNetworkDefaultGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkDefaultGateway, 0, sizeof(_tds__SetNetworkDefaultGateway), 0, soap_copy__tds__SetNetworkDefaultGateway);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__SetNetworkDefaultGateway::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetNetworkDefaultGateway);
	if (this->soap_out(soap, tag?tag:"tds:SetNetworkDefaultGateway", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkDefaultGateway::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkDefaultGateway(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_get__tds__SetNetworkDefaultGateway(struct soap *soap, _tds__SetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__tds__SetNetworkDefaultGateway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkDefaultGateway(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetNetworkDefaultGateway, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetNetworkDefaultGateway);
		if (size)
			*size = sizeof(_tds__SetNetworkDefaultGateway);
		((_tds__SetNetworkDefaultGateway*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetNetworkDefaultGateway, n);
		if (size)
			*size = n * sizeof(_tds__SetNetworkDefaultGateway);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetNetworkDefaultGateway*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetNetworkDefaultGateway*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetNetworkDefaultGateway(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetNetworkDefaultGateway %p -> %p\n", q, p));
	*(_tds__SetNetworkDefaultGateway*)p = *(_tds__SetNetworkDefaultGateway*)q;
}

void _tds__GetNetworkDefaultGatewayResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway = NULL;
	/* transient soap skipped */
}

void _tds__GetNetworkDefaultGatewayResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__NetworkGateway(soap, &this->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway);
	/* transient soap skipped */
#endif
}

int _tds__GetNetworkDefaultGatewayResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkDefaultGatewayResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, const _tds__GetNetworkDefaultGatewayResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse), type))
		return soap->error;
	if (a->NetworkGateway)
		soap_element_result(soap, "tds:NetworkGateway");
	if (a->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway)
	{	if (soap_out_PointerTott__NetworkGateway(soap, "tds:NetworkGateway", -1, &a->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:NetworkGateway"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkDefaultGatewayResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetNetworkDefaultGatewayResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_in__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, _tds__GetNetworkDefaultGatewayResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkDefaultGatewayResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(_tds__GetNetworkDefaultGatewayResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetNetworkDefaultGatewayResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_NetworkGateway1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NetworkGateway1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkGateway(soap, "tds:NetworkGateway", &(a->_tds__GetNetworkDefaultGatewayResponse::NetworkGateway), "tt:NetworkGateway"))
				{	soap_flag_NetworkGateway1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:NetworkGateway");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNetworkDefaultGatewayResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, 0, sizeof(_tds__GetNetworkDefaultGatewayResponse), 0, soap_copy__tds__GetNetworkDefaultGatewayResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NetworkGateway1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetNetworkDefaultGatewayResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetNetworkDefaultGatewayResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkDefaultGatewayResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkDefaultGatewayResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC4 soap_get__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, _tds__GetNetworkDefaultGatewayResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetNetworkDefaultGatewayResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkDefaultGatewayResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetNetworkDefaultGatewayResponse);
		if (size)
			*size = sizeof(_tds__GetNetworkDefaultGatewayResponse);
		((_tds__GetNetworkDefaultGatewayResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetNetworkDefaultGatewayResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetNetworkDefaultGatewayResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetNetworkDefaultGatewayResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetNetworkDefaultGatewayResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetNetworkDefaultGatewayResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetNetworkDefaultGatewayResponse %p -> %p\n", q, p));
	*(_tds__GetNetworkDefaultGatewayResponse*)p = *(_tds__GetNetworkDefaultGatewayResponse*)q;
}

void _tds__GetNetworkDefaultGateway::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__GetNetworkDefaultGateway::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__GetNetworkDefaultGateway::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkDefaultGateway(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const _tds__GetNetworkDefaultGateway *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkDefaultGateway), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkDefaultGateway::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetNetworkDefaultGateway(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_in__tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, _tds__GetNetworkDefaultGateway *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkDefaultGateway *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(_tds__GetNetworkDefaultGateway), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetNetworkDefaultGateway)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetNetworkDefaultGateway *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNetworkDefaultGateway *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkDefaultGateway, 0, sizeof(_tds__GetNetworkDefaultGateway), 0, soap_copy__tds__GetNetworkDefaultGateway);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetNetworkDefaultGateway::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetNetworkDefaultGateway);
	if (this->soap_out(soap, tag?tag:"tds:GetNetworkDefaultGateway", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkDefaultGateway::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkDefaultGateway(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_get__tds__GetNetworkDefaultGateway(struct soap *soap, _tds__GetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate__tds__GetNetworkDefaultGateway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkDefaultGateway(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetNetworkDefaultGateway, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetNetworkDefaultGateway);
		if (size)
			*size = sizeof(_tds__GetNetworkDefaultGateway);
		((_tds__GetNetworkDefaultGateway*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetNetworkDefaultGateway, n);
		if (size)
			*size = n * sizeof(_tds__GetNetworkDefaultGateway);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetNetworkDefaultGateway*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetNetworkDefaultGateway*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetNetworkDefaultGateway(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetNetworkDefaultGateway %p -> %p\n", q, p));
	*(_tds__GetNetworkDefaultGateway*)p = *(_tds__GetNetworkDefaultGateway*)q;
}

void _tds__SetNetworkProtocolsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__SetNetworkProtocolsResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__SetNetworkProtocolsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkProtocolsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, const _tds__SetNetworkProtocolsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkProtocolsResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkProtocolsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetNetworkProtocolsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkProtocolsResponse * SOAP_FMAC4 soap_in__tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, _tds__SetNetworkProtocolsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkProtocolsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(_tds__SetNetworkProtocolsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetNetworkProtocolsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetNetworkProtocolsResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNetworkProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkProtocolsResponse, 0, sizeof(_tds__SetNetworkProtocolsResponse), 0, soap_copy__tds__SetNetworkProtocolsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__SetNetworkProtocolsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetNetworkProtocolsResponse);
	if (this->soap_out(soap, tag?tag:"tds:SetNetworkProtocolsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkProtocolsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkProtocolsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkProtocolsResponse * SOAP_FMAC4 soap_get__tds__SetNetworkProtocolsResponse(struct soap *soap, _tds__SetNetworkProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkProtocolsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkProtocolsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetNetworkProtocolsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetNetworkProtocolsResponse);
		if (size)
			*size = sizeof(_tds__SetNetworkProtocolsResponse);
		((_tds__SetNetworkProtocolsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetNetworkProtocolsResponse, n);
		if (size)
			*size = n * sizeof(_tds__SetNetworkProtocolsResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetNetworkProtocolsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetNetworkProtocolsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetNetworkProtocolsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetNetworkProtocolsResponse %p -> %p\n", q, p));
	*(_tds__SetNetworkProtocolsResponse*)p = *(_tds__SetNetworkProtocolsResponse*)q;
}

void _tds__SetNetworkProtocols::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetNetworkProtocols::__sizeNetworkProtocols = 0;
	this->_tds__SetNetworkProtocols::NetworkProtocols = NULL;
	/* transient soap skipped */
}

void _tds__SetNetworkProtocols::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__SetNetworkProtocols::NetworkProtocols)
	{	int i;
		for (i = 0; i < this->_tds__SetNetworkProtocols::__sizeNetworkProtocols; i++)
		{
			soap_serialize_PointerTott__NetworkProtocol(soap, this->_tds__SetNetworkProtocols::NetworkProtocols + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__SetNetworkProtocols::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkProtocols(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkProtocols(struct soap *soap, const char *tag, int id, const _tds__SetNetworkProtocols *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkProtocols), type))
		return soap->error;
	if (a->_tds__SetNetworkProtocols::NetworkProtocols)
	{	int i;
		for (i = 0; i < a->_tds__SetNetworkProtocols::__sizeNetworkProtocols; i++)
			if (soap_out_PointerTott__NetworkProtocol(soap, "tds:NetworkProtocols", -1, a->_tds__SetNetworkProtocols::NetworkProtocols + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkProtocols::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetNetworkProtocols(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkProtocols * SOAP_FMAC4 soap_in__tds__SetNetworkProtocols(struct soap *soap, const char *tag, _tds__SetNetworkProtocols *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkProtocols *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(_tds__SetNetworkProtocols), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetNetworkProtocols)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetNetworkProtocols *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_NetworkProtocols1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NetworkProtocols", 1, NULL))
			{	if (a->_tds__SetNetworkProtocols::NetworkProtocols == NULL)
				{	if (soap_blist_NetworkProtocols1 == NULL)
						soap_blist_NetworkProtocols1 = soap_new_block(soap);
					a->_tds__SetNetworkProtocols::NetworkProtocols = (tt__NetworkProtocol **)soap_push_block(soap, soap_blist_NetworkProtocols1, sizeof(tt__NetworkProtocol *));
					if (a->_tds__SetNetworkProtocols::NetworkProtocols == NULL)
						return NULL;
					*a->_tds__SetNetworkProtocols::NetworkProtocols = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__NetworkProtocol(soap, "tds:NetworkProtocols", a->_tds__SetNetworkProtocols::NetworkProtocols, "tt:NetworkProtocol"))
				{	a->_tds__SetNetworkProtocols::__sizeNetworkProtocols++;
					a->_tds__SetNetworkProtocols::NetworkProtocols = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__SetNetworkProtocols::NetworkProtocols)
			soap_pop_block(soap, soap_blist_NetworkProtocols1);
		if (a->_tds__SetNetworkProtocols::__sizeNetworkProtocols)
			a->_tds__SetNetworkProtocols::NetworkProtocols = (tt__NetworkProtocol **)soap_save_block(soap, soap_blist_NetworkProtocols1, NULL, 1);
		else
		{	a->_tds__SetNetworkProtocols::NetworkProtocols = NULL;
			if (soap_blist_NetworkProtocols1)
				soap_end_block(soap, soap_blist_NetworkProtocols1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNetworkProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkProtocols, 0, sizeof(_tds__SetNetworkProtocols), 0, soap_copy__tds__SetNetworkProtocols);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__SetNetworkProtocols::__sizeNetworkProtocols < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__SetNetworkProtocols::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetNetworkProtocols);
	if (this->soap_out(soap, tag?tag:"tds:SetNetworkProtocols", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkProtocols::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkProtocols(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkProtocols * SOAP_FMAC4 soap_get__tds__SetNetworkProtocols(struct soap *soap, _tds__SetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetNetworkProtocols * SOAP_FMAC2 soap_instantiate__tds__SetNetworkProtocols(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkProtocols(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetNetworkProtocols, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetNetworkProtocols);
		if (size)
			*size = sizeof(_tds__SetNetworkProtocols);
		((_tds__SetNetworkProtocols*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetNetworkProtocols, n);
		if (size)
			*size = n * sizeof(_tds__SetNetworkProtocols);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetNetworkProtocols*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetNetworkProtocols*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetNetworkProtocols(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetNetworkProtocols %p -> %p\n", q, p));
	*(_tds__SetNetworkProtocols*)p = *(_tds__SetNetworkProtocols*)q;
}

void _tds__GetNetworkProtocolsResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetNetworkProtocolsResponse::__sizeNetworkProtocols = 0;
	this->_tds__GetNetworkProtocolsResponse::NetworkProtocols = NULL;
	/* transient soap skipped */
}

void _tds__GetNetworkProtocolsResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__GetNetworkProtocolsResponse::NetworkProtocols)
	{	int i;
		for (i = 0; i < this->_tds__GetNetworkProtocolsResponse::__sizeNetworkProtocols; i++)
		{
			soap_serialize_PointerTott__NetworkProtocol(soap, this->_tds__GetNetworkProtocolsResponse::NetworkProtocols + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__GetNetworkProtocolsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkProtocolsResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, const _tds__GetNetworkProtocolsResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkProtocolsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNetworkProtocols");
	if (a->_tds__GetNetworkProtocolsResponse::NetworkProtocols)
	{	int i;
		for (i = 0; i < a->_tds__GetNetworkProtocolsResponse::__sizeNetworkProtocols; i++)
			if (soap_out_PointerTott__NetworkProtocol(soap, "tds:NetworkProtocols", -1, a->_tds__GetNetworkProtocolsResponse::NetworkProtocols + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkProtocolsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetNetworkProtocolsResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkProtocolsResponse * SOAP_FMAC4 soap_in__tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, _tds__GetNetworkProtocolsResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkProtocolsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(_tds__GetNetworkProtocolsResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetNetworkProtocolsResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetNetworkProtocolsResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_NetworkProtocols1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NetworkProtocols", 1, NULL))
			{	if (a->_tds__GetNetworkProtocolsResponse::NetworkProtocols == NULL)
				{	if (soap_blist_NetworkProtocols1 == NULL)
						soap_blist_NetworkProtocols1 = soap_new_block(soap);
					a->_tds__GetNetworkProtocolsResponse::NetworkProtocols = (tt__NetworkProtocol **)soap_push_block(soap, soap_blist_NetworkProtocols1, sizeof(tt__NetworkProtocol *));
					if (a->_tds__GetNetworkProtocolsResponse::NetworkProtocols == NULL)
						return NULL;
					*a->_tds__GetNetworkProtocolsResponse::NetworkProtocols = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__NetworkProtocol(soap, "tds:NetworkProtocols", a->_tds__GetNetworkProtocolsResponse::NetworkProtocols, "tt:NetworkProtocol"))
				{	a->_tds__GetNetworkProtocolsResponse::__sizeNetworkProtocols++;
					a->_tds__GetNetworkProtocolsResponse::NetworkProtocols = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			soap_check_result(soap, "-sizeNetworkProtocols");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__GetNetworkProtocolsResponse::NetworkProtocols)
			soap_pop_block(soap, soap_blist_NetworkProtocols1);
		if (a->_tds__GetNetworkProtocolsResponse::__sizeNetworkProtocols)
			a->_tds__GetNetworkProtocolsResponse::NetworkProtocols = (tt__NetworkProtocol **)soap_save_block(soap, soap_blist_NetworkProtocols1, NULL, 1);
		else
		{	a->_tds__GetNetworkProtocolsResponse::NetworkProtocols = NULL;
			if (soap_blist_NetworkProtocols1)
				soap_end_block(soap, soap_blist_NetworkProtocols1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNetworkProtocolsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkProtocolsResponse, 0, sizeof(_tds__GetNetworkProtocolsResponse), 0, soap_copy__tds__GetNetworkProtocolsResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetNetworkProtocolsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetNetworkProtocolsResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetNetworkProtocolsResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkProtocolsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkProtocolsResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkProtocolsResponse * SOAP_FMAC4 soap_get__tds__GetNetworkProtocolsResponse(struct soap *soap, _tds__GetNetworkProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetNetworkProtocolsResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkProtocolsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkProtocolsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetNetworkProtocolsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetNetworkProtocolsResponse);
		if (size)
			*size = sizeof(_tds__GetNetworkProtocolsResponse);
		((_tds__GetNetworkProtocolsResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetNetworkProtocolsResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetNetworkProtocolsResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetNetworkProtocolsResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetNetworkProtocolsResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetNetworkProtocolsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetNetworkProtocolsResponse %p -> %p\n", q, p));
	*(_tds__GetNetworkProtocolsResponse*)p = *(_tds__GetNetworkProtocolsResponse*)q;
}

void _tds__GetNetworkProtocols::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__GetNetworkProtocols::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__GetNetworkProtocols::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkProtocols(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkProtocols(struct soap *soap, const char *tag, int id, const _tds__GetNetworkProtocols *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkProtocols), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkProtocols::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetNetworkProtocols(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkProtocols * SOAP_FMAC4 soap_in__tds__GetNetworkProtocols(struct soap *soap, const char *tag, _tds__GetNetworkProtocols *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkProtocols *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(_tds__GetNetworkProtocols), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetNetworkProtocols)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetNetworkProtocols *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNetworkProtocols *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkProtocols, 0, sizeof(_tds__GetNetworkProtocols), 0, soap_copy__tds__GetNetworkProtocols);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetNetworkProtocols::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetNetworkProtocols);
	if (this->soap_out(soap, tag?tag:"tds:GetNetworkProtocols", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkProtocols::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkProtocols(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkProtocols * SOAP_FMAC4 soap_get__tds__GetNetworkProtocols(struct soap *soap, _tds__GetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetNetworkProtocols * SOAP_FMAC2 soap_instantiate__tds__GetNetworkProtocols(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkProtocols(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetNetworkProtocols, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetNetworkProtocols);
		if (size)
			*size = sizeof(_tds__GetNetworkProtocols);
		((_tds__GetNetworkProtocols*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetNetworkProtocols, n);
		if (size)
			*size = n * sizeof(_tds__GetNetworkProtocols);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetNetworkProtocols*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetNetworkProtocols*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetNetworkProtocols(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetNetworkProtocols %p -> %p\n", q, p));
	*(_tds__GetNetworkProtocols*)p = *(_tds__GetNetworkProtocols*)q;
}

void _tds__SetNetworkInterfacesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetNetworkInterfacesResponse::RebootNeeded);
	/* transient soap skipped */
}

void _tds__SetNetworkInterfacesResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_tds__SetNetworkInterfacesResponse::RebootNeeded, SOAP_TYPE_bool);
	/* transient soap skipped */
#endif
}

int _tds__SetNetworkInterfacesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkInterfacesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, const _tds__SetNetworkInterfacesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkInterfacesResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RebootNeeded");
	if (soap_out_bool(soap, "tds:RebootNeeded", -1, &(a->_tds__SetNetworkInterfacesResponse::RebootNeeded), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkInterfacesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetNetworkInterfacesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkInterfacesResponse * SOAP_FMAC4 soap_in__tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, _tds__SetNetworkInterfacesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkInterfacesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(_tds__SetNetworkInterfacesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetNetworkInterfacesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetNetworkInterfacesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RebootNeeded1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RebootNeeded1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tds:RebootNeeded", &(a->_tds__SetNetworkInterfacesResponse::RebootNeeded), "xsd:boolean"))
				{	soap_flag_RebootNeeded1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:RebootNeeded");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNetworkInterfacesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkInterfacesResponse, 0, sizeof(_tds__SetNetworkInterfacesResponse), 0, soap_copy__tds__SetNetworkInterfacesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RebootNeeded1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__SetNetworkInterfacesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetNetworkInterfacesResponse);
	if (this->soap_out(soap, tag?tag:"tds:SetNetworkInterfacesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkInterfacesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkInterfacesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkInterfacesResponse * SOAP_FMAC4 soap_get__tds__SetNetworkInterfacesResponse(struct soap *soap, _tds__SetNetworkInterfacesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__tds__SetNetworkInterfacesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkInterfacesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetNetworkInterfacesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetNetworkInterfacesResponse);
		if (size)
			*size = sizeof(_tds__SetNetworkInterfacesResponse);
		((_tds__SetNetworkInterfacesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetNetworkInterfacesResponse, n);
		if (size)
			*size = n * sizeof(_tds__SetNetworkInterfacesResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetNetworkInterfacesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetNetworkInterfacesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetNetworkInterfacesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetNetworkInterfacesResponse %p -> %p\n", q, p));
	*(_tds__SetNetworkInterfacesResponse*)p = *(_tds__SetNetworkInterfacesResponse*)q;
}

void _tds__SetNetworkInterfaces::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__ReferenceToken(soap, &this->_tds__SetNetworkInterfaces::InterfaceToken);
	this->_tds__SetNetworkInterfaces::NetworkInterface = NULL;
	/* transient soap skipped */
}

void _tds__SetNetworkInterfaces::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &this->_tds__SetNetworkInterfaces::InterfaceToken);
	soap_serialize_PointerTott__NetworkInterfaceSetConfiguration(soap, &this->_tds__SetNetworkInterfaces::NetworkInterface);
	/* transient soap skipped */
#endif
}

int _tds__SetNetworkInterfaces::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNetworkInterfaces(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNetworkInterfaces(struct soap *soap, const char *tag, int id, const _tds__SetNetworkInterfaces *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNetworkInterfaces), type))
		return soap->error;
	if (a->_tds__SetNetworkInterfaces::InterfaceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->_tds__SetNetworkInterfaces::InterfaceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:InterfaceToken"))
		return soap->error;
	if (a->_tds__SetNetworkInterfaces::NetworkInterface)
	{	if (soap_out_PointerTott__NetworkInterfaceSetConfiguration(soap, "tds:NetworkInterface", -1, &a->_tds__SetNetworkInterfaces::NetworkInterface, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:NetworkInterface"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNetworkInterfaces::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetNetworkInterfaces(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNetworkInterfaces * SOAP_FMAC4 soap_in__tds__SetNetworkInterfaces(struct soap *soap, const char *tag, _tds__SetNetworkInterfaces *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNetworkInterfaces *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(_tds__SetNetworkInterfaces), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetNetworkInterfaces)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetNetworkInterfaces *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_InterfaceToken1 = 1;
	size_t soap_flag_NetworkInterface1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &(a->_tds__SetNetworkInterfaces::InterfaceToken), "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken1--;
					continue;
				}
			if (soap_flag_NetworkInterface1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NetworkInterfaceSetConfiguration(soap, "tds:NetworkInterface", &(a->_tds__SetNetworkInterfaces::NetworkInterface), "tt:NetworkInterfaceSetConfiguration"))
				{	soap_flag_NetworkInterface1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNetworkInterfaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNetworkInterfaces, 0, sizeof(_tds__SetNetworkInterfaces), 0, soap_copy__tds__SetNetworkInterfaces);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken1 > 0 || soap_flag_NetworkInterface1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__SetNetworkInterfaces::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetNetworkInterfaces);
	if (this->soap_out(soap, tag?tag:"tds:SetNetworkInterfaces", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNetworkInterfaces::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNetworkInterfaces(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNetworkInterfaces * SOAP_FMAC4 soap_get__tds__SetNetworkInterfaces(struct soap *soap, _tds__SetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__tds__SetNetworkInterfaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNetworkInterfaces(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetNetworkInterfaces, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetNetworkInterfaces);
		if (size)
			*size = sizeof(_tds__SetNetworkInterfaces);
		((_tds__SetNetworkInterfaces*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetNetworkInterfaces, n);
		if (size)
			*size = n * sizeof(_tds__SetNetworkInterfaces);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetNetworkInterfaces*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetNetworkInterfaces*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetNetworkInterfaces(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetNetworkInterfaces %p -> %p\n", q, p));
	*(_tds__SetNetworkInterfaces*)p = *(_tds__SetNetworkInterfaces*)q;
}

void _tds__GetNetworkInterfacesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetNetworkInterfacesResponse::__sizeNetworkInterfaces = 0;
	this->_tds__GetNetworkInterfacesResponse::NetworkInterfaces = NULL;
	/* transient soap skipped */
}

void _tds__GetNetworkInterfacesResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__GetNetworkInterfacesResponse::NetworkInterfaces)
	{	int i;
		for (i = 0; i < this->_tds__GetNetworkInterfacesResponse::__sizeNetworkInterfaces; i++)
		{
			soap_serialize_PointerTott__NetworkInterface(soap, this->_tds__GetNetworkInterfacesResponse::NetworkInterfaces + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__GetNetworkInterfacesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkInterfacesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, const _tds__GetNetworkInterfacesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkInterfacesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNetworkInterfaces");
	if (a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces)
	{	int i;
		for (i = 0; i < a->_tds__GetNetworkInterfacesResponse::__sizeNetworkInterfaces; i++)
			if (soap_out_PointerTott__NetworkInterface(soap, "tds:NetworkInterfaces", -1, a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkInterfacesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetNetworkInterfacesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkInterfacesResponse * SOAP_FMAC4 soap_in__tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, _tds__GetNetworkInterfacesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkInterfacesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(_tds__GetNetworkInterfacesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetNetworkInterfacesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetNetworkInterfacesResponse *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_NetworkInterfaces1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NetworkInterfaces", 1, NULL))
			{	if (a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces == NULL)
				{	if (soap_blist_NetworkInterfaces1 == NULL)
						soap_blist_NetworkInterfaces1 = soap_new_block(soap);
					a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces = (tt__NetworkInterface **)soap_push_block(soap, soap_blist_NetworkInterfaces1, sizeof(tt__NetworkInterface *));
					if (a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces == NULL)
						return NULL;
					*a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__NetworkInterface(soap, "tds:NetworkInterfaces", a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces, "tt:NetworkInterface"))
				{	a->_tds__GetNetworkInterfacesResponse::__sizeNetworkInterfaces++;
					a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			soap_check_result(soap, "-sizeNetworkInterfaces");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces)
			soap_pop_block(soap, soap_blist_NetworkInterfaces1);
		if (a->_tds__GetNetworkInterfacesResponse::__sizeNetworkInterfaces)
			a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces = (tt__NetworkInterface **)soap_save_block(soap, soap_blist_NetworkInterfaces1, NULL, 1);
		else
		{	a->_tds__GetNetworkInterfacesResponse::NetworkInterfaces = NULL;
			if (soap_blist_NetworkInterfaces1)
				soap_end_block(soap, soap_blist_NetworkInterfaces1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNetworkInterfacesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkInterfacesResponse, 0, sizeof(_tds__GetNetworkInterfacesResponse), 0, soap_copy__tds__GetNetworkInterfacesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__GetNetworkInterfacesResponse::__sizeNetworkInterfaces < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetNetworkInterfacesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetNetworkInterfacesResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetNetworkInterfacesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkInterfacesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkInterfacesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkInterfacesResponse * SOAP_FMAC4 soap_get__tds__GetNetworkInterfacesResponse(struct soap *soap, _tds__GetNetworkInterfacesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetNetworkInterfacesResponse * SOAP_FMAC2 soap_instantiate__tds__GetNetworkInterfacesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkInterfacesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetNetworkInterfacesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetNetworkInterfacesResponse);
		if (size)
			*size = sizeof(_tds__GetNetworkInterfacesResponse);
		((_tds__GetNetworkInterfacesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetNetworkInterfacesResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetNetworkInterfacesResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetNetworkInterfacesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetNetworkInterfacesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetNetworkInterfacesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetNetworkInterfacesResponse %p -> %p\n", q, p));
	*(_tds__GetNetworkInterfacesResponse*)p = *(_tds__GetNetworkInterfacesResponse*)q;
}

void _tds__GetNetworkInterfaces::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__GetNetworkInterfaces::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__GetNetworkInterfaces::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNetworkInterfaces(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNetworkInterfaces(struct soap *soap, const char *tag, int id, const _tds__GetNetworkInterfaces *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNetworkInterfaces), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNetworkInterfaces::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetNetworkInterfaces(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNetworkInterfaces * SOAP_FMAC4 soap_in__tds__GetNetworkInterfaces(struct soap *soap, const char *tag, _tds__GetNetworkInterfaces *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNetworkInterfaces *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(_tds__GetNetworkInterfaces), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetNetworkInterfaces)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetNetworkInterfaces *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNetworkInterfaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNetworkInterfaces, 0, sizeof(_tds__GetNetworkInterfaces), 0, soap_copy__tds__GetNetworkInterfaces);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetNetworkInterfaces::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetNetworkInterfaces);
	if (this->soap_out(soap, tag?tag:"tds:GetNetworkInterfaces", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNetworkInterfaces::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNetworkInterfaces(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNetworkInterfaces * SOAP_FMAC4 soap_get__tds__GetNetworkInterfaces(struct soap *soap, _tds__GetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetNetworkInterfaces * SOAP_FMAC2 soap_instantiate__tds__GetNetworkInterfaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNetworkInterfaces(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetNetworkInterfaces, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetNetworkInterfaces);
		if (size)
			*size = sizeof(_tds__GetNetworkInterfaces);
		((_tds__GetNetworkInterfaces*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetNetworkInterfaces, n);
		if (size)
			*size = n * sizeof(_tds__GetNetworkInterfaces);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetNetworkInterfaces*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetNetworkInterfaces*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetNetworkInterfaces(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetNetworkInterfaces %p -> %p\n", q, p));
	*(_tds__GetNetworkInterfaces*)p = *(_tds__GetNetworkInterfaces*)q;
}

void _tds__SetDynamicDNSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__SetDynamicDNSResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__SetDynamicDNSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDynamicDNSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, int id, const _tds__SetDynamicDNSResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDynamicDNSResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDynamicDNSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetDynamicDNSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDynamicDNSResponse * SOAP_FMAC4 soap_in__tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, _tds__SetDynamicDNSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDynamicDNSResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(_tds__SetDynamicDNSResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetDynamicDNSResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetDynamicDNSResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDynamicDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDynamicDNSResponse, 0, sizeof(_tds__SetDynamicDNSResponse), 0, soap_copy__tds__SetDynamicDNSResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__SetDynamicDNSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetDynamicDNSResponse);
	if (this->soap_out(soap, tag?tag:"tds:SetDynamicDNSResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDynamicDNSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDynamicDNSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDynamicDNSResponse * SOAP_FMAC4 soap_get__tds__SetDynamicDNSResponse(struct soap *soap, _tds__SetDynamicDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__tds__SetDynamicDNSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDynamicDNSResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetDynamicDNSResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetDynamicDNSResponse);
		if (size)
			*size = sizeof(_tds__SetDynamicDNSResponse);
		((_tds__SetDynamicDNSResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetDynamicDNSResponse, n);
		if (size)
			*size = n * sizeof(_tds__SetDynamicDNSResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetDynamicDNSResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetDynamicDNSResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetDynamicDNSResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetDynamicDNSResponse %p -> %p\n", q, p));
	*(_tds__SetDynamicDNSResponse*)p = *(_tds__SetDynamicDNSResponse*)q;
}

void _tds__SetDynamicDNS::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_tt__DynamicDNSType(soap, &this->_tds__SetDynamicDNS::Type);
	soap_default_tt__DNSName(soap, &this->_tds__SetDynamicDNS::Name);
	this->_tds__SetDynamicDNS::TTL = NULL;
	/* transient soap skipped */
}

void _tds__SetDynamicDNS::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_tt__DNSName(soap, &this->_tds__SetDynamicDNS::Name);
	soap_serialize_PointerToxsd__duration(soap, &this->_tds__SetDynamicDNS::TTL);
	/* transient soap skipped */
#endif
}

int _tds__SetDynamicDNS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDynamicDNS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDynamicDNS(struct soap *soap, const char *tag, int id, const _tds__SetDynamicDNS *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDynamicDNS), type))
		return soap->error;
	if (soap_out_tt__DynamicDNSType(soap, "tds:Type", -1, &(a->_tds__SetDynamicDNS::Type), ""))
		return soap->error;
	if (soap_out_tt__DNSName(soap, "tds:Name", -1, &(a->_tds__SetDynamicDNS::Name), ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tds:TTL", -1, &(a->_tds__SetDynamicDNS::TTL), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDynamicDNS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetDynamicDNS(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDynamicDNS * SOAP_FMAC4 soap_in__tds__SetDynamicDNS(struct soap *soap, const char *tag, _tds__SetDynamicDNS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDynamicDNS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDynamicDNS, sizeof(_tds__SetDynamicDNS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetDynamicDNS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetDynamicDNS *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Type1 = 1;
	size_t soap_flag_Name1 = 1;
	size_t soap_flag_TTL1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__DynamicDNSType(soap, "tds:Type", &(a->_tds__SetDynamicDNS::Type), "tt:DynamicDNSType"))
				{	soap_flag_Type1--;
					continue;
				}
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__DNSName(soap, "tds:Name", &(a->_tds__SetDynamicDNS::Name), "tt:DNSName"))
				{	soap_flag_Name1--;
					continue;
				}
			if (soap_flag_TTL1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "tds:TTL", &(a->_tds__SetDynamicDNS::TTL), "xsd:duration"))
				{	soap_flag_TTL1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDynamicDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDynamicDNS, 0, sizeof(_tds__SetDynamicDNS), 0, soap_copy__tds__SetDynamicDNS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Type1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__SetDynamicDNS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetDynamicDNS);
	if (this->soap_out(soap, tag?tag:"tds:SetDynamicDNS", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDynamicDNS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDynamicDNS(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDynamicDNS * SOAP_FMAC4 soap_get__tds__SetDynamicDNS(struct soap *soap, _tds__SetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetDynamicDNS * SOAP_FMAC2 soap_instantiate__tds__SetDynamicDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDynamicDNS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetDynamicDNS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetDynamicDNS);
		if (size)
			*size = sizeof(_tds__SetDynamicDNS);
		((_tds__SetDynamicDNS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetDynamicDNS, n);
		if (size)
			*size = n * sizeof(_tds__SetDynamicDNS);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetDynamicDNS*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetDynamicDNS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetDynamicDNS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetDynamicDNS %p -> %p\n", q, p));
	*(_tds__SetDynamicDNS*)p = *(_tds__SetDynamicDNS*)q;
}

void _tds__GetDynamicDNSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDynamicDNSResponse::DynamicDNSInformation = NULL;
	/* transient soap skipped */
}

void _tds__GetDynamicDNSResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__DynamicDNSInformation(soap, &this->_tds__GetDynamicDNSResponse::DynamicDNSInformation);
	/* transient soap skipped */
#endif
}

int _tds__GetDynamicDNSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDynamicDNSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, int id, const _tds__GetDynamicDNSResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDynamicDNSResponse), type))
		return soap->error;
	if (a->DynamicDNSInformation)
		soap_element_result(soap, "tds:DynamicDNSInformation");
	if (a->_tds__GetDynamicDNSResponse::DynamicDNSInformation)
	{	if (soap_out_PointerTott__DynamicDNSInformation(soap, "tds:DynamicDNSInformation", -1, &a->_tds__GetDynamicDNSResponse::DynamicDNSInformation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:DynamicDNSInformation"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDynamicDNSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetDynamicDNSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDynamicDNSResponse * SOAP_FMAC4 soap_in__tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, _tds__GetDynamicDNSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDynamicDNSResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(_tds__GetDynamicDNSResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetDynamicDNSResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetDynamicDNSResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_DynamicDNSInformation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DynamicDNSInformation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DynamicDNSInformation(soap, "tds:DynamicDNSInformation", &(a->_tds__GetDynamicDNSResponse::DynamicDNSInformation), "tt:DynamicDNSInformation"))
				{	soap_flag_DynamicDNSInformation1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:DynamicDNSInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDynamicDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDynamicDNSResponse, 0, sizeof(_tds__GetDynamicDNSResponse), 0, soap_copy__tds__GetDynamicDNSResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DynamicDNSInformation1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetDynamicDNSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetDynamicDNSResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetDynamicDNSResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDynamicDNSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDynamicDNSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDynamicDNSResponse * SOAP_FMAC4 soap_get__tds__GetDynamicDNSResponse(struct soap *soap, _tds__GetDynamicDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetDynamicDNSResponse * SOAP_FMAC2 soap_instantiate__tds__GetDynamicDNSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDynamicDNSResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetDynamicDNSResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetDynamicDNSResponse);
		if (size)
			*size = sizeof(_tds__GetDynamicDNSResponse);
		((_tds__GetDynamicDNSResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetDynamicDNSResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetDynamicDNSResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetDynamicDNSResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetDynamicDNSResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetDynamicDNSResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetDynamicDNSResponse %p -> %p\n", q, p));
	*(_tds__GetDynamicDNSResponse*)p = *(_tds__GetDynamicDNSResponse*)q;
}

void _tds__GetDynamicDNS::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__GetDynamicDNS::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__GetDynamicDNS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDynamicDNS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDynamicDNS(struct soap *soap, const char *tag, int id, const _tds__GetDynamicDNS *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDynamicDNS), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDynamicDNS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetDynamicDNS(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDynamicDNS * SOAP_FMAC4 soap_in__tds__GetDynamicDNS(struct soap *soap, const char *tag, _tds__GetDynamicDNS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDynamicDNS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDynamicDNS, sizeof(_tds__GetDynamicDNS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetDynamicDNS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetDynamicDNS *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDynamicDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDynamicDNS, 0, sizeof(_tds__GetDynamicDNS), 0, soap_copy__tds__GetDynamicDNS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetDynamicDNS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetDynamicDNS);
	if (this->soap_out(soap, tag?tag:"tds:GetDynamicDNS", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDynamicDNS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDynamicDNS(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDynamicDNS * SOAP_FMAC4 soap_get__tds__GetDynamicDNS(struct soap *soap, _tds__GetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetDynamicDNS * SOAP_FMAC2 soap_instantiate__tds__GetDynamicDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDynamicDNS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetDynamicDNS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetDynamicDNS);
		if (size)
			*size = sizeof(_tds__GetDynamicDNS);
		((_tds__GetDynamicDNS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetDynamicDNS, n);
		if (size)
			*size = n * sizeof(_tds__GetDynamicDNS);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetDynamicDNS*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetDynamicDNS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetDynamicDNS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetDynamicDNS %p -> %p\n", q, p));
	*(_tds__GetDynamicDNS*)p = *(_tds__GetDynamicDNS*)q;
}

void _tds__SetNTPResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__SetNTPResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__SetNTPResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNTPResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNTPResponse(struct soap *soap, const char *tag, int id, const _tds__SetNTPResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNTPResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNTPResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetNTPResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNTPResponse * SOAP_FMAC4 soap_in__tds__SetNTPResponse(struct soap *soap, const char *tag, _tds__SetNTPResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNTPResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNTPResponse, sizeof(_tds__SetNTPResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetNTPResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetNTPResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNTPResponse, 0, sizeof(_tds__SetNTPResponse), 0, soap_copy__tds__SetNTPResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__SetNTPResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetNTPResponse);
	if (this->soap_out(soap, tag?tag:"tds:SetNTPResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNTPResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNTPResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNTPResponse * SOAP_FMAC4 soap_get__tds__SetNTPResponse(struct soap *soap, _tds__SetNTPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetNTPResponse * SOAP_FMAC2 soap_instantiate__tds__SetNTPResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNTPResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetNTPResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetNTPResponse);
		if (size)
			*size = sizeof(_tds__SetNTPResponse);
		((_tds__SetNTPResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetNTPResponse, n);
		if (size)
			*size = n * sizeof(_tds__SetNTPResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetNTPResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetNTPResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetNTPResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetNTPResponse %p -> %p\n", q, p));
	*(_tds__SetNTPResponse*)p = *(_tds__SetNTPResponse*)q;
}

void _tds__SetNTP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetNTP::FromDHCP);
	this->_tds__SetNTP::__sizeNTPManual = 0;
	this->_tds__SetNTP::NTPManual = NULL;
	/* transient soap skipped */
}

void _tds__SetNTP::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_tds__SetNTP::FromDHCP, SOAP_TYPE_bool);
	if (this->_tds__SetNTP::NTPManual)
	{	int i;
		for (i = 0; i < this->_tds__SetNTP::__sizeNTPManual; i++)
		{
			soap_serialize_PointerTott__NetworkHost(soap, this->_tds__SetNTP::NTPManual + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__SetNTP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetNTP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetNTP(struct soap *soap, const char *tag, int id, const _tds__SetNTP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetNTP), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:FromDHCP", -1, &(a->_tds__SetNTP::FromDHCP), ""))
		return soap->error;
	if (a->_tds__SetNTP::NTPManual)
	{	int i;
		for (i = 0; i < a->_tds__SetNTP::__sizeNTPManual; i++)
			if (soap_out_PointerTott__NetworkHost(soap, "tds:NTPManual", -1, a->_tds__SetNTP::NTPManual + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetNTP::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetNTP(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetNTP * SOAP_FMAC4 soap_in__tds__SetNTP(struct soap *soap, const char *tag, _tds__SetNTP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetNTP *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetNTP, sizeof(_tds__SetNTP), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetNTP)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetNTP *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_FromDHCP1 = 1;
	struct soap_blist *soap_blist_NTPManual1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tds:FromDHCP", &(a->_tds__SetNTP::FromDHCP), "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NTPManual", 1, NULL))
			{	if (a->_tds__SetNTP::NTPManual == NULL)
				{	if (soap_blist_NTPManual1 == NULL)
						soap_blist_NTPManual1 = soap_new_block(soap);
					a->_tds__SetNTP::NTPManual = (tt__NetworkHost **)soap_push_block(soap, soap_blist_NTPManual1, sizeof(tt__NetworkHost *));
					if (a->_tds__SetNTP::NTPManual == NULL)
						return NULL;
					*a->_tds__SetNTP::NTPManual = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__NetworkHost(soap, "tds:NTPManual", a->_tds__SetNTP::NTPManual, "tt:NetworkHost"))
				{	a->_tds__SetNTP::__sizeNTPManual++;
					a->_tds__SetNTP::NTPManual = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__SetNTP::NTPManual)
			soap_pop_block(soap, soap_blist_NTPManual1);
		if (a->_tds__SetNTP::__sizeNTPManual)
			a->_tds__SetNTP::NTPManual = (tt__NetworkHost **)soap_save_block(soap, soap_blist_NTPManual1, NULL, 1);
		else
		{	a->_tds__SetNTP::NTPManual = NULL;
			if (soap_blist_NTPManual1)
				soap_end_block(soap, soap_blist_NTPManual1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetNTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetNTP, 0, sizeof(_tds__SetNTP), 0, soap_copy__tds__SetNTP);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__SetNTP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetNTP);
	if (this->soap_out(soap, tag?tag:"tds:SetNTP", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetNTP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetNTP(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetNTP * SOAP_FMAC4 soap_get__tds__SetNTP(struct soap *soap, _tds__SetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetNTP * SOAP_FMAC2 soap_instantiate__tds__SetNTP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetNTP(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetNTP, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetNTP);
		if (size)
			*size = sizeof(_tds__SetNTP);
		((_tds__SetNTP*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetNTP, n);
		if (size)
			*size = n * sizeof(_tds__SetNTP);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetNTP*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetNTP*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetNTP(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetNTP %p -> %p\n", q, p));
	*(_tds__SetNTP*)p = *(_tds__SetNTP*)q;
}

void _tds__GetNTPResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetNTPResponse::NTPInformation = NULL;
	/* transient soap skipped */
}

void _tds__GetNTPResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__NTPInformation(soap, &this->_tds__GetNTPResponse::NTPInformation);
	/* transient soap skipped */
#endif
}

int _tds__GetNTPResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNTPResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNTPResponse(struct soap *soap, const char *tag, int id, const _tds__GetNTPResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNTPResponse), type))
		return soap->error;
	if (a->NTPInformation)
		soap_element_result(soap, "tds:NTPInformation");
	if (a->_tds__GetNTPResponse::NTPInformation)
	{	if (soap_out_PointerTott__NTPInformation(soap, "tds:NTPInformation", -1, &a->_tds__GetNTPResponse::NTPInformation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:NTPInformation"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNTPResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetNTPResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNTPResponse * SOAP_FMAC4 soap_in__tds__GetNTPResponse(struct soap *soap, const char *tag, _tds__GetNTPResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNTPResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNTPResponse, sizeof(_tds__GetNTPResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetNTPResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetNTPResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_NTPInformation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NTPInformation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__NTPInformation(soap, "tds:NTPInformation", &(a->_tds__GetNTPResponse::NTPInformation), "tt:NTPInformation"))
				{	soap_flag_NTPInformation1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:NTPInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNTPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNTPResponse, 0, sizeof(_tds__GetNTPResponse), 0, soap_copy__tds__GetNTPResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NTPInformation1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetNTPResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetNTPResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetNTPResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNTPResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNTPResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNTPResponse * SOAP_FMAC4 soap_get__tds__GetNTPResponse(struct soap *soap, _tds__GetNTPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetNTPResponse * SOAP_FMAC2 soap_instantiate__tds__GetNTPResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNTPResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetNTPResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetNTPResponse);
		if (size)
			*size = sizeof(_tds__GetNTPResponse);
		((_tds__GetNTPResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetNTPResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetNTPResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetNTPResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetNTPResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetNTPResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetNTPResponse %p -> %p\n", q, p));
	*(_tds__GetNTPResponse*)p = *(_tds__GetNTPResponse*)q;
}

void _tds__GetNTP::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__GetNTP::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__GetNTP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetNTP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetNTP(struct soap *soap, const char *tag, int id, const _tds__GetNTP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetNTP), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetNTP::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetNTP(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetNTP * SOAP_FMAC4 soap_in__tds__GetNTP(struct soap *soap, const char *tag, _tds__GetNTP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetNTP *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetNTP, sizeof(_tds__GetNTP), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetNTP)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetNTP *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetNTP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetNTP, 0, sizeof(_tds__GetNTP), 0, soap_copy__tds__GetNTP);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetNTP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetNTP);
	if (this->soap_out(soap, tag?tag:"tds:GetNTP", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetNTP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetNTP(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetNTP * SOAP_FMAC4 soap_get__tds__GetNTP(struct soap *soap, _tds__GetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetNTP * SOAP_FMAC2 soap_instantiate__tds__GetNTP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetNTP(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetNTP, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetNTP);
		if (size)
			*size = sizeof(_tds__GetNTP);
		((_tds__GetNTP*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetNTP, n);
		if (size)
			*size = n * sizeof(_tds__GetNTP);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetNTP*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetNTP*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetNTP(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetNTP %p -> %p\n", q, p));
	*(_tds__GetNTP*)p = *(_tds__GetNTP*)q;
}

void _tds__SetDNSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__SetDNSResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__SetDNSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDNSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDNSResponse(struct soap *soap, const char *tag, int id, const _tds__SetDNSResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDNSResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDNSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetDNSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDNSResponse * SOAP_FMAC4 soap_in__tds__SetDNSResponse(struct soap *soap, const char *tag, _tds__SetDNSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDNSResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDNSResponse, sizeof(_tds__SetDNSResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetDNSResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetDNSResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDNSResponse, 0, sizeof(_tds__SetDNSResponse), 0, soap_copy__tds__SetDNSResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__SetDNSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetDNSResponse);
	if (this->soap_out(soap, tag?tag:"tds:SetDNSResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDNSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDNSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDNSResponse * SOAP_FMAC4 soap_get__tds__SetDNSResponse(struct soap *soap, _tds__SetDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetDNSResponse * SOAP_FMAC2 soap_instantiate__tds__SetDNSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDNSResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetDNSResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetDNSResponse);
		if (size)
			*size = sizeof(_tds__SetDNSResponse);
		((_tds__SetDNSResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetDNSResponse, n);
		if (size)
			*size = n * sizeof(_tds__SetDNSResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetDNSResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetDNSResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetDNSResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetDNSResponse %p -> %p\n", q, p));
	*(_tds__SetDNSResponse*)p = *(_tds__SetDNSResponse*)q;
}

void _tds__SetDNS::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetDNS::FromDHCP);
	this->_tds__SetDNS::__sizeSearchDomain = 0;
	this->_tds__SetDNS::SearchDomain = NULL;
	this->_tds__SetDNS::__sizeDNSManual = 0;
	this->_tds__SetDNS::DNSManual = NULL;
	/* transient soap skipped */
}

void _tds__SetDNS::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_tds__SetDNS::FromDHCP, SOAP_TYPE_bool);
	if (this->_tds__SetDNS::SearchDomain)
	{	int i;
		for (i = 0; i < this->_tds__SetDNS::__sizeSearchDomain; i++)
		{
			soap_serialize_xsd__token(soap, this->_tds__SetDNS::SearchDomain + i);
		}
	}
	if (this->_tds__SetDNS::DNSManual)
	{	int i;
		for (i = 0; i < this->_tds__SetDNS::__sizeDNSManual; i++)
		{
			soap_serialize_PointerTott__IPAddress(soap, this->_tds__SetDNS::DNSManual + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__SetDNS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetDNS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDNS(struct soap *soap, const char *tag, int id, const _tds__SetDNS *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDNS), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:FromDHCP", -1, &(a->_tds__SetDNS::FromDHCP), ""))
		return soap->error;
	if (a->_tds__SetDNS::SearchDomain)
	{	int i;
		for (i = 0; i < a->_tds__SetDNS::__sizeSearchDomain; i++)
			if (soap_out_xsd__token(soap, "tds:SearchDomain", -1, a->_tds__SetDNS::SearchDomain + i, ""))
				return soap->error;
	}
	if (a->_tds__SetDNS::DNSManual)
	{	int i;
		for (i = 0; i < a->_tds__SetDNS::__sizeDNSManual; i++)
			if (soap_out_PointerTott__IPAddress(soap, "tds:DNSManual", -1, a->_tds__SetDNS::DNSManual + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetDNS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetDNS(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetDNS * SOAP_FMAC4 soap_in__tds__SetDNS(struct soap *soap, const char *tag, _tds__SetDNS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetDNS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDNS, sizeof(_tds__SetDNS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetDNS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetDNS *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_FromDHCP1 = 1;
	struct soap_blist *soap_blist_SearchDomain1 = NULL;
	struct soap_blist *soap_blist_DNSManual1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tds:FromDHCP", &(a->_tds__SetDNS::FromDHCP), "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:SearchDomain", 1, NULL))
			{	if (a->_tds__SetDNS::SearchDomain == NULL)
				{	if (soap_blist_SearchDomain1 == NULL)
						soap_blist_SearchDomain1 = soap_new_block(soap);
					a->_tds__SetDNS::SearchDomain = (char **)soap_push_block(soap, soap_blist_SearchDomain1, sizeof(char *));
					if (a->_tds__SetDNS::SearchDomain == NULL)
						return NULL;
					*a->_tds__SetDNS::SearchDomain = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__token(soap, "tds:SearchDomain", a->_tds__SetDNS::SearchDomain, "xsd:token"))
				{	a->_tds__SetDNS::__sizeSearchDomain++;
					a->_tds__SetDNS::SearchDomain = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:DNSManual", 1, NULL))
			{	if (a->_tds__SetDNS::DNSManual == NULL)
				{	if (soap_blist_DNSManual1 == NULL)
						soap_blist_DNSManual1 = soap_new_block(soap);
					a->_tds__SetDNS::DNSManual = (tt__IPAddress **)soap_push_block(soap, soap_blist_DNSManual1, sizeof(tt__IPAddress *));
					if (a->_tds__SetDNS::DNSManual == NULL)
						return NULL;
					*a->_tds__SetDNS::DNSManual = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__IPAddress(soap, "tds:DNSManual", a->_tds__SetDNS::DNSManual, "tt:IPAddress"))
				{	a->_tds__SetDNS::__sizeDNSManual++;
					a->_tds__SetDNS::DNSManual = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__SetDNS::SearchDomain)
			soap_pop_block(soap, soap_blist_SearchDomain1);
		if (a->_tds__SetDNS::__sizeSearchDomain)
			a->_tds__SetDNS::SearchDomain = (char **)soap_save_block(soap, soap_blist_SearchDomain1, NULL, 1);
		else
		{	a->_tds__SetDNS::SearchDomain = NULL;
			if (soap_blist_SearchDomain1)
				soap_end_block(soap, soap_blist_SearchDomain1);
		}
		if (a->_tds__SetDNS::DNSManual)
			soap_pop_block(soap, soap_blist_DNSManual1);
		if (a->_tds__SetDNS::__sizeDNSManual)
			a->_tds__SetDNS::DNSManual = (tt__IPAddress **)soap_save_block(soap, soap_blist_DNSManual1, NULL, 1);
		else
		{	a->_tds__SetDNS::DNSManual = NULL;
			if (soap_blist_DNSManual1)
				soap_end_block(soap, soap_blist_DNSManual1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDNS, 0, sizeof(_tds__SetDNS), 0, soap_copy__tds__SetDNS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__SetDNS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetDNS);
	if (this->soap_out(soap, tag?tag:"tds:SetDNS", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetDNS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetDNS(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetDNS * SOAP_FMAC4 soap_get__tds__SetDNS(struct soap *soap, _tds__SetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetDNS * SOAP_FMAC2 soap_instantiate__tds__SetDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetDNS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetDNS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetDNS);
		if (size)
			*size = sizeof(_tds__SetDNS);
		((_tds__SetDNS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetDNS, n);
		if (size)
			*size = n * sizeof(_tds__SetDNS);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetDNS*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetDNS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetDNS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetDNS %p -> %p\n", q, p));
	*(_tds__SetDNS*)p = *(_tds__SetDNS*)q;
}

void _tds__GetDNSResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetDNSResponse::DNSInformation = NULL;
	/* transient soap skipped */
}

void _tds__GetDNSResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__DNSInformation(soap, &this->_tds__GetDNSResponse::DNSInformation);
	/* transient soap skipped */
#endif
}

int _tds__GetDNSResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDNSResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDNSResponse(struct soap *soap, const char *tag, int id, const _tds__GetDNSResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDNSResponse), type))
		return soap->error;
	if (a->DNSInformation)
		soap_element_result(soap, "tds:DNSInformation");
	if (a->_tds__GetDNSResponse::DNSInformation)
	{	if (soap_out_PointerTott__DNSInformation(soap, "tds:DNSInformation", -1, &a->_tds__GetDNSResponse::DNSInformation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:DNSInformation"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDNSResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetDNSResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDNSResponse * SOAP_FMAC4 soap_in__tds__GetDNSResponse(struct soap *soap, const char *tag, _tds__GetDNSResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDNSResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDNSResponse, sizeof(_tds__GetDNSResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetDNSResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetDNSResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_DNSInformation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DNSInformation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__DNSInformation(soap, "tds:DNSInformation", &(a->_tds__GetDNSResponse::DNSInformation), "tt:DNSInformation"))
				{	soap_flag_DNSInformation1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:DNSInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDNSResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDNSResponse, 0, sizeof(_tds__GetDNSResponse), 0, soap_copy__tds__GetDNSResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DNSInformation1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetDNSResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetDNSResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetDNSResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDNSResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDNSResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDNSResponse * SOAP_FMAC4 soap_get__tds__GetDNSResponse(struct soap *soap, _tds__GetDNSResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetDNSResponse * SOAP_FMAC2 soap_instantiate__tds__GetDNSResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDNSResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetDNSResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetDNSResponse);
		if (size)
			*size = sizeof(_tds__GetDNSResponse);
		((_tds__GetDNSResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetDNSResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetDNSResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetDNSResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetDNSResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetDNSResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetDNSResponse %p -> %p\n", q, p));
	*(_tds__GetDNSResponse*)p = *(_tds__GetDNSResponse*)q;
}

void _tds__GetDNS::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__GetDNS::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__GetDNS::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetDNS(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDNS(struct soap *soap, const char *tag, int id, const _tds__GetDNS *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDNS), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetDNS::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetDNS(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetDNS * SOAP_FMAC4 soap_in__tds__GetDNS(struct soap *soap, const char *tag, _tds__GetDNS *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetDNS *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDNS, sizeof(_tds__GetDNS), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetDNS)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetDNS *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetDNS *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDNS, 0, sizeof(_tds__GetDNS), 0, soap_copy__tds__GetDNS);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetDNS::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetDNS);
	if (this->soap_out(soap, tag?tag:"tds:GetDNS", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetDNS::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetDNS(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetDNS * SOAP_FMAC4 soap_get__tds__GetDNS(struct soap *soap, _tds__GetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetDNS * SOAP_FMAC2 soap_instantiate__tds__GetDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetDNS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetDNS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetDNS);
		if (size)
			*size = sizeof(_tds__GetDNS);
		((_tds__GetDNS*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetDNS, n);
		if (size)
			*size = n * sizeof(_tds__GetDNS);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetDNS*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetDNS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetDNS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetDNS %p -> %p\n", q, p));
	*(_tds__GetDNS*)p = *(_tds__GetDNS*)q;
}

void _tds__SetHostnameFromDHCPResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetHostnameFromDHCPResponse::RebootNeeded);
	/* transient soap skipped */
}

void _tds__SetHostnameFromDHCPResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_tds__SetHostnameFromDHCPResponse::RebootNeeded, SOAP_TYPE_bool);
	/* transient soap skipped */
#endif
}

int _tds__SetHostnameFromDHCPResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHostnameFromDHCPResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, int id, const _tds__SetHostnameFromDHCPResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:RebootNeeded");
	if (soap_out_bool(soap, "tds:RebootNeeded", -1, &(a->_tds__SetHostnameFromDHCPResponse::RebootNeeded), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHostnameFromDHCPResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetHostnameFromDHCPResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCPResponse * SOAP_FMAC4 soap_in__tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, _tds__SetHostnameFromDHCPResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHostnameFromDHCPResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(_tds__SetHostnameFromDHCPResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetHostnameFromDHCPResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetHostnameFromDHCPResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_RebootNeeded1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RebootNeeded1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tds:RebootNeeded", &(a->_tds__SetHostnameFromDHCPResponse::RebootNeeded), "xsd:boolean"))
				{	soap_flag_RebootNeeded1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:RebootNeeded");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetHostnameFromDHCPResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, 0, sizeof(_tds__SetHostnameFromDHCPResponse), 0, soap_copy__tds__SetHostnameFromDHCPResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RebootNeeded1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__SetHostnameFromDHCPResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetHostnameFromDHCPResponse);
	if (this->soap_out(soap, tag?tag:"tds:SetHostnameFromDHCPResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHostnameFromDHCPResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHostnameFromDHCPResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCPResponse * SOAP_FMAC4 soap_get__tds__SetHostnameFromDHCPResponse(struct soap *soap, _tds__SetHostnameFromDHCPResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameFromDHCPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetHostnameFromDHCPResponse * SOAP_FMAC2 soap_instantiate__tds__SetHostnameFromDHCPResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHostnameFromDHCPResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetHostnameFromDHCPResponse);
		if (size)
			*size = sizeof(_tds__SetHostnameFromDHCPResponse);
		((_tds__SetHostnameFromDHCPResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetHostnameFromDHCPResponse, n);
		if (size)
			*size = n * sizeof(_tds__SetHostnameFromDHCPResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetHostnameFromDHCPResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetHostnameFromDHCPResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetHostnameFromDHCPResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetHostnameFromDHCPResponse %p -> %p\n", q, p));
	*(_tds__SetHostnameFromDHCPResponse*)p = *(_tds__SetHostnameFromDHCPResponse*)q;
}

void _tds__SetHostnameFromDHCP::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_bool(soap, &this->_tds__SetHostnameFromDHCP::FromDHCP);
	/* transient soap skipped */
}

void _tds__SetHostnameFromDHCP::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_tds__SetHostnameFromDHCP::FromDHCP, SOAP_TYPE_bool);
	/* transient soap skipped */
#endif
}

int _tds__SetHostnameFromDHCP::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHostnameFromDHCP(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, const _tds__SetHostnameFromDHCP *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameFromDHCP), type))
		return soap->error;
	if (soap_out_bool(soap, "tds:FromDHCP", -1, &(a->_tds__SetHostnameFromDHCP::FromDHCP), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHostnameFromDHCP::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetHostnameFromDHCP(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_in__tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, _tds__SetHostnameFromDHCP *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHostnameFromDHCP *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(_tds__SetHostnameFromDHCP), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetHostnameFromDHCP)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetHostnameFromDHCP *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_FromDHCP1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_FromDHCP1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_bool(soap, "tds:FromDHCP", &(a->_tds__SetHostnameFromDHCP::FromDHCP), "xsd:boolean"))
				{	soap_flag_FromDHCP1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetHostnameFromDHCP *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameFromDHCP, 0, sizeof(_tds__SetHostnameFromDHCP), 0, soap_copy__tds__SetHostnameFromDHCP);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_FromDHCP1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__SetHostnameFromDHCP::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetHostnameFromDHCP);
	if (this->soap_out(soap, tag?tag:"tds:SetHostnameFromDHCP", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHostnameFromDHCP::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHostnameFromDHCP(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_get__tds__SetHostnameFromDHCP(struct soap *soap, _tds__SetHostnameFromDHCP *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetHostnameFromDHCP * SOAP_FMAC2 soap_instantiate__tds__SetHostnameFromDHCP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHostnameFromDHCP(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetHostnameFromDHCP, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetHostnameFromDHCP);
		if (size)
			*size = sizeof(_tds__SetHostnameFromDHCP);
		((_tds__SetHostnameFromDHCP*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetHostnameFromDHCP, n);
		if (size)
			*size = n * sizeof(_tds__SetHostnameFromDHCP);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetHostnameFromDHCP*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetHostnameFromDHCP*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetHostnameFromDHCP(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetHostnameFromDHCP %p -> %p\n", q, p));
	*(_tds__SetHostnameFromDHCP*)p = *(_tds__SetHostnameFromDHCP*)q;
}

void _tds__SetHostnameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__SetHostnameResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__SetHostnameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHostnameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostnameResponse(struct soap *soap, const char *tag, int id, const _tds__SetHostnameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostnameResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHostnameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetHostnameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHostnameResponse * SOAP_FMAC4 soap_in__tds__SetHostnameResponse(struct soap *soap, const char *tag, _tds__SetHostnameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHostnameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostnameResponse, sizeof(_tds__SetHostnameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetHostnameResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetHostnameResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetHostnameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostnameResponse, 0, sizeof(_tds__SetHostnameResponse), 0, soap_copy__tds__SetHostnameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__SetHostnameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetHostnameResponse);
	if (this->soap_out(soap, tag?tag:"tds:SetHostnameResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHostnameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHostnameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHostnameResponse * SOAP_FMAC4 soap_get__tds__SetHostnameResponse(struct soap *soap, _tds__SetHostnameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetHostnameResponse * SOAP_FMAC2 soap_instantiate__tds__SetHostnameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHostnameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetHostnameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetHostnameResponse);
		if (size)
			*size = sizeof(_tds__SetHostnameResponse);
		((_tds__SetHostnameResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetHostnameResponse, n);
		if (size)
			*size = n * sizeof(_tds__SetHostnameResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetHostnameResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetHostnameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetHostnameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetHostnameResponse %p -> %p\n", q, p));
	*(_tds__SetHostnameResponse*)p = *(_tds__SetHostnameResponse*)q;
}

void _tds__SetHostname::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__token(soap, &this->_tds__SetHostname::Name);
	/* transient soap skipped */
}

void _tds__SetHostname::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &this->_tds__SetHostname::Name);
	/* transient soap skipped */
#endif
}

int _tds__SetHostname::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetHostname(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetHostname(struct soap *soap, const char *tag, int id, const _tds__SetHostname *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetHostname), type))
		return soap->error;
	if (a->_tds__SetHostname::Name)
	{	if (soap_out_xsd__token(soap, "tds:Name", -1, &a->_tds__SetHostname::Name, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Name"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetHostname::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetHostname(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetHostname * SOAP_FMAC4 soap_in__tds__SetHostname(struct soap *soap, const char *tag, _tds__SetHostname *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetHostname *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetHostname, sizeof(_tds__SetHostname), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetHostname)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetHostname *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Name1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tds:Name", &(a->_tds__SetHostname::Name), "xsd:token"))
				{	soap_flag_Name1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetHostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetHostname, 0, sizeof(_tds__SetHostname), 0, soap_copy__tds__SetHostname);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Name1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__SetHostname::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetHostname);
	if (this->soap_out(soap, tag?tag:"tds:SetHostname", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetHostname::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetHostname(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetHostname * SOAP_FMAC4 soap_get__tds__SetHostname(struct soap *soap, _tds__SetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetHostname * SOAP_FMAC2 soap_instantiate__tds__SetHostname(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetHostname(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetHostname, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetHostname);
		if (size)
			*size = sizeof(_tds__SetHostname);
		((_tds__SetHostname*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetHostname, n);
		if (size)
			*size = n * sizeof(_tds__SetHostname);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetHostname*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetHostname*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetHostname(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetHostname %p -> %p\n", q, p));
	*(_tds__SetHostname*)p = *(_tds__SetHostname*)q;
}

void _tds__GetHostnameResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetHostnameResponse::HostnameInformation = NULL;
	/* transient soap skipped */
}

void _tds__GetHostnameResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__HostnameInformation(soap, &this->_tds__GetHostnameResponse::HostnameInformation);
	/* transient soap skipped */
#endif
}

int _tds__GetHostnameResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetHostnameResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetHostnameResponse(struct soap *soap, const char *tag, int id, const _tds__GetHostnameResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetHostnameResponse), type))
		return soap->error;
	if (a->HostnameInformation)
		soap_element_result(soap, "tds:HostnameInformation");
	if (a->_tds__GetHostnameResponse::HostnameInformation)
	{	if (soap_out_PointerTott__HostnameInformation(soap, "tds:HostnameInformation", -1, &a->_tds__GetHostnameResponse::HostnameInformation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:HostnameInformation"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetHostnameResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetHostnameResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetHostnameResponse * SOAP_FMAC4 soap_in__tds__GetHostnameResponse(struct soap *soap, const char *tag, _tds__GetHostnameResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetHostnameResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetHostnameResponse, sizeof(_tds__GetHostnameResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetHostnameResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetHostnameResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_HostnameInformation1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HostnameInformation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__HostnameInformation(soap, "tds:HostnameInformation", &(a->_tds__GetHostnameResponse::HostnameInformation), "tt:HostnameInformation"))
				{	soap_flag_HostnameInformation1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:HostnameInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetHostnameResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetHostnameResponse, 0, sizeof(_tds__GetHostnameResponse), 0, soap_copy__tds__GetHostnameResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_HostnameInformation1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetHostnameResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetHostnameResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetHostnameResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetHostnameResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetHostnameResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetHostnameResponse * SOAP_FMAC4 soap_get__tds__GetHostnameResponse(struct soap *soap, _tds__GetHostnameResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetHostnameResponse * SOAP_FMAC2 soap_instantiate__tds__GetHostnameResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetHostnameResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetHostnameResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetHostnameResponse);
		if (size)
			*size = sizeof(_tds__GetHostnameResponse);
		((_tds__GetHostnameResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetHostnameResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetHostnameResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetHostnameResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetHostnameResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetHostnameResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetHostnameResponse %p -> %p\n", q, p));
	*(_tds__GetHostnameResponse*)p = *(_tds__GetHostnameResponse*)q;
}

void _tds__GetHostname::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__GetHostname::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__GetHostname::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetHostname(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetHostname(struct soap *soap, const char *tag, int id, const _tds__GetHostname *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetHostname), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetHostname::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetHostname(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetHostname * SOAP_FMAC4 soap_in__tds__GetHostname(struct soap *soap, const char *tag, _tds__GetHostname *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetHostname *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetHostname, sizeof(_tds__GetHostname), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetHostname)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetHostname *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetHostname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetHostname, 0, sizeof(_tds__GetHostname), 0, soap_copy__tds__GetHostname);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetHostname::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetHostname);
	if (this->soap_out(soap, tag?tag:"tds:GetHostname", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetHostname::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetHostname(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetHostname * SOAP_FMAC4 soap_get__tds__GetHostname(struct soap *soap, _tds__GetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetHostname * SOAP_FMAC2 soap_instantiate__tds__GetHostname(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetHostname(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetHostname, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetHostname);
		if (size)
			*size = sizeof(_tds__GetHostname);
		((_tds__GetHostname*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetHostname, n);
		if (size)
			*size = n * sizeof(_tds__GetHostname);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetHostname*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetHostname*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetHostname(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetHostname %p -> %p\n", q, p));
	*(_tds__GetHostname*)p = *(_tds__GetHostname*)q;
}

void _tds__GetCapabilitiesResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetCapabilitiesResponse::Capabilities = NULL;
	/* transient soap skipped */
}

void _tds__GetCapabilitiesResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Capabilities(soap, &this->_tds__GetCapabilitiesResponse::Capabilities);
	/* transient soap skipped */
#endif
}

int _tds__GetCapabilitiesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCapabilitiesResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, int id, const _tds__GetCapabilitiesResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (a->_tds__GetCapabilitiesResponse::Capabilities)
	{	if (soap_out_PointerTott__Capabilities(soap, "tds:Capabilities", -1, &a->_tds__GetCapabilitiesResponse::Capabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Capabilities"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCapabilitiesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetCapabilitiesResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, _tds__GetCapabilitiesResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCapabilitiesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(_tds__GetCapabilitiesResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetCapabilitiesResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetCapabilitiesResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_Capabilities1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Capabilities(soap, "tds:Capabilities", &(a->_tds__GetCapabilitiesResponse::Capabilities), "tt:Capabilities"))
				{	soap_flag_Capabilities1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilitiesResponse, 0, sizeof(_tds__GetCapabilitiesResponse), 0, soap_copy__tds__GetCapabilitiesResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetCapabilitiesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetCapabilitiesResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetCapabilitiesResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCapabilitiesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCapabilitiesResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetCapabilitiesResponse(struct soap *soap, _tds__GetCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetCapabilitiesResponse * SOAP_FMAC2 soap_instantiate__tds__GetCapabilitiesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCapabilitiesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetCapabilitiesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetCapabilitiesResponse);
		if (size)
			*size = sizeof(_tds__GetCapabilitiesResponse);
		((_tds__GetCapabilitiesResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetCapabilitiesResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetCapabilitiesResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetCapabilitiesResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetCapabilitiesResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetCapabilitiesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetCapabilitiesResponse %p -> %p\n", q, p));
	*(_tds__GetCapabilitiesResponse*)p = *(_tds__GetCapabilitiesResponse*)q;
}

void _tds__GetCapabilities::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__GetCapabilities::__sizeCategory = 0;
	this->_tds__GetCapabilities::Category = NULL;
	/* transient soap skipped */
}

void _tds__GetCapabilities::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__GetCapabilities::Category)
	{	int i;
		for (i = 0; i < this->_tds__GetCapabilities::__sizeCategory; i++)
		{
			soap_embedded(soap, this->_tds__GetCapabilities::Category + i, SOAP_TYPE_tt__CapabilityCategory);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__GetCapabilities::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetCapabilities(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCapabilities(struct soap *soap, const char *tag, int id, const _tds__GetCapabilities *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCapabilities), type))
		return soap->error;
	if (a->_tds__GetCapabilities::Category)
	{	int i;
		for (i = 0; i < a->_tds__GetCapabilities::__sizeCategory; i++)
			if (soap_out_tt__CapabilityCategory(soap, "tds:Category", -1, a->_tds__GetCapabilities::Category + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetCapabilities::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetCapabilities(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetCapabilities * SOAP_FMAC4 soap_in__tds__GetCapabilities(struct soap *soap, const char *tag, _tds__GetCapabilities *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetCapabilities *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCapabilities, sizeof(_tds__GetCapabilities), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetCapabilities)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetCapabilities *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_Category1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Category", 1, NULL))
			{	if (a->_tds__GetCapabilities::Category == NULL)
				{	if (soap_blist_Category1 == NULL)
						soap_blist_Category1 = soap_new_block(soap);
					a->_tds__GetCapabilities::Category = (enum tt__CapabilityCategory *)soap_push_block(soap, soap_blist_Category1, sizeof(enum tt__CapabilityCategory));
					if (a->_tds__GetCapabilities::Category == NULL)
						return NULL;
					soap_default_tt__CapabilityCategory(soap, a->_tds__GetCapabilities::Category);
				}
				soap_revert(soap);
				if (soap_in_tt__CapabilityCategory(soap, "tds:Category", a->_tds__GetCapabilities::Category, "tt:CapabilityCategory"))
				{	a->_tds__GetCapabilities::__sizeCategory++;
					a->_tds__GetCapabilities::Category = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__GetCapabilities::Category)
			soap_pop_block(soap, soap_blist_Category1);
		if (a->_tds__GetCapabilities::__sizeCategory)
			a->_tds__GetCapabilities::Category = (enum tt__CapabilityCategory *)soap_save_block(soap, soap_blist_Category1, NULL, 1);
		else
		{	a->_tds__GetCapabilities::Category = NULL;
			if (soap_blist_Category1)
				soap_end_block(soap, soap_blist_Category1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCapabilities, 0, sizeof(_tds__GetCapabilities), 0, soap_copy__tds__GetCapabilities);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetCapabilities::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetCapabilities);
	if (this->soap_out(soap, tag?tag:"tds:GetCapabilities", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetCapabilities::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetCapabilities(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetCapabilities * SOAP_FMAC4 soap_get__tds__GetCapabilities(struct soap *soap, _tds__GetCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetCapabilities * SOAP_FMAC2 soap_instantiate__tds__GetCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetCapabilities);
		if (size)
			*size = sizeof(_tds__GetCapabilities);
		((_tds__GetCapabilities*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetCapabilities, n);
		if (size)
			*size = n * sizeof(_tds__GetCapabilities);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetCapabilities*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetCapabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetCapabilities %p -> %p\n", q, p));
	*(_tds__GetCapabilities*)p = *(_tds__GetCapabilities*)q;
}

void _tds__GetWsdlUrlResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__anyURI(soap, &this->_tds__GetWsdlUrlResponse::WsdlUrl);
	/* transient soap skipped */
}

void _tds__GetWsdlUrlResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &this->_tds__GetWsdlUrlResponse::WsdlUrl);
	/* transient soap skipped */
#endif
}

int _tds__GetWsdlUrlResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetWsdlUrlResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, int id, const _tds__GetWsdlUrlResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetWsdlUrlResponse), type))
		return soap->error;
	if (a->WsdlUrl)
		soap_element_result(soap, "tds:WsdlUrl");
	if (a->_tds__GetWsdlUrlResponse::WsdlUrl)
	{	if (soap_out_xsd__anyURI(soap, "tds:WsdlUrl", -1, &a->_tds__GetWsdlUrlResponse::WsdlUrl, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:WsdlUrl"))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetWsdlUrlResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetWsdlUrlResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetWsdlUrlResponse * SOAP_FMAC4 soap_in__tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, _tds__GetWsdlUrlResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetWsdlUrlResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(_tds__GetWsdlUrlResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetWsdlUrlResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetWsdlUrlResponse *)a->soap_in(soap, tag, type);
		}
	}
	size_t soap_flag_WsdlUrl1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_WsdlUrl1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tds:WsdlUrl", &(a->_tds__GetWsdlUrlResponse::WsdlUrl), "xsd:anyURI"))
				{	soap_flag_WsdlUrl1--;
					continue;
				}
			/* transient soap skipped */
			soap_check_result(soap, "tds:WsdlUrl");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetWsdlUrlResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetWsdlUrlResponse, 0, sizeof(_tds__GetWsdlUrlResponse), 0, soap_copy__tds__GetWsdlUrlResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_WsdlUrl1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__GetWsdlUrlResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetWsdlUrlResponse);
	if (this->soap_out(soap, tag?tag:"tds:GetWsdlUrlResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetWsdlUrlResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetWsdlUrlResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetWsdlUrlResponse * SOAP_FMAC4 soap_get__tds__GetWsdlUrlResponse(struct soap *soap, _tds__GetWsdlUrlResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetWsdlUrlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetWsdlUrlResponse * SOAP_FMAC2 soap_instantiate__tds__GetWsdlUrlResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetWsdlUrlResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetWsdlUrlResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetWsdlUrlResponse);
		if (size)
			*size = sizeof(_tds__GetWsdlUrlResponse);
		((_tds__GetWsdlUrlResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetWsdlUrlResponse, n);
		if (size)
			*size = n * sizeof(_tds__GetWsdlUrlResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetWsdlUrlResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetWsdlUrlResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetWsdlUrlResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetWsdlUrlResponse %p -> %p\n", q, p));
	*(_tds__GetWsdlUrlResponse*)p = *(_tds__GetWsdlUrlResponse*)q;
}

void _tds__GetWsdlUrl::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__GetWsdlUrl::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__GetWsdlUrl::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__GetWsdlUrl(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetWsdlUrl(struct soap *soap, const char *tag, int id, const _tds__GetWsdlUrl *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetWsdlUrl), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__GetWsdlUrl::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__GetWsdlUrl(soap, tag, this, type);
}

SOAP_FMAC3 _tds__GetWsdlUrl * SOAP_FMAC4 soap_in__tds__GetWsdlUrl(struct soap *soap, const char *tag, _tds__GetWsdlUrl *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__GetWsdlUrl *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetWsdlUrl, sizeof(_tds__GetWsdlUrl), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__GetWsdlUrl)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__GetWsdlUrl *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__GetWsdlUrl *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetWsdlUrl, 0, sizeof(_tds__GetWsdlUrl), 0, soap_copy__tds__GetWsdlUrl);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__GetWsdlUrl::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__GetWsdlUrl);
	if (this->soap_out(soap, tag?tag:"tds:GetWsdlUrl", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__GetWsdlUrl::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__GetWsdlUrl(soap, this, tag, type);
}

SOAP_FMAC3 _tds__GetWsdlUrl * SOAP_FMAC4 soap_get__tds__GetWsdlUrl(struct soap *soap, _tds__GetWsdlUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetWsdlUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__GetWsdlUrl * SOAP_FMAC2 soap_instantiate__tds__GetWsdlUrl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__GetWsdlUrl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__GetWsdlUrl, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__GetWsdlUrl);
		if (size)
			*size = sizeof(_tds__GetWsdlUrl);
		((_tds__GetWsdlUrl*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__GetWsdlUrl, n);
		if (size)
			*size = n * sizeof(_tds__GetWsdlUrl);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__GetWsdlUrl*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__GetWsdlUrl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__GetWsdlUrl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__GetWsdlUrl %p -> %p\n", q, p));
	*(_tds__GetWsdlUrl*)p = *(_tds__GetWsdlUrl*)q;
}

void _tds__SetUserResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__SetUserResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__SetUserResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetUserResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetUserResponse(struct soap *soap, const char *tag, int id, const _tds__SetUserResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetUserResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetUserResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetUserResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetUserResponse * SOAP_FMAC4 soap_in__tds__SetUserResponse(struct soap *soap, const char *tag, _tds__SetUserResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetUserResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetUserResponse, sizeof(_tds__SetUserResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetUserResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetUserResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetUserResponse, 0, sizeof(_tds__SetUserResponse), 0, soap_copy__tds__SetUserResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__SetUserResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetUserResponse);
	if (this->soap_out(soap, tag?tag:"tds:SetUserResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetUserResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetUserResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetUserResponse * SOAP_FMAC4 soap_get__tds__SetUserResponse(struct soap *soap, _tds__SetUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetUserResponse * SOAP_FMAC2 soap_instantiate__tds__SetUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetUserResponse);
		if (size)
			*size = sizeof(_tds__SetUserResponse);
		((_tds__SetUserResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetUserResponse, n);
		if (size)
			*size = n * sizeof(_tds__SetUserResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetUserResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetUserResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetUserResponse %p -> %p\n", q, p));
	*(_tds__SetUserResponse*)p = *(_tds__SetUserResponse*)q;
}

void _tds__SetUser::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__SetUser::__sizeUser = 0;
	this->_tds__SetUser::User = NULL;
	/* transient soap skipped */
}

void _tds__SetUser::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__SetUser::User)
	{	int i;
		for (i = 0; i < this->_tds__SetUser::__sizeUser; i++)
		{
			soap_serialize_PointerTott__User(soap, this->_tds__SetUser::User + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__SetUser::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__SetUser(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetUser(struct soap *soap, const char *tag, int id, const _tds__SetUser *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetUser), type))
		return soap->error;
	if (a->_tds__SetUser::User)
	{	int i;
		for (i = 0; i < a->_tds__SetUser::__sizeUser; i++)
			if (soap_out_PointerTott__User(soap, "tds:User", -1, a->_tds__SetUser::User + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__SetUser::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__SetUser(soap, tag, this, type);
}

SOAP_FMAC3 _tds__SetUser * SOAP_FMAC4 soap_in__tds__SetUser(struct soap *soap, const char *tag, _tds__SetUser *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__SetUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetUser, sizeof(_tds__SetUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__SetUser)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__SetUser *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_User1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:User", 1, NULL))
			{	if (a->_tds__SetUser::User == NULL)
				{	if (soap_blist_User1 == NULL)
						soap_blist_User1 = soap_new_block(soap);
					a->_tds__SetUser::User = (tt__User **)soap_push_block(soap, soap_blist_User1, sizeof(tt__User *));
					if (a->_tds__SetUser::User == NULL)
						return NULL;
					*a->_tds__SetUser::User = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTott__User(soap, "tds:User", a->_tds__SetUser::User, "tt:User"))
				{	a->_tds__SetUser::__sizeUser++;
					a->_tds__SetUser::User = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__SetUser::User)
			soap_pop_block(soap, soap_blist_User1);
		if (a->_tds__SetUser::__sizeUser)
			a->_tds__SetUser::User = (tt__User **)soap_save_block(soap, soap_blist_User1, NULL, 1);
		else
		{	a->_tds__SetUser::User = NULL;
			if (soap_blist_User1)
				soap_end_block(soap, soap_blist_User1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__SetUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetUser, 0, sizeof(_tds__SetUser), 0, soap_copy__tds__SetUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__SetUser::__sizeUser < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__SetUser::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__SetUser);
	if (this->soap_out(soap, tag?tag:"tds:SetUser", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__SetUser::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__SetUser(soap, this, tag, type);
}

SOAP_FMAC3 _tds__SetUser * SOAP_FMAC4 soap_get__tds__SetUser(struct soap *soap, _tds__SetUser *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__SetUser * SOAP_FMAC2 soap_instantiate__tds__SetUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__SetUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__SetUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__SetUser);
		if (size)
			*size = sizeof(_tds__SetUser);
		((_tds__SetUser*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__SetUser, n);
		if (size)
			*size = n * sizeof(_tds__SetUser);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__SetUser*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__SetUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__SetUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__SetUser %p -> %p\n", q, p));
	*(_tds__SetUser*)p = *(_tds__SetUser*)q;
}

void _tds__DeleteUsersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__DeleteUsersResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__DeleteUsersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteUsersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteUsersResponse(struct soap *soap, const char *tag, int id, const _tds__DeleteUsersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteUsersResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteUsersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__DeleteUsersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteUsersResponse * SOAP_FMAC4 soap_in__tds__DeleteUsersResponse(struct soap *soap, const char *tag, _tds__DeleteUsersResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteUsersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(_tds__DeleteUsersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__DeleteUsersResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__DeleteUsersResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteUsersResponse, 0, sizeof(_tds__DeleteUsersResponse), 0, soap_copy__tds__DeleteUsersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__DeleteUsersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__DeleteUsersResponse);
	if (this->soap_out(soap, tag?tag:"tds:DeleteUsersResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteUsersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteUsersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteUsersResponse * SOAP_FMAC4 soap_get__tds__DeleteUsersResponse(struct soap *soap, _tds__DeleteUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__DeleteUsersResponse * SOAP_FMAC2 soap_instantiate__tds__DeleteUsersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteUsersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__DeleteUsersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__DeleteUsersResponse);
		if (size)
			*size = sizeof(_tds__DeleteUsersResponse);
		((_tds__DeleteUsersResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__DeleteUsersResponse, n);
		if (size)
			*size = n * sizeof(_tds__DeleteUsersResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__DeleteUsersResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__DeleteUsersResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__DeleteUsersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__DeleteUsersResponse %p -> %p\n", q, p));
	*(_tds__DeleteUsersResponse*)p = *(_tds__DeleteUsersResponse*)q;
}

void _tds__DeleteUsers::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__DeleteUsers::__sizeUsername = 0;
	this->_tds__DeleteUsers::Username = NULL;
	/* transient soap skipped */
}

void _tds__DeleteUsers::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__DeleteUsers::Username)
	{	int i;
		for (i = 0; i < this->_tds__DeleteUsers::__sizeUsername; i++)
		{
			soap_serialize_string(soap, this->_tds__DeleteUsers::Username + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__DeleteUsers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__DeleteUsers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteUsers(struct soap *soap, const char *tag, int id, const _tds__DeleteUsers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteUsers), type))
		return soap->error;
	if (a->_tds__DeleteUsers::Username)
	{	int i;
		for (i = 0; i < a->_tds__DeleteUsers::__sizeUsername; i++)
			if (soap_out_string(soap, "tds:Username", -1, a->_tds__DeleteUsers::Username + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__DeleteUsers::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__DeleteUsers(soap, tag, this, type);
}

SOAP_FMAC3 _tds__DeleteUsers * SOAP_FMAC4 soap_in__tds__DeleteUsers(struct soap *soap, const char *tag, _tds__DeleteUsers *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__DeleteUsers *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteUsers, sizeof(_tds__DeleteUsers), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__DeleteUsers)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__DeleteUsers *)a->soap_in(soap, tag, type);
		}
	}
	struct soap_blist *soap_blist_Username1 = NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Username", 1, NULL))
			{	if (a->_tds__DeleteUsers::Username == NULL)
				{	if (soap_blist_Username1 == NULL)
						soap_blist_Username1 = soap_new_block(soap);
					a->_tds__DeleteUsers::Username = (char **)soap_push_block(soap, soap_blist_Username1, sizeof(char *));
					if (a->_tds__DeleteUsers::Username == NULL)
						return NULL;
					*a->_tds__DeleteUsers::Username = NULL;
				}
				soap_revert(soap);
				if (soap_in_string(soap, "tds:Username", a->_tds__DeleteUsers::Username, "xsd:string"))
				{	a->_tds__DeleteUsers::__sizeUsername++;
					a->_tds__DeleteUsers::Username = NULL;
					continue;
				}
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->_tds__DeleteUsers::Username)
			soap_pop_block(soap, soap_blist_Username1);
		if (a->_tds__DeleteUsers::__sizeUsername)
			a->_tds__DeleteUsers::Username = (char **)soap_save_block(soap, soap_blist_Username1, NULL, 1);
		else
		{	a->_tds__DeleteUsers::Username = NULL;
			if (soap_blist_Username1)
				soap_end_block(soap, soap_blist_Username1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__DeleteUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteUsers, 0, sizeof(_tds__DeleteUsers), 0, soap_copy__tds__DeleteUsers);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->_tds__DeleteUsers::__sizeUsername < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

int _tds__DeleteUsers::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__DeleteUsers);
	if (this->soap_out(soap, tag?tag:"tds:DeleteUsers", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__DeleteUsers::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__DeleteUsers(soap, this, tag, type);
}

SOAP_FMAC3 _tds__DeleteUsers * SOAP_FMAC4 soap_get__tds__DeleteUsers(struct soap *soap, _tds__DeleteUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__DeleteUsers * SOAP_FMAC2 soap_instantiate__tds__DeleteUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__DeleteUsers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__DeleteUsers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__DeleteUsers);
		if (size)
			*size = sizeof(_tds__DeleteUsers);
		((_tds__DeleteUsers*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__DeleteUsers, n);
		if (size)
			*size = n * sizeof(_tds__DeleteUsers);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__DeleteUsers*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__DeleteUsers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__DeleteUsers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__DeleteUsers %p -> %p\n", q, p));
	*(_tds__DeleteUsers*)p = *(_tds__DeleteUsers*)q;
}

void _tds__CreateUsersResponse::soap_default(struct soap *soap)
{
	this->soap = soap;
	/* transient soap skipped */
}

void _tds__CreateUsersResponse::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
#endif
}

int _tds__CreateUsersResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateUsersResponse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateUsersResponse(struct soap *soap, const char *tag, int id, const _tds__CreateUsersResponse *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateUsersResponse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_tds__CreateUsersResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__tds__CreateUsersResponse(soap, tag, this, type);
}

SOAP_FMAC3 _tds__CreateUsersResponse * SOAP_FMAC4 soap_in__tds__CreateUsersResponse(struct soap *soap, const char *tag, _tds__CreateUsersResponse *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_tds__CreateUsersResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateUsersResponse, sizeof(_tds__CreateUsersResponse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__tds__CreateUsersResponse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_tds__CreateUsersResponse *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_tds__CreateUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateUsersResponse, 0, sizeof(_tds__CreateUsersResponse), 0, soap_copy__tds__CreateUsersResponse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

int _tds__CreateUsersResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__tds__CreateUsersResponse);
	if (this->soap_out(soap, tag?tag:"tds:CreateUsersResponse", id, type))
		return soap->error;
	return soap_putindependent(soap);
}

void *_tds__CreateUsersResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__tds__CreateUsersResponse(soap, this, tag, type);
}

SOAP_FMAC3 _tds__CreateUsersResponse * SOAP_FMAC4 soap_get__tds__CreateUsersResponse(struct soap *soap, _tds__CreateUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 _tds__CreateUsersResponse * SOAP_FMAC2 soap_instantiate__tds__CreateUsersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__tds__CreateUsersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__tds__CreateUsersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(_tds__CreateUsersResponse);
		if (size)
			*size = sizeof(_tds__CreateUsersResponse);
		((_tds__CreateUsersResponse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(_tds__CreateUsersResponse, n);
		if (size)
			*size = n * sizeof(_tds__CreateUsersResponse);
		if (cp->ptr)
			for (int i = 0; i < n; i++)
				((_tds__CreateUsersResponse*)cp->ptr)[i].soap = soap;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (_tds__CreateUsersResponse*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__tds__CreateUsersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _tds__CreateUsersResponse %p -> %p\n", q, p));
	*(_tds__CreateUsersResponse*)p = *(_tds__CreateUsersResponse*)q;
}

void _tds__CreateUsers::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_tds__CreateUsers::__sizeUser = 0;
	this->_tds__CreateUsers::User = NULL;
	/* transient soap skipped */
}

void _tds__CreateUsers::soap_serialize(struct soap *soap) const
{
#ifndef WITH_NOIDREF
	(void)soap; /* appease -Wall -Werror */
	if (this->_tds__CreateUsers::User)
	{	int i;
		for (i = 0; i < this->_tds__CreateUsers::__sizeUser; i++)
		{
			soap_serialize_PointerTott__User(soap, this->_tds__CreateUsers::User + i);
		}
	}
	/* transient soap skipped */
#endif
}

int _tds__CreateUsers::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__tds__CreateUsers(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateUsers(struct soap *soap, const char *tag, int id, const _tds__CreateUsers *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateUsers), type))
		return soap->error;
	if (a->_tds__CreateUsers::User)
	{	int i;
		for (i = 0; i < a->_tds__CreateUsers::__sizeUser; i++)
			if (soap_out_PointerTott__User(soap, "tds:User", -1, a->_tds__CreateUsers::User + i, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}
