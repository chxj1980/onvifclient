#include "soapH.h"


SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioEncoderConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurationOptions(soap, "trt:GetAudioEncoderConfigurationOptions", -1, &a->trt__GetAudioEncoderConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC4 soap_in___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *tag, struct __trt__GetAudioEncoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_trt__GetAudioEncoderConfigurationOptions = 1;
	short soap_flag;
	a = (struct __trt__GetAudioEncoderConfigurationOptions *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions, sizeof(struct __trt__GetAudioEncoderConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioEncoderConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioEncoderConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetAudioEncoderConfigurationOptions(soap, "trt:GetAudioEncoderConfigurationOptions", &a->trt__GetAudioEncoderConfigurationOptions, ""))
				{	soap_flag_trt__GetAudioEncoderConfigurationOptions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const struct __trt__GetAudioEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetAudioEncoderConfigurationOptions(soap, tag?tag:"-trt:GetAudioEncoderConfigurationOptions", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC4 soap_get___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, struct __trt__GetAudioEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetAudioEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioEncoderConfigurationOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetAudioEncoderConfigurationOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetAudioEncoderConfigurationOptions);
		if (size)
			*size = sizeof(struct __trt__GetAudioEncoderConfigurationOptions);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetAudioEncoderConfigurationOptions, n);
		if (size)
			*size = n * sizeof(struct __trt__GetAudioEncoderConfigurationOptions);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetAudioEncoderConfigurationOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetAudioEncoderConfigurationOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetAudioEncoderConfigurationOptions %p -> %p\n", q, p));
	*(struct __trt__GetAudioEncoderConfigurationOptions*)p = *(struct __trt__GetAudioEncoderConfigurationOptions*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioSourceConfigurationOptions(struct soap *soap, struct __trt__GetAudioSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioSourceConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioSourceConfigurationOptions(struct soap *soap, const struct __trt__GetAudioSourceConfigurationOptions *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetAudioSourceConfigurationOptions(soap, &a->trt__GetAudioSourceConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioSourceConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurationOptions(soap, "trt:GetAudioSourceConfigurationOptions", -1, &a->trt__GetAudioSourceConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSourceConfigurationOptions * SOAP_FMAC4 soap_in___trt__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, struct __trt__GetAudioSourceConfigurationOptions *a, const char *type)
{
	size_t soap_flag_trt__GetAudioSourceConfigurationOptions = 1;
	short soap_flag;
	a = (struct __trt__GetAudioSourceConfigurationOptions *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioSourceConfigurationOptions, sizeof(struct __trt__GetAudioSourceConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioSourceConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioSourceConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetAudioSourceConfigurationOptions(soap, "trt:GetAudioSourceConfigurationOptions", &a->trt__GetAudioSourceConfigurationOptions, ""))
				{	soap_flag_trt__GetAudioSourceConfigurationOptions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioSourceConfigurationOptions(struct soap *soap, const struct __trt__GetAudioSourceConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetAudioSourceConfigurationOptions(soap, tag?tag:"-trt:GetAudioSourceConfigurationOptions", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSourceConfigurationOptions * SOAP_FMAC4 soap_get___trt__GetAudioSourceConfigurationOptions(struct soap *soap, struct __trt__GetAudioSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetAudioSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetAudioSourceConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioSourceConfigurationOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetAudioSourceConfigurationOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetAudioSourceConfigurationOptions);
		if (size)
			*size = sizeof(struct __trt__GetAudioSourceConfigurationOptions);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetAudioSourceConfigurationOptions, n);
		if (size)
			*size = n * sizeof(struct __trt__GetAudioSourceConfigurationOptions);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetAudioSourceConfigurationOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetAudioSourceConfigurationOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetAudioSourceConfigurationOptions %p -> %p\n", q, p));
	*(struct __trt__GetAudioSourceConfigurationOptions*)p = *(struct __trt__GetAudioSourceConfigurationOptions*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct __trt__GetVideoEncoderConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoEncoderConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const struct __trt__GetVideoEncoderConfigurationOptions *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, &a->trt__GetVideoEncoderConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoEncoderConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, "trt:GetVideoEncoderConfigurationOptions", -1, &a->trt__GetVideoEncoderConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC4 soap_in___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct __trt__GetVideoEncoderConfigurationOptions *a, const char *type)
{
	size_t soap_flag_trt__GetVideoEncoderConfigurationOptions = 1;
	short soap_flag;
	a = (struct __trt__GetVideoEncoderConfigurationOptions *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions, sizeof(struct __trt__GetVideoEncoderConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoEncoderConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoEncoderConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, "trt:GetVideoEncoderConfigurationOptions", &a->trt__GetVideoEncoderConfigurationOptions, ""))
				{	soap_flag_trt__GetVideoEncoderConfigurationOptions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const struct __trt__GetVideoEncoderConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetVideoEncoderConfigurationOptions(soap, tag?tag:"-trt:GetVideoEncoderConfigurationOptions", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC4 soap_get___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct __trt__GetVideoEncoderConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetVideoEncoderConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetVideoEncoderConfigurationOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetVideoEncoderConfigurationOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetVideoEncoderConfigurationOptions);
		if (size)
			*size = sizeof(struct __trt__GetVideoEncoderConfigurationOptions);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetVideoEncoderConfigurationOptions, n);
		if (size)
			*size = n * sizeof(struct __trt__GetVideoEncoderConfigurationOptions);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetVideoEncoderConfigurationOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetVideoEncoderConfigurationOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetVideoEncoderConfigurationOptions %p -> %p\n", q, p));
	*(struct __trt__GetVideoEncoderConfigurationOptions*)p = *(struct __trt__GetVideoEncoderConfigurationOptions*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoSourceConfigurationOptions(struct soap *soap, struct __trt__GetVideoSourceConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoSourceConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoSourceConfigurationOptions(struct soap *soap, const struct __trt__GetVideoSourceConfigurationOptions *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetVideoSourceConfigurationOptions(soap, &a->trt__GetVideoSourceConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoSourceConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurationOptions(soap, "trt:GetVideoSourceConfigurationOptions", -1, &a->trt__GetVideoSourceConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceConfigurationOptions * SOAP_FMAC4 soap_in___trt__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, struct __trt__GetVideoSourceConfigurationOptions *a, const char *type)
{
	size_t soap_flag_trt__GetVideoSourceConfigurationOptions = 1;
	short soap_flag;
	a = (struct __trt__GetVideoSourceConfigurationOptions *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoSourceConfigurationOptions, sizeof(struct __trt__GetVideoSourceConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoSourceConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoSourceConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetVideoSourceConfigurationOptions(soap, "trt:GetVideoSourceConfigurationOptions", &a->trt__GetVideoSourceConfigurationOptions, ""))
				{	soap_flag_trt__GetVideoSourceConfigurationOptions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoSourceConfigurationOptions(struct soap *soap, const struct __trt__GetVideoSourceConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetVideoSourceConfigurationOptions(soap, tag?tag:"-trt:GetVideoSourceConfigurationOptions", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceConfigurationOptions * SOAP_FMAC4 soap_get___trt__GetVideoSourceConfigurationOptions(struct soap *soap, struct __trt__GetVideoSourceConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetVideoSourceConfigurationOptions * SOAP_FMAC2 soap_instantiate___trt__GetVideoSourceConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetVideoSourceConfigurationOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetVideoSourceConfigurationOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetVideoSourceConfigurationOptions);
		if (size)
			*size = sizeof(struct __trt__GetVideoSourceConfigurationOptions);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetVideoSourceConfigurationOptions, n);
		if (size)
			*size = n * sizeof(struct __trt__GetVideoSourceConfigurationOptions);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetVideoSourceConfigurationOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetVideoSourceConfigurationOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetVideoSourceConfigurationOptions %p -> %p\n", q, p));
	*(struct __trt__GetVideoSourceConfigurationOptions*)p = *(struct __trt__GetVideoSourceConfigurationOptions*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetAudioDecoderConfiguration(struct soap *soap, struct __trt__SetAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetAudioDecoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetAudioDecoderConfiguration(struct soap *soap, const struct __trt__SetAudioDecoderConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__SetAudioDecoderConfiguration(soap, &a->trt__SetAudioDecoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetAudioDecoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__SetAudioDecoderConfiguration(soap, "trt:SetAudioDecoderConfiguration", -1, &a->trt__SetAudioDecoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioDecoderConfiguration * SOAP_FMAC4 soap_in___trt__SetAudioDecoderConfiguration(struct soap *soap, const char *tag, struct __trt__SetAudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetAudioDecoderConfiguration = 1;
	short soap_flag;
	a = (struct __trt__SetAudioDecoderConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetAudioDecoderConfiguration, sizeof(struct __trt__SetAudioDecoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetAudioDecoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetAudioDecoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__SetAudioDecoderConfiguration(soap, "trt:SetAudioDecoderConfiguration", &a->trt__SetAudioDecoderConfiguration, ""))
				{	soap_flag_trt__SetAudioDecoderConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetAudioDecoderConfiguration(struct soap *soap, const struct __trt__SetAudioDecoderConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__SetAudioDecoderConfiguration(soap, tag?tag:"-trt:SetAudioDecoderConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioDecoderConfiguration * SOAP_FMAC4 soap_get___trt__SetAudioDecoderConfiguration(struct soap *soap, struct __trt__SetAudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__SetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioDecoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__SetAudioDecoderConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__SetAudioDecoderConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__SetAudioDecoderConfiguration);
		if (size)
			*size = sizeof(struct __trt__SetAudioDecoderConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__SetAudioDecoderConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__SetAudioDecoderConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__SetAudioDecoderConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__SetAudioDecoderConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__SetAudioDecoderConfiguration %p -> %p\n", q, p));
	*(struct __trt__SetAudioDecoderConfiguration*)p = *(struct __trt__SetAudioDecoderConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetAudioOutputConfiguration(struct soap *soap, struct __trt__SetAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetAudioOutputConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetAudioOutputConfiguration(struct soap *soap, const struct __trt__SetAudioOutputConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__SetAudioOutputConfiguration(soap, &a->trt__SetAudioOutputConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetAudioOutputConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__SetAudioOutputConfiguration(soap, "trt:SetAudioOutputConfiguration", -1, &a->trt__SetAudioOutputConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioOutputConfiguration * SOAP_FMAC4 soap_in___trt__SetAudioOutputConfiguration(struct soap *soap, const char *tag, struct __trt__SetAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetAudioOutputConfiguration = 1;
	short soap_flag;
	a = (struct __trt__SetAudioOutputConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetAudioOutputConfiguration, sizeof(struct __trt__SetAudioOutputConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetAudioOutputConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetAudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__SetAudioOutputConfiguration(soap, "trt:SetAudioOutputConfiguration", &a->trt__SetAudioOutputConfiguration, ""))
				{	soap_flag_trt__SetAudioOutputConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetAudioOutputConfiguration(struct soap *soap, const struct __trt__SetAudioOutputConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__SetAudioOutputConfiguration(soap, tag?tag:"-trt:SetAudioOutputConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioOutputConfiguration * SOAP_FMAC4 soap_get___trt__SetAudioOutputConfiguration(struct soap *soap, struct __trt__SetAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__SetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioOutputConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__SetAudioOutputConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__SetAudioOutputConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__SetAudioOutputConfiguration);
		if (size)
			*size = sizeof(struct __trt__SetAudioOutputConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__SetAudioOutputConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__SetAudioOutputConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__SetAudioOutputConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__SetAudioOutputConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__SetAudioOutputConfiguration %p -> %p\n", q, p));
	*(struct __trt__SetAudioOutputConfiguration*)p = *(struct __trt__SetAudioOutputConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetMetadataConfiguration(struct soap *soap, struct __trt__SetMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetMetadataConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetMetadataConfiguration(struct soap *soap, const struct __trt__SetMetadataConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__SetMetadataConfiguration(soap, &a->trt__SetMetadataConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetMetadataConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetMetadataConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__SetMetadataConfiguration(soap, "trt:SetMetadataConfiguration", -1, &a->trt__SetMetadataConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetMetadataConfiguration * SOAP_FMAC4 soap_in___trt__SetMetadataConfiguration(struct soap *soap, const char *tag, struct __trt__SetMetadataConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetMetadataConfiguration = 1;
	short soap_flag;
	a = (struct __trt__SetMetadataConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetMetadataConfiguration, sizeof(struct __trt__SetMetadataConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetMetadataConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetMetadataConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__SetMetadataConfiguration(soap, "trt:SetMetadataConfiguration", &a->trt__SetMetadataConfiguration, ""))
				{	soap_flag_trt__SetMetadataConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetMetadataConfiguration(struct soap *soap, const struct __trt__SetMetadataConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__SetMetadataConfiguration(soap, tag?tag:"-trt:SetMetadataConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetMetadataConfiguration * SOAP_FMAC4 soap_get___trt__SetMetadataConfiguration(struct soap *soap, struct __trt__SetMetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__SetMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetMetadataConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__SetMetadataConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__SetMetadataConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__SetMetadataConfiguration);
		if (size)
			*size = sizeof(struct __trt__SetMetadataConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__SetMetadataConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__SetMetadataConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__SetMetadataConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__SetMetadataConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__SetMetadataConfiguration %p -> %p\n", q, p));
	*(struct __trt__SetMetadataConfiguration*)p = *(struct __trt__SetMetadataConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetVideoAnalyticsConfiguration(struct soap *soap, struct __trt__SetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetVideoAnalyticsConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__SetVideoAnalyticsConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__SetVideoAnalyticsConfiguration(soap, &a->trt__SetVideoAnalyticsConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__SetVideoAnalyticsConfiguration(soap, "trt:SetVideoAnalyticsConfiguration", -1, &a->trt__SetVideoAnalyticsConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in___trt__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct __trt__SetVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetVideoAnalyticsConfiguration = 1;
	short soap_flag;
	a = (struct __trt__SetVideoAnalyticsConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetVideoAnalyticsConfiguration, sizeof(struct __trt__SetVideoAnalyticsConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetVideoAnalyticsConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetVideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__SetVideoAnalyticsConfiguration(soap, "trt:SetVideoAnalyticsConfiguration", &a->trt__SetVideoAnalyticsConfiguration, ""))
				{	soap_flag_trt__SetVideoAnalyticsConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__SetVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__SetVideoAnalyticsConfiguration(soap, tag?tag:"-trt:SetVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get___trt__SetVideoAnalyticsConfiguration(struct soap *soap, struct __trt__SetVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__SetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetVideoAnalyticsConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__SetVideoAnalyticsConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__SetVideoAnalyticsConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__SetVideoAnalyticsConfiguration);
		if (size)
			*size = sizeof(struct __trt__SetVideoAnalyticsConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__SetVideoAnalyticsConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__SetVideoAnalyticsConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__SetVideoAnalyticsConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__SetVideoAnalyticsConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__SetVideoAnalyticsConfiguration %p -> %p\n", q, p));
	*(struct __trt__SetVideoAnalyticsConfiguration*)p = *(struct __trt__SetVideoAnalyticsConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetAudioEncoderConfiguration(struct soap *soap, struct __trt__SetAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetAudioEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetAudioEncoderConfiguration(struct soap *soap, const struct __trt__SetAudioEncoderConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__SetAudioEncoderConfiguration(soap, &a->trt__SetAudioEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetAudioEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__SetAudioEncoderConfiguration(soap, "trt:SetAudioEncoderConfiguration", -1, &a->trt__SetAudioEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioEncoderConfiguration * SOAP_FMAC4 soap_in___trt__SetAudioEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__SetAudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetAudioEncoderConfiguration = 1;
	short soap_flag;
	a = (struct __trt__SetAudioEncoderConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetAudioEncoderConfiguration, sizeof(struct __trt__SetAudioEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetAudioEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetAudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__SetAudioEncoderConfiguration(soap, "trt:SetAudioEncoderConfiguration", &a->trt__SetAudioEncoderConfiguration, ""))
				{	soap_flag_trt__SetAudioEncoderConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetAudioEncoderConfiguration(struct soap *soap, const struct __trt__SetAudioEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__SetAudioEncoderConfiguration(soap, tag?tag:"-trt:SetAudioEncoderConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioEncoderConfiguration * SOAP_FMAC4 soap_get___trt__SetAudioEncoderConfiguration(struct soap *soap, struct __trt__SetAudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__SetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__SetAudioEncoderConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__SetAudioEncoderConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__SetAudioEncoderConfiguration);
		if (size)
			*size = sizeof(struct __trt__SetAudioEncoderConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__SetAudioEncoderConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__SetAudioEncoderConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__SetAudioEncoderConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__SetAudioEncoderConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__SetAudioEncoderConfiguration %p -> %p\n", q, p));
	*(struct __trt__SetAudioEncoderConfiguration*)p = *(struct __trt__SetAudioEncoderConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetAudioSourceConfiguration(struct soap *soap, struct __trt__SetAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetAudioSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetAudioSourceConfiguration(struct soap *soap, const struct __trt__SetAudioSourceConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__SetAudioSourceConfiguration(soap, &a->trt__SetAudioSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetAudioSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__SetAudioSourceConfiguration(soap, "trt:SetAudioSourceConfiguration", -1, &a->trt__SetAudioSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioSourceConfiguration * SOAP_FMAC4 soap_in___trt__SetAudioSourceConfiguration(struct soap *soap, const char *tag, struct __trt__SetAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetAudioSourceConfiguration = 1;
	short soap_flag;
	a = (struct __trt__SetAudioSourceConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetAudioSourceConfiguration, sizeof(struct __trt__SetAudioSourceConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetAudioSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetAudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__SetAudioSourceConfiguration(soap, "trt:SetAudioSourceConfiguration", &a->trt__SetAudioSourceConfiguration, ""))
				{	soap_flag_trt__SetAudioSourceConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetAudioSourceConfiguration(struct soap *soap, const struct __trt__SetAudioSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__SetAudioSourceConfiguration(soap, tag?tag:"-trt:SetAudioSourceConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetAudioSourceConfiguration * SOAP_FMAC4 soap_get___trt__SetAudioSourceConfiguration(struct soap *soap, struct __trt__SetAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__SetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetAudioSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__SetAudioSourceConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__SetAudioSourceConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__SetAudioSourceConfiguration);
		if (size)
			*size = sizeof(struct __trt__SetAudioSourceConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__SetAudioSourceConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__SetAudioSourceConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__SetAudioSourceConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__SetAudioSourceConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__SetAudioSourceConfiguration %p -> %p\n", q, p));
	*(struct __trt__SetAudioSourceConfiguration*)p = *(struct __trt__SetAudioSourceConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetVideoEncoderConfiguration(struct soap *soap, struct __trt__SetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetVideoEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetVideoEncoderConfiguration(struct soap *soap, const struct __trt__SetVideoEncoderConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__SetVideoEncoderConfiguration(soap, &a->trt__SetVideoEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetVideoEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__SetVideoEncoderConfiguration(soap, "trt:SetVideoEncoderConfiguration", -1, &a->trt__SetVideoEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoEncoderConfiguration * SOAP_FMAC4 soap_in___trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__SetVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetVideoEncoderConfiguration = 1;
	short soap_flag;
	a = (struct __trt__SetVideoEncoderConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetVideoEncoderConfiguration, sizeof(struct __trt__SetVideoEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetVideoEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetVideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__SetVideoEncoderConfiguration(soap, "trt:SetVideoEncoderConfiguration", &a->trt__SetVideoEncoderConfiguration, ""))
				{	soap_flag_trt__SetVideoEncoderConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetVideoEncoderConfiguration(struct soap *soap, const struct __trt__SetVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__SetVideoEncoderConfiguration(soap, tag?tag:"-trt:SetVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoEncoderConfiguration * SOAP_FMAC4 soap_get___trt__SetVideoEncoderConfiguration(struct soap *soap, struct __trt__SetVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__SetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetVideoEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__SetVideoEncoderConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__SetVideoEncoderConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__SetVideoEncoderConfiguration);
		if (size)
			*size = sizeof(struct __trt__SetVideoEncoderConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__SetVideoEncoderConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__SetVideoEncoderConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__SetVideoEncoderConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__SetVideoEncoderConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__SetVideoEncoderConfiguration %p -> %p\n", q, p));
	*(struct __trt__SetVideoEncoderConfiguration*)p = *(struct __trt__SetVideoEncoderConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__SetVideoSourceConfiguration(struct soap *soap, struct __trt__SetVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__SetVideoSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__SetVideoSourceConfiguration(struct soap *soap, const struct __trt__SetVideoSourceConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__SetVideoSourceConfiguration(soap, &a->trt__SetVideoSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__SetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__SetVideoSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__SetVideoSourceConfiguration(soap, "trt:SetVideoSourceConfiguration", -1, &a->trt__SetVideoSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoSourceConfiguration * SOAP_FMAC4 soap_in___trt__SetVideoSourceConfiguration(struct soap *soap, const char *tag, struct __trt__SetVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__SetVideoSourceConfiguration = 1;
	short soap_flag;
	a = (struct __trt__SetVideoSourceConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__SetVideoSourceConfiguration, sizeof(struct __trt__SetVideoSourceConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__SetVideoSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__SetVideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__SetVideoSourceConfiguration(soap, "trt:SetVideoSourceConfiguration", &a->trt__SetVideoSourceConfiguration, ""))
				{	soap_flag_trt__SetVideoSourceConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__SetVideoSourceConfiguration(struct soap *soap, const struct __trt__SetVideoSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__SetVideoSourceConfiguration(soap, tag?tag:"-trt:SetVideoSourceConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__SetVideoSourceConfiguration * SOAP_FMAC4 soap_get___trt__SetVideoSourceConfiguration(struct soap *soap, struct __trt__SetVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__SetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__SetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__SetVideoSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__SetVideoSourceConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__SetVideoSourceConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__SetVideoSourceConfiguration);
		if (size)
			*size = sizeof(struct __trt__SetVideoSourceConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__SetVideoSourceConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__SetVideoSourceConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__SetVideoSourceConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__SetVideoSourceConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__SetVideoSourceConfiguration %p -> %p\n", q, p));
	*(struct __trt__SetVideoSourceConfiguration*)p = *(struct __trt__SetVideoSourceConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioDecoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleAudioDecoderConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioDecoderConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(soap, &a->trt__GetCompatibleAudioDecoderConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleAudioDecoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(soap, "trt:GetCompatibleAudioDecoderConfigurations", -1, &a->trt__GetCompatibleAudioDecoderConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleAudioDecoderConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleAudioDecoderConfigurations = 1;
	short soap_flag;
	a = (struct __trt__GetCompatibleAudioDecoderConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleAudioDecoderConfigurations, sizeof(struct __trt__GetCompatibleAudioDecoderConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleAudioDecoderConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleAudioDecoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(soap, "trt:GetCompatibleAudioDecoderConfigurations", &a->trt__GetCompatibleAudioDecoderConfigurations, ""))
				{	soap_flag_trt__GetCompatibleAudioDecoderConfigurations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioDecoderConfigurations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetCompatibleAudioDecoderConfigurations(soap, tag?tag:"-trt:GetCompatibleAudioDecoderConfigurations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioDecoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleAudioDecoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetCompatibleAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetCompatibleAudioDecoderConfigurations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetCompatibleAudioDecoderConfigurations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetCompatibleAudioDecoderConfigurations);
		if (size)
			*size = sizeof(struct __trt__GetCompatibleAudioDecoderConfigurations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetCompatibleAudioDecoderConfigurations, n);
		if (size)
			*size = n * sizeof(struct __trt__GetCompatibleAudioDecoderConfigurations);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetCompatibleAudioDecoderConfigurations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetCompatibleAudioDecoderConfigurations %p -> %p\n", q, p));
	*(struct __trt__GetCompatibleAudioDecoderConfigurations*)p = *(struct __trt__GetCompatibleAudioDecoderConfigurations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioOutputConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleAudioOutputConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioOutputConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetCompatibleAudioOutputConfigurations(soap, &a->trt__GetCompatibleAudioOutputConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleAudioOutputConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetCompatibleAudioOutputConfigurations(soap, "trt:GetCompatibleAudioOutputConfigurations", -1, &a->trt__GetCompatibleAudioOutputConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioOutputConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleAudioOutputConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleAudioOutputConfigurations = 1;
	short soap_flag;
	a = (struct __trt__GetCompatibleAudioOutputConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleAudioOutputConfigurations, sizeof(struct __trt__GetCompatibleAudioOutputConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleAudioOutputConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleAudioOutputConfigurations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetCompatibleAudioOutputConfigurations(soap, "trt:GetCompatibleAudioOutputConfigurations", &a->trt__GetCompatibleAudioOutputConfigurations, ""))
				{	soap_flag_trt__GetCompatibleAudioOutputConfigurations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioOutputConfigurations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetCompatibleAudioOutputConfigurations(soap, tag?tag:"-trt:GetCompatibleAudioOutputConfigurations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioOutputConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioOutputConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleAudioOutputConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetCompatibleAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetCompatibleAudioOutputConfigurations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetCompatibleAudioOutputConfigurations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetCompatibleAudioOutputConfigurations);
		if (size)
			*size = sizeof(struct __trt__GetCompatibleAudioOutputConfigurations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetCompatibleAudioOutputConfigurations, n);
		if (size)
			*size = n * sizeof(struct __trt__GetCompatibleAudioOutputConfigurations);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetCompatibleAudioOutputConfigurations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetCompatibleAudioOutputConfigurations %p -> %p\n", q, p));
	*(struct __trt__GetCompatibleAudioOutputConfigurations*)p = *(struct __trt__GetCompatibleAudioOutputConfigurations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleMetadataConfigurations(struct soap *soap, struct __trt__GetCompatibleMetadataConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleMetadataConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleMetadataConfigurations(struct soap *soap, const struct __trt__GetCompatibleMetadataConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetCompatibleMetadataConfigurations(soap, &a->trt__GetCompatibleMetadataConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleMetadataConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleMetadataConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetCompatibleMetadataConfigurations(soap, "trt:GetCompatibleMetadataConfigurations", -1, &a->trt__GetCompatibleMetadataConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleMetadataConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleMetadataConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleMetadataConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleMetadataConfigurations = 1;
	short soap_flag;
	a = (struct __trt__GetCompatibleMetadataConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleMetadataConfigurations, sizeof(struct __trt__GetCompatibleMetadataConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleMetadataConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleMetadataConfigurations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetCompatibleMetadataConfigurations(soap, "trt:GetCompatibleMetadataConfigurations", &a->trt__GetCompatibleMetadataConfigurations, ""))
				{	soap_flag_trt__GetCompatibleMetadataConfigurations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleMetadataConfigurations(struct soap *soap, const struct __trt__GetCompatibleMetadataConfigurations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetCompatibleMetadataConfigurations(soap, tag?tag:"-trt:GetCompatibleMetadataConfigurations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleMetadataConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleMetadataConfigurations(struct soap *soap, struct __trt__GetCompatibleMetadataConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleMetadataConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetCompatibleMetadataConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleMetadataConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetCompatibleMetadataConfigurations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetCompatibleMetadataConfigurations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetCompatibleMetadataConfigurations);
		if (size)
			*size = sizeof(struct __trt__GetCompatibleMetadataConfigurations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetCompatibleMetadataConfigurations, n);
		if (size)
			*size = n * sizeof(struct __trt__GetCompatibleMetadataConfigurations);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetCompatibleMetadataConfigurations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetCompatibleMetadataConfigurations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetCompatibleMetadataConfigurations %p -> %p\n", q, p));
	*(struct __trt__GetCompatibleMetadataConfigurations*)p = *(struct __trt__GetCompatibleMetadataConfigurations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoAnalyticsConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleVideoAnalyticsConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const struct __trt__GetCompatibleVideoAnalyticsConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(soap, &a->trt__GetCompatibleVideoAnalyticsConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleVideoAnalyticsConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(soap, "trt:GetCompatibleVideoAnalyticsConfigurations", -1, &a->trt__GetCompatibleVideoAnalyticsConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleVideoAnalyticsConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleVideoAnalyticsConfigurations = 1;
	short soap_flag;
	a = (struct __trt__GetCompatibleVideoAnalyticsConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations, sizeof(struct __trt__GetCompatibleVideoAnalyticsConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleVideoAnalyticsConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleVideoAnalyticsConfigurations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(soap, "trt:GetCompatibleVideoAnalyticsConfigurations", &a->trt__GetCompatibleVideoAnalyticsConfigurations, ""))
				{	soap_flag_trt__GetCompatibleVideoAnalyticsConfigurations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const struct __trt__GetCompatibleVideoAnalyticsConfigurations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag?tag:"-trt:GetCompatibleVideoAnalyticsConfigurations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoAnalyticsConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetCompatibleVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetCompatibleVideoAnalyticsConfigurations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetCompatibleVideoAnalyticsConfigurations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetCompatibleVideoAnalyticsConfigurations);
		if (size)
			*size = sizeof(struct __trt__GetCompatibleVideoAnalyticsConfigurations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetCompatibleVideoAnalyticsConfigurations, n);
		if (size)
			*size = n * sizeof(struct __trt__GetCompatibleVideoAnalyticsConfigurations);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetCompatibleVideoAnalyticsConfigurations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetCompatibleVideoAnalyticsConfigurations %p -> %p\n", q, p));
	*(struct __trt__GetCompatibleVideoAnalyticsConfigurations*)p = *(struct __trt__GetCompatibleVideoAnalyticsConfigurations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleAudioSourceConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioSourceConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetCompatibleAudioSourceConfigurations(soap, &a->trt__GetCompatibleAudioSourceConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleAudioSourceConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetCompatibleAudioSourceConfigurations(soap, "trt:GetCompatibleAudioSourceConfigurations", -1, &a->trt__GetCompatibleAudioSourceConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioSourceConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleAudioSourceConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleAudioSourceConfigurations = 1;
	short soap_flag;
	a = (struct __trt__GetCompatibleAudioSourceConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations, sizeof(struct __trt__GetCompatibleAudioSourceConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleAudioSourceConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleAudioSourceConfigurations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetCompatibleAudioSourceConfigurations(soap, "trt:GetCompatibleAudioSourceConfigurations", &a->trt__GetCompatibleAudioSourceConfigurations, ""))
				{	soap_flag_trt__GetCompatibleAudioSourceConfigurations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioSourceConfigurations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetCompatibleAudioSourceConfigurations(soap, tag?tag:"-trt:GetCompatibleAudioSourceConfigurations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioSourceConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioSourceConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleAudioSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetCompatibleAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetCompatibleAudioSourceConfigurations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetCompatibleAudioSourceConfigurations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetCompatibleAudioSourceConfigurations);
		if (size)
			*size = sizeof(struct __trt__GetCompatibleAudioSourceConfigurations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetCompatibleAudioSourceConfigurations, n);
		if (size)
			*size = n * sizeof(struct __trt__GetCompatibleAudioSourceConfigurations);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetCompatibleAudioSourceConfigurations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetCompatibleAudioSourceConfigurations %p -> %p\n", q, p));
	*(struct __trt__GetCompatibleAudioSourceConfigurations*)p = *(struct __trt__GetCompatibleAudioSourceConfigurations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleAudioEncoderConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioEncoderConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(soap, &a->trt__GetCompatibleAudioEncoderConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleAudioEncoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(soap, "trt:GetCompatibleAudioEncoderConfigurations", -1, &a->trt__GetCompatibleAudioEncoderConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleAudioEncoderConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleAudioEncoderConfigurations = 1;
	short soap_flag;
	a = (struct __trt__GetCompatibleAudioEncoderConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations, sizeof(struct __trt__GetCompatibleAudioEncoderConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleAudioEncoderConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleAudioEncoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(soap, "trt:GetCompatibleAudioEncoderConfigurations", &a->trt__GetCompatibleAudioEncoderConfigurations, ""))
				{	soap_flag_trt__GetCompatibleAudioEncoderConfigurations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const struct __trt__GetCompatibleAudioEncoderConfigurations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetCompatibleAudioEncoderConfigurations(soap, tag?tag:"-trt:GetCompatibleAudioEncoderConfigurations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, struct __trt__GetCompatibleAudioEncoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleAudioEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetCompatibleAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetCompatibleAudioEncoderConfigurations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetCompatibleAudioEncoderConfigurations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetCompatibleAudioEncoderConfigurations);
		if (size)
			*size = sizeof(struct __trt__GetCompatibleAudioEncoderConfigurations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetCompatibleAudioEncoderConfigurations, n);
		if (size)
			*size = n * sizeof(struct __trt__GetCompatibleAudioEncoderConfigurations);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetCompatibleAudioEncoderConfigurations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetCompatibleAudioEncoderConfigurations %p -> %p\n", q, p));
	*(struct __trt__GetCompatibleAudioEncoderConfigurations*)p = *(struct __trt__GetCompatibleAudioEncoderConfigurations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleVideoSourceConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const struct __trt__GetCompatibleVideoSourceConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetCompatibleVideoSourceConfigurations(soap, &a->trt__GetCompatibleVideoSourceConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleVideoSourceConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetCompatibleVideoSourceConfigurations(soap, "trt:GetCompatibleVideoSourceConfigurations", -1, &a->trt__GetCompatibleVideoSourceConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoSourceConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleVideoSourceConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleVideoSourceConfigurations = 1;
	short soap_flag;
	a = (struct __trt__GetCompatibleVideoSourceConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations, sizeof(struct __trt__GetCompatibleVideoSourceConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleVideoSourceConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleVideoSourceConfigurations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetCompatibleVideoSourceConfigurations(soap, "trt:GetCompatibleVideoSourceConfigurations", &a->trt__GetCompatibleVideoSourceConfigurations, ""))
				{	soap_flag_trt__GetCompatibleVideoSourceConfigurations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const struct __trt__GetCompatibleVideoSourceConfigurations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetCompatibleVideoSourceConfigurations(soap, tag?tag:"-trt:GetCompatibleVideoSourceConfigurations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoSourceConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoSourceConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleVideoSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetCompatibleVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetCompatibleVideoSourceConfigurations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetCompatibleVideoSourceConfigurations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetCompatibleVideoSourceConfigurations);
		if (size)
			*size = sizeof(struct __trt__GetCompatibleVideoSourceConfigurations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetCompatibleVideoSourceConfigurations, n);
		if (size)
			*size = n * sizeof(struct __trt__GetCompatibleVideoSourceConfigurations);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetCompatibleVideoSourceConfigurations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetCompatibleVideoSourceConfigurations %p -> %p\n", q, p));
	*(struct __trt__GetCompatibleVideoSourceConfigurations*)p = *(struct __trt__GetCompatibleVideoSourceConfigurations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetCompatibleVideoEncoderConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const struct __trt__GetCompatibleVideoEncoderConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(soap, &a->trt__GetCompatibleVideoEncoderConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetCompatibleVideoEncoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(soap, "trt:GetCompatibleVideoEncoderConfigurations", -1, &a->trt__GetCompatibleVideoEncoderConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC4 soap_in___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const char *tag, struct __trt__GetCompatibleVideoEncoderConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetCompatibleVideoEncoderConfigurations = 1;
	short soap_flag;
	a = (struct __trt__GetCompatibleVideoEncoderConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations, sizeof(struct __trt__GetCompatibleVideoEncoderConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetCompatibleVideoEncoderConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetCompatibleVideoEncoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(soap, "trt:GetCompatibleVideoEncoderConfigurations", &a->trt__GetCompatibleVideoEncoderConfigurations, ""))
				{	soap_flag_trt__GetCompatibleVideoEncoderConfigurations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const struct __trt__GetCompatibleVideoEncoderConfigurations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetCompatibleVideoEncoderConfigurations(soap, tag?tag:"-trt:GetCompatibleVideoEncoderConfigurations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC4 soap_get___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, struct __trt__GetCompatibleVideoEncoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetCompatibleVideoEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetCompatibleVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetCompatibleVideoEncoderConfigurations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetCompatibleVideoEncoderConfigurations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetCompatibleVideoEncoderConfigurations);
		if (size)
			*size = sizeof(struct __trt__GetCompatibleVideoEncoderConfigurations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetCompatibleVideoEncoderConfigurations, n);
		if (size)
			*size = n * sizeof(struct __trt__GetCompatibleVideoEncoderConfigurations);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetCompatibleVideoEncoderConfigurations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetCompatibleVideoEncoderConfigurations %p -> %p\n", q, p));
	*(struct __trt__GetCompatibleVideoEncoderConfigurations*)p = *(struct __trt__GetCompatibleVideoEncoderConfigurations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioDecoderConfiguration(struct soap *soap, struct __trt__GetAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioDecoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioDecoderConfiguration(struct soap *soap, const struct __trt__GetAudioDecoderConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetAudioDecoderConfiguration(soap, &a->trt__GetAudioDecoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioDecoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetAudioDecoderConfiguration(soap, "trt:GetAudioDecoderConfiguration", -1, &a->trt__GetAudioDecoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioDecoderConfiguration * SOAP_FMAC4 soap_in___trt__GetAudioDecoderConfiguration(struct soap *soap, const char *tag, struct __trt__GetAudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetAudioDecoderConfiguration = 1;
	short soap_flag;
	a = (struct __trt__GetAudioDecoderConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioDecoderConfiguration, sizeof(struct __trt__GetAudioDecoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioDecoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioDecoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetAudioDecoderConfiguration(soap, "trt:GetAudioDecoderConfiguration", &a->trt__GetAudioDecoderConfiguration, ""))
				{	soap_flag_trt__GetAudioDecoderConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioDecoderConfiguration(struct soap *soap, const struct __trt__GetAudioDecoderConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetAudioDecoderConfiguration(soap, tag?tag:"-trt:GetAudioDecoderConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioDecoderConfiguration * SOAP_FMAC4 soap_get___trt__GetAudioDecoderConfiguration(struct soap *soap, struct __trt__GetAudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioDecoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioDecoderConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetAudioDecoderConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetAudioDecoderConfiguration);
		if (size)
			*size = sizeof(struct __trt__GetAudioDecoderConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetAudioDecoderConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__GetAudioDecoderConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetAudioDecoderConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetAudioDecoderConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetAudioDecoderConfiguration %p -> %p\n", q, p));
	*(struct __trt__GetAudioDecoderConfiguration*)p = *(struct __trt__GetAudioDecoderConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioOutputConfiguration(struct soap *soap, struct __trt__GetAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioOutputConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioOutputConfiguration(struct soap *soap, const struct __trt__GetAudioOutputConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetAudioOutputConfiguration(soap, &a->trt__GetAudioOutputConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioOutputConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetAudioOutputConfiguration(soap, "trt:GetAudioOutputConfiguration", -1, &a->trt__GetAudioOutputConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputConfiguration * SOAP_FMAC4 soap_in___trt__GetAudioOutputConfiguration(struct soap *soap, const char *tag, struct __trt__GetAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetAudioOutputConfiguration = 1;
	short soap_flag;
	a = (struct __trt__GetAudioOutputConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioOutputConfiguration, sizeof(struct __trt__GetAudioOutputConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioOutputConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetAudioOutputConfiguration(soap, "trt:GetAudioOutputConfiguration", &a->trt__GetAudioOutputConfiguration, ""))
				{	soap_flag_trt__GetAudioOutputConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioOutputConfiguration(struct soap *soap, const struct __trt__GetAudioOutputConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetAudioOutputConfiguration(soap, tag?tag:"-trt:GetAudioOutputConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputConfiguration * SOAP_FMAC4 soap_get___trt__GetAudioOutputConfiguration(struct soap *soap, struct __trt__GetAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioOutputConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioOutputConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetAudioOutputConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetAudioOutputConfiguration);
		if (size)
			*size = sizeof(struct __trt__GetAudioOutputConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetAudioOutputConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__GetAudioOutputConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetAudioOutputConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetAudioOutputConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetAudioOutputConfiguration %p -> %p\n", q, p));
	*(struct __trt__GetAudioOutputConfiguration*)p = *(struct __trt__GetAudioOutputConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetMetadataConfiguration(struct soap *soap, struct __trt__GetMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetMetadataConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetMetadataConfiguration(struct soap *soap, const struct __trt__GetMetadataConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetMetadataConfiguration(soap, &a->trt__GetMetadataConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetMetadataConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetMetadataConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetMetadataConfiguration(soap, "trt:GetMetadataConfiguration", -1, &a->trt__GetMetadataConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetMetadataConfiguration * SOAP_FMAC4 soap_in___trt__GetMetadataConfiguration(struct soap *soap, const char *tag, struct __trt__GetMetadataConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetMetadataConfiguration = 1;
	short soap_flag;
	a = (struct __trt__GetMetadataConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetMetadataConfiguration, sizeof(struct __trt__GetMetadataConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetMetadataConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetMetadataConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetMetadataConfiguration(soap, "trt:GetMetadataConfiguration", &a->trt__GetMetadataConfiguration, ""))
				{	soap_flag_trt__GetMetadataConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetMetadataConfiguration(struct soap *soap, const struct __trt__GetMetadataConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetMetadataConfiguration(soap, tag?tag:"-trt:GetMetadataConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetMetadataConfiguration * SOAP_FMAC4 soap_get___trt__GetMetadataConfiguration(struct soap *soap, struct __trt__GetMetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetMetadataConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetMetadataConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetMetadataConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetMetadataConfiguration);
		if (size)
			*size = sizeof(struct __trt__GetMetadataConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetMetadataConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__GetMetadataConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetMetadataConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetMetadataConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetMetadataConfiguration %p -> %p\n", q, p));
	*(struct __trt__GetMetadataConfiguration*)p = *(struct __trt__GetMetadataConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoAnalyticsConfiguration(struct soap *soap, struct __trt__GetVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoAnalyticsConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__GetVideoAnalyticsConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetVideoAnalyticsConfiguration(soap, &a->trt__GetVideoAnalyticsConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfiguration(soap, "trt:GetVideoAnalyticsConfiguration", -1, &a->trt__GetVideoAnalyticsConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in___trt__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct __trt__GetVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetVideoAnalyticsConfiguration = 1;
	short soap_flag;
	a = (struct __trt__GetVideoAnalyticsConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoAnalyticsConfiguration, sizeof(struct __trt__GetVideoAnalyticsConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoAnalyticsConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetVideoAnalyticsConfiguration(soap, "trt:GetVideoAnalyticsConfiguration", &a->trt__GetVideoAnalyticsConfiguration, ""))
				{	soap_flag_trt__GetVideoAnalyticsConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__GetVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetVideoAnalyticsConfiguration(soap, tag?tag:"-trt:GetVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get___trt__GetVideoAnalyticsConfiguration(struct soap *soap, struct __trt__GetVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetVideoAnalyticsConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetVideoAnalyticsConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetVideoAnalyticsConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetVideoAnalyticsConfiguration);
		if (size)
			*size = sizeof(struct __trt__GetVideoAnalyticsConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetVideoAnalyticsConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__GetVideoAnalyticsConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetVideoAnalyticsConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetVideoAnalyticsConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetVideoAnalyticsConfiguration %p -> %p\n", q, p));
	*(struct __trt__GetVideoAnalyticsConfiguration*)p = *(struct __trt__GetVideoAnalyticsConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioEncoderConfiguration(struct soap *soap, struct __trt__GetAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioEncoderConfiguration(struct soap *soap, const struct __trt__GetAudioEncoderConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetAudioEncoderConfiguration(soap, &a->trt__GetAudioEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetAudioEncoderConfiguration(soap, "trt:GetAudioEncoderConfiguration", -1, &a->trt__GetAudioEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioEncoderConfiguration * SOAP_FMAC4 soap_in___trt__GetAudioEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__GetAudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetAudioEncoderConfiguration = 1;
	short soap_flag;
	a = (struct __trt__GetAudioEncoderConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioEncoderConfiguration, sizeof(struct __trt__GetAudioEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetAudioEncoderConfiguration(soap, "trt:GetAudioEncoderConfiguration", &a->trt__GetAudioEncoderConfiguration, ""))
				{	soap_flag_trt__GetAudioEncoderConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioEncoderConfiguration(struct soap *soap, const struct __trt__GetAudioEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetAudioEncoderConfiguration(soap, tag?tag:"-trt:GetAudioEncoderConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioEncoderConfiguration * SOAP_FMAC4 soap_get___trt__GetAudioEncoderConfiguration(struct soap *soap, struct __trt__GetAudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioEncoderConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetAudioEncoderConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetAudioEncoderConfiguration);
		if (size)
			*size = sizeof(struct __trt__GetAudioEncoderConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetAudioEncoderConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__GetAudioEncoderConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetAudioEncoderConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetAudioEncoderConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetAudioEncoderConfiguration %p -> %p\n", q, p));
	*(struct __trt__GetAudioEncoderConfiguration*)p = *(struct __trt__GetAudioEncoderConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioSourceConfiguration(struct soap *soap, struct __trt__GetAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioSourceConfiguration(struct soap *soap, const struct __trt__GetAudioSourceConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetAudioSourceConfiguration(soap, &a->trt__GetAudioSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetAudioSourceConfiguration(soap, "trt:GetAudioSourceConfiguration", -1, &a->trt__GetAudioSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSourceConfiguration * SOAP_FMAC4 soap_in___trt__GetAudioSourceConfiguration(struct soap *soap, const char *tag, struct __trt__GetAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetAudioSourceConfiguration = 1;
	short soap_flag;
	a = (struct __trt__GetAudioSourceConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioSourceConfiguration, sizeof(struct __trt__GetAudioSourceConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetAudioSourceConfiguration(soap, "trt:GetAudioSourceConfiguration", &a->trt__GetAudioSourceConfiguration, ""))
				{	soap_flag_trt__GetAudioSourceConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioSourceConfiguration(struct soap *soap, const struct __trt__GetAudioSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetAudioSourceConfiguration(soap, tag?tag:"-trt:GetAudioSourceConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSourceConfiguration * SOAP_FMAC4 soap_get___trt__GetAudioSourceConfiguration(struct soap *soap, struct __trt__GetAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetAudioSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioSourceConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetAudioSourceConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetAudioSourceConfiguration);
		if (size)
			*size = sizeof(struct __trt__GetAudioSourceConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetAudioSourceConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__GetAudioSourceConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetAudioSourceConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetAudioSourceConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetAudioSourceConfiguration %p -> %p\n", q, p));
	*(struct __trt__GetAudioSourceConfiguration*)p = *(struct __trt__GetAudioSourceConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoEncoderConfiguration(struct soap *soap, struct __trt__GetVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoEncoderConfiguration(struct soap *soap, const struct __trt__GetVideoEncoderConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetVideoEncoderConfiguration(soap, &a->trt__GetVideoEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetVideoEncoderConfiguration(soap, "trt:GetVideoEncoderConfiguration", -1, &a->trt__GetVideoEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfiguration * SOAP_FMAC4 soap_in___trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__GetVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetVideoEncoderConfiguration = 1;
	short soap_flag;
	a = (struct __trt__GetVideoEncoderConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoEncoderConfiguration, sizeof(struct __trt__GetVideoEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetVideoEncoderConfiguration(soap, "trt:GetVideoEncoderConfiguration", &a->trt__GetVideoEncoderConfiguration, ""))
				{	soap_flag_trt__GetVideoEncoderConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoEncoderConfiguration(struct soap *soap, const struct __trt__GetVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetVideoEncoderConfiguration(soap, tag?tag:"-trt:GetVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfiguration * SOAP_FMAC4 soap_get___trt__GetVideoEncoderConfiguration(struct soap *soap, struct __trt__GetVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetVideoEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetVideoEncoderConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetVideoEncoderConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetVideoEncoderConfiguration);
		if (size)
			*size = sizeof(struct __trt__GetVideoEncoderConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetVideoEncoderConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__GetVideoEncoderConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetVideoEncoderConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetVideoEncoderConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetVideoEncoderConfiguration %p -> %p\n", q, p));
	*(struct __trt__GetVideoEncoderConfiguration*)p = *(struct __trt__GetVideoEncoderConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoSourceConfiguration(struct soap *soap, struct __trt__GetVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoSourceConfiguration(struct soap *soap, const struct __trt__GetVideoSourceConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetVideoSourceConfiguration(soap, &a->trt__GetVideoSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetVideoSourceConfiguration(soap, "trt:GetVideoSourceConfiguration", -1, &a->trt__GetVideoSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceConfiguration * SOAP_FMAC4 soap_in___trt__GetVideoSourceConfiguration(struct soap *soap, const char *tag, struct __trt__GetVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__GetVideoSourceConfiguration = 1;
	short soap_flag;
	a = (struct __trt__GetVideoSourceConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoSourceConfiguration, sizeof(struct __trt__GetVideoSourceConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetVideoSourceConfiguration(soap, "trt:GetVideoSourceConfiguration", &a->trt__GetVideoSourceConfiguration, ""))
				{	soap_flag_trt__GetVideoSourceConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoSourceConfiguration(struct soap *soap, const struct __trt__GetVideoSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetVideoSourceConfiguration(soap, tag?tag:"-trt:GetVideoSourceConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceConfiguration * SOAP_FMAC4 soap_get___trt__GetVideoSourceConfiguration(struct soap *soap, struct __trt__GetVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__GetVideoSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetVideoSourceConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetVideoSourceConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetVideoSourceConfiguration);
		if (size)
			*size = sizeof(struct __trt__GetVideoSourceConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetVideoSourceConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__GetVideoSourceConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetVideoSourceConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetVideoSourceConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetVideoSourceConfiguration %p -> %p\n", q, p));
	*(struct __trt__GetVideoSourceConfiguration*)p = *(struct __trt__GetVideoSourceConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioDecoderConfigurations(struct soap *soap, struct __trt__GetAudioDecoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioDecoderConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioDecoderConfigurations(struct soap *soap, const struct __trt__GetAudioDecoderConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetAudioDecoderConfigurations(soap, &a->trt__GetAudioDecoderConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioDecoderConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioDecoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurations(soap, "trt:GetAudioDecoderConfigurations", -1, &a->trt__GetAudioDecoderConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioDecoderConfigurations * SOAP_FMAC4 soap_in___trt__GetAudioDecoderConfigurations(struct soap *soap, const char *tag, struct __trt__GetAudioDecoderConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetAudioDecoderConfigurations = 1;
	short soap_flag;
	a = (struct __trt__GetAudioDecoderConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioDecoderConfigurations, sizeof(struct __trt__GetAudioDecoderConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioDecoderConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioDecoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetAudioDecoderConfigurations(soap, "trt:GetAudioDecoderConfigurations", &a->trt__GetAudioDecoderConfigurations, ""))
				{	soap_flag_trt__GetAudioDecoderConfigurations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioDecoderConfigurations(struct soap *soap, const struct __trt__GetAudioDecoderConfigurations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetAudioDecoderConfigurations(soap, tag?tag:"-trt:GetAudioDecoderConfigurations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioDecoderConfigurations * SOAP_FMAC4 soap_get___trt__GetAudioDecoderConfigurations(struct soap *soap, struct __trt__GetAudioDecoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioDecoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetAudioDecoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioDecoderConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioDecoderConfigurations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetAudioDecoderConfigurations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetAudioDecoderConfigurations);
		if (size)
			*size = sizeof(struct __trt__GetAudioDecoderConfigurations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetAudioDecoderConfigurations, n);
		if (size)
			*size = n * sizeof(struct __trt__GetAudioDecoderConfigurations);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetAudioDecoderConfigurations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetAudioDecoderConfigurations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetAudioDecoderConfigurations %p -> %p\n", q, p));
	*(struct __trt__GetAudioDecoderConfigurations*)p = *(struct __trt__GetAudioDecoderConfigurations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioOutputConfigurations(struct soap *soap, struct __trt__GetAudioOutputConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioOutputConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioOutputConfigurations(struct soap *soap, const struct __trt__GetAudioOutputConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetAudioOutputConfigurations(soap, &a->trt__GetAudioOutputConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioOutputConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioOutputConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurations(soap, "trt:GetAudioOutputConfigurations", -1, &a->trt__GetAudioOutputConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputConfigurations * SOAP_FMAC4 soap_in___trt__GetAudioOutputConfigurations(struct soap *soap, const char *tag, struct __trt__GetAudioOutputConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetAudioOutputConfigurations = 1;
	short soap_flag;
	a = (struct __trt__GetAudioOutputConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioOutputConfigurations, sizeof(struct __trt__GetAudioOutputConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioOutputConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioOutputConfigurations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetAudioOutputConfigurations(soap, "trt:GetAudioOutputConfigurations", &a->trt__GetAudioOutputConfigurations, ""))
				{	soap_flag_trt__GetAudioOutputConfigurations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioOutputConfigurations(struct soap *soap, const struct __trt__GetAudioOutputConfigurations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetAudioOutputConfigurations(soap, tag?tag:"-trt:GetAudioOutputConfigurations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputConfigurations * SOAP_FMAC4 soap_get___trt__GetAudioOutputConfigurations(struct soap *soap, struct __trt__GetAudioOutputConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioOutputConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetAudioOutputConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioOutputConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioOutputConfigurations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetAudioOutputConfigurations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetAudioOutputConfigurations);
		if (size)
			*size = sizeof(struct __trt__GetAudioOutputConfigurations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetAudioOutputConfigurations, n);
		if (size)
			*size = n * sizeof(struct __trt__GetAudioOutputConfigurations);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetAudioOutputConfigurations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetAudioOutputConfigurations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetAudioOutputConfigurations %p -> %p\n", q, p));
	*(struct __trt__GetAudioOutputConfigurations*)p = *(struct __trt__GetAudioOutputConfigurations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetMetadataConfigurations(struct soap *soap, struct __trt__GetMetadataConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetMetadataConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetMetadataConfigurations(struct soap *soap, const struct __trt__GetMetadataConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetMetadataConfigurations(soap, &a->trt__GetMetadataConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetMetadataConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetMetadataConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetMetadataConfigurations(soap, "trt:GetMetadataConfigurations", -1, &a->trt__GetMetadataConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetMetadataConfigurations * SOAP_FMAC4 soap_in___trt__GetMetadataConfigurations(struct soap *soap, const char *tag, struct __trt__GetMetadataConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetMetadataConfigurations = 1;
	short soap_flag;
	a = (struct __trt__GetMetadataConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetMetadataConfigurations, sizeof(struct __trt__GetMetadataConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetMetadataConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetMetadataConfigurations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetMetadataConfigurations(soap, "trt:GetMetadataConfigurations", &a->trt__GetMetadataConfigurations, ""))
				{	soap_flag_trt__GetMetadataConfigurations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetMetadataConfigurations(struct soap *soap, const struct __trt__GetMetadataConfigurations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetMetadataConfigurations(soap, tag?tag:"-trt:GetMetadataConfigurations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetMetadataConfigurations * SOAP_FMAC4 soap_get___trt__GetMetadataConfigurations(struct soap *soap, struct __trt__GetMetadataConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetMetadataConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetMetadataConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetMetadataConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetMetadataConfigurations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetMetadataConfigurations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetMetadataConfigurations);
		if (size)
			*size = sizeof(struct __trt__GetMetadataConfigurations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetMetadataConfigurations, n);
		if (size)
			*size = n * sizeof(struct __trt__GetMetadataConfigurations);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetMetadataConfigurations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetMetadataConfigurations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetMetadataConfigurations %p -> %p\n", q, p));
	*(struct __trt__GetMetadataConfigurations*)p = *(struct __trt__GetMetadataConfigurations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoAnalyticsConfigurations(struct soap *soap, struct __trt__GetVideoAnalyticsConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoAnalyticsConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoAnalyticsConfigurations(struct soap *soap, const struct __trt__GetVideoAnalyticsConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetVideoAnalyticsConfigurations(soap, &a->trt__GetVideoAnalyticsConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoAnalyticsConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfigurations(soap, "trt:GetVideoAnalyticsConfigurations", -1, &a->trt__GetVideoAnalyticsConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoAnalyticsConfigurations * SOAP_FMAC4 soap_in___trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, struct __trt__GetVideoAnalyticsConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetVideoAnalyticsConfigurations = 1;
	short soap_flag;
	a = (struct __trt__GetVideoAnalyticsConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoAnalyticsConfigurations, sizeof(struct __trt__GetVideoAnalyticsConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoAnalyticsConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoAnalyticsConfigurations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetVideoAnalyticsConfigurations(soap, "trt:GetVideoAnalyticsConfigurations", &a->trt__GetVideoAnalyticsConfigurations, ""))
				{	soap_flag_trt__GetVideoAnalyticsConfigurations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoAnalyticsConfigurations(struct soap *soap, const struct __trt__GetVideoAnalyticsConfigurations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetVideoAnalyticsConfigurations(soap, tag?tag:"-trt:GetVideoAnalyticsConfigurations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoAnalyticsConfigurations * SOAP_FMAC4 soap_get___trt__GetVideoAnalyticsConfigurations(struct soap *soap, struct __trt__GetVideoAnalyticsConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoAnalyticsConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetVideoAnalyticsConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetVideoAnalyticsConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetVideoAnalyticsConfigurations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetVideoAnalyticsConfigurations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetVideoAnalyticsConfigurations);
		if (size)
			*size = sizeof(struct __trt__GetVideoAnalyticsConfigurations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetVideoAnalyticsConfigurations, n);
		if (size)
			*size = n * sizeof(struct __trt__GetVideoAnalyticsConfigurations);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetVideoAnalyticsConfigurations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetVideoAnalyticsConfigurations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetVideoAnalyticsConfigurations %p -> %p\n", q, p));
	*(struct __trt__GetVideoAnalyticsConfigurations*)p = *(struct __trt__GetVideoAnalyticsConfigurations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioEncoderConfigurations(struct soap *soap, struct __trt__GetAudioEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioEncoderConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioEncoderConfigurations(struct soap *soap, const struct __trt__GetAudioEncoderConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetAudioEncoderConfigurations(soap, &a->trt__GetAudioEncoderConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioEncoderConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioEncoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurations(soap, "trt:GetAudioEncoderConfigurations", -1, &a->trt__GetAudioEncoderConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioEncoderConfigurations * SOAP_FMAC4 soap_in___trt__GetAudioEncoderConfigurations(struct soap *soap, const char *tag, struct __trt__GetAudioEncoderConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetAudioEncoderConfigurations = 1;
	short soap_flag;
	a = (struct __trt__GetAudioEncoderConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioEncoderConfigurations, sizeof(struct __trt__GetAudioEncoderConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioEncoderConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioEncoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetAudioEncoderConfigurations(soap, "trt:GetAudioEncoderConfigurations", &a->trt__GetAudioEncoderConfigurations, ""))
				{	soap_flag_trt__GetAudioEncoderConfigurations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioEncoderConfigurations(struct soap *soap, const struct __trt__GetAudioEncoderConfigurations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetAudioEncoderConfigurations(soap, tag?tag:"-trt:GetAudioEncoderConfigurations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioEncoderConfigurations * SOAP_FMAC4 soap_get___trt__GetAudioEncoderConfigurations(struct soap *soap, struct __trt__GetAudioEncoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetAudioEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioEncoderConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioEncoderConfigurations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetAudioEncoderConfigurations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetAudioEncoderConfigurations);
		if (size)
			*size = sizeof(struct __trt__GetAudioEncoderConfigurations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetAudioEncoderConfigurations, n);
		if (size)
			*size = n * sizeof(struct __trt__GetAudioEncoderConfigurations);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetAudioEncoderConfigurations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetAudioEncoderConfigurations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetAudioEncoderConfigurations %p -> %p\n", q, p));
	*(struct __trt__GetAudioEncoderConfigurations*)p = *(struct __trt__GetAudioEncoderConfigurations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioSourceConfigurations(struct soap *soap, struct __trt__GetAudioSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioSourceConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioSourceConfigurations(struct soap *soap, const struct __trt__GetAudioSourceConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetAudioSourceConfigurations(soap, &a->trt__GetAudioSourceConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioSourceConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioSourceConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurations(soap, "trt:GetAudioSourceConfigurations", -1, &a->trt__GetAudioSourceConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSourceConfigurations * SOAP_FMAC4 soap_in___trt__GetAudioSourceConfigurations(struct soap *soap, const char *tag, struct __trt__GetAudioSourceConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetAudioSourceConfigurations = 1;
	short soap_flag;
	a = (struct __trt__GetAudioSourceConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioSourceConfigurations, sizeof(struct __trt__GetAudioSourceConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioSourceConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioSourceConfigurations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetAudioSourceConfigurations(soap, "trt:GetAudioSourceConfigurations", &a->trt__GetAudioSourceConfigurations, ""))
				{	soap_flag_trt__GetAudioSourceConfigurations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioSourceConfigurations(struct soap *soap, const struct __trt__GetAudioSourceConfigurations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetAudioSourceConfigurations(soap, tag?tag:"-trt:GetAudioSourceConfigurations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSourceConfigurations * SOAP_FMAC4 soap_get___trt__GetAudioSourceConfigurations(struct soap *soap, struct __trt__GetAudioSourceConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetAudioSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetAudioSourceConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioSourceConfigurations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetAudioSourceConfigurations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetAudioSourceConfigurations);
		if (size)
			*size = sizeof(struct __trt__GetAudioSourceConfigurations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetAudioSourceConfigurations, n);
		if (size)
			*size = n * sizeof(struct __trt__GetAudioSourceConfigurations);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetAudioSourceConfigurations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetAudioSourceConfigurations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetAudioSourceConfigurations %p -> %p\n", q, p));
	*(struct __trt__GetAudioSourceConfigurations*)p = *(struct __trt__GetAudioSourceConfigurations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoEncoderConfigurations(struct soap *soap, struct __trt__GetVideoEncoderConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoEncoderConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoEncoderConfigurations(struct soap *soap, const struct __trt__GetVideoEncoderConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetVideoEncoderConfigurations(soap, &a->trt__GetVideoEncoderConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoEncoderConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoEncoderConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurations(soap, "trt:GetVideoEncoderConfigurations", -1, &a->trt__GetVideoEncoderConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfigurations * SOAP_FMAC4 soap_in___trt__GetVideoEncoderConfigurations(struct soap *soap, const char *tag, struct __trt__GetVideoEncoderConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetVideoEncoderConfigurations = 1;
	short soap_flag;
	a = (struct __trt__GetVideoEncoderConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoEncoderConfigurations, sizeof(struct __trt__GetVideoEncoderConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoEncoderConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoEncoderConfigurations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetVideoEncoderConfigurations(soap, "trt:GetVideoEncoderConfigurations", &a->trt__GetVideoEncoderConfigurations, ""))
				{	soap_flag_trt__GetVideoEncoderConfigurations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoEncoderConfigurations(struct soap *soap, const struct __trt__GetVideoEncoderConfigurations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetVideoEncoderConfigurations(soap, tag?tag:"-trt:GetVideoEncoderConfigurations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoEncoderConfigurations * SOAP_FMAC4 soap_get___trt__GetVideoEncoderConfigurations(struct soap *soap, struct __trt__GetVideoEncoderConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetVideoEncoderConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetVideoEncoderConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetVideoEncoderConfigurations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetVideoEncoderConfigurations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetVideoEncoderConfigurations);
		if (size)
			*size = sizeof(struct __trt__GetVideoEncoderConfigurations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetVideoEncoderConfigurations, n);
		if (size)
			*size = n * sizeof(struct __trt__GetVideoEncoderConfigurations);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetVideoEncoderConfigurations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetVideoEncoderConfigurations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetVideoEncoderConfigurations %p -> %p\n", q, p));
	*(struct __trt__GetVideoEncoderConfigurations*)p = *(struct __trt__GetVideoEncoderConfigurations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoSourceConfigurations(struct soap *soap, struct __trt__GetVideoSourceConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoSourceConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoSourceConfigurations(struct soap *soap, const struct __trt__GetVideoSourceConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetVideoSourceConfigurations(soap, &a->trt__GetVideoSourceConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoSourceConfigurations(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoSourceConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurations(soap, "trt:GetVideoSourceConfigurations", -1, &a->trt__GetVideoSourceConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceConfigurations * SOAP_FMAC4 soap_in___trt__GetVideoSourceConfigurations(struct soap *soap, const char *tag, struct __trt__GetVideoSourceConfigurations *a, const char *type)
{
	size_t soap_flag_trt__GetVideoSourceConfigurations = 1;
	short soap_flag;
	a = (struct __trt__GetVideoSourceConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoSourceConfigurations, sizeof(struct __trt__GetVideoSourceConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoSourceConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoSourceConfigurations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetVideoSourceConfigurations(soap, "trt:GetVideoSourceConfigurations", &a->trt__GetVideoSourceConfigurations, ""))
				{	soap_flag_trt__GetVideoSourceConfigurations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoSourceConfigurations(struct soap *soap, const struct __trt__GetVideoSourceConfigurations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetVideoSourceConfigurations(soap, tag?tag:"-trt:GetVideoSourceConfigurations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSourceConfigurations * SOAP_FMAC4 soap_get___trt__GetVideoSourceConfigurations(struct soap *soap, struct __trt__GetVideoSourceConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetVideoSourceConfigurations * SOAP_FMAC2 soap_instantiate___trt__GetVideoSourceConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetVideoSourceConfigurations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetVideoSourceConfigurations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetVideoSourceConfigurations);
		if (size)
			*size = sizeof(struct __trt__GetVideoSourceConfigurations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetVideoSourceConfigurations, n);
		if (size)
			*size = n * sizeof(struct __trt__GetVideoSourceConfigurations);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetVideoSourceConfigurations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetVideoSourceConfigurations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetVideoSourceConfigurations %p -> %p\n", q, p));
	*(struct __trt__GetVideoSourceConfigurations*)p = *(struct __trt__GetVideoSourceConfigurations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__DeleteProfile(struct soap *soap, struct __trt__DeleteProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__DeleteProfile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__DeleteProfile(struct soap *soap, const struct __trt__DeleteProfile *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__DeleteProfile(soap, &a->trt__DeleteProfile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__DeleteProfile(struct soap *soap, const char *tag, int id, const struct __trt__DeleteProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__DeleteProfile(soap, "trt:DeleteProfile", -1, &a->trt__DeleteProfile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__DeleteProfile * SOAP_FMAC4 soap_in___trt__DeleteProfile(struct soap *soap, const char *tag, struct __trt__DeleteProfile *a, const char *type)
{
	size_t soap_flag_trt__DeleteProfile = 1;
	short soap_flag;
	a = (struct __trt__DeleteProfile *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__DeleteProfile, sizeof(struct __trt__DeleteProfile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__DeleteProfile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__DeleteProfile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__DeleteProfile(soap, "trt:DeleteProfile", &a->trt__DeleteProfile, ""))
				{	soap_flag_trt__DeleteProfile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__DeleteProfile(struct soap *soap, const struct __trt__DeleteProfile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__DeleteProfile(soap, tag?tag:"-trt:DeleteProfile", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__DeleteProfile * SOAP_FMAC4 soap_get___trt__DeleteProfile(struct soap *soap, struct __trt__DeleteProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__DeleteProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__DeleteProfile * SOAP_FMAC2 soap_instantiate___trt__DeleteProfile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__DeleteProfile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__DeleteProfile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__DeleteProfile);
		if (size)
			*size = sizeof(struct __trt__DeleteProfile);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__DeleteProfile, n);
		if (size)
			*size = n * sizeof(struct __trt__DeleteProfile);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__DeleteProfile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__DeleteProfile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__DeleteProfile %p -> %p\n", q, p));
	*(struct __trt__DeleteProfile*)p = *(struct __trt__DeleteProfile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__RemoveAudioDecoderConfiguration(struct soap *soap, struct __trt__RemoveAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__RemoveAudioDecoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__RemoveAudioDecoderConfiguration(struct soap *soap, const struct __trt__RemoveAudioDecoderConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__RemoveAudioDecoderConfiguration(soap, &a->trt__RemoveAudioDecoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__RemoveAudioDecoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__RemoveAudioDecoderConfiguration(soap, "trt:RemoveAudioDecoderConfiguration", -1, &a->trt__RemoveAudioDecoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveAudioDecoderConfiguration * SOAP_FMAC4 soap_in___trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *tag, struct __trt__RemoveAudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__RemoveAudioDecoderConfiguration = 1;
	short soap_flag;
	a = (struct __trt__RemoveAudioDecoderConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__RemoveAudioDecoderConfiguration, sizeof(struct __trt__RemoveAudioDecoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__RemoveAudioDecoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__RemoveAudioDecoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__RemoveAudioDecoderConfiguration(soap, "trt:RemoveAudioDecoderConfiguration", &a->trt__RemoveAudioDecoderConfiguration, ""))
				{	soap_flag_trt__RemoveAudioDecoderConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__RemoveAudioDecoderConfiguration(struct soap *soap, const struct __trt__RemoveAudioDecoderConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__RemoveAudioDecoderConfiguration(soap, tag?tag:"-trt:RemoveAudioDecoderConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveAudioDecoderConfiguration * SOAP_FMAC4 soap_get___trt__RemoveAudioDecoderConfiguration(struct soap *soap, struct __trt__RemoveAudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__RemoveAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__RemoveAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioDecoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__RemoveAudioDecoderConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__RemoveAudioDecoderConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__RemoveAudioDecoderConfiguration);
		if (size)
			*size = sizeof(struct __trt__RemoveAudioDecoderConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__RemoveAudioDecoderConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__RemoveAudioDecoderConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__RemoveAudioDecoderConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__RemoveAudioDecoderConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__RemoveAudioDecoderConfiguration %p -> %p\n", q, p));
	*(struct __trt__RemoveAudioDecoderConfiguration*)p = *(struct __trt__RemoveAudioDecoderConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__RemoveAudioOutputConfiguration(struct soap *soap, struct __trt__RemoveAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__RemoveAudioOutputConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__RemoveAudioOutputConfiguration(struct soap *soap, const struct __trt__RemoveAudioOutputConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__RemoveAudioOutputConfiguration(soap, &a->trt__RemoveAudioOutputConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__RemoveAudioOutputConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__RemoveAudioOutputConfiguration(soap, "trt:RemoveAudioOutputConfiguration", -1, &a->trt__RemoveAudioOutputConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveAudioOutputConfiguration * SOAP_FMAC4 soap_in___trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *tag, struct __trt__RemoveAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_trt__RemoveAudioOutputConfiguration = 1;
	short soap_flag;
	a = (struct __trt__RemoveAudioOutputConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__RemoveAudioOutputConfiguration, sizeof(struct __trt__RemoveAudioOutputConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__RemoveAudioOutputConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__RemoveAudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__RemoveAudioOutputConfiguration(soap, "trt:RemoveAudioOutputConfiguration", &a->trt__RemoveAudioOutputConfiguration, ""))
				{	soap_flag_trt__RemoveAudioOutputConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__RemoveAudioOutputConfiguration(struct soap *soap, const struct __trt__RemoveAudioOutputConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__RemoveAudioOutputConfiguration(soap, tag?tag:"-trt:RemoveAudioOutputConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveAudioOutputConfiguration * SOAP_FMAC4 soap_get___trt__RemoveAudioOutputConfiguration(struct soap *soap, struct __trt__RemoveAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__RemoveAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__RemoveAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioOutputConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__RemoveAudioOutputConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__RemoveAudioOutputConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__RemoveAudioOutputConfiguration);
		if (size)
			*size = sizeof(struct __trt__RemoveAudioOutputConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__RemoveAudioOutputConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__RemoveAudioOutputConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__RemoveAudioOutputConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__RemoveAudioOutputConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__RemoveAudioOutputConfiguration %p -> %p\n", q, p));
	*(struct __trt__RemoveAudioOutputConfiguration*)p = *(struct __trt__RemoveAudioOutputConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__RemoveMetadataConfiguration(struct soap *soap, struct __trt__RemoveMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__RemoveMetadataConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__RemoveMetadataConfiguration(struct soap *soap, const struct __trt__RemoveMetadataConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__RemoveMetadataConfiguration(soap, &a->trt__RemoveMetadataConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__RemoveMetadataConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__RemoveMetadataConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__RemoveMetadataConfiguration(soap, "trt:RemoveMetadataConfiguration", -1, &a->trt__RemoveMetadataConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveMetadataConfiguration * SOAP_FMAC4 soap_in___trt__RemoveMetadataConfiguration(struct soap *soap, const char *tag, struct __trt__RemoveMetadataConfiguration *a, const char *type)
{
	size_t soap_flag_trt__RemoveMetadataConfiguration = 1;
	short soap_flag;
	a = (struct __trt__RemoveMetadataConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__RemoveMetadataConfiguration, sizeof(struct __trt__RemoveMetadataConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__RemoveMetadataConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__RemoveMetadataConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__RemoveMetadataConfiguration(soap, "trt:RemoveMetadataConfiguration", &a->trt__RemoveMetadataConfiguration, ""))
				{	soap_flag_trt__RemoveMetadataConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__RemoveMetadataConfiguration(struct soap *soap, const struct __trt__RemoveMetadataConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__RemoveMetadataConfiguration(soap, tag?tag:"-trt:RemoveMetadataConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveMetadataConfiguration * SOAP_FMAC4 soap_get___trt__RemoveMetadataConfiguration(struct soap *soap, struct __trt__RemoveMetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__RemoveMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__RemoveMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveMetadataConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__RemoveMetadataConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__RemoveMetadataConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__RemoveMetadataConfiguration);
		if (size)
			*size = sizeof(struct __trt__RemoveMetadataConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__RemoveMetadataConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__RemoveMetadataConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__RemoveMetadataConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__RemoveMetadataConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__RemoveMetadataConfiguration %p -> %p\n", q, p));
	*(struct __trt__RemoveMetadataConfiguration*)p = *(struct __trt__RemoveMetadataConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, struct __trt__RemoveVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__RemoveVideoAnalyticsConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__RemoveVideoAnalyticsConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__RemoveVideoAnalyticsConfiguration(soap, &a->trt__RemoveVideoAnalyticsConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__RemoveVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__RemoveVideoAnalyticsConfiguration(soap, "trt:RemoveVideoAnalyticsConfiguration", -1, &a->trt__RemoveVideoAnalyticsConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in___trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct __trt__RemoveVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_trt__RemoveVideoAnalyticsConfiguration = 1;
	short soap_flag;
	a = (struct __trt__RemoveVideoAnalyticsConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration, sizeof(struct __trt__RemoveVideoAnalyticsConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__RemoveVideoAnalyticsConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__RemoveVideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__RemoveVideoAnalyticsConfiguration(soap, "trt:RemoveVideoAnalyticsConfiguration", &a->trt__RemoveVideoAnalyticsConfiguration, ""))
				{	soap_flag_trt__RemoveVideoAnalyticsConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__RemoveVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__RemoveVideoAnalyticsConfiguration(soap, tag?tag:"-trt:RemoveVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get___trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, struct __trt__RemoveVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__RemoveVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__RemoveVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__RemoveVideoAnalyticsConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__RemoveVideoAnalyticsConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__RemoveVideoAnalyticsConfiguration);
		if (size)
			*size = sizeof(struct __trt__RemoveVideoAnalyticsConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__RemoveVideoAnalyticsConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__RemoveVideoAnalyticsConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__RemoveVideoAnalyticsConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__RemoveVideoAnalyticsConfiguration %p -> %p\n", q, p));
	*(struct __trt__RemoveVideoAnalyticsConfiguration*)p = *(struct __trt__RemoveVideoAnalyticsConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__RemovePTZConfiguration(struct soap *soap, struct __trt__RemovePTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__RemovePTZConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__RemovePTZConfiguration(struct soap *soap, const struct __trt__RemovePTZConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__RemovePTZConfiguration(soap, &a->trt__RemovePTZConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__RemovePTZConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__RemovePTZConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__RemovePTZConfiguration(soap, "trt:RemovePTZConfiguration", -1, &a->trt__RemovePTZConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemovePTZConfiguration * SOAP_FMAC4 soap_in___trt__RemovePTZConfiguration(struct soap *soap, const char *tag, struct __trt__RemovePTZConfiguration *a, const char *type)
{
	size_t soap_flag_trt__RemovePTZConfiguration = 1;
	short soap_flag;
	a = (struct __trt__RemovePTZConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__RemovePTZConfiguration, sizeof(struct __trt__RemovePTZConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__RemovePTZConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__RemovePTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__RemovePTZConfiguration(soap, "trt:RemovePTZConfiguration", &a->trt__RemovePTZConfiguration, ""))
				{	soap_flag_trt__RemovePTZConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__RemovePTZConfiguration(struct soap *soap, const struct __trt__RemovePTZConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__RemovePTZConfiguration(soap, tag?tag:"-trt:RemovePTZConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemovePTZConfiguration * SOAP_FMAC4 soap_get___trt__RemovePTZConfiguration(struct soap *soap, struct __trt__RemovePTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__RemovePTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__RemovePTZConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemovePTZConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__RemovePTZConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__RemovePTZConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__RemovePTZConfiguration);
		if (size)
			*size = sizeof(struct __trt__RemovePTZConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__RemovePTZConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__RemovePTZConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__RemovePTZConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__RemovePTZConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__RemovePTZConfiguration %p -> %p\n", q, p));
	*(struct __trt__RemovePTZConfiguration*)p = *(struct __trt__RemovePTZConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__RemoveAudioSourceConfiguration(struct soap *soap, struct __trt__RemoveAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__RemoveAudioSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__RemoveAudioSourceConfiguration(struct soap *soap, const struct __trt__RemoveAudioSourceConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__RemoveAudioSourceConfiguration(soap, &a->trt__RemoveAudioSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__RemoveAudioSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__RemoveAudioSourceConfiguration(soap, "trt:RemoveAudioSourceConfiguration", -1, &a->trt__RemoveAudioSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveAudioSourceConfiguration * SOAP_FMAC4 soap_in___trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *tag, struct __trt__RemoveAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__RemoveAudioSourceConfiguration = 1;
	short soap_flag;
	a = (struct __trt__RemoveAudioSourceConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__RemoveAudioSourceConfiguration, sizeof(struct __trt__RemoveAudioSourceConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__RemoveAudioSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__RemoveAudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__RemoveAudioSourceConfiguration(soap, "trt:RemoveAudioSourceConfiguration", &a->trt__RemoveAudioSourceConfiguration, ""))
				{	soap_flag_trt__RemoveAudioSourceConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__RemoveAudioSourceConfiguration(struct soap *soap, const struct __trt__RemoveAudioSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__RemoveAudioSourceConfiguration(soap, tag?tag:"-trt:RemoveAudioSourceConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveAudioSourceConfiguration * SOAP_FMAC4 soap_get___trt__RemoveAudioSourceConfiguration(struct soap *soap, struct __trt__RemoveAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__RemoveAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__RemoveAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__RemoveAudioSourceConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__RemoveAudioSourceConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__RemoveAudioSourceConfiguration);
		if (size)
			*size = sizeof(struct __trt__RemoveAudioSourceConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__RemoveAudioSourceConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__RemoveAudioSourceConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__RemoveAudioSourceConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__RemoveAudioSourceConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__RemoveAudioSourceConfiguration %p -> %p\n", q, p));
	*(struct __trt__RemoveAudioSourceConfiguration*)p = *(struct __trt__RemoveAudioSourceConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__RemoveAudioEncoderConfiguration(struct soap *soap, struct __trt__RemoveAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__RemoveAudioEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__RemoveAudioEncoderConfiguration(struct soap *soap, const struct __trt__RemoveAudioEncoderConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__RemoveAudioEncoderConfiguration(soap, &a->trt__RemoveAudioEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__RemoveAudioEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__RemoveAudioEncoderConfiguration(soap, "trt:RemoveAudioEncoderConfiguration", -1, &a->trt__RemoveAudioEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveAudioEncoderConfiguration * SOAP_FMAC4 soap_in___trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__RemoveAudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__RemoveAudioEncoderConfiguration = 1;
	short soap_flag;
	a = (struct __trt__RemoveAudioEncoderConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__RemoveAudioEncoderConfiguration, sizeof(struct __trt__RemoveAudioEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__RemoveAudioEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__RemoveAudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__RemoveAudioEncoderConfiguration(soap, "trt:RemoveAudioEncoderConfiguration", &a->trt__RemoveAudioEncoderConfiguration, ""))
				{	soap_flag_trt__RemoveAudioEncoderConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__RemoveAudioEncoderConfiguration(struct soap *soap, const struct __trt__RemoveAudioEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__RemoveAudioEncoderConfiguration(soap, tag?tag:"-trt:RemoveAudioEncoderConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveAudioEncoderConfiguration * SOAP_FMAC4 soap_get___trt__RemoveAudioEncoderConfiguration(struct soap *soap, struct __trt__RemoveAudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__RemoveAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__RemoveAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveAudioEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__RemoveAudioEncoderConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__RemoveAudioEncoderConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__RemoveAudioEncoderConfiguration);
		if (size)
			*size = sizeof(struct __trt__RemoveAudioEncoderConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__RemoveAudioEncoderConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__RemoveAudioEncoderConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__RemoveAudioEncoderConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__RemoveAudioEncoderConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__RemoveAudioEncoderConfiguration %p -> %p\n", q, p));
	*(struct __trt__RemoveAudioEncoderConfiguration*)p = *(struct __trt__RemoveAudioEncoderConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__RemoveVideoSourceConfiguration(struct soap *soap, struct __trt__RemoveVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__RemoveVideoSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__RemoveVideoSourceConfiguration(struct soap *soap, const struct __trt__RemoveVideoSourceConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__RemoveVideoSourceConfiguration(soap, &a->trt__RemoveVideoSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__RemoveVideoSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__RemoveVideoSourceConfiguration(soap, "trt:RemoveVideoSourceConfiguration", -1, &a->trt__RemoveVideoSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveVideoSourceConfiguration * SOAP_FMAC4 soap_in___trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *tag, struct __trt__RemoveVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__RemoveVideoSourceConfiguration = 1;
	short soap_flag;
	a = (struct __trt__RemoveVideoSourceConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__RemoveVideoSourceConfiguration, sizeof(struct __trt__RemoveVideoSourceConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__RemoveVideoSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__RemoveVideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__RemoveVideoSourceConfiguration(soap, "trt:RemoveVideoSourceConfiguration", &a->trt__RemoveVideoSourceConfiguration, ""))
				{	soap_flag_trt__RemoveVideoSourceConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__RemoveVideoSourceConfiguration(struct soap *soap, const struct __trt__RemoveVideoSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__RemoveVideoSourceConfiguration(soap, tag?tag:"-trt:RemoveVideoSourceConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveVideoSourceConfiguration * SOAP_FMAC4 soap_get___trt__RemoveVideoSourceConfiguration(struct soap *soap, struct __trt__RemoveVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__RemoveVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__RemoveVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveVideoSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__RemoveVideoSourceConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__RemoveVideoSourceConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__RemoveVideoSourceConfiguration);
		if (size)
			*size = sizeof(struct __trt__RemoveVideoSourceConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__RemoveVideoSourceConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__RemoveVideoSourceConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__RemoveVideoSourceConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__RemoveVideoSourceConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__RemoveVideoSourceConfiguration %p -> %p\n", q, p));
	*(struct __trt__RemoveVideoSourceConfiguration*)p = *(struct __trt__RemoveVideoSourceConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__RemoveVideoEncoderConfiguration(struct soap *soap, struct __trt__RemoveVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__RemoveVideoEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__RemoveVideoEncoderConfiguration(struct soap *soap, const struct __trt__RemoveVideoEncoderConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__RemoveVideoEncoderConfiguration(soap, &a->trt__RemoveVideoEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__RemoveVideoEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__RemoveVideoEncoderConfiguration(soap, "trt:RemoveVideoEncoderConfiguration", -1, &a->trt__RemoveVideoEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveVideoEncoderConfiguration * SOAP_FMAC4 soap_in___trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__RemoveVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__RemoveVideoEncoderConfiguration = 1;
	short soap_flag;
	a = (struct __trt__RemoveVideoEncoderConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__RemoveVideoEncoderConfiguration, sizeof(struct __trt__RemoveVideoEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__RemoveVideoEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__RemoveVideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__RemoveVideoEncoderConfiguration(soap, "trt:RemoveVideoEncoderConfiguration", &a->trt__RemoveVideoEncoderConfiguration, ""))
				{	soap_flag_trt__RemoveVideoEncoderConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__RemoveVideoEncoderConfiguration(struct soap *soap, const struct __trt__RemoveVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__RemoveVideoEncoderConfiguration(soap, tag?tag:"-trt:RemoveVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__RemoveVideoEncoderConfiguration * SOAP_FMAC4 soap_get___trt__RemoveVideoEncoderConfiguration(struct soap *soap, struct __trt__RemoveVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__RemoveVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__RemoveVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__RemoveVideoEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__RemoveVideoEncoderConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__RemoveVideoEncoderConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__RemoveVideoEncoderConfiguration);
		if (size)
			*size = sizeof(struct __trt__RemoveVideoEncoderConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__RemoveVideoEncoderConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__RemoveVideoEncoderConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__RemoveVideoEncoderConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__RemoveVideoEncoderConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__RemoveVideoEncoderConfiguration %p -> %p\n", q, p));
	*(struct __trt__RemoveVideoEncoderConfiguration*)p = *(struct __trt__RemoveVideoEncoderConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__AddAudioDecoderConfiguration(struct soap *soap, struct __trt__AddAudioDecoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__AddAudioDecoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__AddAudioDecoderConfiguration(struct soap *soap, const struct __trt__AddAudioDecoderConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__AddAudioDecoderConfiguration(soap, &a->trt__AddAudioDecoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__AddAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__AddAudioDecoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__AddAudioDecoderConfiguration(soap, "trt:AddAudioDecoderConfiguration", -1, &a->trt__AddAudioDecoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddAudioDecoderConfiguration * SOAP_FMAC4 soap_in___trt__AddAudioDecoderConfiguration(struct soap *soap, const char *tag, struct __trt__AddAudioDecoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__AddAudioDecoderConfiguration = 1;
	short soap_flag;
	a = (struct __trt__AddAudioDecoderConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__AddAudioDecoderConfiguration, sizeof(struct __trt__AddAudioDecoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__AddAudioDecoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__AddAudioDecoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__AddAudioDecoderConfiguration(soap, "trt:AddAudioDecoderConfiguration", &a->trt__AddAudioDecoderConfiguration, ""))
				{	soap_flag_trt__AddAudioDecoderConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__AddAudioDecoderConfiguration(struct soap *soap, const struct __trt__AddAudioDecoderConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__AddAudioDecoderConfiguration(soap, tag?tag:"-trt:AddAudioDecoderConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddAudioDecoderConfiguration * SOAP_FMAC4 soap_get___trt__AddAudioDecoderConfiguration(struct soap *soap, struct __trt__AddAudioDecoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__AddAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__AddAudioDecoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioDecoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__AddAudioDecoderConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__AddAudioDecoderConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__AddAudioDecoderConfiguration);
		if (size)
			*size = sizeof(struct __trt__AddAudioDecoderConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__AddAudioDecoderConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__AddAudioDecoderConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__AddAudioDecoderConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__AddAudioDecoderConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__AddAudioDecoderConfiguration %p -> %p\n", q, p));
	*(struct __trt__AddAudioDecoderConfiguration*)p = *(struct __trt__AddAudioDecoderConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__AddAudioOutputConfiguration(struct soap *soap, struct __trt__AddAudioOutputConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__AddAudioOutputConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__AddAudioOutputConfiguration(struct soap *soap, const struct __trt__AddAudioOutputConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__AddAudioOutputConfiguration(soap, &a->trt__AddAudioOutputConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__AddAudioOutputConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__AddAudioOutputConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__AddAudioOutputConfiguration(soap, "trt:AddAudioOutputConfiguration", -1, &a->trt__AddAudioOutputConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddAudioOutputConfiguration * SOAP_FMAC4 soap_in___trt__AddAudioOutputConfiguration(struct soap *soap, const char *tag, struct __trt__AddAudioOutputConfiguration *a, const char *type)
{
	size_t soap_flag_trt__AddAudioOutputConfiguration = 1;
	short soap_flag;
	a = (struct __trt__AddAudioOutputConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__AddAudioOutputConfiguration, sizeof(struct __trt__AddAudioOutputConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__AddAudioOutputConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__AddAudioOutputConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__AddAudioOutputConfiguration(soap, "trt:AddAudioOutputConfiguration", &a->trt__AddAudioOutputConfiguration, ""))
				{	soap_flag_trt__AddAudioOutputConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__AddAudioOutputConfiguration(struct soap *soap, const struct __trt__AddAudioOutputConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__AddAudioOutputConfiguration(soap, tag?tag:"-trt:AddAudioOutputConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddAudioOutputConfiguration * SOAP_FMAC4 soap_get___trt__AddAudioOutputConfiguration(struct soap *soap, struct __trt__AddAudioOutputConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__AddAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__AddAudioOutputConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioOutputConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__AddAudioOutputConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__AddAudioOutputConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__AddAudioOutputConfiguration);
		if (size)
			*size = sizeof(struct __trt__AddAudioOutputConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__AddAudioOutputConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__AddAudioOutputConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__AddAudioOutputConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__AddAudioOutputConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__AddAudioOutputConfiguration %p -> %p\n", q, p));
	*(struct __trt__AddAudioOutputConfiguration*)p = *(struct __trt__AddAudioOutputConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__AddMetadataConfiguration(struct soap *soap, struct __trt__AddMetadataConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__AddMetadataConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__AddMetadataConfiguration(struct soap *soap, const struct __trt__AddMetadataConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__AddMetadataConfiguration(soap, &a->trt__AddMetadataConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__AddMetadataConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__AddMetadataConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__AddMetadataConfiguration(soap, "trt:AddMetadataConfiguration", -1, &a->trt__AddMetadataConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddMetadataConfiguration * SOAP_FMAC4 soap_in___trt__AddMetadataConfiguration(struct soap *soap, const char *tag, struct __trt__AddMetadataConfiguration *a, const char *type)
{
	size_t soap_flag_trt__AddMetadataConfiguration = 1;
	short soap_flag;
	a = (struct __trt__AddMetadataConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__AddMetadataConfiguration, sizeof(struct __trt__AddMetadataConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__AddMetadataConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__AddMetadataConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__AddMetadataConfiguration(soap, "trt:AddMetadataConfiguration", &a->trt__AddMetadataConfiguration, ""))
				{	soap_flag_trt__AddMetadataConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__AddMetadataConfiguration(struct soap *soap, const struct __trt__AddMetadataConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__AddMetadataConfiguration(soap, tag?tag:"-trt:AddMetadataConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddMetadataConfiguration * SOAP_FMAC4 soap_get___trt__AddMetadataConfiguration(struct soap *soap, struct __trt__AddMetadataConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__AddMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__AddMetadataConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddMetadataConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__AddMetadataConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__AddMetadataConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__AddMetadataConfiguration);
		if (size)
			*size = sizeof(struct __trt__AddMetadataConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__AddMetadataConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__AddMetadataConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__AddMetadataConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__AddMetadataConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__AddMetadataConfiguration %p -> %p\n", q, p));
	*(struct __trt__AddMetadataConfiguration*)p = *(struct __trt__AddMetadataConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__AddVideoAnalyticsConfiguration(struct soap *soap, struct __trt__AddVideoAnalyticsConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__AddVideoAnalyticsConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__AddVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__AddVideoAnalyticsConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__AddVideoAnalyticsConfiguration(soap, &a->trt__AddVideoAnalyticsConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__AddVideoAnalyticsConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__AddVideoAnalyticsConfiguration(soap, "trt:AddVideoAnalyticsConfiguration", -1, &a->trt__AddVideoAnalyticsConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddVideoAnalyticsConfiguration * SOAP_FMAC4 soap_in___trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct __trt__AddVideoAnalyticsConfiguration *a, const char *type)
{
	size_t soap_flag_trt__AddVideoAnalyticsConfiguration = 1;
	short soap_flag;
	a = (struct __trt__AddVideoAnalyticsConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__AddVideoAnalyticsConfiguration, sizeof(struct __trt__AddVideoAnalyticsConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__AddVideoAnalyticsConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__AddVideoAnalyticsConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__AddVideoAnalyticsConfiguration(soap, "trt:AddVideoAnalyticsConfiguration", &a->trt__AddVideoAnalyticsConfiguration, ""))
				{	soap_flag_trt__AddVideoAnalyticsConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__AddVideoAnalyticsConfiguration(struct soap *soap, const struct __trt__AddVideoAnalyticsConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__AddVideoAnalyticsConfiguration(soap, tag?tag:"-trt:AddVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddVideoAnalyticsConfiguration * SOAP_FMAC4 soap_get___trt__AddVideoAnalyticsConfiguration(struct soap *soap, struct __trt__AddVideoAnalyticsConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__AddVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__AddVideoAnalyticsConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddVideoAnalyticsConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__AddVideoAnalyticsConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__AddVideoAnalyticsConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__AddVideoAnalyticsConfiguration);
		if (size)
			*size = sizeof(struct __trt__AddVideoAnalyticsConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__AddVideoAnalyticsConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__AddVideoAnalyticsConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__AddVideoAnalyticsConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__AddVideoAnalyticsConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__AddVideoAnalyticsConfiguration %p -> %p\n", q, p));
	*(struct __trt__AddVideoAnalyticsConfiguration*)p = *(struct __trt__AddVideoAnalyticsConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__AddPTZConfiguration(struct soap *soap, struct __trt__AddPTZConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__AddPTZConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__AddPTZConfiguration(struct soap *soap, const struct __trt__AddPTZConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__AddPTZConfiguration(soap, &a->trt__AddPTZConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__AddPTZConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__AddPTZConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__AddPTZConfiguration(soap, "trt:AddPTZConfiguration", -1, &a->trt__AddPTZConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddPTZConfiguration * SOAP_FMAC4 soap_in___trt__AddPTZConfiguration(struct soap *soap, const char *tag, struct __trt__AddPTZConfiguration *a, const char *type)
{
	size_t soap_flag_trt__AddPTZConfiguration = 1;
	short soap_flag;
	a = (struct __trt__AddPTZConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__AddPTZConfiguration, sizeof(struct __trt__AddPTZConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__AddPTZConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__AddPTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__AddPTZConfiguration(soap, "trt:AddPTZConfiguration", &a->trt__AddPTZConfiguration, ""))
				{	soap_flag_trt__AddPTZConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__AddPTZConfiguration(struct soap *soap, const struct __trt__AddPTZConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__AddPTZConfiguration(soap, tag?tag:"-trt:AddPTZConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddPTZConfiguration * SOAP_FMAC4 soap_get___trt__AddPTZConfiguration(struct soap *soap, struct __trt__AddPTZConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__AddPTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__AddPTZConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddPTZConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__AddPTZConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__AddPTZConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__AddPTZConfiguration);
		if (size)
			*size = sizeof(struct __trt__AddPTZConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__AddPTZConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__AddPTZConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__AddPTZConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__AddPTZConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__AddPTZConfiguration %p -> %p\n", q, p));
	*(struct __trt__AddPTZConfiguration*)p = *(struct __trt__AddPTZConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__AddAudioSourceConfiguration(struct soap *soap, struct __trt__AddAudioSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__AddAudioSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__AddAudioSourceConfiguration(struct soap *soap, const struct __trt__AddAudioSourceConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__AddAudioSourceConfiguration(soap, &a->trt__AddAudioSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__AddAudioSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__AddAudioSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__AddAudioSourceConfiguration(soap, "trt:AddAudioSourceConfiguration", -1, &a->trt__AddAudioSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddAudioSourceConfiguration * SOAP_FMAC4 soap_in___trt__AddAudioSourceConfiguration(struct soap *soap, const char *tag, struct __trt__AddAudioSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__AddAudioSourceConfiguration = 1;
	short soap_flag;
	a = (struct __trt__AddAudioSourceConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__AddAudioSourceConfiguration, sizeof(struct __trt__AddAudioSourceConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__AddAudioSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__AddAudioSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__AddAudioSourceConfiguration(soap, "trt:AddAudioSourceConfiguration", &a->trt__AddAudioSourceConfiguration, ""))
				{	soap_flag_trt__AddAudioSourceConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__AddAudioSourceConfiguration(struct soap *soap, const struct __trt__AddAudioSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__AddAudioSourceConfiguration(soap, tag?tag:"-trt:AddAudioSourceConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddAudioSourceConfiguration * SOAP_FMAC4 soap_get___trt__AddAudioSourceConfiguration(struct soap *soap, struct __trt__AddAudioSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__AddAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__AddAudioSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__AddAudioSourceConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__AddAudioSourceConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__AddAudioSourceConfiguration);
		if (size)
			*size = sizeof(struct __trt__AddAudioSourceConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__AddAudioSourceConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__AddAudioSourceConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__AddAudioSourceConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__AddAudioSourceConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__AddAudioSourceConfiguration %p -> %p\n", q, p));
	*(struct __trt__AddAudioSourceConfiguration*)p = *(struct __trt__AddAudioSourceConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__AddAudioEncoderConfiguration(struct soap *soap, struct __trt__AddAudioEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__AddAudioEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__AddAudioEncoderConfiguration(struct soap *soap, const struct __trt__AddAudioEncoderConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__AddAudioEncoderConfiguration(soap, &a->trt__AddAudioEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__AddAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__AddAudioEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__AddAudioEncoderConfiguration(soap, "trt:AddAudioEncoderConfiguration", -1, &a->trt__AddAudioEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddAudioEncoderConfiguration * SOAP_FMAC4 soap_in___trt__AddAudioEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__AddAudioEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__AddAudioEncoderConfiguration = 1;
	short soap_flag;
	a = (struct __trt__AddAudioEncoderConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__AddAudioEncoderConfiguration, sizeof(struct __trt__AddAudioEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__AddAudioEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__AddAudioEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__AddAudioEncoderConfiguration(soap, "trt:AddAudioEncoderConfiguration", &a->trt__AddAudioEncoderConfiguration, ""))
				{	soap_flag_trt__AddAudioEncoderConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__AddAudioEncoderConfiguration(struct soap *soap, const struct __trt__AddAudioEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__AddAudioEncoderConfiguration(soap, tag?tag:"-trt:AddAudioEncoderConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddAudioEncoderConfiguration * SOAP_FMAC4 soap_get___trt__AddAudioEncoderConfiguration(struct soap *soap, struct __trt__AddAudioEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__AddAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__AddAudioEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddAudioEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__AddAudioEncoderConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__AddAudioEncoderConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__AddAudioEncoderConfiguration);
		if (size)
			*size = sizeof(struct __trt__AddAudioEncoderConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__AddAudioEncoderConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__AddAudioEncoderConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__AddAudioEncoderConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__AddAudioEncoderConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__AddAudioEncoderConfiguration %p -> %p\n", q, p));
	*(struct __trt__AddAudioEncoderConfiguration*)p = *(struct __trt__AddAudioEncoderConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__AddVideoSourceConfiguration(struct soap *soap, struct __trt__AddVideoSourceConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__AddVideoSourceConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__AddVideoSourceConfiguration(struct soap *soap, const struct __trt__AddVideoSourceConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__AddVideoSourceConfiguration(soap, &a->trt__AddVideoSourceConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__AddVideoSourceConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__AddVideoSourceConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__AddVideoSourceConfiguration(soap, "trt:AddVideoSourceConfiguration", -1, &a->trt__AddVideoSourceConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddVideoSourceConfiguration * SOAP_FMAC4 soap_in___trt__AddVideoSourceConfiguration(struct soap *soap, const char *tag, struct __trt__AddVideoSourceConfiguration *a, const char *type)
{
	size_t soap_flag_trt__AddVideoSourceConfiguration = 1;
	short soap_flag;
	a = (struct __trt__AddVideoSourceConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__AddVideoSourceConfiguration, sizeof(struct __trt__AddVideoSourceConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__AddVideoSourceConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__AddVideoSourceConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__AddVideoSourceConfiguration(soap, "trt:AddVideoSourceConfiguration", &a->trt__AddVideoSourceConfiguration, ""))
				{	soap_flag_trt__AddVideoSourceConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__AddVideoSourceConfiguration(struct soap *soap, const struct __trt__AddVideoSourceConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__AddVideoSourceConfiguration(soap, tag?tag:"-trt:AddVideoSourceConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddVideoSourceConfiguration * SOAP_FMAC4 soap_get___trt__AddVideoSourceConfiguration(struct soap *soap, struct __trt__AddVideoSourceConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__AddVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__AddVideoSourceConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddVideoSourceConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__AddVideoSourceConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__AddVideoSourceConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__AddVideoSourceConfiguration);
		if (size)
			*size = sizeof(struct __trt__AddVideoSourceConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__AddVideoSourceConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__AddVideoSourceConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__AddVideoSourceConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__AddVideoSourceConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__AddVideoSourceConfiguration %p -> %p\n", q, p));
	*(struct __trt__AddVideoSourceConfiguration*)p = *(struct __trt__AddVideoSourceConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__AddVideoEncoderConfiguration(struct soap *soap, struct __trt__AddVideoEncoderConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__AddVideoEncoderConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__AddVideoEncoderConfiguration(struct soap *soap, const struct __trt__AddVideoEncoderConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__AddVideoEncoderConfiguration(soap, &a->trt__AddVideoEncoderConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__AddVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, const struct __trt__AddVideoEncoderConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__AddVideoEncoderConfiguration(soap, "trt:AddVideoEncoderConfiguration", -1, &a->trt__AddVideoEncoderConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddVideoEncoderConfiguration * SOAP_FMAC4 soap_in___trt__AddVideoEncoderConfiguration(struct soap *soap, const char *tag, struct __trt__AddVideoEncoderConfiguration *a, const char *type)
{
	size_t soap_flag_trt__AddVideoEncoderConfiguration = 1;
	short soap_flag;
	a = (struct __trt__AddVideoEncoderConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__AddVideoEncoderConfiguration, sizeof(struct __trt__AddVideoEncoderConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__AddVideoEncoderConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__AddVideoEncoderConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__AddVideoEncoderConfiguration(soap, "trt:AddVideoEncoderConfiguration", &a->trt__AddVideoEncoderConfiguration, ""))
				{	soap_flag_trt__AddVideoEncoderConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__AddVideoEncoderConfiguration(struct soap *soap, const struct __trt__AddVideoEncoderConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__AddVideoEncoderConfiguration(soap, tag?tag:"-trt:AddVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__AddVideoEncoderConfiguration * SOAP_FMAC4 soap_get___trt__AddVideoEncoderConfiguration(struct soap *soap, struct __trt__AddVideoEncoderConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__AddVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__AddVideoEncoderConfiguration * SOAP_FMAC2 soap_instantiate___trt__AddVideoEncoderConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__AddVideoEncoderConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__AddVideoEncoderConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__AddVideoEncoderConfiguration);
		if (size)
			*size = sizeof(struct __trt__AddVideoEncoderConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__AddVideoEncoderConfiguration, n);
		if (size)
			*size = n * sizeof(struct __trt__AddVideoEncoderConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__AddVideoEncoderConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__AddVideoEncoderConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__AddVideoEncoderConfiguration %p -> %p\n", q, p));
	*(struct __trt__AddVideoEncoderConfiguration*)p = *(struct __trt__AddVideoEncoderConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetProfiles(struct soap *soap, struct __trt__GetProfiles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetProfiles = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetProfiles(struct soap *soap, const struct __trt__GetProfiles *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetProfiles(soap, &a->trt__GetProfiles);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetProfiles(struct soap *soap, const char *tag, int id, const struct __trt__GetProfiles *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetProfiles(soap, "trt:GetProfiles", -1, &a->trt__GetProfiles, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetProfiles * SOAP_FMAC4 soap_in___trt__GetProfiles(struct soap *soap, const char *tag, struct __trt__GetProfiles *a, const char *type)
{
	size_t soap_flag_trt__GetProfiles = 1;
	short soap_flag;
	a = (struct __trt__GetProfiles *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetProfiles, sizeof(struct __trt__GetProfiles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetProfiles(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetProfiles && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetProfiles(soap, "trt:GetProfiles", &a->trt__GetProfiles, ""))
				{	soap_flag_trt__GetProfiles--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetProfiles(struct soap *soap, const struct __trt__GetProfiles *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetProfiles(soap, tag?tag:"-trt:GetProfiles", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetProfiles * SOAP_FMAC4 soap_get___trt__GetProfiles(struct soap *soap, struct __trt__GetProfiles *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetProfiles * SOAP_FMAC2 soap_instantiate___trt__GetProfiles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetProfiles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetProfiles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetProfiles);
		if (size)
			*size = sizeof(struct __trt__GetProfiles);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetProfiles, n);
		if (size)
			*size = n * sizeof(struct __trt__GetProfiles);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetProfiles*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetProfiles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetProfiles %p -> %p\n", q, p));
	*(struct __trt__GetProfiles*)p = *(struct __trt__GetProfiles*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetProfile(struct soap *soap, struct __trt__GetProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetProfile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetProfile(struct soap *soap, const struct __trt__GetProfile *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetProfile(soap, &a->trt__GetProfile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetProfile(struct soap *soap, const char *tag, int id, const struct __trt__GetProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetProfile(soap, "trt:GetProfile", -1, &a->trt__GetProfile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetProfile * SOAP_FMAC4 soap_in___trt__GetProfile(struct soap *soap, const char *tag, struct __trt__GetProfile *a, const char *type)
{
	size_t soap_flag_trt__GetProfile = 1;
	short soap_flag;
	a = (struct __trt__GetProfile *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetProfile, sizeof(struct __trt__GetProfile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetProfile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetProfile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetProfile(soap, "trt:GetProfile", &a->trt__GetProfile, ""))
				{	soap_flag_trt__GetProfile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetProfile(struct soap *soap, const struct __trt__GetProfile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetProfile(soap, tag?tag:"-trt:GetProfile", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetProfile * SOAP_FMAC4 soap_get___trt__GetProfile(struct soap *soap, struct __trt__GetProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetProfile * SOAP_FMAC2 soap_instantiate___trt__GetProfile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetProfile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetProfile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetProfile);
		if (size)
			*size = sizeof(struct __trt__GetProfile);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetProfile, n);
		if (size)
			*size = n * sizeof(struct __trt__GetProfile);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetProfile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetProfile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetProfile %p -> %p\n", q, p));
	*(struct __trt__GetProfile*)p = *(struct __trt__GetProfile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__CreateProfile(struct soap *soap, struct __trt__CreateProfile *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__CreateProfile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__CreateProfile(struct soap *soap, const struct __trt__CreateProfile *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__CreateProfile(soap, &a->trt__CreateProfile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__CreateProfile(struct soap *soap, const char *tag, int id, const struct __trt__CreateProfile *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__CreateProfile(soap, "trt:CreateProfile", -1, &a->trt__CreateProfile, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__CreateProfile * SOAP_FMAC4 soap_in___trt__CreateProfile(struct soap *soap, const char *tag, struct __trt__CreateProfile *a, const char *type)
{
	size_t soap_flag_trt__CreateProfile = 1;
	short soap_flag;
	a = (struct __trt__CreateProfile *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__CreateProfile, sizeof(struct __trt__CreateProfile), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__CreateProfile(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__CreateProfile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__CreateProfile(soap, "trt:CreateProfile", &a->trt__CreateProfile, ""))
				{	soap_flag_trt__CreateProfile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__CreateProfile(struct soap *soap, const struct __trt__CreateProfile *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__CreateProfile(soap, tag?tag:"-trt:CreateProfile", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__CreateProfile * SOAP_FMAC4 soap_get___trt__CreateProfile(struct soap *soap, struct __trt__CreateProfile *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__CreateProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__CreateProfile * SOAP_FMAC2 soap_instantiate___trt__CreateProfile(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__CreateProfile(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__CreateProfile, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__CreateProfile);
		if (size)
			*size = sizeof(struct __trt__CreateProfile);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__CreateProfile, n);
		if (size)
			*size = n * sizeof(struct __trt__CreateProfile);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__CreateProfile*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__CreateProfile(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__CreateProfile %p -> %p\n", q, p));
	*(struct __trt__CreateProfile*)p = *(struct __trt__CreateProfile*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioOutputs(struct soap *soap, struct __trt__GetAudioOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioOutputs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioOutputs(struct soap *soap, const struct __trt__GetAudioOutputs *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetAudioOutputs(soap, &a->trt__GetAudioOutputs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioOutputs(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioOutputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetAudioOutputs(soap, "trt:GetAudioOutputs", -1, &a->trt__GetAudioOutputs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputs * SOAP_FMAC4 soap_in___trt__GetAudioOutputs(struct soap *soap, const char *tag, struct __trt__GetAudioOutputs *a, const char *type)
{
	size_t soap_flag_trt__GetAudioOutputs = 1;
	short soap_flag;
	a = (struct __trt__GetAudioOutputs *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioOutputs, sizeof(struct __trt__GetAudioOutputs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioOutputs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioOutputs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetAudioOutputs(soap, "trt:GetAudioOutputs", &a->trt__GetAudioOutputs, ""))
				{	soap_flag_trt__GetAudioOutputs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioOutputs(struct soap *soap, const struct __trt__GetAudioOutputs *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetAudioOutputs(soap, tag?tag:"-trt:GetAudioOutputs", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioOutputs * SOAP_FMAC4 soap_get___trt__GetAudioOutputs(struct soap *soap, struct __trt__GetAudioOutputs *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetAudioOutputs * SOAP_FMAC2 soap_instantiate___trt__GetAudioOutputs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioOutputs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetAudioOutputs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetAudioOutputs);
		if (size)
			*size = sizeof(struct __trt__GetAudioOutputs);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetAudioOutputs, n);
		if (size)
			*size = n * sizeof(struct __trt__GetAudioOutputs);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetAudioOutputs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetAudioOutputs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetAudioOutputs %p -> %p\n", q, p));
	*(struct __trt__GetAudioOutputs*)p = *(struct __trt__GetAudioOutputs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetAudioSources(struct soap *soap, struct __trt__GetAudioSources *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetAudioSources = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetAudioSources(struct soap *soap, const struct __trt__GetAudioSources *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetAudioSources(soap, &a->trt__GetAudioSources);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetAudioSources(struct soap *soap, const char *tag, int id, const struct __trt__GetAudioSources *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetAudioSources(soap, "trt:GetAudioSources", -1, &a->trt__GetAudioSources, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSources * SOAP_FMAC4 soap_in___trt__GetAudioSources(struct soap *soap, const char *tag, struct __trt__GetAudioSources *a, const char *type)
{
	size_t soap_flag_trt__GetAudioSources = 1;
	short soap_flag;
	a = (struct __trt__GetAudioSources *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetAudioSources, sizeof(struct __trt__GetAudioSources), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetAudioSources(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetAudioSources && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetAudioSources(soap, "trt:GetAudioSources", &a->trt__GetAudioSources, ""))
				{	soap_flag_trt__GetAudioSources--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetAudioSources(struct soap *soap, const struct __trt__GetAudioSources *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetAudioSources(soap, tag?tag:"-trt:GetAudioSources", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetAudioSources * SOAP_FMAC4 soap_get___trt__GetAudioSources(struct soap *soap, struct __trt__GetAudioSources *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetAudioSources(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetAudioSources * SOAP_FMAC2 soap_instantiate___trt__GetAudioSources(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetAudioSources(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetAudioSources, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetAudioSources);
		if (size)
			*size = sizeof(struct __trt__GetAudioSources);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetAudioSources, n);
		if (size)
			*size = n * sizeof(struct __trt__GetAudioSources);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetAudioSources*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetAudioSources(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetAudioSources %p -> %p\n", q, p));
	*(struct __trt__GetAudioSources*)p = *(struct __trt__GetAudioSources*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetVideoSources(struct soap *soap, struct __trt__GetVideoSources *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetVideoSources = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetVideoSources(struct soap *soap, const struct __trt__GetVideoSources *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetVideoSources(soap, &a->trt__GetVideoSources);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetVideoSources(struct soap *soap, const char *tag, int id, const struct __trt__GetVideoSources *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetVideoSources(soap, "trt:GetVideoSources", -1, &a->trt__GetVideoSources, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSources * SOAP_FMAC4 soap_in___trt__GetVideoSources(struct soap *soap, const char *tag, struct __trt__GetVideoSources *a, const char *type)
{
	size_t soap_flag_trt__GetVideoSources = 1;
	short soap_flag;
	a = (struct __trt__GetVideoSources *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetVideoSources, sizeof(struct __trt__GetVideoSources), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetVideoSources(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetVideoSources && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetVideoSources(soap, "trt:GetVideoSources", &a->trt__GetVideoSources, ""))
				{	soap_flag_trt__GetVideoSources--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetVideoSources(struct soap *soap, const struct __trt__GetVideoSources *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetVideoSources(soap, tag?tag:"-trt:GetVideoSources", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetVideoSources * SOAP_FMAC4 soap_get___trt__GetVideoSources(struct soap *soap, struct __trt__GetVideoSources *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetVideoSources(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetVideoSources * SOAP_FMAC2 soap_instantiate___trt__GetVideoSources(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetVideoSources(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetVideoSources, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetVideoSources);
		if (size)
			*size = sizeof(struct __trt__GetVideoSources);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetVideoSources, n);
		if (size)
			*size = n * sizeof(struct __trt__GetVideoSources);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetVideoSources*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetVideoSources(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetVideoSources %p -> %p\n", q, p));
	*(struct __trt__GetVideoSources*)p = *(struct __trt__GetVideoSources*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___trt__GetServiceCapabilities(struct soap *soap, struct __trt__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->trt__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___trt__GetServiceCapabilities(struct soap *soap, const struct __trt__GetServiceCapabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_trt__GetServiceCapabilities(soap, &a->trt__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___trt__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __trt__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_trt__GetServiceCapabilities(soap, "trt:GetServiceCapabilities", -1, &a->trt__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetServiceCapabilities * SOAP_FMAC4 soap_in___trt__GetServiceCapabilities(struct soap *soap, const char *tag, struct __trt__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_trt__GetServiceCapabilities = 1;
	short soap_flag;
	a = (struct __trt__GetServiceCapabilities *)soap_id_enter(soap, "", a, SOAP_TYPE___trt__GetServiceCapabilities, sizeof(struct __trt__GetServiceCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___trt__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_trt__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_trt__GetServiceCapabilities(soap, "trt:GetServiceCapabilities", &a->trt__GetServiceCapabilities, ""))
				{	soap_flag_trt__GetServiceCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___trt__GetServiceCapabilities(struct soap *soap, const struct __trt__GetServiceCapabilities *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___trt__GetServiceCapabilities(soap, tag?tag:"-trt:GetServiceCapabilities", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __trt__GetServiceCapabilities * SOAP_FMAC4 soap_get___trt__GetServiceCapabilities(struct soap *soap, struct __trt__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___trt__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __trt__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___trt__GetServiceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___trt__GetServiceCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___trt__GetServiceCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __trt__GetServiceCapabilities);
		if (size)
			*size = sizeof(struct __trt__GetServiceCapabilities);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __trt__GetServiceCapabilities, n);
		if (size)
			*size = n * sizeof(struct __trt__GetServiceCapabilities);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __trt__GetServiceCapabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___trt__GetServiceCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __trt__GetServiceCapabilities %p -> %p\n", q, p));
	*(struct __trt__GetServiceCapabilities*)p = *(struct __trt__GetServiceCapabilities*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__RemovePresetTour(struct soap *soap, struct __tptz__RemovePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__RemovePresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__RemovePresetTour(struct soap *soap, const struct __tptz__RemovePresetTour *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__RemovePresetTour(soap, &a->tptz__RemovePresetTour);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__RemovePresetTour(struct soap *soap, const char *tag, int id, const struct __tptz__RemovePresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__RemovePresetTour(soap, "tptz:RemovePresetTour", -1, &a->tptz__RemovePresetTour, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__RemovePresetTour * SOAP_FMAC4 soap_in___tptz__RemovePresetTour(struct soap *soap, const char *tag, struct __tptz__RemovePresetTour *a, const char *type)
{
	size_t soap_flag_tptz__RemovePresetTour = 1;
	short soap_flag;
	a = (struct __tptz__RemovePresetTour *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__RemovePresetTour, sizeof(struct __tptz__RemovePresetTour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__RemovePresetTour(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__RemovePresetTour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__RemovePresetTour(soap, "tptz:RemovePresetTour", &a->tptz__RemovePresetTour, ""))
				{	soap_flag_tptz__RemovePresetTour--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__RemovePresetTour(struct soap *soap, const struct __tptz__RemovePresetTour *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__RemovePresetTour(soap, tag?tag:"-tptz:RemovePresetTour", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__RemovePresetTour * SOAP_FMAC4 soap_get___tptz__RemovePresetTour(struct soap *soap, struct __tptz__RemovePresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__RemovePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__RemovePresetTour * SOAP_FMAC2 soap_instantiate___tptz__RemovePresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__RemovePresetTour(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__RemovePresetTour, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__RemovePresetTour);
		if (size)
			*size = sizeof(struct __tptz__RemovePresetTour);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__RemovePresetTour, n);
		if (size)
			*size = n * sizeof(struct __tptz__RemovePresetTour);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__RemovePresetTour*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__RemovePresetTour(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__RemovePresetTour %p -> %p\n", q, p));
	*(struct __tptz__RemovePresetTour*)p = *(struct __tptz__RemovePresetTour*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__OperatePresetTour(struct soap *soap, struct __tptz__OperatePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__OperatePresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__OperatePresetTour(struct soap *soap, const struct __tptz__OperatePresetTour *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__OperatePresetTour(soap, &a->tptz__OperatePresetTour);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__OperatePresetTour(struct soap *soap, const char *tag, int id, const struct __tptz__OperatePresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__OperatePresetTour(soap, "tptz:OperatePresetTour", -1, &a->tptz__OperatePresetTour, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__OperatePresetTour * SOAP_FMAC4 soap_in___tptz__OperatePresetTour(struct soap *soap, const char *tag, struct __tptz__OperatePresetTour *a, const char *type)
{
	size_t soap_flag_tptz__OperatePresetTour = 1;
	short soap_flag;
	a = (struct __tptz__OperatePresetTour *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__OperatePresetTour, sizeof(struct __tptz__OperatePresetTour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__OperatePresetTour(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__OperatePresetTour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__OperatePresetTour(soap, "tptz:OperatePresetTour", &a->tptz__OperatePresetTour, ""))
				{	soap_flag_tptz__OperatePresetTour--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__OperatePresetTour(struct soap *soap, const struct __tptz__OperatePresetTour *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__OperatePresetTour(soap, tag?tag:"-tptz:OperatePresetTour", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__OperatePresetTour * SOAP_FMAC4 soap_get___tptz__OperatePresetTour(struct soap *soap, struct __tptz__OperatePresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__OperatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__OperatePresetTour * SOAP_FMAC2 soap_instantiate___tptz__OperatePresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__OperatePresetTour(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__OperatePresetTour, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__OperatePresetTour);
		if (size)
			*size = sizeof(struct __tptz__OperatePresetTour);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__OperatePresetTour, n);
		if (size)
			*size = n * sizeof(struct __tptz__OperatePresetTour);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__OperatePresetTour*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__OperatePresetTour(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__OperatePresetTour %p -> %p\n", q, p));
	*(struct __tptz__OperatePresetTour*)p = *(struct __tptz__OperatePresetTour*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__ModifyPresetTour(struct soap *soap, struct __tptz__ModifyPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__ModifyPresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__ModifyPresetTour(struct soap *soap, const struct __tptz__ModifyPresetTour *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__ModifyPresetTour(soap, &a->tptz__ModifyPresetTour);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__ModifyPresetTour(struct soap *soap, const char *tag, int id, const struct __tptz__ModifyPresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__ModifyPresetTour(soap, "tptz:ModifyPresetTour", -1, &a->tptz__ModifyPresetTour, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__ModifyPresetTour * SOAP_FMAC4 soap_in___tptz__ModifyPresetTour(struct soap *soap, const char *tag, struct __tptz__ModifyPresetTour *a, const char *type)
{
	size_t soap_flag_tptz__ModifyPresetTour = 1;
	short soap_flag;
	a = (struct __tptz__ModifyPresetTour *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__ModifyPresetTour, sizeof(struct __tptz__ModifyPresetTour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__ModifyPresetTour(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__ModifyPresetTour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__ModifyPresetTour(soap, "tptz:ModifyPresetTour", &a->tptz__ModifyPresetTour, ""))
				{	soap_flag_tptz__ModifyPresetTour--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__ModifyPresetTour(struct soap *soap, const struct __tptz__ModifyPresetTour *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__ModifyPresetTour(soap, tag?tag:"-tptz:ModifyPresetTour", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__ModifyPresetTour * SOAP_FMAC4 soap_get___tptz__ModifyPresetTour(struct soap *soap, struct __tptz__ModifyPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__ModifyPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__ModifyPresetTour * SOAP_FMAC2 soap_instantiate___tptz__ModifyPresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__ModifyPresetTour(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__ModifyPresetTour, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__ModifyPresetTour);
		if (size)
			*size = sizeof(struct __tptz__ModifyPresetTour);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__ModifyPresetTour, n);
		if (size)
			*size = n * sizeof(struct __tptz__ModifyPresetTour);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__ModifyPresetTour*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__ModifyPresetTour(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__ModifyPresetTour %p -> %p\n", q, p));
	*(struct __tptz__ModifyPresetTour*)p = *(struct __tptz__ModifyPresetTour*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__CreatePresetTour(struct soap *soap, struct __tptz__CreatePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__CreatePresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__CreatePresetTour(struct soap *soap, const struct __tptz__CreatePresetTour *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__CreatePresetTour(soap, &a->tptz__CreatePresetTour);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__CreatePresetTour(struct soap *soap, const char *tag, int id, const struct __tptz__CreatePresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__CreatePresetTour(soap, "tptz:CreatePresetTour", -1, &a->tptz__CreatePresetTour, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__CreatePresetTour * SOAP_FMAC4 soap_in___tptz__CreatePresetTour(struct soap *soap, const char *tag, struct __tptz__CreatePresetTour *a, const char *type)
{
	size_t soap_flag_tptz__CreatePresetTour = 1;
	short soap_flag;
	a = (struct __tptz__CreatePresetTour *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__CreatePresetTour, sizeof(struct __tptz__CreatePresetTour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__CreatePresetTour(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__CreatePresetTour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__CreatePresetTour(soap, "tptz:CreatePresetTour", &a->tptz__CreatePresetTour, ""))
				{	soap_flag_tptz__CreatePresetTour--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__CreatePresetTour(struct soap *soap, const struct __tptz__CreatePresetTour *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__CreatePresetTour(soap, tag?tag:"-tptz:CreatePresetTour", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__CreatePresetTour * SOAP_FMAC4 soap_get___tptz__CreatePresetTour(struct soap *soap, struct __tptz__CreatePresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__CreatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__CreatePresetTour * SOAP_FMAC2 soap_instantiate___tptz__CreatePresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__CreatePresetTour(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__CreatePresetTour, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__CreatePresetTour);
		if (size)
			*size = sizeof(struct __tptz__CreatePresetTour);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__CreatePresetTour, n);
		if (size)
			*size = n * sizeof(struct __tptz__CreatePresetTour);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__CreatePresetTour*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__CreatePresetTour(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__CreatePresetTour %p -> %p\n", q, p));
	*(struct __tptz__CreatePresetTour*)p = *(struct __tptz__CreatePresetTour*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetPresetTourOptions(struct soap *soap, struct __tptz__GetPresetTourOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetPresetTourOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetPresetTourOptions(struct soap *soap, const struct __tptz__GetPresetTourOptions *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__GetPresetTourOptions(soap, &a->tptz__GetPresetTourOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetPresetTourOptions(struct soap *soap, const char *tag, int id, const struct __tptz__GetPresetTourOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__GetPresetTourOptions(soap, "tptz:GetPresetTourOptions", -1, &a->tptz__GetPresetTourOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetPresetTourOptions * SOAP_FMAC4 soap_in___tptz__GetPresetTourOptions(struct soap *soap, const char *tag, struct __tptz__GetPresetTourOptions *a, const char *type)
{
	size_t soap_flag_tptz__GetPresetTourOptions = 1;
	short soap_flag;
	a = (struct __tptz__GetPresetTourOptions *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetPresetTourOptions, sizeof(struct __tptz__GetPresetTourOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetPresetTourOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetPresetTourOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__GetPresetTourOptions(soap, "tptz:GetPresetTourOptions", &a->tptz__GetPresetTourOptions, ""))
				{	soap_flag_tptz__GetPresetTourOptions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetPresetTourOptions(struct soap *soap, const struct __tptz__GetPresetTourOptions *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__GetPresetTourOptions(soap, tag?tag:"-tptz:GetPresetTourOptions", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetPresetTourOptions * SOAP_FMAC4 soap_get___tptz__GetPresetTourOptions(struct soap *soap, struct __tptz__GetPresetTourOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetPresetTourOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__GetPresetTourOptions * SOAP_FMAC2 soap_instantiate___tptz__GetPresetTourOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetPresetTourOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__GetPresetTourOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__GetPresetTourOptions);
		if (size)
			*size = sizeof(struct __tptz__GetPresetTourOptions);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__GetPresetTourOptions, n);
		if (size)
			*size = n * sizeof(struct __tptz__GetPresetTourOptions);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__GetPresetTourOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__GetPresetTourOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__GetPresetTourOptions %p -> %p\n", q, p));
	*(struct __tptz__GetPresetTourOptions*)p = *(struct __tptz__GetPresetTourOptions*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetPresetTour(struct soap *soap, struct __tptz__GetPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetPresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetPresetTour(struct soap *soap, const struct __tptz__GetPresetTour *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__GetPresetTour(soap, &a->tptz__GetPresetTour);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetPresetTour(struct soap *soap, const char *tag, int id, const struct __tptz__GetPresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__GetPresetTour(soap, "tptz:GetPresetTour", -1, &a->tptz__GetPresetTour, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetPresetTour * SOAP_FMAC4 soap_in___tptz__GetPresetTour(struct soap *soap, const char *tag, struct __tptz__GetPresetTour *a, const char *type)
{
	size_t soap_flag_tptz__GetPresetTour = 1;
	short soap_flag;
	a = (struct __tptz__GetPresetTour *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetPresetTour, sizeof(struct __tptz__GetPresetTour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetPresetTour(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetPresetTour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__GetPresetTour(soap, "tptz:GetPresetTour", &a->tptz__GetPresetTour, ""))
				{	soap_flag_tptz__GetPresetTour--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetPresetTour(struct soap *soap, const struct __tptz__GetPresetTour *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__GetPresetTour(soap, tag?tag:"-tptz:GetPresetTour", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetPresetTour * SOAP_FMAC4 soap_get___tptz__GetPresetTour(struct soap *soap, struct __tptz__GetPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__GetPresetTour * SOAP_FMAC2 soap_instantiate___tptz__GetPresetTour(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetPresetTour(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__GetPresetTour, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__GetPresetTour);
		if (size)
			*size = sizeof(struct __tptz__GetPresetTour);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__GetPresetTour, n);
		if (size)
			*size = n * sizeof(struct __tptz__GetPresetTour);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__GetPresetTour*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__GetPresetTour(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__GetPresetTour %p -> %p\n", q, p));
	*(struct __tptz__GetPresetTour*)p = *(struct __tptz__GetPresetTour*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetPresetTours(struct soap *soap, struct __tptz__GetPresetTours *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetPresetTours = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetPresetTours(struct soap *soap, const struct __tptz__GetPresetTours *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__GetPresetTours(soap, &a->tptz__GetPresetTours);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetPresetTours(struct soap *soap, const char *tag, int id, const struct __tptz__GetPresetTours *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__GetPresetTours(soap, "tptz:GetPresetTours", -1, &a->tptz__GetPresetTours, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetPresetTours * SOAP_FMAC4 soap_in___tptz__GetPresetTours(struct soap *soap, const char *tag, struct __tptz__GetPresetTours *a, const char *type)
{
	size_t soap_flag_tptz__GetPresetTours = 1;
	short soap_flag;
	a = (struct __tptz__GetPresetTours *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetPresetTours, sizeof(struct __tptz__GetPresetTours), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetPresetTours(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetPresetTours && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__GetPresetTours(soap, "tptz:GetPresetTours", &a->tptz__GetPresetTours, ""))
				{	soap_flag_tptz__GetPresetTours--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetPresetTours(struct soap *soap, const struct __tptz__GetPresetTours *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__GetPresetTours(soap, tag?tag:"-tptz:GetPresetTours", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetPresetTours * SOAP_FMAC4 soap_get___tptz__GetPresetTours(struct soap *soap, struct __tptz__GetPresetTours *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetPresetTours(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__GetPresetTours * SOAP_FMAC2 soap_instantiate___tptz__GetPresetTours(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetPresetTours(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__GetPresetTours, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__GetPresetTours);
		if (size)
			*size = sizeof(struct __tptz__GetPresetTours);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__GetPresetTours, n);
		if (size)
			*size = n * sizeof(struct __tptz__GetPresetTours);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__GetPresetTours*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__GetPresetTours(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__GetPresetTours %p -> %p\n", q, p));
	*(struct __tptz__GetPresetTours*)p = *(struct __tptz__GetPresetTours*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__Stop(struct soap *soap, struct __tptz__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__Stop = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__Stop(struct soap *soap, const struct __tptz__Stop *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__Stop(soap, &a->tptz__Stop);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__Stop(struct soap *soap, const char *tag, int id, const struct __tptz__Stop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__Stop(soap, "tptz:Stop", -1, &a->tptz__Stop, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__Stop * SOAP_FMAC4 soap_in___tptz__Stop(struct soap *soap, const char *tag, struct __tptz__Stop *a, const char *type)
{
	size_t soap_flag_tptz__Stop = 1;
	short soap_flag;
	a = (struct __tptz__Stop *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__Stop, sizeof(struct __tptz__Stop), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__Stop(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__Stop && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__Stop(soap, "tptz:Stop", &a->tptz__Stop, ""))
				{	soap_flag_tptz__Stop--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__Stop(struct soap *soap, const struct __tptz__Stop *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__Stop(soap, tag?tag:"-tptz:Stop", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__Stop * SOAP_FMAC4 soap_get___tptz__Stop(struct soap *soap, struct __tptz__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__Stop * SOAP_FMAC2 soap_instantiate___tptz__Stop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__Stop(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__Stop, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__Stop);
		if (size)
			*size = sizeof(struct __tptz__Stop);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__Stop, n);
		if (size)
			*size = n * sizeof(struct __tptz__Stop);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__Stop*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__Stop(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__Stop %p -> %p\n", q, p));
	*(struct __tptz__Stop*)p = *(struct __tptz__Stop*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__AbsoluteMove(struct soap *soap, struct __tptz__AbsoluteMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__AbsoluteMove = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__AbsoluteMove(struct soap *soap, const struct __tptz__AbsoluteMove *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__AbsoluteMove(soap, &a->tptz__AbsoluteMove);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__AbsoluteMove(struct soap *soap, const char *tag, int id, const struct __tptz__AbsoluteMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__AbsoluteMove(soap, "tptz:AbsoluteMove", -1, &a->tptz__AbsoluteMove, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__AbsoluteMove * SOAP_FMAC4 soap_in___tptz__AbsoluteMove(struct soap *soap, const char *tag, struct __tptz__AbsoluteMove *a, const char *type)
{
	size_t soap_flag_tptz__AbsoluteMove = 1;
	short soap_flag;
	a = (struct __tptz__AbsoluteMove *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__AbsoluteMove, sizeof(struct __tptz__AbsoluteMove), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__AbsoluteMove(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__AbsoluteMove && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__AbsoluteMove(soap, "tptz:AbsoluteMove", &a->tptz__AbsoluteMove, ""))
				{	soap_flag_tptz__AbsoluteMove--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__AbsoluteMove(struct soap *soap, const struct __tptz__AbsoluteMove *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__AbsoluteMove(soap, tag?tag:"-tptz:AbsoluteMove", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__AbsoluteMove * SOAP_FMAC4 soap_get___tptz__AbsoluteMove(struct soap *soap, struct __tptz__AbsoluteMove *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__AbsoluteMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__AbsoluteMove * SOAP_FMAC2 soap_instantiate___tptz__AbsoluteMove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__AbsoluteMove(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__AbsoluteMove, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__AbsoluteMove);
		if (size)
			*size = sizeof(struct __tptz__AbsoluteMove);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__AbsoluteMove, n);
		if (size)
			*size = n * sizeof(struct __tptz__AbsoluteMove);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__AbsoluteMove*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__AbsoluteMove(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__AbsoluteMove %p -> %p\n", q, p));
	*(struct __tptz__AbsoluteMove*)p = *(struct __tptz__AbsoluteMove*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__SendAuxiliaryCommand(struct soap *soap, struct __tptz__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__SendAuxiliaryCommand = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__SendAuxiliaryCommand(struct soap *soap, const struct __tptz__SendAuxiliaryCommand *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__SendAuxiliaryCommand(soap, &a->tptz__SendAuxiliaryCommand);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, const struct __tptz__SendAuxiliaryCommand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__SendAuxiliaryCommand(soap, "tptz:SendAuxiliaryCommand", -1, &a->tptz__SendAuxiliaryCommand, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SendAuxiliaryCommand * SOAP_FMAC4 soap_in___tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct __tptz__SendAuxiliaryCommand *a, const char *type)
{
	size_t soap_flag_tptz__SendAuxiliaryCommand = 1;
	short soap_flag;
	a = (struct __tptz__SendAuxiliaryCommand *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__SendAuxiliaryCommand, sizeof(struct __tptz__SendAuxiliaryCommand), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__SendAuxiliaryCommand(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__SendAuxiliaryCommand && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__SendAuxiliaryCommand(soap, "tptz:SendAuxiliaryCommand", &a->tptz__SendAuxiliaryCommand, ""))
				{	soap_flag_tptz__SendAuxiliaryCommand--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__SendAuxiliaryCommand(struct soap *soap, const struct __tptz__SendAuxiliaryCommand *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__SendAuxiliaryCommand(soap, tag?tag:"-tptz:SendAuxiliaryCommand", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SendAuxiliaryCommand * SOAP_FMAC4 soap_get___tptz__SendAuxiliaryCommand(struct soap *soap, struct __tptz__SendAuxiliaryCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate___tptz__SendAuxiliaryCommand(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__SendAuxiliaryCommand(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__SendAuxiliaryCommand, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__SendAuxiliaryCommand);
		if (size)
			*size = sizeof(struct __tptz__SendAuxiliaryCommand);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__SendAuxiliaryCommand, n);
		if (size)
			*size = n * sizeof(struct __tptz__SendAuxiliaryCommand);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__SendAuxiliaryCommand*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__SendAuxiliaryCommand(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__SendAuxiliaryCommand %p -> %p\n", q, p));
	*(struct __tptz__SendAuxiliaryCommand*)p = *(struct __tptz__SendAuxiliaryCommand*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__RelativeMove(struct soap *soap, struct __tptz__RelativeMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__RelativeMove = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__RelativeMove(struct soap *soap, const struct __tptz__RelativeMove *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__RelativeMove(soap, &a->tptz__RelativeMove);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__RelativeMove(struct soap *soap, const char *tag, int id, const struct __tptz__RelativeMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__RelativeMove(soap, "tptz:RelativeMove", -1, &a->tptz__RelativeMove, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__RelativeMove * SOAP_FMAC4 soap_in___tptz__RelativeMove(struct soap *soap, const char *tag, struct __tptz__RelativeMove *a, const char *type)
{
	size_t soap_flag_tptz__RelativeMove = 1;
	short soap_flag;
	a = (struct __tptz__RelativeMove *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__RelativeMove, sizeof(struct __tptz__RelativeMove), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__RelativeMove(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__RelativeMove && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__RelativeMove(soap, "tptz:RelativeMove", &a->tptz__RelativeMove, ""))
				{	soap_flag_tptz__RelativeMove--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__RelativeMove(struct soap *soap, const struct __tptz__RelativeMove *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__RelativeMove(soap, tag?tag:"-tptz:RelativeMove", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__RelativeMove * SOAP_FMAC4 soap_get___tptz__RelativeMove(struct soap *soap, struct __tptz__RelativeMove *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__RelativeMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__RelativeMove * SOAP_FMAC2 soap_instantiate___tptz__RelativeMove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__RelativeMove(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__RelativeMove, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__RelativeMove);
		if (size)
			*size = sizeof(struct __tptz__RelativeMove);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__RelativeMove, n);
		if (size)
			*size = n * sizeof(struct __tptz__RelativeMove);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__RelativeMove*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__RelativeMove(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__RelativeMove %p -> %p\n", q, p));
	*(struct __tptz__RelativeMove*)p = *(struct __tptz__RelativeMove*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__ContinuousMove(struct soap *soap, struct __tptz__ContinuousMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__ContinuousMove = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__ContinuousMove(struct soap *soap, const struct __tptz__ContinuousMove *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__ContinuousMove(soap, &a->tptz__ContinuousMove);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__ContinuousMove(struct soap *soap, const char *tag, int id, const struct __tptz__ContinuousMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__ContinuousMove(soap, "tptz:ContinuousMove", -1, &a->tptz__ContinuousMove, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__ContinuousMove * SOAP_FMAC4 soap_in___tptz__ContinuousMove(struct soap *soap, const char *tag, struct __tptz__ContinuousMove *a, const char *type)
{
	size_t soap_flag_tptz__ContinuousMove = 1;
	short soap_flag;
	a = (struct __tptz__ContinuousMove *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__ContinuousMove, sizeof(struct __tptz__ContinuousMove), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__ContinuousMove(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__ContinuousMove && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__ContinuousMove(soap, "tptz:ContinuousMove", &a->tptz__ContinuousMove, ""))
				{	soap_flag_tptz__ContinuousMove--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__ContinuousMove(struct soap *soap, const struct __tptz__ContinuousMove *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__ContinuousMove(soap, tag?tag:"-tptz:ContinuousMove", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__ContinuousMove * SOAP_FMAC4 soap_get___tptz__ContinuousMove(struct soap *soap, struct __tptz__ContinuousMove *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__ContinuousMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__ContinuousMove * SOAP_FMAC2 soap_instantiate___tptz__ContinuousMove(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__ContinuousMove(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__ContinuousMove, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__ContinuousMove);
		if (size)
			*size = sizeof(struct __tptz__ContinuousMove);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__ContinuousMove, n);
		if (size)
			*size = n * sizeof(struct __tptz__ContinuousMove);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__ContinuousMove*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__ContinuousMove(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__ContinuousMove %p -> %p\n", q, p));
	*(struct __tptz__ContinuousMove*)p = *(struct __tptz__ContinuousMove*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__SetHomePosition(struct soap *soap, struct __tptz__SetHomePosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__SetHomePosition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__SetHomePosition(struct soap *soap, const struct __tptz__SetHomePosition *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__SetHomePosition(soap, &a->tptz__SetHomePosition);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__SetHomePosition(struct soap *soap, const char *tag, int id, const struct __tptz__SetHomePosition *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__SetHomePosition(soap, "tptz:SetHomePosition", -1, &a->tptz__SetHomePosition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetHomePosition * SOAP_FMAC4 soap_in___tptz__SetHomePosition(struct soap *soap, const char *tag, struct __tptz__SetHomePosition *a, const char *type)
{
	size_t soap_flag_tptz__SetHomePosition = 1;
	short soap_flag;
	a = (struct __tptz__SetHomePosition *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__SetHomePosition, sizeof(struct __tptz__SetHomePosition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__SetHomePosition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__SetHomePosition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__SetHomePosition(soap, "tptz:SetHomePosition", &a->tptz__SetHomePosition, ""))
				{	soap_flag_tptz__SetHomePosition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__SetHomePosition(struct soap *soap, const struct __tptz__SetHomePosition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__SetHomePosition(soap, tag?tag:"-tptz:SetHomePosition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetHomePosition * SOAP_FMAC4 soap_get___tptz__SetHomePosition(struct soap *soap, struct __tptz__SetHomePosition *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__SetHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__SetHomePosition * SOAP_FMAC2 soap_instantiate___tptz__SetHomePosition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__SetHomePosition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__SetHomePosition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__SetHomePosition);
		if (size)
			*size = sizeof(struct __tptz__SetHomePosition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__SetHomePosition, n);
		if (size)
			*size = n * sizeof(struct __tptz__SetHomePosition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__SetHomePosition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__SetHomePosition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__SetHomePosition %p -> %p\n", q, p));
	*(struct __tptz__SetHomePosition*)p = *(struct __tptz__SetHomePosition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GotoHomePosition(struct soap *soap, struct __tptz__GotoHomePosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GotoHomePosition = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GotoHomePosition(struct soap *soap, const struct __tptz__GotoHomePosition *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__GotoHomePosition(soap, &a->tptz__GotoHomePosition);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GotoHomePosition(struct soap *soap, const char *tag, int id, const struct __tptz__GotoHomePosition *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__GotoHomePosition(soap, "tptz:GotoHomePosition", -1, &a->tptz__GotoHomePosition, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GotoHomePosition * SOAP_FMAC4 soap_in___tptz__GotoHomePosition(struct soap *soap, const char *tag, struct __tptz__GotoHomePosition *a, const char *type)
{
	size_t soap_flag_tptz__GotoHomePosition = 1;
	short soap_flag;
	a = (struct __tptz__GotoHomePosition *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GotoHomePosition, sizeof(struct __tptz__GotoHomePosition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GotoHomePosition(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GotoHomePosition && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__GotoHomePosition(soap, "tptz:GotoHomePosition", &a->tptz__GotoHomePosition, ""))
				{	soap_flag_tptz__GotoHomePosition--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GotoHomePosition(struct soap *soap, const struct __tptz__GotoHomePosition *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__GotoHomePosition(soap, tag?tag:"-tptz:GotoHomePosition", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GotoHomePosition * SOAP_FMAC4 soap_get___tptz__GotoHomePosition(struct soap *soap, struct __tptz__GotoHomePosition *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GotoHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__GotoHomePosition * SOAP_FMAC2 soap_instantiate___tptz__GotoHomePosition(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GotoHomePosition(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__GotoHomePosition, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__GotoHomePosition);
		if (size)
			*size = sizeof(struct __tptz__GotoHomePosition);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__GotoHomePosition, n);
		if (size)
			*size = n * sizeof(struct __tptz__GotoHomePosition);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__GotoHomePosition*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__GotoHomePosition(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__GotoHomePosition %p -> %p\n", q, p));
	*(struct __tptz__GotoHomePosition*)p = *(struct __tptz__GotoHomePosition*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetConfigurationOptions(struct soap *soap, struct __tptz__GetConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetConfigurationOptions(struct soap *soap, const struct __tptz__GetConfigurationOptions *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__GetConfigurationOptions(soap, &a->tptz__GetConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetConfigurationOptions(struct soap *soap, const char *tag, int id, const struct __tptz__GetConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__GetConfigurationOptions(soap, "tptz:GetConfigurationOptions", -1, &a->tptz__GetConfigurationOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetConfigurationOptions * SOAP_FMAC4 soap_in___tptz__GetConfigurationOptions(struct soap *soap, const char *tag, struct __tptz__GetConfigurationOptions *a, const char *type)
{
	size_t soap_flag_tptz__GetConfigurationOptions = 1;
	short soap_flag;
	a = (struct __tptz__GetConfigurationOptions *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetConfigurationOptions, sizeof(struct __tptz__GetConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetConfigurationOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__GetConfigurationOptions(soap, "tptz:GetConfigurationOptions", &a->tptz__GetConfigurationOptions, ""))
				{	soap_flag_tptz__GetConfigurationOptions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetConfigurationOptions(struct soap *soap, const struct __tptz__GetConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__GetConfigurationOptions(soap, tag?tag:"-tptz:GetConfigurationOptions", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetConfigurationOptions * SOAP_FMAC4 soap_get___tptz__GetConfigurationOptions(struct soap *soap, struct __tptz__GetConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__GetConfigurationOptions * SOAP_FMAC2 soap_instantiate___tptz__GetConfigurationOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetConfigurationOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__GetConfigurationOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__GetConfigurationOptions);
		if (size)
			*size = sizeof(struct __tptz__GetConfigurationOptions);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__GetConfigurationOptions, n);
		if (size)
			*size = n * sizeof(struct __tptz__GetConfigurationOptions);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__GetConfigurationOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__GetConfigurationOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__GetConfigurationOptions %p -> %p\n", q, p));
	*(struct __tptz__GetConfigurationOptions*)p = *(struct __tptz__GetConfigurationOptions*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__SetConfiguration(struct soap *soap, struct __tptz__SetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__SetConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__SetConfiguration(struct soap *soap, const struct __tptz__SetConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__SetConfiguration(soap, &a->tptz__SetConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__SetConfiguration(struct soap *soap, const char *tag, int id, const struct __tptz__SetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__SetConfiguration(soap, "tptz:SetConfiguration", -1, &a->tptz__SetConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetConfiguration * SOAP_FMAC4 soap_in___tptz__SetConfiguration(struct soap *soap, const char *tag, struct __tptz__SetConfiguration *a, const char *type)
{
	size_t soap_flag_tptz__SetConfiguration = 1;
	short soap_flag;
	a = (struct __tptz__SetConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__SetConfiguration, sizeof(struct __tptz__SetConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__SetConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__SetConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__SetConfiguration(soap, "tptz:SetConfiguration", &a->tptz__SetConfiguration, ""))
				{	soap_flag_tptz__SetConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__SetConfiguration(struct soap *soap, const struct __tptz__SetConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__SetConfiguration(soap, tag?tag:"-tptz:SetConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetConfiguration * SOAP_FMAC4 soap_get___tptz__SetConfiguration(struct soap *soap, struct __tptz__SetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__SetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__SetConfiguration * SOAP_FMAC2 soap_instantiate___tptz__SetConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__SetConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__SetConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__SetConfiguration);
		if (size)
			*size = sizeof(struct __tptz__SetConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__SetConfiguration, n);
		if (size)
			*size = n * sizeof(struct __tptz__SetConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__SetConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__SetConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__SetConfiguration %p -> %p\n", q, p));
	*(struct __tptz__SetConfiguration*)p = *(struct __tptz__SetConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetNode(struct soap *soap, struct __tptz__GetNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetNode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetNode(struct soap *soap, const struct __tptz__GetNode *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__GetNode(soap, &a->tptz__GetNode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetNode(struct soap *soap, const char *tag, int id, const struct __tptz__GetNode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__GetNode(soap, "tptz:GetNode", -1, &a->tptz__GetNode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetNode * SOAP_FMAC4 soap_in___tptz__GetNode(struct soap *soap, const char *tag, struct __tptz__GetNode *a, const char *type)
{
	size_t soap_flag_tptz__GetNode = 1;
	short soap_flag;
	a = (struct __tptz__GetNode *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetNode, sizeof(struct __tptz__GetNode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetNode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetNode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__GetNode(soap, "tptz:GetNode", &a->tptz__GetNode, ""))
				{	soap_flag_tptz__GetNode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetNode(struct soap *soap, const struct __tptz__GetNode *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__GetNode(soap, tag?tag:"-tptz:GetNode", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetNode * SOAP_FMAC4 soap_get___tptz__GetNode(struct soap *soap, struct __tptz__GetNode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__GetNode * SOAP_FMAC2 soap_instantiate___tptz__GetNode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetNode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__GetNode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__GetNode);
		if (size)
			*size = sizeof(struct __tptz__GetNode);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__GetNode, n);
		if (size)
			*size = n * sizeof(struct __tptz__GetNode);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__GetNode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__GetNode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__GetNode %p -> %p\n", q, p));
	*(struct __tptz__GetNode*)p = *(struct __tptz__GetNode*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetNodes(struct soap *soap, struct __tptz__GetNodes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetNodes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetNodes(struct soap *soap, const struct __tptz__GetNodes *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__GetNodes(soap, &a->tptz__GetNodes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetNodes(struct soap *soap, const char *tag, int id, const struct __tptz__GetNodes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__GetNodes(soap, "tptz:GetNodes", -1, &a->tptz__GetNodes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetNodes * SOAP_FMAC4 soap_in___tptz__GetNodes(struct soap *soap, const char *tag, struct __tptz__GetNodes *a, const char *type)
{
	size_t soap_flag_tptz__GetNodes = 1;
	short soap_flag;
	a = (struct __tptz__GetNodes *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetNodes, sizeof(struct __tptz__GetNodes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetNodes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetNodes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__GetNodes(soap, "tptz:GetNodes", &a->tptz__GetNodes, ""))
				{	soap_flag_tptz__GetNodes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetNodes(struct soap *soap, const struct __tptz__GetNodes *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__GetNodes(soap, tag?tag:"-tptz:GetNodes", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetNodes * SOAP_FMAC4 soap_get___tptz__GetNodes(struct soap *soap, struct __tptz__GetNodes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetNodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__GetNodes * SOAP_FMAC2 soap_instantiate___tptz__GetNodes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetNodes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__GetNodes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__GetNodes);
		if (size)
			*size = sizeof(struct __tptz__GetNodes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__GetNodes, n);
		if (size)
			*size = n * sizeof(struct __tptz__GetNodes);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__GetNodes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__GetNodes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__GetNodes %p -> %p\n", q, p));
	*(struct __tptz__GetNodes*)p = *(struct __tptz__GetNodes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetConfiguration(struct soap *soap, struct __tptz__GetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetConfiguration(struct soap *soap, const struct __tptz__GetConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__GetConfiguration(soap, &a->tptz__GetConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetConfiguration(struct soap *soap, const char *tag, int id, const struct __tptz__GetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__GetConfiguration(soap, "tptz:GetConfiguration", -1, &a->tptz__GetConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetConfiguration * SOAP_FMAC4 soap_in___tptz__GetConfiguration(struct soap *soap, const char *tag, struct __tptz__GetConfiguration *a, const char *type)
{
	size_t soap_flag_tptz__GetConfiguration = 1;
	short soap_flag;
	a = (struct __tptz__GetConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetConfiguration, sizeof(struct __tptz__GetConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__GetConfiguration(soap, "tptz:GetConfiguration", &a->tptz__GetConfiguration, ""))
				{	soap_flag_tptz__GetConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetConfiguration(struct soap *soap, const struct __tptz__GetConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__GetConfiguration(soap, tag?tag:"-tptz:GetConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetConfiguration * SOAP_FMAC4 soap_get___tptz__GetConfiguration(struct soap *soap, struct __tptz__GetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__GetConfiguration * SOAP_FMAC2 soap_instantiate___tptz__GetConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__GetConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__GetConfiguration);
		if (size)
			*size = sizeof(struct __tptz__GetConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__GetConfiguration, n);
		if (size)
			*size = n * sizeof(struct __tptz__GetConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__GetConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__GetConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__GetConfiguration %p -> %p\n", q, p));
	*(struct __tptz__GetConfiguration*)p = *(struct __tptz__GetConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetStatus(struct soap *soap, struct __tptz__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetStatus(struct soap *soap, const struct __tptz__GetStatus *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__GetStatus(soap, &a->tptz__GetStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetStatus(struct soap *soap, const char *tag, int id, const struct __tptz__GetStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__GetStatus(soap, "tptz:GetStatus", -1, &a->tptz__GetStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetStatus * SOAP_FMAC4 soap_in___tptz__GetStatus(struct soap *soap, const char *tag, struct __tptz__GetStatus *a, const char *type)
{
	size_t soap_flag_tptz__GetStatus = 1;
	short soap_flag;
	a = (struct __tptz__GetStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetStatus, sizeof(struct __tptz__GetStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__GetStatus(soap, "tptz:GetStatus", &a->tptz__GetStatus, ""))
				{	soap_flag_tptz__GetStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetStatus(struct soap *soap, const struct __tptz__GetStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__GetStatus(soap, tag?tag:"-tptz:GetStatus", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetStatus * SOAP_FMAC4 soap_get___tptz__GetStatus(struct soap *soap, struct __tptz__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__GetStatus * SOAP_FMAC2 soap_instantiate___tptz__GetStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__GetStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__GetStatus);
		if (size)
			*size = sizeof(struct __tptz__GetStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__GetStatus, n);
		if (size)
			*size = n * sizeof(struct __tptz__GetStatus);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__GetStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__GetStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__GetStatus %p -> %p\n", q, p));
	*(struct __tptz__GetStatus*)p = *(struct __tptz__GetStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GotoPreset(struct soap *soap, struct __tptz__GotoPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GotoPreset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GotoPreset(struct soap *soap, const struct __tptz__GotoPreset *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__GotoPreset(soap, &a->tptz__GotoPreset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GotoPreset(struct soap *soap, const char *tag, int id, const struct __tptz__GotoPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__GotoPreset(soap, "tptz:GotoPreset", -1, &a->tptz__GotoPreset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GotoPreset * SOAP_FMAC4 soap_in___tptz__GotoPreset(struct soap *soap, const char *tag, struct __tptz__GotoPreset *a, const char *type)
{
	size_t soap_flag_tptz__GotoPreset = 1;
	short soap_flag;
	a = (struct __tptz__GotoPreset *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GotoPreset, sizeof(struct __tptz__GotoPreset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GotoPreset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GotoPreset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__GotoPreset(soap, "tptz:GotoPreset", &a->tptz__GotoPreset, ""))
				{	soap_flag_tptz__GotoPreset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GotoPreset(struct soap *soap, const struct __tptz__GotoPreset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__GotoPreset(soap, tag?tag:"-tptz:GotoPreset", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GotoPreset * SOAP_FMAC4 soap_get___tptz__GotoPreset(struct soap *soap, struct __tptz__GotoPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GotoPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__GotoPreset * SOAP_FMAC2 soap_instantiate___tptz__GotoPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GotoPreset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__GotoPreset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__GotoPreset);
		if (size)
			*size = sizeof(struct __tptz__GotoPreset);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__GotoPreset, n);
		if (size)
			*size = n * sizeof(struct __tptz__GotoPreset);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__GotoPreset*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__GotoPreset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__GotoPreset %p -> %p\n", q, p));
	*(struct __tptz__GotoPreset*)p = *(struct __tptz__GotoPreset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__RemovePreset(struct soap *soap, struct __tptz__RemovePreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__RemovePreset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__RemovePreset(struct soap *soap, const struct __tptz__RemovePreset *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__RemovePreset(soap, &a->tptz__RemovePreset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__RemovePreset(struct soap *soap, const char *tag, int id, const struct __tptz__RemovePreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__RemovePreset(soap, "tptz:RemovePreset", -1, &a->tptz__RemovePreset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__RemovePreset * SOAP_FMAC4 soap_in___tptz__RemovePreset(struct soap *soap, const char *tag, struct __tptz__RemovePreset *a, const char *type)
{
	size_t soap_flag_tptz__RemovePreset = 1;
	short soap_flag;
	a = (struct __tptz__RemovePreset *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__RemovePreset, sizeof(struct __tptz__RemovePreset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__RemovePreset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__RemovePreset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__RemovePreset(soap, "tptz:RemovePreset", &a->tptz__RemovePreset, ""))
				{	soap_flag_tptz__RemovePreset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__RemovePreset(struct soap *soap, const struct __tptz__RemovePreset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__RemovePreset(soap, tag?tag:"-tptz:RemovePreset", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__RemovePreset * SOAP_FMAC4 soap_get___tptz__RemovePreset(struct soap *soap, struct __tptz__RemovePreset *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__RemovePreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__RemovePreset * SOAP_FMAC2 soap_instantiate___tptz__RemovePreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__RemovePreset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__RemovePreset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__RemovePreset);
		if (size)
			*size = sizeof(struct __tptz__RemovePreset);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__RemovePreset, n);
		if (size)
			*size = n * sizeof(struct __tptz__RemovePreset);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__RemovePreset*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__RemovePreset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__RemovePreset %p -> %p\n", q, p));
	*(struct __tptz__RemovePreset*)p = *(struct __tptz__RemovePreset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__SetPreset(struct soap *soap, struct __tptz__SetPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__SetPreset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__SetPreset(struct soap *soap, const struct __tptz__SetPreset *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__SetPreset(soap, &a->tptz__SetPreset);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__SetPreset(struct soap *soap, const char *tag, int id, const struct __tptz__SetPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__SetPreset(soap, "tptz:SetPreset", -1, &a->tptz__SetPreset, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetPreset * SOAP_FMAC4 soap_in___tptz__SetPreset(struct soap *soap, const char *tag, struct __tptz__SetPreset *a, const char *type)
{
	size_t soap_flag_tptz__SetPreset = 1;
	short soap_flag;
	a = (struct __tptz__SetPreset *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__SetPreset, sizeof(struct __tptz__SetPreset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__SetPreset(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__SetPreset && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__SetPreset(soap, "tptz:SetPreset", &a->tptz__SetPreset, ""))
				{	soap_flag_tptz__SetPreset--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__SetPreset(struct soap *soap, const struct __tptz__SetPreset *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__SetPreset(soap, tag?tag:"-tptz:SetPreset", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetPreset * SOAP_FMAC4 soap_get___tptz__SetPreset(struct soap *soap, struct __tptz__SetPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__SetPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__SetPreset * SOAP_FMAC2 soap_instantiate___tptz__SetPreset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__SetPreset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__SetPreset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__SetPreset);
		if (size)
			*size = sizeof(struct __tptz__SetPreset);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__SetPreset, n);
		if (size)
			*size = n * sizeof(struct __tptz__SetPreset);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__SetPreset*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__SetPreset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__SetPreset %p -> %p\n", q, p));
	*(struct __tptz__SetPreset*)p = *(struct __tptz__SetPreset*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetPresets(struct soap *soap, struct __tptz__GetPresets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetPresets = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetPresets(struct soap *soap, const struct __tptz__GetPresets *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__GetPresets(soap, &a->tptz__GetPresets);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetPresets(struct soap *soap, const char *tag, int id, const struct __tptz__GetPresets *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__GetPresets(soap, "tptz:GetPresets", -1, &a->tptz__GetPresets, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetPresets * SOAP_FMAC4 soap_in___tptz__GetPresets(struct soap *soap, const char *tag, struct __tptz__GetPresets *a, const char *type)
{
	size_t soap_flag_tptz__GetPresets = 1;
	short soap_flag;
	a = (struct __tptz__GetPresets *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetPresets, sizeof(struct __tptz__GetPresets), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetPresets(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetPresets && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__GetPresets(soap, "tptz:GetPresets", &a->tptz__GetPresets, ""))
				{	soap_flag_tptz__GetPresets--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetPresets(struct soap *soap, const struct __tptz__GetPresets *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__GetPresets(soap, tag?tag:"-tptz:GetPresets", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetPresets * SOAP_FMAC4 soap_get___tptz__GetPresets(struct soap *soap, struct __tptz__GetPresets *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetPresets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__GetPresets * SOAP_FMAC2 soap_instantiate___tptz__GetPresets(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetPresets(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__GetPresets, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__GetPresets);
		if (size)
			*size = sizeof(struct __tptz__GetPresets);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__GetPresets, n);
		if (size)
			*size = n * sizeof(struct __tptz__GetPresets);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__GetPresets*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__GetPresets(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__GetPresets %p -> %p\n", q, p));
	*(struct __tptz__GetPresets*)p = *(struct __tptz__GetPresets*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetConfigurations(struct soap *soap, struct __tptz__GetConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetConfigurations(struct soap *soap, const struct __tptz__GetConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__GetConfigurations(soap, &a->tptz__GetConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetConfigurations(struct soap *soap, const char *tag, int id, const struct __tptz__GetConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__GetConfigurations(soap, "tptz:GetConfigurations", -1, &a->tptz__GetConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetConfigurations * SOAP_FMAC4 soap_in___tptz__GetConfigurations(struct soap *soap, const char *tag, struct __tptz__GetConfigurations *a, const char *type)
{
	size_t soap_flag_tptz__GetConfigurations = 1;
	short soap_flag;
	a = (struct __tptz__GetConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetConfigurations, sizeof(struct __tptz__GetConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetConfigurations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__GetConfigurations(soap, "tptz:GetConfigurations", &a->tptz__GetConfigurations, ""))
				{	soap_flag_tptz__GetConfigurations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetConfigurations(struct soap *soap, const struct __tptz__GetConfigurations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__GetConfigurations(soap, tag?tag:"-tptz:GetConfigurations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetConfigurations * SOAP_FMAC4 soap_get___tptz__GetConfigurations(struct soap *soap, struct __tptz__GetConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__GetConfigurations * SOAP_FMAC2 soap_instantiate___tptz__GetConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetConfigurations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__GetConfigurations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__GetConfigurations);
		if (size)
			*size = sizeof(struct __tptz__GetConfigurations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__GetConfigurations, n);
		if (size)
			*size = n * sizeof(struct __tptz__GetConfigurations);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__GetConfigurations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__GetConfigurations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__GetConfigurations %p -> %p\n", q, p));
	*(struct __tptz__GetConfigurations*)p = *(struct __tptz__GetConfigurations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__GetServiceCapabilities(struct soap *soap, struct __tptz__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tptz__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__GetServiceCapabilities(struct soap *soap, const struct __tptz__GetServiceCapabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tptz__GetServiceCapabilities(soap, &a->tptz__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __tptz__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tptz__GetServiceCapabilities(soap, "tptz:GetServiceCapabilities", -1, &a->tptz__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetServiceCapabilities * SOAP_FMAC4 soap_in___tptz__GetServiceCapabilities(struct soap *soap, const char *tag, struct __tptz__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_tptz__GetServiceCapabilities = 1;
	short soap_flag;
	a = (struct __tptz__GetServiceCapabilities *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__GetServiceCapabilities, sizeof(struct __tptz__GetServiceCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tptz__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tptz__GetServiceCapabilities(soap, "tptz:GetServiceCapabilities", &a->tptz__GetServiceCapabilities, ""))
				{	soap_flag_tptz__GetServiceCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__GetServiceCapabilities(struct soap *soap, const struct __tptz__GetServiceCapabilities *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__GetServiceCapabilities(soap, tag?tag:"-tptz:GetServiceCapabilities", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__GetServiceCapabilities * SOAP_FMAC4 soap_get___tptz__GetServiceCapabilities(struct soap *soap, struct __tptz__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tptz__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tptz__GetServiceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tptz__GetServiceCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tptz__GetServiceCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tptz__GetServiceCapabilities);
		if (size)
			*size = sizeof(struct __tptz__GetServiceCapabilities);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tptz__GetServiceCapabilities, n);
		if (size)
			*size = n * sizeof(struct __tptz__GetServiceCapabilities);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tptz__GetServiceCapabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tptz__GetServiceCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tptz__GetServiceCapabilities %p -> %p\n", q, p));
	*(struct __tptz__GetServiceCapabilities*)p = *(struct __tptz__GetServiceCapabilities*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetMoveOptions(struct soap *soap, struct __timg__GetMoveOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetMoveOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetMoveOptions(struct soap *soap, const struct __timg__GetMoveOptions *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_timg__GetMoveOptions(soap, &a->timg__GetMoveOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetMoveOptions(struct soap *soap, const char *tag, int id, const struct __timg__GetMoveOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_timg__GetMoveOptions(soap, "timg:GetMoveOptions", -1, &a->timg__GetMoveOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetMoveOptions * SOAP_FMAC4 soap_in___timg__GetMoveOptions(struct soap *soap, const char *tag, struct __timg__GetMoveOptions *a, const char *type)
{
	size_t soap_flag_timg__GetMoveOptions = 1;
	short soap_flag;
	a = (struct __timg__GetMoveOptions *)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetMoveOptions, sizeof(struct __timg__GetMoveOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__GetMoveOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__GetMoveOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_timg__GetMoveOptions(soap, "timg:GetMoveOptions", &a->timg__GetMoveOptions, ""))
				{	soap_flag_timg__GetMoveOptions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetMoveOptions(struct soap *soap, const struct __timg__GetMoveOptions *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___timg__GetMoveOptions(soap, tag?tag:"-timg:GetMoveOptions", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetMoveOptions * SOAP_FMAC4 soap_get___timg__GetMoveOptions(struct soap *soap, struct __timg__GetMoveOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetMoveOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __timg__GetMoveOptions * SOAP_FMAC2 soap_instantiate___timg__GetMoveOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___timg__GetMoveOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___timg__GetMoveOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __timg__GetMoveOptions);
		if (size)
			*size = sizeof(struct __timg__GetMoveOptions);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __timg__GetMoveOptions, n);
		if (size)
			*size = n * sizeof(struct __timg__GetMoveOptions);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __timg__GetMoveOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___timg__GetMoveOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __timg__GetMoveOptions %p -> %p\n", q, p));
	*(struct __timg__GetMoveOptions*)p = *(struct __timg__GetMoveOptions*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetStatus(struct soap *soap, struct __timg__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetStatus(struct soap *soap, const struct __timg__GetStatus *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_timg__GetStatus(soap, &a->timg__GetStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetStatus(struct soap *soap, const char *tag, int id, const struct __timg__GetStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_timg__GetStatus(soap, "timg:GetStatus", -1, &a->timg__GetStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetStatus * SOAP_FMAC4 soap_in___timg__GetStatus(struct soap *soap, const char *tag, struct __timg__GetStatus *a, const char *type)
{
	size_t soap_flag_timg__GetStatus = 1;
	short soap_flag;
	a = (struct __timg__GetStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetStatus, sizeof(struct __timg__GetStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__GetStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__GetStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_timg__GetStatus(soap, "timg:GetStatus", &a->timg__GetStatus, ""))
				{	soap_flag_timg__GetStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetStatus(struct soap *soap, const struct __timg__GetStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___timg__GetStatus(soap, tag?tag:"-timg:GetStatus", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetStatus * SOAP_FMAC4 soap_get___timg__GetStatus(struct soap *soap, struct __timg__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __timg__GetStatus * SOAP_FMAC2 soap_instantiate___timg__GetStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___timg__GetStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___timg__GetStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __timg__GetStatus);
		if (size)
			*size = sizeof(struct __timg__GetStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __timg__GetStatus, n);
		if (size)
			*size = n * sizeof(struct __timg__GetStatus);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __timg__GetStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___timg__GetStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __timg__GetStatus %p -> %p\n", q, p));
	*(struct __timg__GetStatus*)p = *(struct __timg__GetStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__Stop(struct soap *soap, struct __timg__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__Stop = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__Stop(struct soap *soap, const struct __timg__Stop *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_timg__Stop(soap, &a->timg__Stop);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__Stop(struct soap *soap, const char *tag, int id, const struct __timg__Stop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_timg__Stop(soap, "timg:Stop", -1, &a->timg__Stop, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__Stop * SOAP_FMAC4 soap_in___timg__Stop(struct soap *soap, const char *tag, struct __timg__Stop *a, const char *type)
{
	size_t soap_flag_timg__Stop = 1;
	short soap_flag;
	a = (struct __timg__Stop *)soap_id_enter(soap, "", a, SOAP_TYPE___timg__Stop, sizeof(struct __timg__Stop), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__Stop(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__Stop && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_timg__Stop(soap, "timg:Stop", &a->timg__Stop, ""))
				{	soap_flag_timg__Stop--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__Stop(struct soap *soap, const struct __timg__Stop *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___timg__Stop(soap, tag?tag:"-timg:Stop", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__Stop * SOAP_FMAC4 soap_get___timg__Stop(struct soap *soap, struct __timg__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __timg__Stop * SOAP_FMAC2 soap_instantiate___timg__Stop(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___timg__Stop(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___timg__Stop, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __timg__Stop);
		if (size)
			*size = sizeof(struct __timg__Stop);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __timg__Stop, n);
		if (size)
			*size = n * sizeof(struct __timg__Stop);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __timg__Stop*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___timg__Stop(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __timg__Stop %p -> %p\n", q, p));
	*(struct __timg__Stop*)p = *(struct __timg__Stop*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__Move(struct soap *soap, struct __timg__Move *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__Move = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__Move(struct soap *soap, const struct __timg__Move *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_timg__Move(soap, &a->timg__Move);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__Move(struct soap *soap, const char *tag, int id, const struct __timg__Move *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_timg__Move(soap, "timg:Move", -1, &a->timg__Move, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__Move * SOAP_FMAC4 soap_in___timg__Move(struct soap *soap, const char *tag, struct __timg__Move *a, const char *type)
{
	size_t soap_flag_timg__Move = 1;
	short soap_flag;
	a = (struct __timg__Move *)soap_id_enter(soap, "", a, SOAP_TYPE___timg__Move, sizeof(struct __timg__Move), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__Move(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__Move && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_timg__Move(soap, "timg:Move", &a->timg__Move, ""))
				{	soap_flag_timg__Move--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__Move(struct soap *soap, const struct __timg__Move *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___timg__Move(soap, tag?tag:"-timg:Move", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__Move * SOAP_FMAC4 soap_get___timg__Move(struct soap *soap, struct __timg__Move *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__Move(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __timg__Move * SOAP_FMAC2 soap_instantiate___timg__Move(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___timg__Move(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___timg__Move, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __timg__Move);
		if (size)
			*size = sizeof(struct __timg__Move);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __timg__Move, n);
		if (size)
			*size = n * sizeof(struct __timg__Move);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __timg__Move*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___timg__Move(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __timg__Move %p -> %p\n", q, p));
	*(struct __timg__Move*)p = *(struct __timg__Move*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetOptions(struct soap *soap, struct __timg__GetOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetOptions(struct soap *soap, const struct __timg__GetOptions *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_timg__GetOptions(soap, &a->timg__GetOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetOptions(struct soap *soap, const char *tag, int id, const struct __timg__GetOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_timg__GetOptions(soap, "timg:GetOptions", -1, &a->timg__GetOptions, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetOptions * SOAP_FMAC4 soap_in___timg__GetOptions(struct soap *soap, const char *tag, struct __timg__GetOptions *a, const char *type)
{
	size_t soap_flag_timg__GetOptions = 1;
	short soap_flag;
	a = (struct __timg__GetOptions *)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetOptions, sizeof(struct __timg__GetOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__GetOptions(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__GetOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_timg__GetOptions(soap, "timg:GetOptions", &a->timg__GetOptions, ""))
				{	soap_flag_timg__GetOptions--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetOptions(struct soap *soap, const struct __timg__GetOptions *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___timg__GetOptions(soap, tag?tag:"-timg:GetOptions", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetOptions * SOAP_FMAC4 soap_get___timg__GetOptions(struct soap *soap, struct __timg__GetOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __timg__GetOptions * SOAP_FMAC2 soap_instantiate___timg__GetOptions(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___timg__GetOptions(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___timg__GetOptions, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __timg__GetOptions);
		if (size)
			*size = sizeof(struct __timg__GetOptions);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __timg__GetOptions, n);
		if (size)
			*size = n * sizeof(struct __timg__GetOptions);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __timg__GetOptions*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___timg__GetOptions(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __timg__GetOptions %p -> %p\n", q, p));
	*(struct __timg__GetOptions*)p = *(struct __timg__GetOptions*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__SetImagingSettings(struct soap *soap, struct __timg__SetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__SetImagingSettings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__SetImagingSettings(struct soap *soap, const struct __timg__SetImagingSettings *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_timg__SetImagingSettings(soap, &a->timg__SetImagingSettings);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__SetImagingSettings(struct soap *soap, const char *tag, int id, const struct __timg__SetImagingSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_timg__SetImagingSettings(soap, "timg:SetImagingSettings", -1, &a->timg__SetImagingSettings, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__SetImagingSettings * SOAP_FMAC4 soap_in___timg__SetImagingSettings(struct soap *soap, const char *tag, struct __timg__SetImagingSettings *a, const char *type)
{
	size_t soap_flag_timg__SetImagingSettings = 1;
	short soap_flag;
	a = (struct __timg__SetImagingSettings *)soap_id_enter(soap, "", a, SOAP_TYPE___timg__SetImagingSettings, sizeof(struct __timg__SetImagingSettings), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__SetImagingSettings(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__SetImagingSettings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_timg__SetImagingSettings(soap, "timg:SetImagingSettings", &a->timg__SetImagingSettings, ""))
				{	soap_flag_timg__SetImagingSettings--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__SetImagingSettings(struct soap *soap, const struct __timg__SetImagingSettings *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___timg__SetImagingSettings(soap, tag?tag:"-timg:SetImagingSettings", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__SetImagingSettings * SOAP_FMAC4 soap_get___timg__SetImagingSettings(struct soap *soap, struct __timg__SetImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__SetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __timg__SetImagingSettings * SOAP_FMAC2 soap_instantiate___timg__SetImagingSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___timg__SetImagingSettings(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___timg__SetImagingSettings, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __timg__SetImagingSettings);
		if (size)
			*size = sizeof(struct __timg__SetImagingSettings);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __timg__SetImagingSettings, n);
		if (size)
			*size = n * sizeof(struct __timg__SetImagingSettings);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __timg__SetImagingSettings*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___timg__SetImagingSettings(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __timg__SetImagingSettings %p -> %p\n", q, p));
	*(struct __timg__SetImagingSettings*)p = *(struct __timg__SetImagingSettings*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetImagingSettings(struct soap *soap, struct __timg__GetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetImagingSettings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetImagingSettings(struct soap *soap, const struct __timg__GetImagingSettings *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_timg__GetImagingSettings(soap, &a->timg__GetImagingSettings);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetImagingSettings(struct soap *soap, const char *tag, int id, const struct __timg__GetImagingSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_timg__GetImagingSettings(soap, "timg:GetImagingSettings", -1, &a->timg__GetImagingSettings, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetImagingSettings * SOAP_FMAC4 soap_in___timg__GetImagingSettings(struct soap *soap, const char *tag, struct __timg__GetImagingSettings *a, const char *type)
{
	size_t soap_flag_timg__GetImagingSettings = 1;
	short soap_flag;
	a = (struct __timg__GetImagingSettings *)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetImagingSettings, sizeof(struct __timg__GetImagingSettings), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__GetImagingSettings(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__GetImagingSettings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_timg__GetImagingSettings(soap, "timg:GetImagingSettings", &a->timg__GetImagingSettings, ""))
				{	soap_flag_timg__GetImagingSettings--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetImagingSettings(struct soap *soap, const struct __timg__GetImagingSettings *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___timg__GetImagingSettings(soap, tag?tag:"-timg:GetImagingSettings", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetImagingSettings * SOAP_FMAC4 soap_get___timg__GetImagingSettings(struct soap *soap, struct __timg__GetImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __timg__GetImagingSettings * SOAP_FMAC2 soap_instantiate___timg__GetImagingSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___timg__GetImagingSettings(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___timg__GetImagingSettings, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __timg__GetImagingSettings);
		if (size)
			*size = sizeof(struct __timg__GetImagingSettings);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __timg__GetImagingSettings, n);
		if (size)
			*size = n * sizeof(struct __timg__GetImagingSettings);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __timg__GetImagingSettings*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___timg__GetImagingSettings(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __timg__GetImagingSettings %p -> %p\n", q, p));
	*(struct __timg__GetImagingSettings*)p = *(struct __timg__GetImagingSettings*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___timg__GetServiceCapabilities(struct soap *soap, struct __timg__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->timg__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___timg__GetServiceCapabilities(struct soap *soap, const struct __timg__GetServiceCapabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_timg__GetServiceCapabilities(soap, &a->timg__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___timg__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __timg__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_timg__GetServiceCapabilities(soap, "timg:GetServiceCapabilities", -1, &a->timg__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetServiceCapabilities * SOAP_FMAC4 soap_in___timg__GetServiceCapabilities(struct soap *soap, const char *tag, struct __timg__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_timg__GetServiceCapabilities = 1;
	short soap_flag;
	a = (struct __timg__GetServiceCapabilities *)soap_id_enter(soap, "", a, SOAP_TYPE___timg__GetServiceCapabilities, sizeof(struct __timg__GetServiceCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___timg__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_timg__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_timg__GetServiceCapabilities(soap, "timg:GetServiceCapabilities", &a->timg__GetServiceCapabilities, ""))
				{	soap_flag_timg__GetServiceCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___timg__GetServiceCapabilities(struct soap *soap, const struct __timg__GetServiceCapabilities *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___timg__GetServiceCapabilities(soap, tag?tag:"-timg:GetServiceCapabilities", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __timg__GetServiceCapabilities * SOAP_FMAC4 soap_get___timg__GetServiceCapabilities(struct soap *soap, struct __timg__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___timg__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __timg__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___timg__GetServiceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___timg__GetServiceCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___timg__GetServiceCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __timg__GetServiceCapabilities);
		if (size)
			*size = sizeof(struct __timg__GetServiceCapabilities);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __timg__GetServiceCapabilities, n);
		if (size)
			*size = n * sizeof(struct __timg__GetServiceCapabilities);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __timg__GetServiceCapabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___timg__GetServiceCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __timg__GetServiceCapabilities %p -> %p\n", q, p));
	*(struct __timg__GetServiceCapabilities*)p = *(struct __timg__GetServiceCapabilities*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__StartSystemRestore(struct soap *soap, struct __tds__StartSystemRestore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__StartSystemRestore = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__StartSystemRestore(struct soap *soap, const struct __tds__StartSystemRestore *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__StartSystemRestore(soap, &a->tds__StartSystemRestore);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__StartSystemRestore(struct soap *soap, const char *tag, int id, const struct __tds__StartSystemRestore *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__StartSystemRestore(soap, "tds:StartSystemRestore", -1, &a->tds__StartSystemRestore, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__StartSystemRestore * SOAP_FMAC4 soap_in___tds__StartSystemRestore(struct soap *soap, const char *tag, struct __tds__StartSystemRestore *a, const char *type)
{
	size_t soap_flag_tds__StartSystemRestore = 1;
	short soap_flag;
	a = (struct __tds__StartSystemRestore *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__StartSystemRestore, sizeof(struct __tds__StartSystemRestore), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__StartSystemRestore(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__StartSystemRestore && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__StartSystemRestore(soap, "tds:StartSystemRestore", &a->tds__StartSystemRestore, ""))
				{	soap_flag_tds__StartSystemRestore--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__StartSystemRestore(struct soap *soap, const struct __tds__StartSystemRestore *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__StartSystemRestore(soap, tag?tag:"-tds:StartSystemRestore", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__StartSystemRestore * SOAP_FMAC4 soap_get___tds__StartSystemRestore(struct soap *soap, struct __tds__StartSystemRestore *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__StartSystemRestore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__StartSystemRestore * SOAP_FMAC2 soap_instantiate___tds__StartSystemRestore(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__StartSystemRestore(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__StartSystemRestore, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__StartSystemRestore);
		if (size)
			*size = sizeof(struct __tds__StartSystemRestore);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__StartSystemRestore, n);
		if (size)
			*size = n * sizeof(struct __tds__StartSystemRestore);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__StartSystemRestore*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__StartSystemRestore(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__StartSystemRestore %p -> %p\n", q, p));
	*(struct __tds__StartSystemRestore*)p = *(struct __tds__StartSystemRestore*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__StartFirmwareUpgrade(struct soap *soap, struct __tds__StartFirmwareUpgrade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__StartFirmwareUpgrade = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__StartFirmwareUpgrade(struct soap *soap, const struct __tds__StartFirmwareUpgrade *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__StartFirmwareUpgrade(soap, &a->tds__StartFirmwareUpgrade);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, int id, const struct __tds__StartFirmwareUpgrade *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__StartFirmwareUpgrade(soap, "tds:StartFirmwareUpgrade", -1, &a->tds__StartFirmwareUpgrade, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_in___tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, struct __tds__StartFirmwareUpgrade *a, const char *type)
{
	size_t soap_flag_tds__StartFirmwareUpgrade = 1;
	short soap_flag;
	a = (struct __tds__StartFirmwareUpgrade *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__StartFirmwareUpgrade, sizeof(struct __tds__StartFirmwareUpgrade), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__StartFirmwareUpgrade(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__StartFirmwareUpgrade && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__StartFirmwareUpgrade(soap, "tds:StartFirmwareUpgrade", &a->tds__StartFirmwareUpgrade, ""))
				{	soap_flag_tds__StartFirmwareUpgrade--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__StartFirmwareUpgrade(struct soap *soap, const struct __tds__StartFirmwareUpgrade *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__StartFirmwareUpgrade(soap, tag?tag:"-tds:StartFirmwareUpgrade", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_get___tds__StartFirmwareUpgrade(struct soap *soap, struct __tds__StartFirmwareUpgrade *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__StartFirmwareUpgrade(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__StartFirmwareUpgrade * SOAP_FMAC2 soap_instantiate___tds__StartFirmwareUpgrade(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__StartFirmwareUpgrade(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__StartFirmwareUpgrade, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__StartFirmwareUpgrade);
		if (size)
			*size = sizeof(struct __tds__StartFirmwareUpgrade);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__StartFirmwareUpgrade, n);
		if (size)
			*size = n * sizeof(struct __tds__StartFirmwareUpgrade);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__StartFirmwareUpgrade*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__StartFirmwareUpgrade(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__StartFirmwareUpgrade %p -> %p\n", q, p));
	*(struct __tds__StartFirmwareUpgrade*)p = *(struct __tds__StartFirmwareUpgrade*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemUris(struct soap *soap, struct __tds__GetSystemUris *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemUris = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemUris(struct soap *soap, const struct __tds__GetSystemUris *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetSystemUris(soap, &a->tds__GetSystemUris);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemUris(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemUris *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetSystemUris(soap, "tds:GetSystemUris", -1, &a->tds__GetSystemUris, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemUris * SOAP_FMAC4 soap_in___tds__GetSystemUris(struct soap *soap, const char *tag, struct __tds__GetSystemUris *a, const char *type)
{
	size_t soap_flag_tds__GetSystemUris = 1;
	short soap_flag;
	a = (struct __tds__GetSystemUris *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemUris, sizeof(struct __tds__GetSystemUris), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemUris(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemUris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetSystemUris(soap, "tds:GetSystemUris", &a->tds__GetSystemUris, ""))
				{	soap_flag_tds__GetSystemUris--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemUris(struct soap *soap, const struct __tds__GetSystemUris *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetSystemUris(soap, tag?tag:"-tds:GetSystemUris", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemUris * SOAP_FMAC4 soap_get___tds__GetSystemUris(struct soap *soap, struct __tds__GetSystemUris *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemUris(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetSystemUris * SOAP_FMAC2 soap_instantiate___tds__GetSystemUris(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetSystemUris(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetSystemUris, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetSystemUris);
		if (size)
			*size = sizeof(struct __tds__GetSystemUris);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetSystemUris, n);
		if (size)
			*size = n * sizeof(struct __tds__GetSystemUris);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetSystemUris*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetSystemUris(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetSystemUris %p -> %p\n", q, p));
	*(struct __tds__GetSystemUris*)p = *(struct __tds__GetSystemUris*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__ScanAvailableDot11Networks(struct soap *soap, struct __tds__ScanAvailableDot11Networks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__ScanAvailableDot11Networks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__ScanAvailableDot11Networks(struct soap *soap, const struct __tds__ScanAvailableDot11Networks *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__ScanAvailableDot11Networks(soap, &a->tds__ScanAvailableDot11Networks);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, int id, const struct __tds__ScanAvailableDot11Networks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__ScanAvailableDot11Networks(soap, "tds:ScanAvailableDot11Networks", -1, &a->tds__ScanAvailableDot11Networks, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_in___tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, struct __tds__ScanAvailableDot11Networks *a, const char *type)
{
	size_t soap_flag_tds__ScanAvailableDot11Networks = 1;
	short soap_flag;
	a = (struct __tds__ScanAvailableDot11Networks *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__ScanAvailableDot11Networks, sizeof(struct __tds__ScanAvailableDot11Networks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__ScanAvailableDot11Networks(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__ScanAvailableDot11Networks && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__ScanAvailableDot11Networks(soap, "tds:ScanAvailableDot11Networks", &a->tds__ScanAvailableDot11Networks, ""))
				{	soap_flag_tds__ScanAvailableDot11Networks--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__ScanAvailableDot11Networks(struct soap *soap, const struct __tds__ScanAvailableDot11Networks *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__ScanAvailableDot11Networks(soap, tag?tag:"-tds:ScanAvailableDot11Networks", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_get___tds__ScanAvailableDot11Networks(struct soap *soap, struct __tds__ScanAvailableDot11Networks *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__ScanAvailableDot11Networks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__ScanAvailableDot11Networks * SOAP_FMAC2 soap_instantiate___tds__ScanAvailableDot11Networks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__ScanAvailableDot11Networks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__ScanAvailableDot11Networks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__ScanAvailableDot11Networks);
		if (size)
			*size = sizeof(struct __tds__ScanAvailableDot11Networks);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__ScanAvailableDot11Networks, n);
		if (size)
			*size = n * sizeof(struct __tds__ScanAvailableDot11Networks);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__ScanAvailableDot11Networks*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__ScanAvailableDot11Networks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__ScanAvailableDot11Networks %p -> %p\n", q, p));
	*(struct __tds__ScanAvailableDot11Networks*)p = *(struct __tds__ScanAvailableDot11Networks*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDot11Status(struct soap *soap, struct __tds__GetDot11Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDot11Status = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDot11Status(struct soap *soap, const struct __tds__GetDot11Status *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetDot11Status(soap, &a->tds__GetDot11Status);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDot11Status(struct soap *soap, const char *tag, int id, const struct __tds__GetDot11Status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetDot11Status(soap, "tds:GetDot11Status", -1, &a->tds__GetDot11Status, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot11Status * SOAP_FMAC4 soap_in___tds__GetDot11Status(struct soap *soap, const char *tag, struct __tds__GetDot11Status *a, const char *type)
{
	size_t soap_flag_tds__GetDot11Status = 1;
	short soap_flag;
	a = (struct __tds__GetDot11Status *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDot11Status, sizeof(struct __tds__GetDot11Status), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDot11Status(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDot11Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetDot11Status(soap, "tds:GetDot11Status", &a->tds__GetDot11Status, ""))
				{	soap_flag_tds__GetDot11Status--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDot11Status(struct soap *soap, const struct __tds__GetDot11Status *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetDot11Status(soap, tag?tag:"-tds:GetDot11Status", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot11Status * SOAP_FMAC4 soap_get___tds__GetDot11Status(struct soap *soap, struct __tds__GetDot11Status *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetDot11Status * SOAP_FMAC2 soap_instantiate___tds__GetDot11Status(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDot11Status(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetDot11Status, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetDot11Status);
		if (size)
			*size = sizeof(struct __tds__GetDot11Status);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetDot11Status, n);
		if (size)
			*size = n * sizeof(struct __tds__GetDot11Status);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetDot11Status*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetDot11Status(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetDot11Status %p -> %p\n", q, p));
	*(struct __tds__GetDot11Status*)p = *(struct __tds__GetDot11Status*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDot11Capabilities(struct soap *soap, struct __tds__GetDot11Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDot11Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDot11Capabilities(struct soap *soap, const struct __tds__GetDot11Capabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetDot11Capabilities(soap, &a->tds__GetDot11Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDot11Capabilities(struct soap *soap, const char *tag, int id, const struct __tds__GetDot11Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetDot11Capabilities(soap, "tds:GetDot11Capabilities", -1, &a->tds__GetDot11Capabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot11Capabilities * SOAP_FMAC4 soap_in___tds__GetDot11Capabilities(struct soap *soap, const char *tag, struct __tds__GetDot11Capabilities *a, const char *type)
{
	size_t soap_flag_tds__GetDot11Capabilities = 1;
	short soap_flag;
	a = (struct __tds__GetDot11Capabilities *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDot11Capabilities, sizeof(struct __tds__GetDot11Capabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDot11Capabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDot11Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetDot11Capabilities(soap, "tds:GetDot11Capabilities", &a->tds__GetDot11Capabilities, ""))
				{	soap_flag_tds__GetDot11Capabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDot11Capabilities(struct soap *soap, const struct __tds__GetDot11Capabilities *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetDot11Capabilities(soap, tag?tag:"-tds:GetDot11Capabilities", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot11Capabilities * SOAP_FMAC4 soap_get___tds__GetDot11Capabilities(struct soap *soap, struct __tds__GetDot11Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetDot11Capabilities * SOAP_FMAC2 soap_instantiate___tds__GetDot11Capabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDot11Capabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetDot11Capabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetDot11Capabilities);
		if (size)
			*size = sizeof(struct __tds__GetDot11Capabilities);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetDot11Capabilities, n);
		if (size)
			*size = n * sizeof(struct __tds__GetDot11Capabilities);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetDot11Capabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetDot11Capabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetDot11Capabilities %p -> %p\n", q, p));
	*(struct __tds__GetDot11Capabilities*)p = *(struct __tds__GetDot11Capabilities*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__DeleteDot1XConfiguration(struct soap *soap, struct __tds__DeleteDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__DeleteDot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__DeleteDot1XConfiguration(struct soap *soap, const struct __tds__DeleteDot1XConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__DeleteDot1XConfiguration(soap, &a->tds__DeleteDot1XConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__DeleteDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__DeleteDot1XConfiguration(soap, "tds:DeleteDot1XConfiguration", -1, &a->tds__DeleteDot1XConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_in___tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, struct __tds__DeleteDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_tds__DeleteDot1XConfiguration = 1;
	short soap_flag;
	a = (struct __tds__DeleteDot1XConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__DeleteDot1XConfiguration, sizeof(struct __tds__DeleteDot1XConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__DeleteDot1XConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__DeleteDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__DeleteDot1XConfiguration(soap, "tds:DeleteDot1XConfiguration", &a->tds__DeleteDot1XConfiguration, ""))
				{	soap_flag_tds__DeleteDot1XConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__DeleteDot1XConfiguration(struct soap *soap, const struct __tds__DeleteDot1XConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__DeleteDot1XConfiguration(soap, tag?tag:"-tds:DeleteDot1XConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_get___tds__DeleteDot1XConfiguration(struct soap *soap, struct __tds__DeleteDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__DeleteDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__DeleteDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__DeleteDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__DeleteDot1XConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__DeleteDot1XConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__DeleteDot1XConfiguration);
		if (size)
			*size = sizeof(struct __tds__DeleteDot1XConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__DeleteDot1XConfiguration, n);
		if (size)
			*size = n * sizeof(struct __tds__DeleteDot1XConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__DeleteDot1XConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__DeleteDot1XConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__DeleteDot1XConfiguration %p -> %p\n", q, p));
	*(struct __tds__DeleteDot1XConfiguration*)p = *(struct __tds__DeleteDot1XConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDot1XConfigurations(struct soap *soap, struct __tds__GetDot1XConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDot1XConfigurations = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDot1XConfigurations(struct soap *soap, const struct __tds__GetDot1XConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetDot1XConfigurations(soap, &a->tds__GetDot1XConfigurations);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDot1XConfigurations(struct soap *soap, const char *tag, int id, const struct __tds__GetDot1XConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetDot1XConfigurations(soap, "tds:GetDot1XConfigurations", -1, &a->tds__GetDot1XConfigurations, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot1XConfigurations * SOAP_FMAC4 soap_in___tds__GetDot1XConfigurations(struct soap *soap, const char *tag, struct __tds__GetDot1XConfigurations *a, const char *type)
{
	size_t soap_flag_tds__GetDot1XConfigurations = 1;
	short soap_flag;
	a = (struct __tds__GetDot1XConfigurations *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDot1XConfigurations, sizeof(struct __tds__GetDot1XConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDot1XConfigurations(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDot1XConfigurations && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetDot1XConfigurations(soap, "tds:GetDot1XConfigurations", &a->tds__GetDot1XConfigurations, ""))
				{	soap_flag_tds__GetDot1XConfigurations--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDot1XConfigurations(struct soap *soap, const struct __tds__GetDot1XConfigurations *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetDot1XConfigurations(soap, tag?tag:"-tds:GetDot1XConfigurations", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot1XConfigurations * SOAP_FMAC4 soap_get___tds__GetDot1XConfigurations(struct soap *soap, struct __tds__GetDot1XConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDot1XConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetDot1XConfigurations * SOAP_FMAC2 soap_instantiate___tds__GetDot1XConfigurations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDot1XConfigurations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetDot1XConfigurations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetDot1XConfigurations);
		if (size)
			*size = sizeof(struct __tds__GetDot1XConfigurations);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetDot1XConfigurations, n);
		if (size)
			*size = n * sizeof(struct __tds__GetDot1XConfigurations);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetDot1XConfigurations*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetDot1XConfigurations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetDot1XConfigurations %p -> %p\n", q, p));
	*(struct __tds__GetDot1XConfigurations*)p = *(struct __tds__GetDot1XConfigurations*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDot1XConfiguration(struct soap *soap, struct __tds__GetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDot1XConfiguration(struct soap *soap, const struct __tds__GetDot1XConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetDot1XConfiguration(soap, &a->tds__GetDot1XConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__GetDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetDot1XConfiguration(soap, "tds:GetDot1XConfiguration", -1, &a->tds__GetDot1XConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot1XConfiguration * SOAP_FMAC4 soap_in___tds__GetDot1XConfiguration(struct soap *soap, const char *tag, struct __tds__GetDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_tds__GetDot1XConfiguration = 1;
	short soap_flag;
	a = (struct __tds__GetDot1XConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDot1XConfiguration, sizeof(struct __tds__GetDot1XConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDot1XConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetDot1XConfiguration(soap, "tds:GetDot1XConfiguration", &a->tds__GetDot1XConfiguration, ""))
				{	soap_flag_tds__GetDot1XConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDot1XConfiguration(struct soap *soap, const struct __tds__GetDot1XConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetDot1XConfiguration(soap, tag?tag:"-tds:GetDot1XConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDot1XConfiguration * SOAP_FMAC4 soap_get___tds__GetDot1XConfiguration(struct soap *soap, struct __tds__GetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDot1XConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetDot1XConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetDot1XConfiguration);
		if (size)
			*size = sizeof(struct __tds__GetDot1XConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetDot1XConfiguration, n);
		if (size)
			*size = n * sizeof(struct __tds__GetDot1XConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetDot1XConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetDot1XConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetDot1XConfiguration %p -> %p\n", q, p));
	*(struct __tds__GetDot1XConfiguration*)p = *(struct __tds__GetDot1XConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDot1XConfiguration(struct soap *soap, struct __tds__SetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDot1XConfiguration(struct soap *soap, const struct __tds__SetDot1XConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetDot1XConfiguration(soap, &a->tds__SetDot1XConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__SetDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetDot1XConfiguration(soap, "tds:SetDot1XConfiguration", -1, &a->tds__SetDot1XConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDot1XConfiguration * SOAP_FMAC4 soap_in___tds__SetDot1XConfiguration(struct soap *soap, const char *tag, struct __tds__SetDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_tds__SetDot1XConfiguration = 1;
	short soap_flag;
	a = (struct __tds__SetDot1XConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDot1XConfiguration, sizeof(struct __tds__SetDot1XConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDot1XConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetDot1XConfiguration(soap, "tds:SetDot1XConfiguration", &a->tds__SetDot1XConfiguration, ""))
				{	soap_flag_tds__SetDot1XConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDot1XConfiguration(struct soap *soap, const struct __tds__SetDot1XConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetDot1XConfiguration(soap, tag?tag:"-tds:SetDot1XConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDot1XConfiguration * SOAP_FMAC4 soap_get___tds__SetDot1XConfiguration(struct soap *soap, struct __tds__SetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetDot1XConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetDot1XConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetDot1XConfiguration);
		if (size)
			*size = sizeof(struct __tds__SetDot1XConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetDot1XConfiguration, n);
		if (size)
			*size = n * sizeof(struct __tds__SetDot1XConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetDot1XConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetDot1XConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetDot1XConfiguration %p -> %p\n", q, p));
	*(struct __tds__SetDot1XConfiguration*)p = *(struct __tds__SetDot1XConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__CreateDot1XConfiguration(struct soap *soap, struct __tds__CreateDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__CreateDot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__CreateDot1XConfiguration(struct soap *soap, const struct __tds__CreateDot1XConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__CreateDot1XConfiguration(soap, &a->tds__CreateDot1XConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__CreateDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__CreateDot1XConfiguration(soap, "tds:CreateDot1XConfiguration", -1, &a->tds__CreateDot1XConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_in___tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, struct __tds__CreateDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_tds__CreateDot1XConfiguration = 1;
	short soap_flag;
	a = (struct __tds__CreateDot1XConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__CreateDot1XConfiguration, sizeof(struct __tds__CreateDot1XConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__CreateDot1XConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__CreateDot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__CreateDot1XConfiguration(soap, "tds:CreateDot1XConfiguration", &a->tds__CreateDot1XConfiguration, ""))
				{	soap_flag_tds__CreateDot1XConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__CreateDot1XConfiguration(struct soap *soap, const struct __tds__CreateDot1XConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__CreateDot1XConfiguration(soap, tag?tag:"-tds:CreateDot1XConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_get___tds__CreateDot1XConfiguration(struct soap *soap, struct __tds__CreateDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__CreateDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__CreateDot1XConfiguration * SOAP_FMAC2 soap_instantiate___tds__CreateDot1XConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__CreateDot1XConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__CreateDot1XConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__CreateDot1XConfiguration);
		if (size)
			*size = sizeof(struct __tds__CreateDot1XConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__CreateDot1XConfiguration, n);
		if (size)
			*size = n * sizeof(struct __tds__CreateDot1XConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__CreateDot1XConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__CreateDot1XConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__CreateDot1XConfiguration %p -> %p\n", q, p));
	*(struct __tds__CreateDot1XConfiguration*)p = *(struct __tds__CreateDot1XConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__LoadCACertificates(struct soap *soap, struct __tds__LoadCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__LoadCACertificates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__LoadCACertificates(struct soap *soap, const struct __tds__LoadCACertificates *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__LoadCACertificates(soap, &a->tds__LoadCACertificates);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__LoadCACertificates(struct soap *soap, const char *tag, int id, const struct __tds__LoadCACertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__LoadCACertificates(soap, "tds:LoadCACertificates", -1, &a->tds__LoadCACertificates, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__LoadCACertificates * SOAP_FMAC4 soap_in___tds__LoadCACertificates(struct soap *soap, const char *tag, struct __tds__LoadCACertificates *a, const char *type)
{
	size_t soap_flag_tds__LoadCACertificates = 1;
	short soap_flag;
	a = (struct __tds__LoadCACertificates *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__LoadCACertificates, sizeof(struct __tds__LoadCACertificates), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__LoadCACertificates(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__LoadCACertificates && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__LoadCACertificates(soap, "tds:LoadCACertificates", &a->tds__LoadCACertificates, ""))
				{	soap_flag_tds__LoadCACertificates--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__LoadCACertificates(struct soap *soap, const struct __tds__LoadCACertificates *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__LoadCACertificates(soap, tag?tag:"-tds:LoadCACertificates", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__LoadCACertificates * SOAP_FMAC4 soap_get___tds__LoadCACertificates(struct soap *soap, struct __tds__LoadCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__LoadCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__LoadCACertificates * SOAP_FMAC2 soap_instantiate___tds__LoadCACertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__LoadCACertificates(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__LoadCACertificates, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__LoadCACertificates);
		if (size)
			*size = sizeof(struct __tds__LoadCACertificates);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__LoadCACertificates, n);
		if (size)
			*size = n * sizeof(struct __tds__LoadCACertificates);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__LoadCACertificates*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__LoadCACertificates(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__LoadCACertificates %p -> %p\n", q, p));
	*(struct __tds__LoadCACertificates*)p = *(struct __tds__LoadCACertificates*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetCertificateInformation(struct soap *soap, struct __tds__GetCertificateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetCertificateInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetCertificateInformation(struct soap *soap, const struct __tds__GetCertificateInformation *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetCertificateInformation(soap, &a->tds__GetCertificateInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetCertificateInformation(struct soap *soap, const char *tag, int id, const struct __tds__GetCertificateInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetCertificateInformation(soap, "tds:GetCertificateInformation", -1, &a->tds__GetCertificateInformation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCertificateInformation * SOAP_FMAC4 soap_in___tds__GetCertificateInformation(struct soap *soap, const char *tag, struct __tds__GetCertificateInformation *a, const char *type)
{
	size_t soap_flag_tds__GetCertificateInformation = 1;
	short soap_flag;
	a = (struct __tds__GetCertificateInformation *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetCertificateInformation, sizeof(struct __tds__GetCertificateInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetCertificateInformation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetCertificateInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetCertificateInformation(soap, "tds:GetCertificateInformation", &a->tds__GetCertificateInformation, ""))
				{	soap_flag_tds__GetCertificateInformation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetCertificateInformation(struct soap *soap, const struct __tds__GetCertificateInformation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetCertificateInformation(soap, tag?tag:"-tds:GetCertificateInformation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCertificateInformation * SOAP_FMAC4 soap_get___tds__GetCertificateInformation(struct soap *soap, struct __tds__GetCertificateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetCertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetCertificateInformation * SOAP_FMAC2 soap_instantiate___tds__GetCertificateInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetCertificateInformation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetCertificateInformation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetCertificateInformation);
		if (size)
			*size = sizeof(struct __tds__GetCertificateInformation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetCertificateInformation, n);
		if (size)
			*size = n * sizeof(struct __tds__GetCertificateInformation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetCertificateInformation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetCertificateInformation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetCertificateInformation %p -> %p\n", q, p));
	*(struct __tds__GetCertificateInformation*)p = *(struct __tds__GetCertificateInformation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__LoadCertificateWithPrivateKey(struct soap *soap, struct __tds__LoadCertificateWithPrivateKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__LoadCertificateWithPrivateKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__LoadCertificateWithPrivateKey(struct soap *soap, const struct __tds__LoadCertificateWithPrivateKey *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__LoadCertificateWithPrivateKey(soap, &a->tds__LoadCertificateWithPrivateKey);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const struct __tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__LoadCertificateWithPrivateKey(soap, "tds:LoadCertificateWithPrivateKey", -1, &a->tds__LoadCertificateWithPrivateKey, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_in___tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, struct __tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	size_t soap_flag_tds__LoadCertificateWithPrivateKey = 1;
	short soap_flag;
	a = (struct __tds__LoadCertificateWithPrivateKey *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__LoadCertificateWithPrivateKey, sizeof(struct __tds__LoadCertificateWithPrivateKey), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__LoadCertificateWithPrivateKey(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__LoadCertificateWithPrivateKey && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__LoadCertificateWithPrivateKey(soap, "tds:LoadCertificateWithPrivateKey", &a->tds__LoadCertificateWithPrivateKey, ""))
				{	soap_flag_tds__LoadCertificateWithPrivateKey--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__LoadCertificateWithPrivateKey(struct soap *soap, const struct __tds__LoadCertificateWithPrivateKey *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__LoadCertificateWithPrivateKey(soap, tag?tag:"-tds:LoadCertificateWithPrivateKey", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_get___tds__LoadCertificateWithPrivateKey(struct soap *soap, struct __tds__LoadCertificateWithPrivateKey *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__LoadCertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__LoadCertificateWithPrivateKey * SOAP_FMAC2 soap_instantiate___tds__LoadCertificateWithPrivateKey(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__LoadCertificateWithPrivateKey(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__LoadCertificateWithPrivateKey, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__LoadCertificateWithPrivateKey);
		if (size)
			*size = sizeof(struct __tds__LoadCertificateWithPrivateKey);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__LoadCertificateWithPrivateKey, n);
		if (size)
			*size = n * sizeof(struct __tds__LoadCertificateWithPrivateKey);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__LoadCertificateWithPrivateKey*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__LoadCertificateWithPrivateKey(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__LoadCertificateWithPrivateKey %p -> %p\n", q, p));
	*(struct __tds__LoadCertificateWithPrivateKey*)p = *(struct __tds__LoadCertificateWithPrivateKey*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetCACertificates(struct soap *soap, struct __tds__GetCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetCACertificates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetCACertificates(struct soap *soap, const struct __tds__GetCACertificates *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetCACertificates(soap, &a->tds__GetCACertificates);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetCACertificates(struct soap *soap, const char *tag, int id, const struct __tds__GetCACertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetCACertificates(soap, "tds:GetCACertificates", -1, &a->tds__GetCACertificates, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCACertificates * SOAP_FMAC4 soap_in___tds__GetCACertificates(struct soap *soap, const char *tag, struct __tds__GetCACertificates *a, const char *type)
{
	size_t soap_flag_tds__GetCACertificates = 1;
	short soap_flag;
	a = (struct __tds__GetCACertificates *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetCACertificates, sizeof(struct __tds__GetCACertificates), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetCACertificates(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetCACertificates && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetCACertificates(soap, "tds:GetCACertificates", &a->tds__GetCACertificates, ""))
				{	soap_flag_tds__GetCACertificates--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetCACertificates(struct soap *soap, const struct __tds__GetCACertificates *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetCACertificates(soap, tag?tag:"-tds:GetCACertificates", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCACertificates * SOAP_FMAC4 soap_get___tds__GetCACertificates(struct soap *soap, struct __tds__GetCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetCACertificates * SOAP_FMAC2 soap_instantiate___tds__GetCACertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetCACertificates(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetCACertificates, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetCACertificates);
		if (size)
			*size = sizeof(struct __tds__GetCACertificates);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetCACertificates, n);
		if (size)
			*size = n * sizeof(struct __tds__GetCACertificates);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetCACertificates*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetCACertificates(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetCACertificates %p -> %p\n", q, p));
	*(struct __tds__GetCACertificates*)p = *(struct __tds__GetCACertificates*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SendAuxiliaryCommand(struct soap *soap, struct __tds__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SendAuxiliaryCommand = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SendAuxiliaryCommand(struct soap *soap, const struct __tds__SendAuxiliaryCommand *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SendAuxiliaryCommand(soap, &a->tds__SendAuxiliaryCommand);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, const struct __tds__SendAuxiliaryCommand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SendAuxiliaryCommand(soap, "tds:SendAuxiliaryCommand", -1, &a->tds__SendAuxiliaryCommand, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_in___tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct __tds__SendAuxiliaryCommand *a, const char *type)
{
	size_t soap_flag_tds__SendAuxiliaryCommand = 1;
	short soap_flag;
	a = (struct __tds__SendAuxiliaryCommand *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SendAuxiliaryCommand, sizeof(struct __tds__SendAuxiliaryCommand), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SendAuxiliaryCommand(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SendAuxiliaryCommand && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SendAuxiliaryCommand(soap, "tds:SendAuxiliaryCommand", &a->tds__SendAuxiliaryCommand, ""))
				{	soap_flag_tds__SendAuxiliaryCommand--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SendAuxiliaryCommand(struct soap *soap, const struct __tds__SendAuxiliaryCommand *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SendAuxiliaryCommand(soap, tag?tag:"-tds:SendAuxiliaryCommand", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_get___tds__SendAuxiliaryCommand(struct soap *soap, struct __tds__SendAuxiliaryCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SendAuxiliaryCommand * SOAP_FMAC2 soap_instantiate___tds__SendAuxiliaryCommand(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SendAuxiliaryCommand(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SendAuxiliaryCommand, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SendAuxiliaryCommand);
		if (size)
			*size = sizeof(struct __tds__SendAuxiliaryCommand);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SendAuxiliaryCommand, n);
		if (size)
			*size = n * sizeof(struct __tds__SendAuxiliaryCommand);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SendAuxiliaryCommand*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SendAuxiliaryCommand(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SendAuxiliaryCommand %p -> %p\n", q, p));
	*(struct __tds__SendAuxiliaryCommand*)p = *(struct __tds__SendAuxiliaryCommand*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetRelayOutputState(struct soap *soap, struct __tds__SetRelayOutputState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetRelayOutputState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetRelayOutputState(struct soap *soap, const struct __tds__SetRelayOutputState *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetRelayOutputState(soap, &a->tds__SetRelayOutputState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetRelayOutputState(struct soap *soap, const char *tag, int id, const struct __tds__SetRelayOutputState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetRelayOutputState(soap, "tds:SetRelayOutputState", -1, &a->tds__SetRelayOutputState, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRelayOutputState * SOAP_FMAC4 soap_in___tds__SetRelayOutputState(struct soap *soap, const char *tag, struct __tds__SetRelayOutputState *a, const char *type)
{
	size_t soap_flag_tds__SetRelayOutputState = 1;
	short soap_flag;
	a = (struct __tds__SetRelayOutputState *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetRelayOutputState, sizeof(struct __tds__SetRelayOutputState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetRelayOutputState(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetRelayOutputState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetRelayOutputState(soap, "tds:SetRelayOutputState", &a->tds__SetRelayOutputState, ""))
				{	soap_flag_tds__SetRelayOutputState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetRelayOutputState(struct soap *soap, const struct __tds__SetRelayOutputState *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetRelayOutputState(soap, tag?tag:"-tds:SetRelayOutputState", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRelayOutputState * SOAP_FMAC4 soap_get___tds__SetRelayOutputState(struct soap *soap, struct __tds__SetRelayOutputState *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetRelayOutputState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetRelayOutputState * SOAP_FMAC2 soap_instantiate___tds__SetRelayOutputState(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetRelayOutputState(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetRelayOutputState, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetRelayOutputState);
		if (size)
			*size = sizeof(struct __tds__SetRelayOutputState);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetRelayOutputState, n);
		if (size)
			*size = n * sizeof(struct __tds__SetRelayOutputState);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetRelayOutputState*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetRelayOutputState(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetRelayOutputState %p -> %p\n", q, p));
	*(struct __tds__SetRelayOutputState*)p = *(struct __tds__SetRelayOutputState*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetRelayOutputSettings(struct soap *soap, struct __tds__SetRelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetRelayOutputSettings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetRelayOutputSettings(struct soap *soap, const struct __tds__SetRelayOutputSettings *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetRelayOutputSettings(soap, &a->tds__SetRelayOutputSettings);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, const struct __tds__SetRelayOutputSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetRelayOutputSettings(soap, "tds:SetRelayOutputSettings", -1, &a->tds__SetRelayOutputSettings, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRelayOutputSettings * SOAP_FMAC4 soap_in___tds__SetRelayOutputSettings(struct soap *soap, const char *tag, struct __tds__SetRelayOutputSettings *a, const char *type)
{
	size_t soap_flag_tds__SetRelayOutputSettings = 1;
	short soap_flag;
	a = (struct __tds__SetRelayOutputSettings *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetRelayOutputSettings, sizeof(struct __tds__SetRelayOutputSettings), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetRelayOutputSettings(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetRelayOutputSettings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetRelayOutputSettings(soap, "tds:SetRelayOutputSettings", &a->tds__SetRelayOutputSettings, ""))
				{	soap_flag_tds__SetRelayOutputSettings--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetRelayOutputSettings(struct soap *soap, const struct __tds__SetRelayOutputSettings *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetRelayOutputSettings(soap, tag?tag:"-tds:SetRelayOutputSettings", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRelayOutputSettings * SOAP_FMAC4 soap_get___tds__SetRelayOutputSettings(struct soap *soap, struct __tds__SetRelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetRelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetRelayOutputSettings * SOAP_FMAC2 soap_instantiate___tds__SetRelayOutputSettings(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetRelayOutputSettings(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetRelayOutputSettings, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetRelayOutputSettings);
		if (size)
			*size = sizeof(struct __tds__SetRelayOutputSettings);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetRelayOutputSettings, n);
		if (size)
			*size = n * sizeof(struct __tds__SetRelayOutputSettings);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetRelayOutputSettings*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetRelayOutputSettings(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetRelayOutputSettings %p -> %p\n", q, p));
	*(struct __tds__SetRelayOutputSettings*)p = *(struct __tds__SetRelayOutputSettings*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetRelayOutputs(struct soap *soap, struct __tds__GetRelayOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetRelayOutputs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetRelayOutputs(struct soap *soap, const struct __tds__GetRelayOutputs *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetRelayOutputs(soap, &a->tds__GetRelayOutputs);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetRelayOutputs(struct soap *soap, const char *tag, int id, const struct __tds__GetRelayOutputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetRelayOutputs(soap, "tds:GetRelayOutputs", -1, &a->tds__GetRelayOutputs, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRelayOutputs * SOAP_FMAC4 soap_in___tds__GetRelayOutputs(struct soap *soap, const char *tag, struct __tds__GetRelayOutputs *a, const char *type)
{
	size_t soap_flag_tds__GetRelayOutputs = 1;
	short soap_flag;
	a = (struct __tds__GetRelayOutputs *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetRelayOutputs, sizeof(struct __tds__GetRelayOutputs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetRelayOutputs(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetRelayOutputs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetRelayOutputs(soap, "tds:GetRelayOutputs", &a->tds__GetRelayOutputs, ""))
				{	soap_flag_tds__GetRelayOutputs--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetRelayOutputs(struct soap *soap, const struct __tds__GetRelayOutputs *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetRelayOutputs(soap, tag?tag:"-tds:GetRelayOutputs", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRelayOutputs * SOAP_FMAC4 soap_get___tds__GetRelayOutputs(struct soap *soap, struct __tds__GetRelayOutputs *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetRelayOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetRelayOutputs * SOAP_FMAC2 soap_instantiate___tds__GetRelayOutputs(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetRelayOutputs(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetRelayOutputs, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetRelayOutputs);
		if (size)
			*size = sizeof(struct __tds__GetRelayOutputs);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetRelayOutputs, n);
		if (size)
			*size = n * sizeof(struct __tds__GetRelayOutputs);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetRelayOutputs*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetRelayOutputs(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetRelayOutputs %p -> %p\n", q, p));
	*(struct __tds__GetRelayOutputs*)p = *(struct __tds__GetRelayOutputs*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetClientCertificateMode(struct soap *soap, struct __tds__SetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetClientCertificateMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetClientCertificateMode(struct soap *soap, const struct __tds__SetClientCertificateMode *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetClientCertificateMode(soap, &a->tds__SetClientCertificateMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetClientCertificateMode(struct soap *soap, const char *tag, int id, const struct __tds__SetClientCertificateMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetClientCertificateMode(soap, "tds:SetClientCertificateMode", -1, &a->tds__SetClientCertificateMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetClientCertificateMode * SOAP_FMAC4 soap_in___tds__SetClientCertificateMode(struct soap *soap, const char *tag, struct __tds__SetClientCertificateMode *a, const char *type)
{
	size_t soap_flag_tds__SetClientCertificateMode = 1;
	short soap_flag;
	a = (struct __tds__SetClientCertificateMode *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetClientCertificateMode, sizeof(struct __tds__SetClientCertificateMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetClientCertificateMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetClientCertificateMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetClientCertificateMode(soap, "tds:SetClientCertificateMode", &a->tds__SetClientCertificateMode, ""))
				{	soap_flag_tds__SetClientCertificateMode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetClientCertificateMode(struct soap *soap, const struct __tds__SetClientCertificateMode *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetClientCertificateMode(soap, tag?tag:"-tds:SetClientCertificateMode", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetClientCertificateMode * SOAP_FMAC4 soap_get___tds__SetClientCertificateMode(struct soap *soap, struct __tds__SetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetClientCertificateMode * SOAP_FMAC2 soap_instantiate___tds__SetClientCertificateMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetClientCertificateMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetClientCertificateMode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetClientCertificateMode);
		if (size)
			*size = sizeof(struct __tds__SetClientCertificateMode);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetClientCertificateMode, n);
		if (size)
			*size = n * sizeof(struct __tds__SetClientCertificateMode);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetClientCertificateMode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetClientCertificateMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetClientCertificateMode %p -> %p\n", q, p));
	*(struct __tds__SetClientCertificateMode*)p = *(struct __tds__SetClientCertificateMode*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetClientCertificateMode(struct soap *soap, struct __tds__GetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetClientCertificateMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetClientCertificateMode(struct soap *soap, const struct __tds__GetClientCertificateMode *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetClientCertificateMode(soap, &a->tds__GetClientCertificateMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetClientCertificateMode(struct soap *soap, const char *tag, int id, const struct __tds__GetClientCertificateMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetClientCertificateMode(soap, "tds:GetClientCertificateMode", -1, &a->tds__GetClientCertificateMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetClientCertificateMode * SOAP_FMAC4 soap_in___tds__GetClientCertificateMode(struct soap *soap, const char *tag, struct __tds__GetClientCertificateMode *a, const char *type)
{
	size_t soap_flag_tds__GetClientCertificateMode = 1;
	short soap_flag;
	a = (struct __tds__GetClientCertificateMode *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetClientCertificateMode, sizeof(struct __tds__GetClientCertificateMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetClientCertificateMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetClientCertificateMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetClientCertificateMode(soap, "tds:GetClientCertificateMode", &a->tds__GetClientCertificateMode, ""))
				{	soap_flag_tds__GetClientCertificateMode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetClientCertificateMode(struct soap *soap, const struct __tds__GetClientCertificateMode *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetClientCertificateMode(soap, tag?tag:"-tds:GetClientCertificateMode", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetClientCertificateMode * SOAP_FMAC4 soap_get___tds__GetClientCertificateMode(struct soap *soap, struct __tds__GetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetClientCertificateMode * SOAP_FMAC2 soap_instantiate___tds__GetClientCertificateMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetClientCertificateMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetClientCertificateMode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetClientCertificateMode);
		if (size)
			*size = sizeof(struct __tds__GetClientCertificateMode);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetClientCertificateMode, n);
		if (size)
			*size = n * sizeof(struct __tds__GetClientCertificateMode);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetClientCertificateMode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetClientCertificateMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetClientCertificateMode %p -> %p\n", q, p));
	*(struct __tds__GetClientCertificateMode*)p = *(struct __tds__GetClientCertificateMode*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__LoadCertificates(struct soap *soap, struct __tds__LoadCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__LoadCertificates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__LoadCertificates(struct soap *soap, const struct __tds__LoadCertificates *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__LoadCertificates(soap, &a->tds__LoadCertificates);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__LoadCertificates(struct soap *soap, const char *tag, int id, const struct __tds__LoadCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__LoadCertificates(soap, "tds:LoadCertificates", -1, &a->tds__LoadCertificates, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__LoadCertificates * SOAP_FMAC4 soap_in___tds__LoadCertificates(struct soap *soap, const char *tag, struct __tds__LoadCertificates *a, const char *type)
{
	size_t soap_flag_tds__LoadCertificates = 1;
	short soap_flag;
	a = (struct __tds__LoadCertificates *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__LoadCertificates, sizeof(struct __tds__LoadCertificates), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__LoadCertificates(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__LoadCertificates && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__LoadCertificates(soap, "tds:LoadCertificates", &a->tds__LoadCertificates, ""))
				{	soap_flag_tds__LoadCertificates--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__LoadCertificates(struct soap *soap, const struct __tds__LoadCertificates *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__LoadCertificates(soap, tag?tag:"-tds:LoadCertificates", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__LoadCertificates * SOAP_FMAC4 soap_get___tds__LoadCertificates(struct soap *soap, struct __tds__LoadCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__LoadCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__LoadCertificates * SOAP_FMAC2 soap_instantiate___tds__LoadCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__LoadCertificates(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__LoadCertificates, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__LoadCertificates);
		if (size)
			*size = sizeof(struct __tds__LoadCertificates);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__LoadCertificates, n);
		if (size)
			*size = n * sizeof(struct __tds__LoadCertificates);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__LoadCertificates*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__LoadCertificates(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__LoadCertificates %p -> %p\n", q, p));
	*(struct __tds__LoadCertificates*)p = *(struct __tds__LoadCertificates*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetPkcs10Request(struct soap *soap, struct __tds__GetPkcs10Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetPkcs10Request = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetPkcs10Request(struct soap *soap, const struct __tds__GetPkcs10Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetPkcs10Request(soap, &a->tds__GetPkcs10Request);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetPkcs10Request(struct soap *soap, const char *tag, int id, const struct __tds__GetPkcs10Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetPkcs10Request(soap, "tds:GetPkcs10Request", -1, &a->tds__GetPkcs10Request, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetPkcs10Request * SOAP_FMAC4 soap_in___tds__GetPkcs10Request(struct soap *soap, const char *tag, struct __tds__GetPkcs10Request *a, const char *type)
{
	size_t soap_flag_tds__GetPkcs10Request = 1;
	short soap_flag;
	a = (struct __tds__GetPkcs10Request *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetPkcs10Request, sizeof(struct __tds__GetPkcs10Request), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetPkcs10Request(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetPkcs10Request && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetPkcs10Request(soap, "tds:GetPkcs10Request", &a->tds__GetPkcs10Request, ""))
				{	soap_flag_tds__GetPkcs10Request--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetPkcs10Request(struct soap *soap, const struct __tds__GetPkcs10Request *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetPkcs10Request(soap, tag?tag:"-tds:GetPkcs10Request", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetPkcs10Request * SOAP_FMAC4 soap_get___tds__GetPkcs10Request(struct soap *soap, struct __tds__GetPkcs10Request *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetPkcs10Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetPkcs10Request * SOAP_FMAC2 soap_instantiate___tds__GetPkcs10Request(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetPkcs10Request(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetPkcs10Request, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetPkcs10Request);
		if (size)
			*size = sizeof(struct __tds__GetPkcs10Request);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetPkcs10Request, n);
		if (size)
			*size = n * sizeof(struct __tds__GetPkcs10Request);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetPkcs10Request*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetPkcs10Request(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetPkcs10Request %p -> %p\n", q, p));
	*(struct __tds__GetPkcs10Request*)p = *(struct __tds__GetPkcs10Request*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__DeleteCertificates(struct soap *soap, struct __tds__DeleteCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__DeleteCertificates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__DeleteCertificates(struct soap *soap, const struct __tds__DeleteCertificates *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__DeleteCertificates(soap, &a->tds__DeleteCertificates);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__DeleteCertificates(struct soap *soap, const char *tag, int id, const struct __tds__DeleteCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__DeleteCertificates(soap, "tds:DeleteCertificates", -1, &a->tds__DeleteCertificates, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteCertificates * SOAP_FMAC4 soap_in___tds__DeleteCertificates(struct soap *soap, const char *tag, struct __tds__DeleteCertificates *a, const char *type)
{
	size_t soap_flag_tds__DeleteCertificates = 1;
	short soap_flag;
	a = (struct __tds__DeleteCertificates *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__DeleteCertificates, sizeof(struct __tds__DeleteCertificates), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__DeleteCertificates(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__DeleteCertificates && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__DeleteCertificates(soap, "tds:DeleteCertificates", &a->tds__DeleteCertificates, ""))
				{	soap_flag_tds__DeleteCertificates--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__DeleteCertificates(struct soap *soap, const struct __tds__DeleteCertificates *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__DeleteCertificates(soap, tag?tag:"-tds:DeleteCertificates", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteCertificates * SOAP_FMAC4 soap_get___tds__DeleteCertificates(struct soap *soap, struct __tds__DeleteCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__DeleteCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__DeleteCertificates * SOAP_FMAC2 soap_instantiate___tds__DeleteCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__DeleteCertificates(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__DeleteCertificates, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__DeleteCertificates);
		if (size)
			*size = sizeof(struct __tds__DeleteCertificates);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__DeleteCertificates, n);
		if (size)
			*size = n * sizeof(struct __tds__DeleteCertificates);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__DeleteCertificates*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__DeleteCertificates(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__DeleteCertificates %p -> %p\n", q, p));
	*(struct __tds__DeleteCertificates*)p = *(struct __tds__DeleteCertificates*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetCertificatesStatus(struct soap *soap, struct __tds__SetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetCertificatesStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetCertificatesStatus(struct soap *soap, const struct __tds__SetCertificatesStatus *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetCertificatesStatus(soap, &a->tds__SetCertificatesStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetCertificatesStatus(struct soap *soap, const char *tag, int id, const struct __tds__SetCertificatesStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetCertificatesStatus(soap, "tds:SetCertificatesStatus", -1, &a->tds__SetCertificatesStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetCertificatesStatus * SOAP_FMAC4 soap_in___tds__SetCertificatesStatus(struct soap *soap, const char *tag, struct __tds__SetCertificatesStatus *a, const char *type)
{
	size_t soap_flag_tds__SetCertificatesStatus = 1;
	short soap_flag;
	a = (struct __tds__SetCertificatesStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetCertificatesStatus, sizeof(struct __tds__SetCertificatesStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetCertificatesStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetCertificatesStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetCertificatesStatus(soap, "tds:SetCertificatesStatus", &a->tds__SetCertificatesStatus, ""))
				{	soap_flag_tds__SetCertificatesStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetCertificatesStatus(struct soap *soap, const struct __tds__SetCertificatesStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetCertificatesStatus(soap, tag?tag:"-tds:SetCertificatesStatus", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetCertificatesStatus * SOAP_FMAC4 soap_get___tds__SetCertificatesStatus(struct soap *soap, struct __tds__SetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetCertificatesStatus * SOAP_FMAC2 soap_instantiate___tds__SetCertificatesStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetCertificatesStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetCertificatesStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetCertificatesStatus);
		if (size)
			*size = sizeof(struct __tds__SetCertificatesStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetCertificatesStatus, n);
		if (size)
			*size = n * sizeof(struct __tds__SetCertificatesStatus);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetCertificatesStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetCertificatesStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetCertificatesStatus %p -> %p\n", q, p));
	*(struct __tds__SetCertificatesStatus*)p = *(struct __tds__SetCertificatesStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetCertificatesStatus(struct soap *soap, struct __tds__GetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetCertificatesStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetCertificatesStatus(struct soap *soap, const struct __tds__GetCertificatesStatus *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetCertificatesStatus(soap, &a->tds__GetCertificatesStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetCertificatesStatus(struct soap *soap, const char *tag, int id, const struct __tds__GetCertificatesStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetCertificatesStatus(soap, "tds:GetCertificatesStatus", -1, &a->tds__GetCertificatesStatus, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCertificatesStatus * SOAP_FMAC4 soap_in___tds__GetCertificatesStatus(struct soap *soap, const char *tag, struct __tds__GetCertificatesStatus *a, const char *type)
{
	size_t soap_flag_tds__GetCertificatesStatus = 1;
	short soap_flag;
	a = (struct __tds__GetCertificatesStatus *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetCertificatesStatus, sizeof(struct __tds__GetCertificatesStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetCertificatesStatus(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetCertificatesStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetCertificatesStatus(soap, "tds:GetCertificatesStatus", &a->tds__GetCertificatesStatus, ""))
				{	soap_flag_tds__GetCertificatesStatus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetCertificatesStatus(struct soap *soap, const struct __tds__GetCertificatesStatus *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetCertificatesStatus(soap, tag?tag:"-tds:GetCertificatesStatus", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCertificatesStatus * SOAP_FMAC4 soap_get___tds__GetCertificatesStatus(struct soap *soap, struct __tds__GetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetCertificatesStatus * SOAP_FMAC2 soap_instantiate___tds__GetCertificatesStatus(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetCertificatesStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetCertificatesStatus, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetCertificatesStatus);
		if (size)
			*size = sizeof(struct __tds__GetCertificatesStatus);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetCertificatesStatus, n);
		if (size)
			*size = n * sizeof(struct __tds__GetCertificatesStatus);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetCertificatesStatus*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetCertificatesStatus(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetCertificatesStatus %p -> %p\n", q, p));
	*(struct __tds__GetCertificatesStatus*)p = *(struct __tds__GetCertificatesStatus*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetCertificates(struct soap *soap, struct __tds__GetCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetCertificates = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetCertificates(struct soap *soap, const struct __tds__GetCertificates *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetCertificates(soap, &a->tds__GetCertificates);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetCertificates(struct soap *soap, const char *tag, int id, const struct __tds__GetCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetCertificates(soap, "tds:GetCertificates", -1, &a->tds__GetCertificates, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCertificates * SOAP_FMAC4 soap_in___tds__GetCertificates(struct soap *soap, const char *tag, struct __tds__GetCertificates *a, const char *type)
{
	size_t soap_flag_tds__GetCertificates = 1;
	short soap_flag;
	a = (struct __tds__GetCertificates *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetCertificates, sizeof(struct __tds__GetCertificates), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetCertificates(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetCertificates && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetCertificates(soap, "tds:GetCertificates", &a->tds__GetCertificates, ""))
				{	soap_flag_tds__GetCertificates--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetCertificates(struct soap *soap, const struct __tds__GetCertificates *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetCertificates(soap, tag?tag:"-tds:GetCertificates", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCertificates * SOAP_FMAC4 soap_get___tds__GetCertificates(struct soap *soap, struct __tds__GetCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetCertificates * SOAP_FMAC2 soap_instantiate___tds__GetCertificates(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetCertificates(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetCertificates, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetCertificates);
		if (size)
			*size = sizeof(struct __tds__GetCertificates);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetCertificates, n);
		if (size)
			*size = n * sizeof(struct __tds__GetCertificates);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetCertificates*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetCertificates(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetCertificates %p -> %p\n", q, p));
	*(struct __tds__GetCertificates*)p = *(struct __tds__GetCertificates*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__CreateCertificate(struct soap *soap, struct __tds__CreateCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__CreateCertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__CreateCertificate(struct soap *soap, const struct __tds__CreateCertificate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__CreateCertificate(soap, &a->tds__CreateCertificate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__CreateCertificate(struct soap *soap, const char *tag, int id, const struct __tds__CreateCertificate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__CreateCertificate(soap, "tds:CreateCertificate", -1, &a->tds__CreateCertificate, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateCertificate * SOAP_FMAC4 soap_in___tds__CreateCertificate(struct soap *soap, const char *tag, struct __tds__CreateCertificate *a, const char *type)
{
	size_t soap_flag_tds__CreateCertificate = 1;
	short soap_flag;
	a = (struct __tds__CreateCertificate *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__CreateCertificate, sizeof(struct __tds__CreateCertificate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__CreateCertificate(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__CreateCertificate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__CreateCertificate(soap, "tds:CreateCertificate", &a->tds__CreateCertificate, ""))
				{	soap_flag_tds__CreateCertificate--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__CreateCertificate(struct soap *soap, const struct __tds__CreateCertificate *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__CreateCertificate(soap, tag?tag:"-tds:CreateCertificate", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateCertificate * SOAP_FMAC4 soap_get___tds__CreateCertificate(struct soap *soap, struct __tds__CreateCertificate *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__CreateCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__CreateCertificate * SOAP_FMAC2 soap_instantiate___tds__CreateCertificate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__CreateCertificate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__CreateCertificate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__CreateCertificate);
		if (size)
			*size = sizeof(struct __tds__CreateCertificate);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__CreateCertificate, n);
		if (size)
			*size = n * sizeof(struct __tds__CreateCertificate);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__CreateCertificate*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__CreateCertificate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__CreateCertificate %p -> %p\n", q, p));
	*(struct __tds__CreateCertificate*)p = *(struct __tds__CreateCertificate*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetAccessPolicy(struct soap *soap, struct __tds__SetAccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetAccessPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetAccessPolicy(struct soap *soap, const struct __tds__SetAccessPolicy *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetAccessPolicy(soap, &a->tds__SetAccessPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetAccessPolicy(struct soap *soap, const char *tag, int id, const struct __tds__SetAccessPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetAccessPolicy(soap, "tds:SetAccessPolicy", -1, &a->tds__SetAccessPolicy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetAccessPolicy * SOAP_FMAC4 soap_in___tds__SetAccessPolicy(struct soap *soap, const char *tag, struct __tds__SetAccessPolicy *a, const char *type)
{
	size_t soap_flag_tds__SetAccessPolicy = 1;
	short soap_flag;
	a = (struct __tds__SetAccessPolicy *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetAccessPolicy, sizeof(struct __tds__SetAccessPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetAccessPolicy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetAccessPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetAccessPolicy(soap, "tds:SetAccessPolicy", &a->tds__SetAccessPolicy, ""))
				{	soap_flag_tds__SetAccessPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetAccessPolicy(struct soap *soap, const struct __tds__SetAccessPolicy *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetAccessPolicy(soap, tag?tag:"-tds:SetAccessPolicy", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetAccessPolicy * SOAP_FMAC4 soap_get___tds__SetAccessPolicy(struct soap *soap, struct __tds__SetAccessPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetAccessPolicy * SOAP_FMAC2 soap_instantiate___tds__SetAccessPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetAccessPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetAccessPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetAccessPolicy);
		if (size)
			*size = sizeof(struct __tds__SetAccessPolicy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetAccessPolicy, n);
		if (size)
			*size = n * sizeof(struct __tds__SetAccessPolicy);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetAccessPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetAccessPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetAccessPolicy %p -> %p\n", q, p));
	*(struct __tds__SetAccessPolicy*)p = *(struct __tds__SetAccessPolicy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetAccessPolicy(struct soap *soap, struct __tds__GetAccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetAccessPolicy = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetAccessPolicy(struct soap *soap, const struct __tds__GetAccessPolicy *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetAccessPolicy(soap, &a->tds__GetAccessPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetAccessPolicy(struct soap *soap, const char *tag, int id, const struct __tds__GetAccessPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetAccessPolicy(soap, "tds:GetAccessPolicy", -1, &a->tds__GetAccessPolicy, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetAccessPolicy * SOAP_FMAC4 soap_in___tds__GetAccessPolicy(struct soap *soap, const char *tag, struct __tds__GetAccessPolicy *a, const char *type)
{
	size_t soap_flag_tds__GetAccessPolicy = 1;
	short soap_flag;
	a = (struct __tds__GetAccessPolicy *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetAccessPolicy, sizeof(struct __tds__GetAccessPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetAccessPolicy(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetAccessPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetAccessPolicy(soap, "tds:GetAccessPolicy", &a->tds__GetAccessPolicy, ""))
				{	soap_flag_tds__GetAccessPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetAccessPolicy(struct soap *soap, const struct __tds__GetAccessPolicy *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetAccessPolicy(soap, tag?tag:"-tds:GetAccessPolicy", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetAccessPolicy * SOAP_FMAC4 soap_get___tds__GetAccessPolicy(struct soap *soap, struct __tds__GetAccessPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetAccessPolicy * SOAP_FMAC2 soap_instantiate___tds__GetAccessPolicy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetAccessPolicy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetAccessPolicy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetAccessPolicy);
		if (size)
			*size = sizeof(struct __tds__GetAccessPolicy);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetAccessPolicy, n);
		if (size)
			*size = n * sizeof(struct __tds__GetAccessPolicy);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetAccessPolicy*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetAccessPolicy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetAccessPolicy %p -> %p\n", q, p));
	*(struct __tds__GetAccessPolicy*)p = *(struct __tds__GetAccessPolicy*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__RemoveIPAddressFilter(struct soap *soap, struct __tds__RemoveIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__RemoveIPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__RemoveIPAddressFilter(struct soap *soap, const struct __tds__RemoveIPAddressFilter *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__RemoveIPAddressFilter(soap, &a->tds__RemoveIPAddressFilter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, int id, const struct __tds__RemoveIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__RemoveIPAddressFilter(soap, "tds:RemoveIPAddressFilter", -1, &a->tds__RemoveIPAddressFilter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_in___tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, struct __tds__RemoveIPAddressFilter *a, const char *type)
{
	size_t soap_flag_tds__RemoveIPAddressFilter = 1;
	short soap_flag;
	a = (struct __tds__RemoveIPAddressFilter *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__RemoveIPAddressFilter, sizeof(struct __tds__RemoveIPAddressFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__RemoveIPAddressFilter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__RemoveIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__RemoveIPAddressFilter(soap, "tds:RemoveIPAddressFilter", &a->tds__RemoveIPAddressFilter, ""))
				{	soap_flag_tds__RemoveIPAddressFilter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__RemoveIPAddressFilter(struct soap *soap, const struct __tds__RemoveIPAddressFilter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__RemoveIPAddressFilter(soap, tag?tag:"-tds:RemoveIPAddressFilter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RemoveIPAddressFilter * SOAP_FMAC4 soap_get___tds__RemoveIPAddressFilter(struct soap *soap, struct __tds__RemoveIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__RemoveIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__RemoveIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__RemoveIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__RemoveIPAddressFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__RemoveIPAddressFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__RemoveIPAddressFilter);
		if (size)
			*size = sizeof(struct __tds__RemoveIPAddressFilter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__RemoveIPAddressFilter, n);
		if (size)
			*size = n * sizeof(struct __tds__RemoveIPAddressFilter);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__RemoveIPAddressFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__RemoveIPAddressFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__RemoveIPAddressFilter %p -> %p\n", q, p));
	*(struct __tds__RemoveIPAddressFilter*)p = *(struct __tds__RemoveIPAddressFilter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__AddIPAddressFilter(struct soap *soap, struct __tds__AddIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__AddIPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__AddIPAddressFilter(struct soap *soap, const struct __tds__AddIPAddressFilter *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__AddIPAddressFilter(soap, &a->tds__AddIPAddressFilter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__AddIPAddressFilter(struct soap *soap, const char *tag, int id, const struct __tds__AddIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__AddIPAddressFilter(soap, "tds:AddIPAddressFilter", -1, &a->tds__AddIPAddressFilter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__AddIPAddressFilter * SOAP_FMAC4 soap_in___tds__AddIPAddressFilter(struct soap *soap, const char *tag, struct __tds__AddIPAddressFilter *a, const char *type)
{
	size_t soap_flag_tds__AddIPAddressFilter = 1;
	short soap_flag;
	a = (struct __tds__AddIPAddressFilter *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__AddIPAddressFilter, sizeof(struct __tds__AddIPAddressFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__AddIPAddressFilter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__AddIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__AddIPAddressFilter(soap, "tds:AddIPAddressFilter", &a->tds__AddIPAddressFilter, ""))
				{	soap_flag_tds__AddIPAddressFilter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__AddIPAddressFilter(struct soap *soap, const struct __tds__AddIPAddressFilter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__AddIPAddressFilter(soap, tag?tag:"-tds:AddIPAddressFilter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__AddIPAddressFilter * SOAP_FMAC4 soap_get___tds__AddIPAddressFilter(struct soap *soap, struct __tds__AddIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__AddIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__AddIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__AddIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__AddIPAddressFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__AddIPAddressFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__AddIPAddressFilter);
		if (size)
			*size = sizeof(struct __tds__AddIPAddressFilter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__AddIPAddressFilter, n);
		if (size)
			*size = n * sizeof(struct __tds__AddIPAddressFilter);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__AddIPAddressFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__AddIPAddressFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__AddIPAddressFilter %p -> %p\n", q, p));
	*(struct __tds__AddIPAddressFilter*)p = *(struct __tds__AddIPAddressFilter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetIPAddressFilter(struct soap *soap, struct __tds__SetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetIPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetIPAddressFilter(struct soap *soap, const struct __tds__SetIPAddressFilter *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetIPAddressFilter(soap, &a->tds__SetIPAddressFilter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetIPAddressFilter(struct soap *soap, const char *tag, int id, const struct __tds__SetIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetIPAddressFilter(soap, "tds:SetIPAddressFilter", -1, &a->tds__SetIPAddressFilter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetIPAddressFilter * SOAP_FMAC4 soap_in___tds__SetIPAddressFilter(struct soap *soap, const char *tag, struct __tds__SetIPAddressFilter *a, const char *type)
{
	size_t soap_flag_tds__SetIPAddressFilter = 1;
	short soap_flag;
	a = (struct __tds__SetIPAddressFilter *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetIPAddressFilter, sizeof(struct __tds__SetIPAddressFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetIPAddressFilter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetIPAddressFilter(soap, "tds:SetIPAddressFilter", &a->tds__SetIPAddressFilter, ""))
				{	soap_flag_tds__SetIPAddressFilter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetIPAddressFilter(struct soap *soap, const struct __tds__SetIPAddressFilter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetIPAddressFilter(soap, tag?tag:"-tds:SetIPAddressFilter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetIPAddressFilter * SOAP_FMAC4 soap_get___tds__SetIPAddressFilter(struct soap *soap, struct __tds__SetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__SetIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetIPAddressFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetIPAddressFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetIPAddressFilter);
		if (size)
			*size = sizeof(struct __tds__SetIPAddressFilter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetIPAddressFilter, n);
		if (size)
			*size = n * sizeof(struct __tds__SetIPAddressFilter);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetIPAddressFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetIPAddressFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetIPAddressFilter %p -> %p\n", q, p));
	*(struct __tds__SetIPAddressFilter*)p = *(struct __tds__SetIPAddressFilter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetIPAddressFilter(struct soap *soap, struct __tds__GetIPAddressFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetIPAddressFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetIPAddressFilter(struct soap *soap, const struct __tds__GetIPAddressFilter *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetIPAddressFilter(soap, &a->tds__GetIPAddressFilter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetIPAddressFilter(struct soap *soap, const char *tag, int id, const struct __tds__GetIPAddressFilter *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetIPAddressFilter(soap, "tds:GetIPAddressFilter", -1, &a->tds__GetIPAddressFilter, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetIPAddressFilter * SOAP_FMAC4 soap_in___tds__GetIPAddressFilter(struct soap *soap, const char *tag, struct __tds__GetIPAddressFilter *a, const char *type)
{
	size_t soap_flag_tds__GetIPAddressFilter = 1;
	short soap_flag;
	a = (struct __tds__GetIPAddressFilter *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetIPAddressFilter, sizeof(struct __tds__GetIPAddressFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetIPAddressFilter(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetIPAddressFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetIPAddressFilter(soap, "tds:GetIPAddressFilter", &a->tds__GetIPAddressFilter, ""))
				{	soap_flag_tds__GetIPAddressFilter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetIPAddressFilter(struct soap *soap, const struct __tds__GetIPAddressFilter *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetIPAddressFilter(soap, tag?tag:"-tds:GetIPAddressFilter", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetIPAddressFilter * SOAP_FMAC4 soap_get___tds__GetIPAddressFilter(struct soap *soap, struct __tds__GetIPAddressFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetIPAddressFilter * SOAP_FMAC2 soap_instantiate___tds__GetIPAddressFilter(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetIPAddressFilter(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetIPAddressFilter, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetIPAddressFilter);
		if (size)
			*size = sizeof(struct __tds__GetIPAddressFilter);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetIPAddressFilter, n);
		if (size)
			*size = n * sizeof(struct __tds__GetIPAddressFilter);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetIPAddressFilter*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetIPAddressFilter(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetIPAddressFilter %p -> %p\n", q, p));
	*(struct __tds__GetIPAddressFilter*)p = *(struct __tds__GetIPAddressFilter*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetZeroConfiguration(struct soap *soap, struct __tds__SetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetZeroConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetZeroConfiguration(struct soap *soap, const struct __tds__SetZeroConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetZeroConfiguration(soap, &a->tds__SetZeroConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetZeroConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__SetZeroConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetZeroConfiguration(soap, "tds:SetZeroConfiguration", -1, &a->tds__SetZeroConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetZeroConfiguration * SOAP_FMAC4 soap_in___tds__SetZeroConfiguration(struct soap *soap, const char *tag, struct __tds__SetZeroConfiguration *a, const char *type)
{
	size_t soap_flag_tds__SetZeroConfiguration = 1;
	short soap_flag;
	a = (struct __tds__SetZeroConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetZeroConfiguration, sizeof(struct __tds__SetZeroConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetZeroConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetZeroConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetZeroConfiguration(soap, "tds:SetZeroConfiguration", &a->tds__SetZeroConfiguration, ""))
				{	soap_flag_tds__SetZeroConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetZeroConfiguration(struct soap *soap, const struct __tds__SetZeroConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetZeroConfiguration(soap, tag?tag:"-tds:SetZeroConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetZeroConfiguration * SOAP_FMAC4 soap_get___tds__SetZeroConfiguration(struct soap *soap, struct __tds__SetZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetZeroConfiguration * SOAP_FMAC2 soap_instantiate___tds__SetZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetZeroConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetZeroConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetZeroConfiguration);
		if (size)
			*size = sizeof(struct __tds__SetZeroConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetZeroConfiguration, n);
		if (size)
			*size = n * sizeof(struct __tds__SetZeroConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetZeroConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetZeroConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetZeroConfiguration %p -> %p\n", q, p));
	*(struct __tds__SetZeroConfiguration*)p = *(struct __tds__SetZeroConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetZeroConfiguration(struct soap *soap, struct __tds__GetZeroConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetZeroConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetZeroConfiguration(struct soap *soap, const struct __tds__GetZeroConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetZeroConfiguration(soap, &a->tds__GetZeroConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetZeroConfiguration(struct soap *soap, const char *tag, int id, const struct __tds__GetZeroConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetZeroConfiguration(soap, "tds:GetZeroConfiguration", -1, &a->tds__GetZeroConfiguration, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetZeroConfiguration * SOAP_FMAC4 soap_in___tds__GetZeroConfiguration(struct soap *soap, const char *tag, struct __tds__GetZeroConfiguration *a, const char *type)
{
	size_t soap_flag_tds__GetZeroConfiguration = 1;
	short soap_flag;
	a = (struct __tds__GetZeroConfiguration *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetZeroConfiguration, sizeof(struct __tds__GetZeroConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetZeroConfiguration(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetZeroConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetZeroConfiguration(soap, "tds:GetZeroConfiguration", &a->tds__GetZeroConfiguration, ""))
				{	soap_flag_tds__GetZeroConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetZeroConfiguration(struct soap *soap, const struct __tds__GetZeroConfiguration *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetZeroConfiguration(soap, tag?tag:"-tds:GetZeroConfiguration", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetZeroConfiguration * SOAP_FMAC4 soap_get___tds__GetZeroConfiguration(struct soap *soap, struct __tds__GetZeroConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetZeroConfiguration * SOAP_FMAC2 soap_instantiate___tds__GetZeroConfiguration(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetZeroConfiguration(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetZeroConfiguration, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetZeroConfiguration);
		if (size)
			*size = sizeof(struct __tds__GetZeroConfiguration);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetZeroConfiguration, n);
		if (size)
			*size = n * sizeof(struct __tds__GetZeroConfiguration);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetZeroConfiguration*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetZeroConfiguration(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetZeroConfiguration %p -> %p\n", q, p));
	*(struct __tds__GetZeroConfiguration*)p = *(struct __tds__GetZeroConfiguration*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNetworkDefaultGateway(struct soap *soap, struct __tds__SetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNetworkDefaultGateway = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNetworkDefaultGateway(struct soap *soap, const struct __tds__SetNetworkDefaultGateway *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetNetworkDefaultGateway(soap, &a->tds__SetNetworkDefaultGateway);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const struct __tds__SetNetworkDefaultGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetNetworkDefaultGateway(soap, "tds:SetNetworkDefaultGateway", -1, &a->tds__SetNetworkDefaultGateway, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_in___tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, struct __tds__SetNetworkDefaultGateway *a, const char *type)
{
	size_t soap_flag_tds__SetNetworkDefaultGateway = 1;
	short soap_flag;
	a = (struct __tds__SetNetworkDefaultGateway *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNetworkDefaultGateway, sizeof(struct __tds__SetNetworkDefaultGateway), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetNetworkDefaultGateway(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetNetworkDefaultGateway && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetNetworkDefaultGateway(soap, "tds:SetNetworkDefaultGateway", &a->tds__SetNetworkDefaultGateway, ""))
				{	soap_flag_tds__SetNetworkDefaultGateway--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNetworkDefaultGateway(struct soap *soap, const struct __tds__SetNetworkDefaultGateway *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetNetworkDefaultGateway(soap, tag?tag:"-tds:SetNetworkDefaultGateway", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkDefaultGateway * SOAP_FMAC4 soap_get___tds__SetNetworkDefaultGateway(struct soap *soap, struct __tds__SetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate___tds__SetNetworkDefaultGateway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetNetworkDefaultGateway(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetNetworkDefaultGateway, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetNetworkDefaultGateway);
		if (size)
			*size = sizeof(struct __tds__SetNetworkDefaultGateway);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetNetworkDefaultGateway, n);
		if (size)
			*size = n * sizeof(struct __tds__SetNetworkDefaultGateway);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetNetworkDefaultGateway*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetNetworkDefaultGateway(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetNetworkDefaultGateway %p -> %p\n", q, p));
	*(struct __tds__SetNetworkDefaultGateway*)p = *(struct __tds__SetNetworkDefaultGateway*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNetworkDefaultGateway(struct soap *soap, struct __tds__GetNetworkDefaultGateway *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNetworkDefaultGateway = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNetworkDefaultGateway(struct soap *soap, const struct __tds__GetNetworkDefaultGateway *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetNetworkDefaultGateway(soap, &a->tds__GetNetworkDefaultGateway);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, const struct __tds__GetNetworkDefaultGateway *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetNetworkDefaultGateway(soap, "tds:GetNetworkDefaultGateway", -1, &a->tds__GetNetworkDefaultGateway, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_in___tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, struct __tds__GetNetworkDefaultGateway *a, const char *type)
{
	size_t soap_flag_tds__GetNetworkDefaultGateway = 1;
	short soap_flag;
	a = (struct __tds__GetNetworkDefaultGateway *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNetworkDefaultGateway, sizeof(struct __tds__GetNetworkDefaultGateway), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetNetworkDefaultGateway(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetNetworkDefaultGateway && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetNetworkDefaultGateway(soap, "tds:GetNetworkDefaultGateway", &a->tds__GetNetworkDefaultGateway, ""))
				{	soap_flag_tds__GetNetworkDefaultGateway--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNetworkDefaultGateway(struct soap *soap, const struct __tds__GetNetworkDefaultGateway *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetNetworkDefaultGateway(soap, tag?tag:"-tds:GetNetworkDefaultGateway", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkDefaultGateway * SOAP_FMAC4 soap_get___tds__GetNetworkDefaultGateway(struct soap *soap, struct __tds__GetNetworkDefaultGateway *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetNetworkDefaultGateway * SOAP_FMAC2 soap_instantiate___tds__GetNetworkDefaultGateway(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetNetworkDefaultGateway(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetNetworkDefaultGateway, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetNetworkDefaultGateway);
		if (size)
			*size = sizeof(struct __tds__GetNetworkDefaultGateway);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetNetworkDefaultGateway, n);
		if (size)
			*size = n * sizeof(struct __tds__GetNetworkDefaultGateway);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetNetworkDefaultGateway*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetNetworkDefaultGateway(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetNetworkDefaultGateway %p -> %p\n", q, p));
	*(struct __tds__GetNetworkDefaultGateway*)p = *(struct __tds__GetNetworkDefaultGateway*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNetworkProtocols(struct soap *soap, struct __tds__SetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNetworkProtocols = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNetworkProtocols(struct soap *soap, const struct __tds__SetNetworkProtocols *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetNetworkProtocols(soap, &a->tds__SetNetworkProtocols);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNetworkProtocols(struct soap *soap, const char *tag, int id, const struct __tds__SetNetworkProtocols *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetNetworkProtocols(soap, "tds:SetNetworkProtocols", -1, &a->tds__SetNetworkProtocols, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkProtocols * SOAP_FMAC4 soap_in___tds__SetNetworkProtocols(struct soap *soap, const char *tag, struct __tds__SetNetworkProtocols *a, const char *type)
{
	size_t soap_flag_tds__SetNetworkProtocols = 1;
	short soap_flag;
	a = (struct __tds__SetNetworkProtocols *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNetworkProtocols, sizeof(struct __tds__SetNetworkProtocols), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetNetworkProtocols(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetNetworkProtocols && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetNetworkProtocols(soap, "tds:SetNetworkProtocols", &a->tds__SetNetworkProtocols, ""))
				{	soap_flag_tds__SetNetworkProtocols--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNetworkProtocols(struct soap *soap, const struct __tds__SetNetworkProtocols *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetNetworkProtocols(soap, tag?tag:"-tds:SetNetworkProtocols", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkProtocols * SOAP_FMAC4 soap_get___tds__SetNetworkProtocols(struct soap *soap, struct __tds__SetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetNetworkProtocols * SOAP_FMAC2 soap_instantiate___tds__SetNetworkProtocols(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetNetworkProtocols(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetNetworkProtocols, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetNetworkProtocols);
		if (size)
			*size = sizeof(struct __tds__SetNetworkProtocols);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetNetworkProtocols, n);
		if (size)
			*size = n * sizeof(struct __tds__SetNetworkProtocols);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetNetworkProtocols*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetNetworkProtocols(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetNetworkProtocols %p -> %p\n", q, p));
	*(struct __tds__SetNetworkProtocols*)p = *(struct __tds__SetNetworkProtocols*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNetworkProtocols(struct soap *soap, struct __tds__GetNetworkProtocols *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNetworkProtocols = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNetworkProtocols(struct soap *soap, const struct __tds__GetNetworkProtocols *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetNetworkProtocols(soap, &a->tds__GetNetworkProtocols);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNetworkProtocols(struct soap *soap, const char *tag, int id, const struct __tds__GetNetworkProtocols *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetNetworkProtocols(soap, "tds:GetNetworkProtocols", -1, &a->tds__GetNetworkProtocols, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkProtocols * SOAP_FMAC4 soap_in___tds__GetNetworkProtocols(struct soap *soap, const char *tag, struct __tds__GetNetworkProtocols *a, const char *type)
{
	size_t soap_flag_tds__GetNetworkProtocols = 1;
	short soap_flag;
	a = (struct __tds__GetNetworkProtocols *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNetworkProtocols, sizeof(struct __tds__GetNetworkProtocols), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetNetworkProtocols(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetNetworkProtocols && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetNetworkProtocols(soap, "tds:GetNetworkProtocols", &a->tds__GetNetworkProtocols, ""))
				{	soap_flag_tds__GetNetworkProtocols--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNetworkProtocols(struct soap *soap, const struct __tds__GetNetworkProtocols *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetNetworkProtocols(soap, tag?tag:"-tds:GetNetworkProtocols", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkProtocols * SOAP_FMAC4 soap_get___tds__GetNetworkProtocols(struct soap *soap, struct __tds__GetNetworkProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetNetworkProtocols * SOAP_FMAC2 soap_instantiate___tds__GetNetworkProtocols(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetNetworkProtocols(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetNetworkProtocols, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetNetworkProtocols);
		if (size)
			*size = sizeof(struct __tds__GetNetworkProtocols);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetNetworkProtocols, n);
		if (size)
			*size = n * sizeof(struct __tds__GetNetworkProtocols);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetNetworkProtocols*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetNetworkProtocols(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetNetworkProtocols %p -> %p\n", q, p));
	*(struct __tds__GetNetworkProtocols*)p = *(struct __tds__GetNetworkProtocols*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNetworkInterfaces(struct soap *soap, struct __tds__SetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNetworkInterfaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNetworkInterfaces(struct soap *soap, const struct __tds__SetNetworkInterfaces *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetNetworkInterfaces(soap, &a->tds__SetNetworkInterfaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNetworkInterfaces(struct soap *soap, const char *tag, int id, const struct __tds__SetNetworkInterfaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetNetworkInterfaces(soap, "tds:SetNetworkInterfaces", -1, &a->tds__SetNetworkInterfaces, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkInterfaces * SOAP_FMAC4 soap_in___tds__SetNetworkInterfaces(struct soap *soap, const char *tag, struct __tds__SetNetworkInterfaces *a, const char *type)
{
	size_t soap_flag_tds__SetNetworkInterfaces = 1;
	short soap_flag;
	a = (struct __tds__SetNetworkInterfaces *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNetworkInterfaces, sizeof(struct __tds__SetNetworkInterfaces), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetNetworkInterfaces(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetNetworkInterfaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetNetworkInterfaces(soap, "tds:SetNetworkInterfaces", &a->tds__SetNetworkInterfaces, ""))
				{	soap_flag_tds__SetNetworkInterfaces--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNetworkInterfaces(struct soap *soap, const struct __tds__SetNetworkInterfaces *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetNetworkInterfaces(soap, tag?tag:"-tds:SetNetworkInterfaces", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNetworkInterfaces * SOAP_FMAC4 soap_get___tds__SetNetworkInterfaces(struct soap *soap, struct __tds__SetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetNetworkInterfaces * SOAP_FMAC2 soap_instantiate___tds__SetNetworkInterfaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetNetworkInterfaces(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetNetworkInterfaces, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetNetworkInterfaces);
		if (size)
			*size = sizeof(struct __tds__SetNetworkInterfaces);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetNetworkInterfaces, n);
		if (size)
			*size = n * sizeof(struct __tds__SetNetworkInterfaces);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetNetworkInterfaces*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetNetworkInterfaces(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetNetworkInterfaces %p -> %p\n", q, p));
	*(struct __tds__SetNetworkInterfaces*)p = *(struct __tds__SetNetworkInterfaces*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNetworkInterfaces(struct soap *soap, struct __tds__GetNetworkInterfaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNetworkInterfaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNetworkInterfaces(struct soap *soap, const struct __tds__GetNetworkInterfaces *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetNetworkInterfaces(soap, &a->tds__GetNetworkInterfaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNetworkInterfaces(struct soap *soap, const char *tag, int id, const struct __tds__GetNetworkInterfaces *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetNetworkInterfaces(soap, "tds:GetNetworkInterfaces", -1, &a->tds__GetNetworkInterfaces, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkInterfaces * SOAP_FMAC4 soap_in___tds__GetNetworkInterfaces(struct soap *soap, const char *tag, struct __tds__GetNetworkInterfaces *a, const char *type)
{
	size_t soap_flag_tds__GetNetworkInterfaces = 1;
	short soap_flag;
	a = (struct __tds__GetNetworkInterfaces *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNetworkInterfaces, sizeof(struct __tds__GetNetworkInterfaces), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetNetworkInterfaces(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetNetworkInterfaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetNetworkInterfaces(soap, "tds:GetNetworkInterfaces", &a->tds__GetNetworkInterfaces, ""))
				{	soap_flag_tds__GetNetworkInterfaces--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNetworkInterfaces(struct soap *soap, const struct __tds__GetNetworkInterfaces *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetNetworkInterfaces(soap, tag?tag:"-tds:GetNetworkInterfaces", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNetworkInterfaces * SOAP_FMAC4 soap_get___tds__GetNetworkInterfaces(struct soap *soap, struct __tds__GetNetworkInterfaces *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetNetworkInterfaces * SOAP_FMAC2 soap_instantiate___tds__GetNetworkInterfaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetNetworkInterfaces(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetNetworkInterfaces, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetNetworkInterfaces);
		if (size)
			*size = sizeof(struct __tds__GetNetworkInterfaces);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetNetworkInterfaces, n);
		if (size)
			*size = n * sizeof(struct __tds__GetNetworkInterfaces);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetNetworkInterfaces*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetNetworkInterfaces(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetNetworkInterfaces %p -> %p\n", q, p));
	*(struct __tds__GetNetworkInterfaces*)p = *(struct __tds__GetNetworkInterfaces*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDynamicDNS(struct soap *soap, struct __tds__SetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDynamicDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDynamicDNS(struct soap *soap, const struct __tds__SetDynamicDNS *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetDynamicDNS(soap, &a->tds__SetDynamicDNS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDynamicDNS(struct soap *soap, const char *tag, int id, const struct __tds__SetDynamicDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetDynamicDNS(soap, "tds:SetDynamicDNS", -1, &a->tds__SetDynamicDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDynamicDNS * SOAP_FMAC4 soap_in___tds__SetDynamicDNS(struct soap *soap, const char *tag, struct __tds__SetDynamicDNS *a, const char *type)
{
	size_t soap_flag_tds__SetDynamicDNS = 1;
	short soap_flag;
	a = (struct __tds__SetDynamicDNS *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDynamicDNS, sizeof(struct __tds__SetDynamicDNS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDynamicDNS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDynamicDNS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetDynamicDNS(soap, "tds:SetDynamicDNS", &a->tds__SetDynamicDNS, ""))
				{	soap_flag_tds__SetDynamicDNS--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDynamicDNS(struct soap *soap, const struct __tds__SetDynamicDNS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetDynamicDNS(soap, tag?tag:"-tds:SetDynamicDNS", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDynamicDNS * SOAP_FMAC4 soap_get___tds__SetDynamicDNS(struct soap *soap, struct __tds__SetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetDynamicDNS * SOAP_FMAC2 soap_instantiate___tds__SetDynamicDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetDynamicDNS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetDynamicDNS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetDynamicDNS);
		if (size)
			*size = sizeof(struct __tds__SetDynamicDNS);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetDynamicDNS, n);
		if (size)
			*size = n * sizeof(struct __tds__SetDynamicDNS);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetDynamicDNS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetDynamicDNS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetDynamicDNS %p -> %p\n", q, p));
	*(struct __tds__SetDynamicDNS*)p = *(struct __tds__SetDynamicDNS*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDynamicDNS(struct soap *soap, struct __tds__GetDynamicDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDynamicDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDynamicDNS(struct soap *soap, const struct __tds__GetDynamicDNS *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetDynamicDNS(soap, &a->tds__GetDynamicDNS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDynamicDNS(struct soap *soap, const char *tag, int id, const struct __tds__GetDynamicDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetDynamicDNS(soap, "tds:GetDynamicDNS", -1, &a->tds__GetDynamicDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDynamicDNS * SOAP_FMAC4 soap_in___tds__GetDynamicDNS(struct soap *soap, const char *tag, struct __tds__GetDynamicDNS *a, const char *type)
{
	size_t soap_flag_tds__GetDynamicDNS = 1;
	short soap_flag;
	a = (struct __tds__GetDynamicDNS *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDynamicDNS, sizeof(struct __tds__GetDynamicDNS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDynamicDNS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDynamicDNS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetDynamicDNS(soap, "tds:GetDynamicDNS", &a->tds__GetDynamicDNS, ""))
				{	soap_flag_tds__GetDynamicDNS--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDynamicDNS(struct soap *soap, const struct __tds__GetDynamicDNS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetDynamicDNS(soap, tag?tag:"-tds:GetDynamicDNS", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDynamicDNS * SOAP_FMAC4 soap_get___tds__GetDynamicDNS(struct soap *soap, struct __tds__GetDynamicDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetDynamicDNS * SOAP_FMAC2 soap_instantiate___tds__GetDynamicDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDynamicDNS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetDynamicDNS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetDynamicDNS);
		if (size)
			*size = sizeof(struct __tds__GetDynamicDNS);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetDynamicDNS, n);
		if (size)
			*size = n * sizeof(struct __tds__GetDynamicDNS);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetDynamicDNS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetDynamicDNS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetDynamicDNS %p -> %p\n", q, p));
	*(struct __tds__GetDynamicDNS*)p = *(struct __tds__GetDynamicDNS*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetNTP(struct soap *soap, struct __tds__SetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetNTP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetNTP(struct soap *soap, const struct __tds__SetNTP *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetNTP(soap, &a->tds__SetNTP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetNTP(struct soap *soap, const char *tag, int id, const struct __tds__SetNTP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetNTP(soap, "tds:SetNTP", -1, &a->tds__SetNTP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNTP * SOAP_FMAC4 soap_in___tds__SetNTP(struct soap *soap, const char *tag, struct __tds__SetNTP *a, const char *type)
{
	size_t soap_flag_tds__SetNTP = 1;
	short soap_flag;
	a = (struct __tds__SetNTP *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetNTP, sizeof(struct __tds__SetNTP), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetNTP(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetNTP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetNTP(soap, "tds:SetNTP", &a->tds__SetNTP, ""))
				{	soap_flag_tds__SetNTP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetNTP(struct soap *soap, const struct __tds__SetNTP *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetNTP(soap, tag?tag:"-tds:SetNTP", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetNTP * SOAP_FMAC4 soap_get___tds__SetNTP(struct soap *soap, struct __tds__SetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetNTP * SOAP_FMAC2 soap_instantiate___tds__SetNTP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetNTP(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetNTP, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetNTP);
		if (size)
			*size = sizeof(struct __tds__SetNTP);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetNTP, n);
		if (size)
			*size = n * sizeof(struct __tds__SetNTP);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetNTP*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetNTP(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetNTP %p -> %p\n", q, p));
	*(struct __tds__SetNTP*)p = *(struct __tds__SetNTP*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetNTP(struct soap *soap, struct __tds__GetNTP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetNTP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetNTP(struct soap *soap, const struct __tds__GetNTP *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetNTP(soap, &a->tds__GetNTP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetNTP(struct soap *soap, const char *tag, int id, const struct __tds__GetNTP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetNTP(soap, "tds:GetNTP", -1, &a->tds__GetNTP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNTP * SOAP_FMAC4 soap_in___tds__GetNTP(struct soap *soap, const char *tag, struct __tds__GetNTP *a, const char *type)
{
	size_t soap_flag_tds__GetNTP = 1;
	short soap_flag;
	a = (struct __tds__GetNTP *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetNTP, sizeof(struct __tds__GetNTP), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetNTP(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetNTP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetNTP(soap, "tds:GetNTP", &a->tds__GetNTP, ""))
				{	soap_flag_tds__GetNTP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetNTP(struct soap *soap, const struct __tds__GetNTP *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetNTP(soap, tag?tag:"-tds:GetNTP", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetNTP * SOAP_FMAC4 soap_get___tds__GetNTP(struct soap *soap, struct __tds__GetNTP *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetNTP * SOAP_FMAC2 soap_instantiate___tds__GetNTP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetNTP(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetNTP, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetNTP);
		if (size)
			*size = sizeof(struct __tds__GetNTP);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetNTP, n);
		if (size)
			*size = n * sizeof(struct __tds__GetNTP);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetNTP*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetNTP(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetNTP %p -> %p\n", q, p));
	*(struct __tds__GetNTP*)p = *(struct __tds__GetNTP*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDNS(struct soap *soap, struct __tds__SetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDNS(struct soap *soap, const struct __tds__SetDNS *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetDNS(soap, &a->tds__SetDNS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDNS(struct soap *soap, const char *tag, int id, const struct __tds__SetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetDNS(soap, "tds:SetDNS", -1, &a->tds__SetDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDNS * SOAP_FMAC4 soap_in___tds__SetDNS(struct soap *soap, const char *tag, struct __tds__SetDNS *a, const char *type)
{
	size_t soap_flag_tds__SetDNS = 1;
	short soap_flag;
	a = (struct __tds__SetDNS *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDNS, sizeof(struct __tds__SetDNS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDNS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDNS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetDNS(soap, "tds:SetDNS", &a->tds__SetDNS, ""))
				{	soap_flag_tds__SetDNS--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDNS(struct soap *soap, const struct __tds__SetDNS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetDNS(soap, tag?tag:"-tds:SetDNS", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDNS * SOAP_FMAC4 soap_get___tds__SetDNS(struct soap *soap, struct __tds__SetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetDNS * SOAP_FMAC2 soap_instantiate___tds__SetDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetDNS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetDNS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetDNS);
		if (size)
			*size = sizeof(struct __tds__SetDNS);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetDNS, n);
		if (size)
			*size = n * sizeof(struct __tds__SetDNS);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetDNS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetDNS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetDNS %p -> %p\n", q, p));
	*(struct __tds__SetDNS*)p = *(struct __tds__SetDNS*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDNS(struct soap *soap, struct __tds__GetDNS *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDNS = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDNS(struct soap *soap, const struct __tds__GetDNS *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetDNS(soap, &a->tds__GetDNS);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDNS(struct soap *soap, const char *tag, int id, const struct __tds__GetDNS *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetDNS(soap, "tds:GetDNS", -1, &a->tds__GetDNS, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDNS * SOAP_FMAC4 soap_in___tds__GetDNS(struct soap *soap, const char *tag, struct __tds__GetDNS *a, const char *type)
{
	size_t soap_flag_tds__GetDNS = 1;
	short soap_flag;
	a = (struct __tds__GetDNS *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDNS, sizeof(struct __tds__GetDNS), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDNS(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDNS && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetDNS(soap, "tds:GetDNS", &a->tds__GetDNS, ""))
				{	soap_flag_tds__GetDNS--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDNS(struct soap *soap, const struct __tds__GetDNS *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetDNS(soap, tag?tag:"-tds:GetDNS", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDNS * SOAP_FMAC4 soap_get___tds__GetDNS(struct soap *soap, struct __tds__GetDNS *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetDNS * SOAP_FMAC2 soap_instantiate___tds__GetDNS(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDNS(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetDNS, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetDNS);
		if (size)
			*size = sizeof(struct __tds__GetDNS);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetDNS, n);
		if (size)
			*size = n * sizeof(struct __tds__GetDNS);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetDNS*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetDNS(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetDNS %p -> %p\n", q, p));
	*(struct __tds__GetDNS*)p = *(struct __tds__GetDNS*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetHostnameFromDHCP(struct soap *soap, struct __tds__SetHostnameFromDHCP *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetHostnameFromDHCP = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetHostnameFromDHCP(struct soap *soap, const struct __tds__SetHostnameFromDHCP *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetHostnameFromDHCP(soap, &a->tds__SetHostnameFromDHCP);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, const struct __tds__SetHostnameFromDHCP *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetHostnameFromDHCP(soap, "tds:SetHostnameFromDHCP", -1, &a->tds__SetHostnameFromDHCP, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_in___tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, struct __tds__SetHostnameFromDHCP *a, const char *type)
{
	size_t soap_flag_tds__SetHostnameFromDHCP = 1;
	short soap_flag;
	a = (struct __tds__SetHostnameFromDHCP *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetHostnameFromDHCP, sizeof(struct __tds__SetHostnameFromDHCP), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetHostnameFromDHCP(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetHostnameFromDHCP && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetHostnameFromDHCP(soap, "tds:SetHostnameFromDHCP", &a->tds__SetHostnameFromDHCP, ""))
				{	soap_flag_tds__SetHostnameFromDHCP--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetHostnameFromDHCP(struct soap *soap, const struct __tds__SetHostnameFromDHCP *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetHostnameFromDHCP(soap, tag?tag:"-tds:SetHostnameFromDHCP", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostnameFromDHCP * SOAP_FMAC4 soap_get___tds__SetHostnameFromDHCP(struct soap *soap, struct __tds__SetHostnameFromDHCP *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetHostnameFromDHCP * SOAP_FMAC2 soap_instantiate___tds__SetHostnameFromDHCP(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetHostnameFromDHCP(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetHostnameFromDHCP, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetHostnameFromDHCP);
		if (size)
			*size = sizeof(struct __tds__SetHostnameFromDHCP);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetHostnameFromDHCP, n);
		if (size)
			*size = n * sizeof(struct __tds__SetHostnameFromDHCP);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetHostnameFromDHCP*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetHostnameFromDHCP(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetHostnameFromDHCP %p -> %p\n", q, p));
	*(struct __tds__SetHostnameFromDHCP*)p = *(struct __tds__SetHostnameFromDHCP*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetHostname(struct soap *soap, struct __tds__SetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetHostname = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetHostname(struct soap *soap, const struct __tds__SetHostname *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetHostname(soap, &a->tds__SetHostname);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetHostname(struct soap *soap, const char *tag, int id, const struct __tds__SetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetHostname(soap, "tds:SetHostname", -1, &a->tds__SetHostname, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostname * SOAP_FMAC4 soap_in___tds__SetHostname(struct soap *soap, const char *tag, struct __tds__SetHostname *a, const char *type)
{
	size_t soap_flag_tds__SetHostname = 1;
	short soap_flag;
	a = (struct __tds__SetHostname *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetHostname, sizeof(struct __tds__SetHostname), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetHostname(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetHostname && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetHostname(soap, "tds:SetHostname", &a->tds__SetHostname, ""))
				{	soap_flag_tds__SetHostname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetHostname(struct soap *soap, const struct __tds__SetHostname *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetHostname(soap, tag?tag:"-tds:SetHostname", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetHostname * SOAP_FMAC4 soap_get___tds__SetHostname(struct soap *soap, struct __tds__SetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetHostname * SOAP_FMAC2 soap_instantiate___tds__SetHostname(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetHostname(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetHostname, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetHostname);
		if (size)
			*size = sizeof(struct __tds__SetHostname);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetHostname, n);
		if (size)
			*size = n * sizeof(struct __tds__SetHostname);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetHostname*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetHostname(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetHostname %p -> %p\n", q, p));
	*(struct __tds__SetHostname*)p = *(struct __tds__SetHostname*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetHostname(struct soap *soap, struct __tds__GetHostname *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetHostname = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetHostname(struct soap *soap, const struct __tds__GetHostname *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetHostname(soap, &a->tds__GetHostname);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetHostname(struct soap *soap, const char *tag, int id, const struct __tds__GetHostname *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetHostname(soap, "tds:GetHostname", -1, &a->tds__GetHostname, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetHostname * SOAP_FMAC4 soap_in___tds__GetHostname(struct soap *soap, const char *tag, struct __tds__GetHostname *a, const char *type)
{
	size_t soap_flag_tds__GetHostname = 1;
	short soap_flag;
	a = (struct __tds__GetHostname *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetHostname, sizeof(struct __tds__GetHostname), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetHostname(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetHostname && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetHostname(soap, "tds:GetHostname", &a->tds__GetHostname, ""))
				{	soap_flag_tds__GetHostname--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetHostname(struct soap *soap, const struct __tds__GetHostname *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetHostname(soap, tag?tag:"-tds:GetHostname", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetHostname * SOAP_FMAC4 soap_get___tds__GetHostname(struct soap *soap, struct __tds__GetHostname *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetHostname * SOAP_FMAC2 soap_instantiate___tds__GetHostname(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetHostname(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetHostname, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetHostname);
		if (size)
			*size = sizeof(struct __tds__GetHostname);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetHostname, n);
		if (size)
			*size = n * sizeof(struct __tds__GetHostname);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetHostname*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetHostname(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetHostname %p -> %p\n", q, p));
	*(struct __tds__GetHostname*)p = *(struct __tds__GetHostname*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDPAddresses(struct soap *soap, struct __tds__SetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDPAddresses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDPAddresses(struct soap *soap, const struct __tds__SetDPAddresses *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetDPAddresses(soap, &a->tds__SetDPAddresses);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDPAddresses(struct soap *soap, const char *tag, int id, const struct __tds__SetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetDPAddresses(soap, "tds:SetDPAddresses", -1, &a->tds__SetDPAddresses, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDPAddresses * SOAP_FMAC4 soap_in___tds__SetDPAddresses(struct soap *soap, const char *tag, struct __tds__SetDPAddresses *a, const char *type)
{
	size_t soap_flag_tds__SetDPAddresses = 1;
	short soap_flag;
	a = (struct __tds__SetDPAddresses *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDPAddresses, sizeof(struct __tds__SetDPAddresses), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDPAddresses(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDPAddresses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetDPAddresses(soap, "tds:SetDPAddresses", &a->tds__SetDPAddresses, ""))
				{	soap_flag_tds__SetDPAddresses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDPAddresses(struct soap *soap, const struct __tds__SetDPAddresses *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetDPAddresses(soap, tag?tag:"-tds:SetDPAddresses", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDPAddresses * SOAP_FMAC4 soap_get___tds__SetDPAddresses(struct soap *soap, struct __tds__SetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetDPAddresses * SOAP_FMAC2 soap_instantiate___tds__SetDPAddresses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetDPAddresses(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetDPAddresses, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetDPAddresses);
		if (size)
			*size = sizeof(struct __tds__SetDPAddresses);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetDPAddresses, n);
		if (size)
			*size = n * sizeof(struct __tds__SetDPAddresses);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetDPAddresses*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetDPAddresses(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetDPAddresses %p -> %p\n", q, p));
	*(struct __tds__SetDPAddresses*)p = *(struct __tds__SetDPAddresses*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetCapabilities(struct soap *soap, struct __tds__GetCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetCapabilities(struct soap *soap, const struct __tds__GetCapabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetCapabilities(soap, &a->tds__GetCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetCapabilities(struct soap *soap, const char *tag, int id, const struct __tds__GetCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetCapabilities(soap, "tds:GetCapabilities", -1, &a->tds__GetCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCapabilities * SOAP_FMAC4 soap_in___tds__GetCapabilities(struct soap *soap, const char *tag, struct __tds__GetCapabilities *a, const char *type)
{
	size_t soap_flag_tds__GetCapabilities = 1;
	short soap_flag;
	a = (struct __tds__GetCapabilities *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetCapabilities, sizeof(struct __tds__GetCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetCapabilities(soap, "tds:GetCapabilities", &a->tds__GetCapabilities, ""))
				{	soap_flag_tds__GetCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetCapabilities(struct soap *soap, const struct __tds__GetCapabilities *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetCapabilities(soap, tag?tag:"-tds:GetCapabilities", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetCapabilities * SOAP_FMAC4 soap_get___tds__GetCapabilities(struct soap *soap, struct __tds__GetCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetCapabilities * SOAP_FMAC2 soap_instantiate___tds__GetCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetCapabilities);
		if (size)
			*size = sizeof(struct __tds__GetCapabilities);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetCapabilities, n);
		if (size)
			*size = n * sizeof(struct __tds__GetCapabilities);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetCapabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetCapabilities %p -> %p\n", q, p));
	*(struct __tds__GetCapabilities*)p = *(struct __tds__GetCapabilities*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetWsdlUrl(struct soap *soap, struct __tds__GetWsdlUrl *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetWsdlUrl = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetWsdlUrl(struct soap *soap, const struct __tds__GetWsdlUrl *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetWsdlUrl(soap, &a->tds__GetWsdlUrl);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetWsdlUrl(struct soap *soap, const char *tag, int id, const struct __tds__GetWsdlUrl *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetWsdlUrl(soap, "tds:GetWsdlUrl", -1, &a->tds__GetWsdlUrl, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetWsdlUrl * SOAP_FMAC4 soap_in___tds__GetWsdlUrl(struct soap *soap, const char *tag, struct __tds__GetWsdlUrl *a, const char *type)
{
	size_t soap_flag_tds__GetWsdlUrl = 1;
	short soap_flag;
	a = (struct __tds__GetWsdlUrl *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetWsdlUrl, sizeof(struct __tds__GetWsdlUrl), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetWsdlUrl(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetWsdlUrl && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetWsdlUrl(soap, "tds:GetWsdlUrl", &a->tds__GetWsdlUrl, ""))
				{	soap_flag_tds__GetWsdlUrl--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetWsdlUrl(struct soap *soap, const struct __tds__GetWsdlUrl *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetWsdlUrl(soap, tag?tag:"-tds:GetWsdlUrl", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetWsdlUrl * SOAP_FMAC4 soap_get___tds__GetWsdlUrl(struct soap *soap, struct __tds__GetWsdlUrl *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetWsdlUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetWsdlUrl * SOAP_FMAC2 soap_instantiate___tds__GetWsdlUrl(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetWsdlUrl(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetWsdlUrl, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetWsdlUrl);
		if (size)
			*size = sizeof(struct __tds__GetWsdlUrl);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetWsdlUrl, n);
		if (size)
			*size = n * sizeof(struct __tds__GetWsdlUrl);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetWsdlUrl*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetWsdlUrl(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetWsdlUrl %p -> %p\n", q, p));
	*(struct __tds__GetWsdlUrl*)p = *(struct __tds__GetWsdlUrl*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetUser(struct soap *soap, struct __tds__SetUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetUser(struct soap *soap, const struct __tds__SetUser *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetUser(soap, &a->tds__SetUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetUser(struct soap *soap, const char *tag, int id, const struct __tds__SetUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetUser(soap, "tds:SetUser", -1, &a->tds__SetUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetUser * SOAP_FMAC4 soap_in___tds__SetUser(struct soap *soap, const char *tag, struct __tds__SetUser *a, const char *type)
{
	size_t soap_flag_tds__SetUser = 1;
	short soap_flag;
	a = (struct __tds__SetUser *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetUser, sizeof(struct __tds__SetUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetUser(soap, "tds:SetUser", &a->tds__SetUser, ""))
				{	soap_flag_tds__SetUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetUser(struct soap *soap, const struct __tds__SetUser *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetUser(soap, tag?tag:"-tds:SetUser", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetUser * SOAP_FMAC4 soap_get___tds__SetUser(struct soap *soap, struct __tds__SetUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetUser * SOAP_FMAC2 soap_instantiate___tds__SetUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetUser);
		if (size)
			*size = sizeof(struct __tds__SetUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetUser, n);
		if (size)
			*size = n * sizeof(struct __tds__SetUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetUser %p -> %p\n", q, p));
	*(struct __tds__SetUser*)p = *(struct __tds__SetUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__DeleteUsers(struct soap *soap, struct __tds__DeleteUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__DeleteUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__DeleteUsers(struct soap *soap, const struct __tds__DeleteUsers *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__DeleteUsers(soap, &a->tds__DeleteUsers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__DeleteUsers(struct soap *soap, const char *tag, int id, const struct __tds__DeleteUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__DeleteUsers(soap, "tds:DeleteUsers", -1, &a->tds__DeleteUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteUsers * SOAP_FMAC4 soap_in___tds__DeleteUsers(struct soap *soap, const char *tag, struct __tds__DeleteUsers *a, const char *type)
{
	size_t soap_flag_tds__DeleteUsers = 1;
	short soap_flag;
	a = (struct __tds__DeleteUsers *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__DeleteUsers, sizeof(struct __tds__DeleteUsers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__DeleteUsers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__DeleteUsers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__DeleteUsers(soap, "tds:DeleteUsers", &a->tds__DeleteUsers, ""))
				{	soap_flag_tds__DeleteUsers--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__DeleteUsers(struct soap *soap, const struct __tds__DeleteUsers *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__DeleteUsers(soap, tag?tag:"-tds:DeleteUsers", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__DeleteUsers * SOAP_FMAC4 soap_get___tds__DeleteUsers(struct soap *soap, struct __tds__DeleteUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__DeleteUsers * SOAP_FMAC2 soap_instantiate___tds__DeleteUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__DeleteUsers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__DeleteUsers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__DeleteUsers);
		if (size)
			*size = sizeof(struct __tds__DeleteUsers);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__DeleteUsers, n);
		if (size)
			*size = n * sizeof(struct __tds__DeleteUsers);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__DeleteUsers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__DeleteUsers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__DeleteUsers %p -> %p\n", q, p));
	*(struct __tds__DeleteUsers*)p = *(struct __tds__DeleteUsers*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__CreateUsers(struct soap *soap, struct __tds__CreateUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__CreateUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__CreateUsers(struct soap *soap, const struct __tds__CreateUsers *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__CreateUsers(soap, &a->tds__CreateUsers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__CreateUsers(struct soap *soap, const char *tag, int id, const struct __tds__CreateUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__CreateUsers(soap, "tds:CreateUsers", -1, &a->tds__CreateUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateUsers * SOAP_FMAC4 soap_in___tds__CreateUsers(struct soap *soap, const char *tag, struct __tds__CreateUsers *a, const char *type)
{
	size_t soap_flag_tds__CreateUsers = 1;
	short soap_flag;
	a = (struct __tds__CreateUsers *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__CreateUsers, sizeof(struct __tds__CreateUsers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__CreateUsers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__CreateUsers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__CreateUsers(soap, "tds:CreateUsers", &a->tds__CreateUsers, ""))
				{	soap_flag_tds__CreateUsers--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__CreateUsers(struct soap *soap, const struct __tds__CreateUsers *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__CreateUsers(soap, tag?tag:"-tds:CreateUsers", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__CreateUsers * SOAP_FMAC4 soap_get___tds__CreateUsers(struct soap *soap, struct __tds__CreateUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__CreateUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__CreateUsers * SOAP_FMAC2 soap_instantiate___tds__CreateUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__CreateUsers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__CreateUsers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__CreateUsers);
		if (size)
			*size = sizeof(struct __tds__CreateUsers);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__CreateUsers, n);
		if (size)
			*size = n * sizeof(struct __tds__CreateUsers);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__CreateUsers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__CreateUsers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__CreateUsers %p -> %p\n", q, p));
	*(struct __tds__CreateUsers*)p = *(struct __tds__CreateUsers*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetUsers(struct soap *soap, struct __tds__GetUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetUsers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetUsers(struct soap *soap, const struct __tds__GetUsers *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetUsers(soap, &a->tds__GetUsers);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetUsers(struct soap *soap, const char *tag, int id, const struct __tds__GetUsers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetUsers(soap, "tds:GetUsers", -1, &a->tds__GetUsers, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetUsers * SOAP_FMAC4 soap_in___tds__GetUsers(struct soap *soap, const char *tag, struct __tds__GetUsers *a, const char *type)
{
	size_t soap_flag_tds__GetUsers = 1;
	short soap_flag;
	a = (struct __tds__GetUsers *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetUsers, sizeof(struct __tds__GetUsers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetUsers(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetUsers && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetUsers(soap, "tds:GetUsers", &a->tds__GetUsers, ""))
				{	soap_flag_tds__GetUsers--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetUsers(struct soap *soap, const struct __tds__GetUsers *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetUsers(soap, tag?tag:"-tds:GetUsers", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetUsers * SOAP_FMAC4 soap_get___tds__GetUsers(struct soap *soap, struct __tds__GetUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetUsers * SOAP_FMAC2 soap_instantiate___tds__GetUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetUsers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetUsers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetUsers);
		if (size)
			*size = sizeof(struct __tds__GetUsers);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetUsers, n);
		if (size)
			*size = n * sizeof(struct __tds__GetUsers);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetUsers*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetUsers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetUsers %p -> %p\n", q, p));
	*(struct __tds__GetUsers*)p = *(struct __tds__GetUsers*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetRemoteUser(struct soap *soap, struct __tds__SetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetRemoteUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetRemoteUser(struct soap *soap, const struct __tds__SetRemoteUser *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetRemoteUser(soap, &a->tds__SetRemoteUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetRemoteUser(struct soap *soap, const char *tag, int id, const struct __tds__SetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetRemoteUser(soap, "tds:SetRemoteUser", -1, &a->tds__SetRemoteUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteUser * SOAP_FMAC4 soap_in___tds__SetRemoteUser(struct soap *soap, const char *tag, struct __tds__SetRemoteUser *a, const char *type)
{
	size_t soap_flag_tds__SetRemoteUser = 1;
	short soap_flag;
	a = (struct __tds__SetRemoteUser *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetRemoteUser, sizeof(struct __tds__SetRemoteUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetRemoteUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetRemoteUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetRemoteUser(soap, "tds:SetRemoteUser", &a->tds__SetRemoteUser, ""))
				{	soap_flag_tds__SetRemoteUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetRemoteUser(struct soap *soap, const struct __tds__SetRemoteUser *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetRemoteUser(soap, tag?tag:"-tds:SetRemoteUser", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteUser * SOAP_FMAC4 soap_get___tds__SetRemoteUser(struct soap *soap, struct __tds__SetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetRemoteUser * SOAP_FMAC2 soap_instantiate___tds__SetRemoteUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetRemoteUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetRemoteUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetRemoteUser);
		if (size)
			*size = sizeof(struct __tds__SetRemoteUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetRemoteUser, n);
		if (size)
			*size = n * sizeof(struct __tds__SetRemoteUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetRemoteUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetRemoteUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetRemoteUser %p -> %p\n", q, p));
	*(struct __tds__SetRemoteUser*)p = *(struct __tds__SetRemoteUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetRemoteUser(struct soap *soap, struct __tds__GetRemoteUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetRemoteUser = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetRemoteUser(struct soap *soap, const struct __tds__GetRemoteUser *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetRemoteUser(soap, &a->tds__GetRemoteUser);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetRemoteUser(struct soap *soap, const char *tag, int id, const struct __tds__GetRemoteUser *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetRemoteUser(soap, "tds:GetRemoteUser", -1, &a->tds__GetRemoteUser, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteUser * SOAP_FMAC4 soap_in___tds__GetRemoteUser(struct soap *soap, const char *tag, struct __tds__GetRemoteUser *a, const char *type)
{
	size_t soap_flag_tds__GetRemoteUser = 1;
	short soap_flag;
	a = (struct __tds__GetRemoteUser *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetRemoteUser, sizeof(struct __tds__GetRemoteUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetRemoteUser(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetRemoteUser && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetRemoteUser(soap, "tds:GetRemoteUser", &a->tds__GetRemoteUser, ""))
				{	soap_flag_tds__GetRemoteUser--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetRemoteUser(struct soap *soap, const struct __tds__GetRemoteUser *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetRemoteUser(soap, tag?tag:"-tds:GetRemoteUser", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteUser * SOAP_FMAC4 soap_get___tds__GetRemoteUser(struct soap *soap, struct __tds__GetRemoteUser *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetRemoteUser * SOAP_FMAC2 soap_instantiate___tds__GetRemoteUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetRemoteUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetRemoteUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetRemoteUser);
		if (size)
			*size = sizeof(struct __tds__GetRemoteUser);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetRemoteUser, n);
		if (size)
			*size = n * sizeof(struct __tds__GetRemoteUser);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetRemoteUser*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetRemoteUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetRemoteUser %p -> %p\n", q, p));
	*(struct __tds__GetRemoteUser*)p = *(struct __tds__GetRemoteUser*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetEndpointReference(struct soap *soap, struct __tds__GetEndpointReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetEndpointReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetEndpointReference(struct soap *soap, const struct __tds__GetEndpointReference *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetEndpointReference(soap, &a->tds__GetEndpointReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetEndpointReference(struct soap *soap, const char *tag, int id, const struct __tds__GetEndpointReference *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetEndpointReference(soap, "tds:GetEndpointReference", -1, &a->tds__GetEndpointReference, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetEndpointReference * SOAP_FMAC4 soap_in___tds__GetEndpointReference(struct soap *soap, const char *tag, struct __tds__GetEndpointReference *a, const char *type)
{
	size_t soap_flag_tds__GetEndpointReference = 1;
	short soap_flag;
	a = (struct __tds__GetEndpointReference *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetEndpointReference, sizeof(struct __tds__GetEndpointReference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetEndpointReference(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetEndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetEndpointReference(soap, "tds:GetEndpointReference", &a->tds__GetEndpointReference, ""))
				{	soap_flag_tds__GetEndpointReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetEndpointReference(struct soap *soap, const struct __tds__GetEndpointReference *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetEndpointReference(soap, tag?tag:"-tds:GetEndpointReference", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetEndpointReference * SOAP_FMAC4 soap_get___tds__GetEndpointReference(struct soap *soap, struct __tds__GetEndpointReference *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetEndpointReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetEndpointReference * SOAP_FMAC2 soap_instantiate___tds__GetEndpointReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetEndpointReference(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetEndpointReference, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetEndpointReference);
		if (size)
			*size = sizeof(struct __tds__GetEndpointReference);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetEndpointReference, n);
		if (size)
			*size = n * sizeof(struct __tds__GetEndpointReference);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetEndpointReference*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetEndpointReference(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetEndpointReference %p -> %p\n", q, p));
	*(struct __tds__GetEndpointReference*)p = *(struct __tds__GetEndpointReference*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDPAddresses(struct soap *soap, struct __tds__GetDPAddresses *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDPAddresses = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDPAddresses(struct soap *soap, const struct __tds__GetDPAddresses *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetDPAddresses(soap, &a->tds__GetDPAddresses);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDPAddresses(struct soap *soap, const char *tag, int id, const struct __tds__GetDPAddresses *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetDPAddresses(soap, "tds:GetDPAddresses", -1, &a->tds__GetDPAddresses, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDPAddresses * SOAP_FMAC4 soap_in___tds__GetDPAddresses(struct soap *soap, const char *tag, struct __tds__GetDPAddresses *a, const char *type)
{
	size_t soap_flag_tds__GetDPAddresses = 1;
	short soap_flag;
	a = (struct __tds__GetDPAddresses *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDPAddresses, sizeof(struct __tds__GetDPAddresses), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDPAddresses(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDPAddresses && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetDPAddresses(soap, "tds:GetDPAddresses", &a->tds__GetDPAddresses, ""))
				{	soap_flag_tds__GetDPAddresses--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDPAddresses(struct soap *soap, const struct __tds__GetDPAddresses *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetDPAddresses(soap, tag?tag:"-tds:GetDPAddresses", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDPAddresses * SOAP_FMAC4 soap_get___tds__GetDPAddresses(struct soap *soap, struct __tds__GetDPAddresses *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetDPAddresses * SOAP_FMAC2 soap_instantiate___tds__GetDPAddresses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDPAddresses(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetDPAddresses, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetDPAddresses);
		if (size)
			*size = sizeof(struct __tds__GetDPAddresses);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetDPAddresses, n);
		if (size)
			*size = n * sizeof(struct __tds__GetDPAddresses);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetDPAddresses*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetDPAddresses(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetDPAddresses %p -> %p\n", q, p));
	*(struct __tds__GetDPAddresses*)p = *(struct __tds__GetDPAddresses*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetRemoteDiscoveryMode(struct soap *soap, struct __tds__SetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetRemoteDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetRemoteDiscoveryMode(struct soap *soap, const struct __tds__SetRemoteDiscoveryMode *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetRemoteDiscoveryMode(soap, &a->tds__SetRemoteDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__SetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetRemoteDiscoveryMode(soap, "tds:SetRemoteDiscoveryMode", -1, &a->tds__SetRemoteDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_in___tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct __tds__SetRemoteDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__SetRemoteDiscoveryMode = 1;
	short soap_flag;
	a = (struct __tds__SetRemoteDiscoveryMode *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetRemoteDiscoveryMode, sizeof(struct __tds__SetRemoteDiscoveryMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetRemoteDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetRemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetRemoteDiscoveryMode(soap, "tds:SetRemoteDiscoveryMode", &a->tds__SetRemoteDiscoveryMode, ""))
				{	soap_flag_tds__SetRemoteDiscoveryMode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetRemoteDiscoveryMode(struct soap *soap, const struct __tds__SetRemoteDiscoveryMode *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetRemoteDiscoveryMode(soap, tag?tag:"-tds:SetRemoteDiscoveryMode", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetRemoteDiscoveryMode * SOAP_FMAC4 soap_get___tds__SetRemoteDiscoveryMode(struct soap *soap, struct __tds__SetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__SetRemoteDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetRemoteDiscoveryMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetRemoteDiscoveryMode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetRemoteDiscoveryMode);
		if (size)
			*size = sizeof(struct __tds__SetRemoteDiscoveryMode);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetRemoteDiscoveryMode, n);
		if (size)
			*size = n * sizeof(struct __tds__SetRemoteDiscoveryMode);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetRemoteDiscoveryMode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetRemoteDiscoveryMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetRemoteDiscoveryMode %p -> %p\n", q, p));
	*(struct __tds__SetRemoteDiscoveryMode*)p = *(struct __tds__SetRemoteDiscoveryMode*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetRemoteDiscoveryMode(struct soap *soap, struct __tds__GetRemoteDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetRemoteDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetRemoteDiscoveryMode(struct soap *soap, const struct __tds__GetRemoteDiscoveryMode *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetRemoteDiscoveryMode(soap, &a->tds__GetRemoteDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__GetRemoteDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetRemoteDiscoveryMode(soap, "tds:GetRemoteDiscoveryMode", -1, &a->tds__GetRemoteDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_in___tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct __tds__GetRemoteDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__GetRemoteDiscoveryMode = 1;
	short soap_flag;
	a = (struct __tds__GetRemoteDiscoveryMode *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetRemoteDiscoveryMode, sizeof(struct __tds__GetRemoteDiscoveryMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetRemoteDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetRemoteDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetRemoteDiscoveryMode(soap, "tds:GetRemoteDiscoveryMode", &a->tds__GetRemoteDiscoveryMode, ""))
				{	soap_flag_tds__GetRemoteDiscoveryMode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetRemoteDiscoveryMode(struct soap *soap, const struct __tds__GetRemoteDiscoveryMode *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetRemoteDiscoveryMode(soap, tag?tag:"-tds:GetRemoteDiscoveryMode", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetRemoteDiscoveryMode * SOAP_FMAC4 soap_get___tds__GetRemoteDiscoveryMode(struct soap *soap, struct __tds__GetRemoteDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetRemoteDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__GetRemoteDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetRemoteDiscoveryMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetRemoteDiscoveryMode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetRemoteDiscoveryMode);
		if (size)
			*size = sizeof(struct __tds__GetRemoteDiscoveryMode);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetRemoteDiscoveryMode, n);
		if (size)
			*size = n * sizeof(struct __tds__GetRemoteDiscoveryMode);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetRemoteDiscoveryMode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetRemoteDiscoveryMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetRemoteDiscoveryMode %p -> %p\n", q, p));
	*(struct __tds__GetRemoteDiscoveryMode*)p = *(struct __tds__GetRemoteDiscoveryMode*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetDiscoveryMode(struct soap *soap, struct __tds__SetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetDiscoveryMode(struct soap *soap, const struct __tds__SetDiscoveryMode *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetDiscoveryMode(soap, &a->tds__SetDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__SetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetDiscoveryMode(soap, "tds:SetDiscoveryMode", -1, &a->tds__SetDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDiscoveryMode * SOAP_FMAC4 soap_in___tds__SetDiscoveryMode(struct soap *soap, const char *tag, struct __tds__SetDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__SetDiscoveryMode = 1;
	short soap_flag;
	a = (struct __tds__SetDiscoveryMode *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetDiscoveryMode, sizeof(struct __tds__SetDiscoveryMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetDiscoveryMode(soap, "tds:SetDiscoveryMode", &a->tds__SetDiscoveryMode, ""))
				{	soap_flag_tds__SetDiscoveryMode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetDiscoveryMode(struct soap *soap, const struct __tds__SetDiscoveryMode *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetDiscoveryMode(soap, tag?tag:"-tds:SetDiscoveryMode", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetDiscoveryMode * SOAP_FMAC4 soap_get___tds__SetDiscoveryMode(struct soap *soap, struct __tds__SetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__SetDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetDiscoveryMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetDiscoveryMode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetDiscoveryMode);
		if (size)
			*size = sizeof(struct __tds__SetDiscoveryMode);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetDiscoveryMode, n);
		if (size)
			*size = n * sizeof(struct __tds__SetDiscoveryMode);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetDiscoveryMode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetDiscoveryMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetDiscoveryMode %p -> %p\n", q, p));
	*(struct __tds__SetDiscoveryMode*)p = *(struct __tds__SetDiscoveryMode*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDiscoveryMode(struct soap *soap, struct __tds__GetDiscoveryMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDiscoveryMode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDiscoveryMode(struct soap *soap, const struct __tds__GetDiscoveryMode *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetDiscoveryMode(soap, &a->tds__GetDiscoveryMode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDiscoveryMode(struct soap *soap, const char *tag, int id, const struct __tds__GetDiscoveryMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetDiscoveryMode(soap, "tds:GetDiscoveryMode", -1, &a->tds__GetDiscoveryMode, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDiscoveryMode * SOAP_FMAC4 soap_in___tds__GetDiscoveryMode(struct soap *soap, const char *tag, struct __tds__GetDiscoveryMode *a, const char *type)
{
	size_t soap_flag_tds__GetDiscoveryMode = 1;
	short soap_flag;
	a = (struct __tds__GetDiscoveryMode *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDiscoveryMode, sizeof(struct __tds__GetDiscoveryMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDiscoveryMode(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDiscoveryMode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetDiscoveryMode(soap, "tds:GetDiscoveryMode", &a->tds__GetDiscoveryMode, ""))
				{	soap_flag_tds__GetDiscoveryMode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDiscoveryMode(struct soap *soap, const struct __tds__GetDiscoveryMode *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetDiscoveryMode(soap, tag?tag:"-tds:GetDiscoveryMode", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDiscoveryMode * SOAP_FMAC4 soap_get___tds__GetDiscoveryMode(struct soap *soap, struct __tds__GetDiscoveryMode *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetDiscoveryMode * SOAP_FMAC2 soap_instantiate___tds__GetDiscoveryMode(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDiscoveryMode(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetDiscoveryMode, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetDiscoveryMode);
		if (size)
			*size = sizeof(struct __tds__GetDiscoveryMode);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetDiscoveryMode, n);
		if (size)
			*size = n * sizeof(struct __tds__GetDiscoveryMode);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetDiscoveryMode*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetDiscoveryMode(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetDiscoveryMode %p -> %p\n", q, p));
	*(struct __tds__GetDiscoveryMode*)p = *(struct __tds__GetDiscoveryMode*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__RemoveScopes(struct soap *soap, struct __tds__RemoveScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__RemoveScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__RemoveScopes(struct soap *soap, const struct __tds__RemoveScopes *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__RemoveScopes(soap, &a->tds__RemoveScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__RemoveScopes(struct soap *soap, const char *tag, int id, const struct __tds__RemoveScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__RemoveScopes(soap, "tds:RemoveScopes", -1, &a->tds__RemoveScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RemoveScopes * SOAP_FMAC4 soap_in___tds__RemoveScopes(struct soap *soap, const char *tag, struct __tds__RemoveScopes *a, const char *type)
{
	size_t soap_flag_tds__RemoveScopes = 1;
	short soap_flag;
	a = (struct __tds__RemoveScopes *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__RemoveScopes, sizeof(struct __tds__RemoveScopes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__RemoveScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__RemoveScopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__RemoveScopes(soap, "tds:RemoveScopes", &a->tds__RemoveScopes, ""))
				{	soap_flag_tds__RemoveScopes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__RemoveScopes(struct soap *soap, const struct __tds__RemoveScopes *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__RemoveScopes(soap, tag?tag:"-tds:RemoveScopes", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RemoveScopes * SOAP_FMAC4 soap_get___tds__RemoveScopes(struct soap *soap, struct __tds__RemoveScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__RemoveScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__RemoveScopes * SOAP_FMAC2 soap_instantiate___tds__RemoveScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__RemoveScopes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__RemoveScopes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__RemoveScopes);
		if (size)
			*size = sizeof(struct __tds__RemoveScopes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__RemoveScopes, n);
		if (size)
			*size = n * sizeof(struct __tds__RemoveScopes);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__RemoveScopes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__RemoveScopes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__RemoveScopes %p -> %p\n", q, p));
	*(struct __tds__RemoveScopes*)p = *(struct __tds__RemoveScopes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__AddScopes(struct soap *soap, struct __tds__AddScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__AddScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__AddScopes(struct soap *soap, const struct __tds__AddScopes *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__AddScopes(soap, &a->tds__AddScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__AddScopes(struct soap *soap, const char *tag, int id, const struct __tds__AddScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__AddScopes(soap, "tds:AddScopes", -1, &a->tds__AddScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__AddScopes * SOAP_FMAC4 soap_in___tds__AddScopes(struct soap *soap, const char *tag, struct __tds__AddScopes *a, const char *type)
{
	size_t soap_flag_tds__AddScopes = 1;
	short soap_flag;
	a = (struct __tds__AddScopes *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__AddScopes, sizeof(struct __tds__AddScopes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__AddScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__AddScopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__AddScopes(soap, "tds:AddScopes", &a->tds__AddScopes, ""))
				{	soap_flag_tds__AddScopes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__AddScopes(struct soap *soap, const struct __tds__AddScopes *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__AddScopes(soap, tag?tag:"-tds:AddScopes", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__AddScopes * SOAP_FMAC4 soap_get___tds__AddScopes(struct soap *soap, struct __tds__AddScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__AddScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__AddScopes * SOAP_FMAC2 soap_instantiate___tds__AddScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__AddScopes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__AddScopes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__AddScopes);
		if (size)
			*size = sizeof(struct __tds__AddScopes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__AddScopes, n);
		if (size)
			*size = n * sizeof(struct __tds__AddScopes);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__AddScopes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__AddScopes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__AddScopes %p -> %p\n", q, p));
	*(struct __tds__AddScopes*)p = *(struct __tds__AddScopes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetScopes(struct soap *soap, struct __tds__SetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetScopes(struct soap *soap, const struct __tds__SetScopes *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetScopes(soap, &a->tds__SetScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetScopes(struct soap *soap, const char *tag, int id, const struct __tds__SetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetScopes(soap, "tds:SetScopes", -1, &a->tds__SetScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetScopes * SOAP_FMAC4 soap_in___tds__SetScopes(struct soap *soap, const char *tag, struct __tds__SetScopes *a, const char *type)
{
	size_t soap_flag_tds__SetScopes = 1;
	short soap_flag;
	a = (struct __tds__SetScopes *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetScopes, sizeof(struct __tds__SetScopes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetScopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetScopes(soap, "tds:SetScopes", &a->tds__SetScopes, ""))
				{	soap_flag_tds__SetScopes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetScopes(struct soap *soap, const struct __tds__SetScopes *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetScopes(soap, tag?tag:"-tds:SetScopes", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetScopes * SOAP_FMAC4 soap_get___tds__SetScopes(struct soap *soap, struct __tds__SetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetScopes * SOAP_FMAC2 soap_instantiate___tds__SetScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetScopes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetScopes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetScopes);
		if (size)
			*size = sizeof(struct __tds__SetScopes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetScopes, n);
		if (size)
			*size = n * sizeof(struct __tds__SetScopes);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetScopes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetScopes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetScopes %p -> %p\n", q, p));
	*(struct __tds__SetScopes*)p = *(struct __tds__SetScopes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetScopes(struct soap *soap, struct __tds__GetScopes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetScopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetScopes(struct soap *soap, const struct __tds__GetScopes *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetScopes(soap, &a->tds__GetScopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetScopes(struct soap *soap, const char *tag, int id, const struct __tds__GetScopes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetScopes(soap, "tds:GetScopes", -1, &a->tds__GetScopes, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetScopes * SOAP_FMAC4 soap_in___tds__GetScopes(struct soap *soap, const char *tag, struct __tds__GetScopes *a, const char *type)
{
	size_t soap_flag_tds__GetScopes = 1;
	short soap_flag;
	a = (struct __tds__GetScopes *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetScopes, sizeof(struct __tds__GetScopes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetScopes(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetScopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetScopes(soap, "tds:GetScopes", &a->tds__GetScopes, ""))
				{	soap_flag_tds__GetScopes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetScopes(struct soap *soap, const struct __tds__GetScopes *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetScopes(soap, tag?tag:"-tds:GetScopes", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetScopes * SOAP_FMAC4 soap_get___tds__GetScopes(struct soap *soap, struct __tds__GetScopes *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetScopes * SOAP_FMAC2 soap_instantiate___tds__GetScopes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetScopes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetScopes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetScopes);
		if (size)
			*size = sizeof(struct __tds__GetScopes);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetScopes, n);
		if (size)
			*size = n * sizeof(struct __tds__GetScopes);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetScopes*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetScopes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetScopes %p -> %p\n", q, p));
	*(struct __tds__GetScopes*)p = *(struct __tds__GetScopes*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemSupportInformation(struct soap *soap, struct __tds__GetSystemSupportInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemSupportInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemSupportInformation(struct soap *soap, const struct __tds__GetSystemSupportInformation *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetSystemSupportInformation(soap, &a->tds__GetSystemSupportInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemSupportInformation(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemSupportInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetSystemSupportInformation(soap, "tds:GetSystemSupportInformation", -1, &a->tds__GetSystemSupportInformation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemSupportInformation * SOAP_FMAC4 soap_in___tds__GetSystemSupportInformation(struct soap *soap, const char *tag, struct __tds__GetSystemSupportInformation *a, const char *type)
{
	size_t soap_flag_tds__GetSystemSupportInformation = 1;
	short soap_flag;
	a = (struct __tds__GetSystemSupportInformation *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemSupportInformation, sizeof(struct __tds__GetSystemSupportInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemSupportInformation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemSupportInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetSystemSupportInformation(soap, "tds:GetSystemSupportInformation", &a->tds__GetSystemSupportInformation, ""))
				{	soap_flag_tds__GetSystemSupportInformation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemSupportInformation(struct soap *soap, const struct __tds__GetSystemSupportInformation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetSystemSupportInformation(soap, tag?tag:"-tds:GetSystemSupportInformation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemSupportInformation * SOAP_FMAC4 soap_get___tds__GetSystemSupportInformation(struct soap *soap, struct __tds__GetSystemSupportInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemSupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetSystemSupportInformation * SOAP_FMAC2 soap_instantiate___tds__GetSystemSupportInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetSystemSupportInformation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetSystemSupportInformation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetSystemSupportInformation);
		if (size)
			*size = sizeof(struct __tds__GetSystemSupportInformation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetSystemSupportInformation, n);
		if (size)
			*size = n * sizeof(struct __tds__GetSystemSupportInformation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetSystemSupportInformation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetSystemSupportInformation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetSystemSupportInformation %p -> %p\n", q, p));
	*(struct __tds__GetSystemSupportInformation*)p = *(struct __tds__GetSystemSupportInformation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemLog(struct soap *soap, struct __tds__GetSystemLog *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemLog = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemLog(struct soap *soap, const struct __tds__GetSystemLog *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetSystemLog(soap, &a->tds__GetSystemLog);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemLog(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemLog *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetSystemLog(soap, "tds:GetSystemLog", -1, &a->tds__GetSystemLog, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemLog * SOAP_FMAC4 soap_in___tds__GetSystemLog(struct soap *soap, const char *tag, struct __tds__GetSystemLog *a, const char *type)
{
	size_t soap_flag_tds__GetSystemLog = 1;
	short soap_flag;
	a = (struct __tds__GetSystemLog *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemLog, sizeof(struct __tds__GetSystemLog), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemLog(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemLog && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetSystemLog(soap, "tds:GetSystemLog", &a->tds__GetSystemLog, ""))
				{	soap_flag_tds__GetSystemLog--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemLog(struct soap *soap, const struct __tds__GetSystemLog *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetSystemLog(soap, tag?tag:"-tds:GetSystemLog", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemLog * SOAP_FMAC4 soap_get___tds__GetSystemLog(struct soap *soap, struct __tds__GetSystemLog *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetSystemLog * SOAP_FMAC2 soap_instantiate___tds__GetSystemLog(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetSystemLog(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetSystemLog, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetSystemLog);
		if (size)
			*size = sizeof(struct __tds__GetSystemLog);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetSystemLog, n);
		if (size)
			*size = n * sizeof(struct __tds__GetSystemLog);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetSystemLog*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetSystemLog(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetSystemLog %p -> %p\n", q, p));
	*(struct __tds__GetSystemLog*)p = *(struct __tds__GetSystemLog*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemBackup(struct soap *soap, struct __tds__GetSystemBackup *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemBackup = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemBackup(struct soap *soap, const struct __tds__GetSystemBackup *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetSystemBackup(soap, &a->tds__GetSystemBackup);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemBackup(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemBackup *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetSystemBackup(soap, "tds:GetSystemBackup", -1, &a->tds__GetSystemBackup, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemBackup * SOAP_FMAC4 soap_in___tds__GetSystemBackup(struct soap *soap, const char *tag, struct __tds__GetSystemBackup *a, const char *type)
{
	size_t soap_flag_tds__GetSystemBackup = 1;
	short soap_flag;
	a = (struct __tds__GetSystemBackup *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemBackup, sizeof(struct __tds__GetSystemBackup), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemBackup(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemBackup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetSystemBackup(soap, "tds:GetSystemBackup", &a->tds__GetSystemBackup, ""))
				{	soap_flag_tds__GetSystemBackup--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemBackup(struct soap *soap, const struct __tds__GetSystemBackup *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetSystemBackup(soap, tag?tag:"-tds:GetSystemBackup", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemBackup * SOAP_FMAC4 soap_get___tds__GetSystemBackup(struct soap *soap, struct __tds__GetSystemBackup *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemBackup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetSystemBackup * SOAP_FMAC2 soap_instantiate___tds__GetSystemBackup(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetSystemBackup(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetSystemBackup, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetSystemBackup);
		if (size)
			*size = sizeof(struct __tds__GetSystemBackup);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetSystemBackup, n);
		if (size)
			*size = n * sizeof(struct __tds__GetSystemBackup);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetSystemBackup*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetSystemBackup(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetSystemBackup %p -> %p\n", q, p));
	*(struct __tds__GetSystemBackup*)p = *(struct __tds__GetSystemBackup*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__RestoreSystem(struct soap *soap, struct __tds__RestoreSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__RestoreSystem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__RestoreSystem(struct soap *soap, const struct __tds__RestoreSystem *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__RestoreSystem(soap, &a->tds__RestoreSystem);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__RestoreSystem(struct soap *soap, const char *tag, int id, const struct __tds__RestoreSystem *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__RestoreSystem(soap, "tds:RestoreSystem", -1, &a->tds__RestoreSystem, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RestoreSystem * SOAP_FMAC4 soap_in___tds__RestoreSystem(struct soap *soap, const char *tag, struct __tds__RestoreSystem *a, const char *type)
{
	size_t soap_flag_tds__RestoreSystem = 1;
	short soap_flag;
	a = (struct __tds__RestoreSystem *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__RestoreSystem, sizeof(struct __tds__RestoreSystem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__RestoreSystem(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__RestoreSystem && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__RestoreSystem(soap, "tds:RestoreSystem", &a->tds__RestoreSystem, ""))
				{	soap_flag_tds__RestoreSystem--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__RestoreSystem(struct soap *soap, const struct __tds__RestoreSystem *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__RestoreSystem(soap, tag?tag:"-tds:RestoreSystem", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__RestoreSystem * SOAP_FMAC4 soap_get___tds__RestoreSystem(struct soap *soap, struct __tds__RestoreSystem *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__RestoreSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__RestoreSystem * SOAP_FMAC2 soap_instantiate___tds__RestoreSystem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__RestoreSystem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__RestoreSystem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__RestoreSystem);
		if (size)
			*size = sizeof(struct __tds__RestoreSystem);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__RestoreSystem, n);
		if (size)
			*size = n * sizeof(struct __tds__RestoreSystem);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__RestoreSystem*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__RestoreSystem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__RestoreSystem %p -> %p\n", q, p));
	*(struct __tds__RestoreSystem*)p = *(struct __tds__RestoreSystem*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SystemReboot(struct soap *soap, struct __tds__SystemReboot *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SystemReboot = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SystemReboot(struct soap *soap, const struct __tds__SystemReboot *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SystemReboot(soap, &a->tds__SystemReboot);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SystemReboot(struct soap *soap, const char *tag, int id, const struct __tds__SystemReboot *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SystemReboot(soap, "tds:SystemReboot", -1, &a->tds__SystemReboot, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SystemReboot * SOAP_FMAC4 soap_in___tds__SystemReboot(struct soap *soap, const char *tag, struct __tds__SystemReboot *a, const char *type)
{
	size_t soap_flag_tds__SystemReboot = 1;
	short soap_flag;
	a = (struct __tds__SystemReboot *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SystemReboot, sizeof(struct __tds__SystemReboot), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SystemReboot(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SystemReboot && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SystemReboot(soap, "tds:SystemReboot", &a->tds__SystemReboot, ""))
				{	soap_flag_tds__SystemReboot--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SystemReboot(struct soap *soap, const struct __tds__SystemReboot *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SystemReboot(soap, tag?tag:"-tds:SystemReboot", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SystemReboot * SOAP_FMAC4 soap_get___tds__SystemReboot(struct soap *soap, struct __tds__SystemReboot *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SystemReboot * SOAP_FMAC2 soap_instantiate___tds__SystemReboot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SystemReboot(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SystemReboot, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SystemReboot);
		if (size)
			*size = sizeof(struct __tds__SystemReboot);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SystemReboot, n);
		if (size)
			*size = n * sizeof(struct __tds__SystemReboot);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SystemReboot*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SystemReboot(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SystemReboot %p -> %p\n", q, p));
	*(struct __tds__SystemReboot*)p = *(struct __tds__SystemReboot*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__UpgradeSystemFirmware(struct soap *soap, struct __tds__UpgradeSystemFirmware *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__UpgradeSystemFirmware = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__UpgradeSystemFirmware(struct soap *soap, const struct __tds__UpgradeSystemFirmware *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__UpgradeSystemFirmware(soap, &a->tds__UpgradeSystemFirmware);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, int id, const struct __tds__UpgradeSystemFirmware *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__UpgradeSystemFirmware(soap, "tds:UpgradeSystemFirmware", -1, &a->tds__UpgradeSystemFirmware, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_in___tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, struct __tds__UpgradeSystemFirmware *a, const char *type)
{
	size_t soap_flag_tds__UpgradeSystemFirmware = 1;
	short soap_flag;
	a = (struct __tds__UpgradeSystemFirmware *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__UpgradeSystemFirmware, sizeof(struct __tds__UpgradeSystemFirmware), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__UpgradeSystemFirmware(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__UpgradeSystemFirmware && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__UpgradeSystemFirmware(soap, "tds:UpgradeSystemFirmware", &a->tds__UpgradeSystemFirmware, ""))
				{	soap_flag_tds__UpgradeSystemFirmware--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__UpgradeSystemFirmware(struct soap *soap, const struct __tds__UpgradeSystemFirmware *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__UpgradeSystemFirmware(soap, tag?tag:"-tds:UpgradeSystemFirmware", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__UpgradeSystemFirmware * SOAP_FMAC4 soap_get___tds__UpgradeSystemFirmware(struct soap *soap, struct __tds__UpgradeSystemFirmware *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__UpgradeSystemFirmware(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__UpgradeSystemFirmware * SOAP_FMAC2 soap_instantiate___tds__UpgradeSystemFirmware(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__UpgradeSystemFirmware(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__UpgradeSystemFirmware, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__UpgradeSystemFirmware);
		if (size)
			*size = sizeof(struct __tds__UpgradeSystemFirmware);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__UpgradeSystemFirmware, n);
		if (size)
			*size = n * sizeof(struct __tds__UpgradeSystemFirmware);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__UpgradeSystemFirmware*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__UpgradeSystemFirmware(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__UpgradeSystemFirmware %p -> %p\n", q, p));
	*(struct __tds__UpgradeSystemFirmware*)p = *(struct __tds__UpgradeSystemFirmware*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetSystemFactoryDefault(struct soap *soap, struct __tds__SetSystemFactoryDefault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetSystemFactoryDefault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetSystemFactoryDefault(struct soap *soap, const struct __tds__SetSystemFactoryDefault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetSystemFactoryDefault(soap, &a->tds__SetSystemFactoryDefault);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, const struct __tds__SetSystemFactoryDefault *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetSystemFactoryDefault(soap, "tds:SetSystemFactoryDefault", -1, &a->tds__SetSystemFactoryDefault, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_in___tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, struct __tds__SetSystemFactoryDefault *a, const char *type)
{
	size_t soap_flag_tds__SetSystemFactoryDefault = 1;
	short soap_flag;
	a = (struct __tds__SetSystemFactoryDefault *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetSystemFactoryDefault, sizeof(struct __tds__SetSystemFactoryDefault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetSystemFactoryDefault(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetSystemFactoryDefault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetSystemFactoryDefault(soap, "tds:SetSystemFactoryDefault", &a->tds__SetSystemFactoryDefault, ""))
				{	soap_flag_tds__SetSystemFactoryDefault--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetSystemFactoryDefault(struct soap *soap, const struct __tds__SetSystemFactoryDefault *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetSystemFactoryDefault(soap, tag?tag:"-tds:SetSystemFactoryDefault", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemFactoryDefault * SOAP_FMAC4 soap_get___tds__SetSystemFactoryDefault(struct soap *soap, struct __tds__SetSystemFactoryDefault *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetSystemFactoryDefault * SOAP_FMAC2 soap_instantiate___tds__SetSystemFactoryDefault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetSystemFactoryDefault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetSystemFactoryDefault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetSystemFactoryDefault);
		if (size)
			*size = sizeof(struct __tds__SetSystemFactoryDefault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetSystemFactoryDefault, n);
		if (size)
			*size = n * sizeof(struct __tds__SetSystemFactoryDefault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetSystemFactoryDefault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetSystemFactoryDefault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetSystemFactoryDefault %p -> %p\n", q, p));
	*(struct __tds__SetSystemFactoryDefault*)p = *(struct __tds__SetSystemFactoryDefault*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetSystemDateAndTime(struct soap *soap, struct __tds__GetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetSystemDateAndTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetSystemDateAndTime(struct soap *soap, const struct __tds__GetSystemDateAndTime *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetSystemDateAndTime(soap, &a->tds__GetSystemDateAndTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct __tds__GetSystemDateAndTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetSystemDateAndTime(soap, "tds:GetSystemDateAndTime", -1, &a->tds__GetSystemDateAndTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemDateAndTime * SOAP_FMAC4 soap_in___tds__GetSystemDateAndTime(struct soap *soap, const char *tag, struct __tds__GetSystemDateAndTime *a, const char *type)
{
	size_t soap_flag_tds__GetSystemDateAndTime = 1;
	short soap_flag;
	a = (struct __tds__GetSystemDateAndTime *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetSystemDateAndTime, sizeof(struct __tds__GetSystemDateAndTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetSystemDateAndTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetSystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetSystemDateAndTime(soap, "tds:GetSystemDateAndTime", &a->tds__GetSystemDateAndTime, ""))
				{	soap_flag_tds__GetSystemDateAndTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetSystemDateAndTime(struct soap *soap, const struct __tds__GetSystemDateAndTime *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetSystemDateAndTime(soap, tag?tag:"-tds:GetSystemDateAndTime", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetSystemDateAndTime * SOAP_FMAC4 soap_get___tds__GetSystemDateAndTime(struct soap *soap, struct __tds__GetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetSystemDateAndTime * SOAP_FMAC2 soap_instantiate___tds__GetSystemDateAndTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetSystemDateAndTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetSystemDateAndTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetSystemDateAndTime);
		if (size)
			*size = sizeof(struct __tds__GetSystemDateAndTime);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetSystemDateAndTime, n);
		if (size)
			*size = n * sizeof(struct __tds__GetSystemDateAndTime);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetSystemDateAndTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetSystemDateAndTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetSystemDateAndTime %p -> %p\n", q, p));
	*(struct __tds__GetSystemDateAndTime*)p = *(struct __tds__GetSystemDateAndTime*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__SetSystemDateAndTime(struct soap *soap, struct __tds__SetSystemDateAndTime *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__SetSystemDateAndTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__SetSystemDateAndTime(struct soap *soap, const struct __tds__SetSystemDateAndTime *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__SetSystemDateAndTime(soap, &a->tds__SetSystemDateAndTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, const struct __tds__SetSystemDateAndTime *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__SetSystemDateAndTime(soap, "tds:SetSystemDateAndTime", -1, &a->tds__SetSystemDateAndTime, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemDateAndTime * SOAP_FMAC4 soap_in___tds__SetSystemDateAndTime(struct soap *soap, const char *tag, struct __tds__SetSystemDateAndTime *a, const char *type)
{
	size_t soap_flag_tds__SetSystemDateAndTime = 1;
	short soap_flag;
	a = (struct __tds__SetSystemDateAndTime *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__SetSystemDateAndTime, sizeof(struct __tds__SetSystemDateAndTime), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__SetSystemDateAndTime(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__SetSystemDateAndTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__SetSystemDateAndTime(soap, "tds:SetSystemDateAndTime", &a->tds__SetSystemDateAndTime, ""))
				{	soap_flag_tds__SetSystemDateAndTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__SetSystemDateAndTime(struct soap *soap, const struct __tds__SetSystemDateAndTime *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__SetSystemDateAndTime(soap, tag?tag:"-tds:SetSystemDateAndTime", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__SetSystemDateAndTime * SOAP_FMAC4 soap_get___tds__SetSystemDateAndTime(struct soap *soap, struct __tds__SetSystemDateAndTime *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__SetSystemDateAndTime * SOAP_FMAC2 soap_instantiate___tds__SetSystemDateAndTime(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__SetSystemDateAndTime(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__SetSystemDateAndTime, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__SetSystemDateAndTime);
		if (size)
			*size = sizeof(struct __tds__SetSystemDateAndTime);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__SetSystemDateAndTime, n);
		if (size)
			*size = n * sizeof(struct __tds__SetSystemDateAndTime);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__SetSystemDateAndTime*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__SetSystemDateAndTime(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__SetSystemDateAndTime %p -> %p\n", q, p));
	*(struct __tds__SetSystemDateAndTime*)p = *(struct __tds__SetSystemDateAndTime*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetDeviceInformation(struct soap *soap, struct __tds__GetDeviceInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetDeviceInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetDeviceInformation(struct soap *soap, const struct __tds__GetDeviceInformation *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetDeviceInformation(soap, &a->tds__GetDeviceInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, const struct __tds__GetDeviceInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetDeviceInformation(soap, "tds:GetDeviceInformation", -1, &a->tds__GetDeviceInformation, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDeviceInformation * SOAP_FMAC4 soap_in___tds__GetDeviceInformation(struct soap *soap, const char *tag, struct __tds__GetDeviceInformation *a, const char *type)
{
	size_t soap_flag_tds__GetDeviceInformation = 1;
	short soap_flag;
	a = (struct __tds__GetDeviceInformation *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetDeviceInformation, sizeof(struct __tds__GetDeviceInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetDeviceInformation(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetDeviceInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetDeviceInformation(soap, "tds:GetDeviceInformation", &a->tds__GetDeviceInformation, ""))
				{	soap_flag_tds__GetDeviceInformation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetDeviceInformation(struct soap *soap, const struct __tds__GetDeviceInformation *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetDeviceInformation(soap, tag?tag:"-tds:GetDeviceInformation", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetDeviceInformation * SOAP_FMAC4 soap_get___tds__GetDeviceInformation(struct soap *soap, struct __tds__GetDeviceInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetDeviceInformation * SOAP_FMAC2 soap_instantiate___tds__GetDeviceInformation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetDeviceInformation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetDeviceInformation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetDeviceInformation);
		if (size)
			*size = sizeof(struct __tds__GetDeviceInformation);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetDeviceInformation, n);
		if (size)
			*size = n * sizeof(struct __tds__GetDeviceInformation);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetDeviceInformation*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetDeviceInformation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetDeviceInformation %p -> %p\n", q, p));
	*(struct __tds__GetDeviceInformation*)p = *(struct __tds__GetDeviceInformation*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetServiceCapabilities(struct soap *soap, struct __tds__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetServiceCapabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetServiceCapabilities(struct soap *soap, const struct __tds__GetServiceCapabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetServiceCapabilities(soap, &a->tds__GetServiceCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct __tds__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetServiceCapabilities(soap, "tds:GetServiceCapabilities", -1, &a->tds__GetServiceCapabilities, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServiceCapabilities * SOAP_FMAC4 soap_in___tds__GetServiceCapabilities(struct soap *soap, const char *tag, struct __tds__GetServiceCapabilities *a, const char *type)
{
	size_t soap_flag_tds__GetServiceCapabilities = 1;
	short soap_flag;
	a = (struct __tds__GetServiceCapabilities *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetServiceCapabilities, sizeof(struct __tds__GetServiceCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetServiceCapabilities(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetServiceCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetServiceCapabilities(soap, "tds:GetServiceCapabilities", &a->tds__GetServiceCapabilities, ""))
				{	soap_flag_tds__GetServiceCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetServiceCapabilities(struct soap *soap, const struct __tds__GetServiceCapabilities *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetServiceCapabilities(soap, tag?tag:"-tds:GetServiceCapabilities", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServiceCapabilities * SOAP_FMAC4 soap_get___tds__GetServiceCapabilities(struct soap *soap, struct __tds__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetServiceCapabilities * SOAP_FMAC2 soap_instantiate___tds__GetServiceCapabilities(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetServiceCapabilities(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetServiceCapabilities, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetServiceCapabilities);
		if (size)
			*size = sizeof(struct __tds__GetServiceCapabilities);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetServiceCapabilities, n);
		if (size)
			*size = n * sizeof(struct __tds__GetServiceCapabilities);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetServiceCapabilities*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetServiceCapabilities(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetServiceCapabilities %p -> %p\n", q, p));
	*(struct __tds__GetServiceCapabilities*)p = *(struct __tds__GetServiceCapabilities*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tds__GetServices(struct soap *soap, struct __tds__GetServices *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->tds__GetServices = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tds__GetServices(struct soap *soap, const struct __tds__GetServices *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_tds__GetServices(soap, &a->tds__GetServices);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tds__GetServices(struct soap *soap, const char *tag, int id, const struct __tds__GetServices *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTo_tds__GetServices(soap, "tds:GetServices", -1, &a->tds__GetServices, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServices * SOAP_FMAC4 soap_in___tds__GetServices(struct soap *soap, const char *tag, struct __tds__GetServices *a, const char *type)
{
	size_t soap_flag_tds__GetServices = 1;
	short soap_flag;
	a = (struct __tds__GetServices *)soap_id_enter(soap, "", a, SOAP_TYPE___tds__GetServices, sizeof(struct __tds__GetServices), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tds__GetServices(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_tds__GetServices && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetServices(soap, "tds:GetServices", &a->tds__GetServices, ""))
				{	soap_flag_tds__GetServices--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tds__GetServices(struct soap *soap, const struct __tds__GetServices *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tds__GetServices(soap, tag?tag:"-tds:GetServices", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tds__GetServices * SOAP_FMAC4 soap_get___tds__GetServices(struct soap *soap, struct __tds__GetServices *p, const char *tag, const char *type)
{
	if ((p = soap_in___tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __tds__GetServices * SOAP_FMAC2 soap_instantiate___tds__GetServices(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___tds__GetServices(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___tds__GetServices, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __tds__GetServices);
		if (size)
			*size = sizeof(struct __tds__GetServices);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __tds__GetServices, n);
		if (size)
			*size = n * sizeof(struct __tds__GetServices);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __tds__GetServices*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___tds__GetServices(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __tds__GetServices %p -> %p\n", q, p));
	*(struct __tds__GetServices*)p = *(struct __tds__GetServices*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___dn__Probe(struct soap *soap, struct __dn__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__ProbeType(soap, &a->dn__Probe);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___dn__Probe(struct soap *soap, const struct __dn__Probe *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->dn__Probe, SOAP_TYPE_wsdd__ProbeType);
	soap_serialize_wsdd__ProbeType(soap, &a->dn__Probe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___dn__Probe(struct soap *soap, const char *tag, int id, const struct __dn__Probe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_wsdd__ProbeType(soap, "dn:Probe", -1, &a->dn__Probe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __dn__Probe * SOAP_FMAC4 soap_in___dn__Probe(struct soap *soap, const char *tag, struct __dn__Probe *a, const char *type)
{
	size_t soap_flag_dn__Probe = 1;
	short soap_flag;
	a = (struct __dn__Probe *)soap_id_enter(soap, "", a, SOAP_TYPE___dn__Probe, sizeof(struct __dn__Probe), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___dn__Probe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dn__Probe && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsdd__ProbeType(soap, "dn:Probe", &a->dn__Probe, "wsdd:ProbeType"))
				{	soap_flag_dn__Probe--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dn__Probe > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___dn__Probe(struct soap *soap, const struct __dn__Probe *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___dn__Probe(soap, tag?tag:"-dn:Probe", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __dn__Probe * SOAP_FMAC4 soap_get___dn__Probe(struct soap *soap, struct __dn__Probe *p, const char *tag, const char *type)
{
	if ((p = soap_in___dn__Probe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __dn__Probe * SOAP_FMAC2 soap_instantiate___dn__Probe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___dn__Probe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___dn__Probe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __dn__Probe);
		if (size)
			*size = sizeof(struct __dn__Probe);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __dn__Probe, n);
		if (size)
			*size = n * sizeof(struct __dn__Probe);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __dn__Probe*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___dn__Probe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __dn__Probe %p -> %p\n", q, p));
	*(struct __dn__Probe*)p = *(struct __dn__Probe*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___dn__Bye(struct soap *soap, struct __dn__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__ByeType(soap, &a->dn__Bye);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___dn__Bye(struct soap *soap, const struct __dn__Bye *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->dn__Bye, SOAP_TYPE_wsdd__ByeType);
	soap_serialize_wsdd__ByeType(soap, &a->dn__Bye);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___dn__Bye(struct soap *soap, const char *tag, int id, const struct __dn__Bye *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_wsdd__ByeType(soap, "dn:Bye", -1, &a->dn__Bye, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __dn__Bye * SOAP_FMAC4 soap_in___dn__Bye(struct soap *soap, const char *tag, struct __dn__Bye *a, const char *type)
{
	size_t soap_flag_dn__Bye = 1;
	short soap_flag;
	a = (struct __dn__Bye *)soap_id_enter(soap, "", a, SOAP_TYPE___dn__Bye, sizeof(struct __dn__Bye), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___dn__Bye(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dn__Bye && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsdd__ByeType(soap, "dn:Bye", &a->dn__Bye, "wsdd:ByeType"))
				{	soap_flag_dn__Bye--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dn__Bye > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___dn__Bye(struct soap *soap, const struct __dn__Bye *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___dn__Bye(soap, tag?tag:"-dn:Bye", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __dn__Bye * SOAP_FMAC4 soap_get___dn__Bye(struct soap *soap, struct __dn__Bye *p, const char *tag, const char *type)
{
	if ((p = soap_in___dn__Bye(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __dn__Bye * SOAP_FMAC2 soap_instantiate___dn__Bye(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___dn__Bye(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___dn__Bye, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __dn__Bye);
		if (size)
			*size = sizeof(struct __dn__Bye);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __dn__Bye, n);
		if (size)
			*size = n * sizeof(struct __dn__Bye);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __dn__Bye*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___dn__Bye(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __dn__Bye %p -> %p\n", q, p));
	*(struct __dn__Bye*)p = *(struct __dn__Bye*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___dn__Hello(struct soap *soap, struct __dn__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__HelloType(soap, &a->dn__Hello);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___dn__Hello(struct soap *soap, const struct __dn__Hello *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->dn__Hello, SOAP_TYPE_wsdd__HelloType);
	soap_serialize_wsdd__HelloType(soap, &a->dn__Hello);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___dn__Hello(struct soap *soap, const char *tag, int id, const struct __dn__Hello *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_wsdd__HelloType(soap, "dn:Hello", -1, &a->dn__Hello, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __dn__Hello * SOAP_FMAC4 soap_in___dn__Hello(struct soap *soap, const char *tag, struct __dn__Hello *a, const char *type)
{
	size_t soap_flag_dn__Hello = 1;
	short soap_flag;
	a = (struct __dn__Hello *)soap_id_enter(soap, "", a, SOAP_TYPE___dn__Hello, sizeof(struct __dn__Hello), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___dn__Hello(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_dn__Hello && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsdd__HelloType(soap, "dn:Hello", &a->dn__Hello, "wsdd:HelloType"))
				{	soap_flag_dn__Hello--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_dn__Hello > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___dn__Hello(struct soap *soap, const struct __dn__Hello *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___dn__Hello(soap, tag?tag:"-dn:Hello", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __dn__Hello * SOAP_FMAC4 soap_get___dn__Hello(struct soap *soap, struct __dn__Hello *p, const char *tag, const char *type)
{
	if ((p = soap_in___dn__Hello(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __dn__Hello * SOAP_FMAC2 soap_instantiate___dn__Hello(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___dn__Hello(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___dn__Hello, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __dn__Hello);
		if (size)
			*size = sizeof(struct __dn__Hello);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __dn__Hello, n);
		if (size)
			*size = n * sizeof(struct __dn__Hello);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __dn__Hello*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___dn__Hello(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __dn__Hello %p -> %p\n", q, p));
	*(struct __dn__Hello*)p = *(struct __dn__Hello*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SOAP_ENV__Header = NULL;
	a->SOAP_ENV__Body = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Envelope(struct soap *soap, const struct SOAP_ENV__Envelope *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToSOAP_ENV__Header(soap, &a->SOAP_ENV__Header);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Envelope(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Envelope *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Envelope), type))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Header(soap, "SOAP-ENV:Header", -1, &a->SOAP_ENV__Header, ""))
		return soap->error;
	soap_outliteral(soap, "SOAP-ENV:Body", &a->SOAP_ENV__Body, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope * SOAP_FMAC4 soap_in_SOAP_ENV__Envelope(struct soap *soap, const char *tag, struct SOAP_ENV__Envelope *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Header = 1;
	size_t soap_flag_SOAP_ENV__Body = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Envelope *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Envelope, sizeof(struct SOAP_ENV__Envelope), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Envelope(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Header && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Header(soap, "SOAP-ENV:Header", &a->SOAP_ENV__Header, ""))
				{	soap_flag_SOAP_ENV__Header--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Body && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "SOAP-ENV:Body", &a->SOAP_ENV__Body))
				{	soap_flag_SOAP_ENV__Body--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Envelope *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Envelope, 0, sizeof(struct SOAP_ENV__Envelope), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Envelope(struct soap *soap, const struct SOAP_ENV__Envelope *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Envelope);
	if (soap_out_SOAP_ENV__Envelope(soap, tag?tag:"SOAP-ENV:Envelope", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Envelope * SOAP_FMAC4 soap_get_SOAP_ENV__Envelope(struct soap *soap, struct SOAP_ENV__Envelope *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Envelope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Envelope * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Envelope(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Envelope(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Envelope, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Envelope);
		if (size)
			*size = sizeof(struct SOAP_ENV__Envelope);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Envelope, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Envelope);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Envelope*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Envelope(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Envelope %p -> %p\n", q, p));
	*(struct SOAP_ENV__Envelope*)p = *(struct SOAP_ENV__Envelope*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_int(soap, &a->__item);
	a->wsa5__IsReferenceParameter = (enum _wsa5__IsReferenceParameter)0;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->__item, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_chan__ChannelInstanceType(struct soap *soap, const char *tag, int id, const struct chan__ChannelInstanceType *a, const char *type)
{
	soap_set_attr(soap, "wsa5:IsReferenceParameter", soap__wsa5__IsReferenceParameter2s(soap, a->wsa5__IsReferenceParameter), 1);
	(void)soap; (void)tag; (void)id; (void)type;
	return soap_out_int(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_in_chan__ChannelInstanceType(struct soap *soap, const char *tag, struct chan__ChannelInstanceType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct chan__ChannelInstanceType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_chan__ChannelInstanceType, sizeof(struct chan__ChannelInstanceType), soap->type, soap->arrayType)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_chan__ChannelInstanceType(soap, a);
	if (soap_s2_wsa5__IsReferenceParameter(soap, soap_attr_value(soap, "wsa5:IsReferenceParameter", 0), &a->wsa5__IsReferenceParameter))
		return NULL;
	if (!soap_in_int(soap, tag, &a->__item, "chan:ChannelInstanceType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_chan__ChannelInstanceType(struct soap *soap, const struct chan__ChannelInstanceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_chan__ChannelInstanceType);
	if (soap_out_chan__ChannelInstanceType(soap, tag?tag:"chan:ChannelInstanceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct chan__ChannelInstanceType * SOAP_FMAC4 soap_get_chan__ChannelInstanceType(struct soap *soap, struct chan__ChannelInstanceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_chan__ChannelInstanceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct chan__ChannelInstanceType * SOAP_FMAC2 soap_instantiate_chan__ChannelInstanceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_chan__ChannelInstanceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_chan__ChannelInstanceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct chan__ChannelInstanceType);
		if (size)
			*size = sizeof(struct chan__ChannelInstanceType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct chan__ChannelInstanceType, n);
		if (size)
			*size = n * sizeof(struct chan__ChannelInstanceType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct chan__ChannelInstanceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_chan__ChannelInstanceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct chan__ChannelInstanceType %p -> %p\n", q, p));
	*(struct chan__ChannelInstanceType*)p = *(struct chan__ChannelInstanceType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Action);
	soap_default_string(soap, &a->SoapAction);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Action);
	soap_serialize_string(soap, &a->SoapAction);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ProblemActionType(struct soap *soap, const char *tag, int id, const struct wsa5__ProblemActionType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ProblemActionType), type))
		return soap->error;
	if (soap_out_string(soap, "wsa5:Action", -1, &a->Action, ""))
		return soap->error;
	if (soap_out_string(soap, "wsa5:SoapAction", -1, &a->SoapAction, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_in_wsa5__ProblemActionType(struct soap *soap, const char *tag, struct wsa5__ProblemActionType *a, const char *type)
{
	size_t soap_flag_Action = 1;
	size_t soap_flag_SoapAction = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__ProblemActionType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ProblemActionType, sizeof(struct wsa5__ProblemActionType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ProblemActionType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa5:Action", &a->Action, "xsd:string"))
				{	soap_flag_Action--;
					continue;
				}
			if (soap_flag_SoapAction && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa5:SoapAction", &a->SoapAction, "xsd:string"))
				{	soap_flag_SoapAction--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ProblemActionType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ProblemActionType, 0, sizeof(struct wsa5__ProblemActionType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ProblemActionType(struct soap *soap, const struct wsa5__ProblemActionType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__ProblemActionType);
	if (soap_out_wsa5__ProblemActionType(soap, tag?tag:"wsa5:ProblemActionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ProblemActionType * SOAP_FMAC4 soap_get_wsa5__ProblemActionType(struct soap *soap, struct wsa5__ProblemActionType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ProblemActionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__ProblemActionType * SOAP_FMAC2 soap_instantiate_wsa5__ProblemActionType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ProblemActionType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__ProblemActionType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__ProblemActionType);
		if (size)
			*size = sizeof(struct wsa5__ProblemActionType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsa5__ProblemActionType, n);
		if (size)
			*size = n * sizeof(struct wsa5__ProblemActionType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsa5__ProblemActionType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__ProblemActionType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__ProblemActionType %p -> %p\n", q, p));
	*(struct wsa5__ProblemActionType*)p = *(struct wsa5__ProblemActionType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_wsa5__RelationshipTypeOpenEnum(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__RelatesToType(struct soap *soap, const char *tag, int id, const struct wsa5__RelatesToType *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", a->RelationshipType, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_in_wsa5__RelatesToType(struct soap *soap, const char *tag, struct wsa5__RelatesToType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa5__RelatesToType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__RelatesToType, sizeof(struct wsa5__RelatesToType), soap->type, soap->arrayType)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa5__RelatesToType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "RelationshipType", 0), &a->RelationshipType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "wsa5:RelatesToType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__RelatesToType(struct soap *soap, const struct wsa5__RelatesToType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__RelatesToType);
	if (soap_out_wsa5__RelatesToType(soap, tag?tag:"wsa5:RelatesToType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__RelatesToType * SOAP_FMAC4 soap_get_wsa5__RelatesToType(struct soap *soap, struct wsa5__RelatesToType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__RelatesToType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__RelatesToType * SOAP_FMAC2 soap_instantiate_wsa5__RelatesToType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__RelatesToType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__RelatesToType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__RelatesToType);
		if (size)
			*size = sizeof(struct wsa5__RelatesToType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsa5__RelatesToType, n);
		if (size)
			*size = n * sizeof(struct wsa5__RelatesToType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsa5__RelatesToType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__RelatesToType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__RelatesToType %p -> %p\n", q, p));
	*(struct wsa5__RelatesToType*)p = *(struct wsa5__RelatesToType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__MetadataType(struct soap *soap, const char *tag, int id, const struct wsa5__MetadataType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__MetadataType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_in_wsa5__MetadataType(struct soap *soap, const char *tag, struct wsa5__MetadataType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__MetadataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__MetadataType, sizeof(struct wsa5__MetadataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__MetadataType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__MetadataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__MetadataType, 0, sizeof(struct wsa5__MetadataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__MetadataType(struct soap *soap, const struct wsa5__MetadataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__MetadataType);
	if (soap_out_wsa5__MetadataType(soap, tag?tag:"wsa5:MetadataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__MetadataType * SOAP_FMAC4 soap_get_wsa5__MetadataType(struct soap *soap, struct wsa5__MetadataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__MetadataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__MetadataType * SOAP_FMAC2 soap_instantiate_wsa5__MetadataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__MetadataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__MetadataType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__MetadataType);
		if (size)
			*size = sizeof(struct wsa5__MetadataType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsa5__MetadataType, n);
		if (size)
			*size = n * sizeof(struct wsa5__MetadataType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsa5__MetadataType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__MetadataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__MetadataType %p -> %p\n", q, p));
	*(struct wsa5__MetadataType*)p = *(struct wsa5__MetadataType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->chan__ChannelInstance = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa5__ReferenceParametersType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__ReferenceParametersType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa5__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa5__ReferenceParametersType *a, const char *type)
{
	size_t soap_flag_chan__ChannelInstance = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__ReferenceParametersType, sizeof(struct wsa5__ReferenceParametersType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__ReferenceParametersType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "xsd:int"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__ReferenceParametersType, 0, sizeof(struct wsa5__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__ReferenceParametersType(struct soap *soap, const struct wsa5__ReferenceParametersType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__ReferenceParametersType);
	if (soap_out_wsa5__ReferenceParametersType(soap, tag?tag:"wsa5:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa5__ReferenceParametersType(struct soap *soap, struct wsa5__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa5__ReferenceParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__ReferenceParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__ReferenceParametersType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__ReferenceParametersType);
		if (size)
			*size = sizeof(struct wsa5__ReferenceParametersType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsa5__ReferenceParametersType, n);
		if (size)
			*size = n * sizeof(struct wsa5__ReferenceParametersType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsa5__ReferenceParametersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__ReferenceParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__ReferenceParametersType %p -> %p\n", q, p));
	*(struct wsa5__ReferenceParametersType*)p = *(struct wsa5__ReferenceParametersType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceParameters = NULL;
	a->Metadata = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Address);
	soap_serialize_PointerTowsa5__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTowsa5__MetadataType(soap, &a->Metadata);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa5__EndpointReferenceType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa5__EndpointReferenceType), type))
		return soap->error;
	if (a->Address)
	{	if (soap_out_string(soap, "wsa5:Address", -1, &a->Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsa5:Address"))
		return soap->error;
	if (soap_out_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", -1, &a->Metadata, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa5__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa5__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_Metadata = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa5__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa5__EndpointReferenceType, sizeof(struct wsa5__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa5__EndpointReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa5:Address", &a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__ReferenceParametersType(soap, "wsa5:ReferenceParameters", &a->ReferenceParameters, "wsa5:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			if (soap_flag_Metadata && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__MetadataType(soap, "wsa5:Metadata", &a->Metadata, "wsa5:MetadataType"))
				{	soap_flag_Metadata--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa5__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa5__EndpointReferenceType, 0, sizeof(struct wsa5__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa5__EndpointReferenceType(struct soap *soap, const struct wsa5__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa5__EndpointReferenceType);
	if (soap_out_wsa5__EndpointReferenceType(soap, tag?tag:"wsa5:EndpointReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa5__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa5__EndpointReferenceType(struct soap *soap, struct wsa5__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa5__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa5__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa5__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa5__EndpointReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa5__EndpointReferenceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa5__EndpointReferenceType);
		if (size)
			*size = sizeof(struct wsa5__EndpointReferenceType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsa5__EndpointReferenceType, n);
		if (size)
			*size = n * sizeof(struct wsa5__EndpointReferenceType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsa5__EndpointReferenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa5__EndpointReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa5__EndpointReferenceType %p -> %p\n", q, p));
	*(struct wsa5__EndpointReferenceType*)p = *(struct wsa5__EndpointReferenceType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xop__Include(struct soap *soap, struct _xop__Include *a)
{	(void)soap;
	(void)soap; /* appease -Wall -Werror */
	a->__size = 0;
	a->__ptr = NULL;
	a->id = NULL;
	a->type = NULL;
	a->options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xop__Include(struct soap *soap, struct _xop__Include const*a)
{
#ifndef WITH_NOIDREF
	if (a->__ptr && !soap_array_reference(soap, a, (struct soap_array*)&a->__ptr, 1, SOAP_TYPE__xop__Include))
		if (a->id || a->type)
			soap->mode |= SOAP_ENC_DIME;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xop__Include(struct soap *soap, const char *tag, int id, const struct _xop__Include *a, const char *type)
{
#ifndef WITH_LEANER
	id = soap_attachment(soap, tag, id, a, (struct soap_array*)&a->__ptr, a->id, a->type, a->options, 1, type, SOAP_TYPE__xop__Include);
#else
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE__xop__Include);
#endif
	if (id < 0)
		return soap->error;
	if (soap_element_begin_out(soap, tag, id, type))
		return soap->error;
	if (soap_putbase64(soap, a->__ptr, a->__size))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_in__xop__Include(struct soap *soap, const char *tag, struct _xop__Include *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type) && soap_match_tag(soap, soap->type, ":base64Binary") && soap_match_tag(soap, soap->type, ":base64"))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (struct _xop__Include *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xop__Include, sizeof(struct _xop__Include), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xop__Include(soap, a);
	if (soap->body && !*soap->href)
	{
		a->__ptr = soap_getbase64(soap, &a->__size, 0);
#ifndef WITH_LEANER
		if (soap_xop_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
			return NULL;
#endif
		if ((!a->__ptr && soap->error) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	
#ifndef WITH_LEANER
		if (*soap->href != '#')
		{	if (soap_dime_forward(soap, &a->__ptr, &a->__size, &a->id, &a->type, &a->options))
				return NULL;
		}
		else
#endif
			a = (struct _xop__Include *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xop__Include, 0, sizeof(struct _xop__Include), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xop__Include(struct soap *soap, const struct _xop__Include *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, (struct soap_array*)&a->__ptr, 1, tag, SOAP_TYPE__xop__Include);
	if (soap_out__xop__Include(soap, tag?tag:"xop:Include", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xop__Include * SOAP_FMAC4 soap_get__xop__Include(struct soap *soap, struct _xop__Include *p, const char *tag, const char *type)
{
	if ((p = soap_in__xop__Include(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _xop__Include * SOAP_FMAC2 soap_instantiate__xop__Include(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__xop__Include(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__xop__Include, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _xop__Include);
		if (size)
			*size = sizeof(struct _xop__Include);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct _xop__Include, n);
		if (size)
			*size = n * sizeof(struct _xop__Include);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct _xop__Include*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__xop__Include(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _xop__Include %p -> %p\n", q, p));
	*(struct _xop__Include*)p = *(struct _xop__Include*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__ResolveMatches(struct soap *soap, struct __wsdd__ResolveMatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__ResolveMatches = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__ResolveMatches(struct soap *soap, const struct __wsdd__ResolveMatches *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsdd__ResolveMatchesType(soap, &a->wsdd__ResolveMatches);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__ResolveMatches(struct soap *soap, const char *tag, int id, const struct __wsdd__ResolveMatches *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTowsdd__ResolveMatchesType(soap, "wsdd:ResolveMatches", -1, &a->wsdd__ResolveMatches, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ResolveMatches * SOAP_FMAC4 soap_in___wsdd__ResolveMatches(struct soap *soap, const char *tag, struct __wsdd__ResolveMatches *a, const char *type)
{
	size_t soap_flag_wsdd__ResolveMatches = 1;
	short soap_flag;
	a = (struct __wsdd__ResolveMatches *)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__ResolveMatches, sizeof(struct __wsdd__ResolveMatches), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__ResolveMatches(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__ResolveMatches && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsdd__ResolveMatchesType(soap, "wsdd:ResolveMatches", &a->wsdd__ResolveMatches, "wsdd:ResolveMatchesType"))
				{	soap_flag_wsdd__ResolveMatches--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__ResolveMatches(struct soap *soap, const struct __wsdd__ResolveMatches *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wsdd__ResolveMatches(soap, tag?tag:"-wsdd:ResolveMatches", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ResolveMatches * SOAP_FMAC4 soap_get___wsdd__ResolveMatches(struct soap *soap, struct __wsdd__ResolveMatches *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__ResolveMatches(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __wsdd__ResolveMatches * SOAP_FMAC2 soap_instantiate___wsdd__ResolveMatches(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsdd__ResolveMatches(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___wsdd__ResolveMatches, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __wsdd__ResolveMatches);
		if (size)
			*size = sizeof(struct __wsdd__ResolveMatches);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __wsdd__ResolveMatches, n);
		if (size)
			*size = n * sizeof(struct __wsdd__ResolveMatches);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __wsdd__ResolveMatches*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___wsdd__ResolveMatches(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __wsdd__ResolveMatches %p -> %p\n", q, p));
	*(struct __wsdd__ResolveMatches*)p = *(struct __wsdd__ResolveMatches*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Resolve(struct soap *soap, struct __wsdd__Resolve *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Resolve = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Resolve(struct soap *soap, const struct __wsdd__Resolve *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsdd__ResolveType(soap, &a->wsdd__Resolve);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Resolve(struct soap *soap, const char *tag, int id, const struct __wsdd__Resolve *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTowsdd__ResolveType(soap, "wsdd:Resolve", -1, &a->wsdd__Resolve, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Resolve * SOAP_FMAC4 soap_in___wsdd__Resolve(struct soap *soap, const char *tag, struct __wsdd__Resolve *a, const char *type)
{
	size_t soap_flag_wsdd__Resolve = 1;
	short soap_flag;
	a = (struct __wsdd__Resolve *)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Resolve, sizeof(struct __wsdd__Resolve), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Resolve(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Resolve && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsdd__ResolveType(soap, "wsdd:Resolve", &a->wsdd__Resolve, "wsdd:ResolveType"))
				{	soap_flag_wsdd__Resolve--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Resolve(struct soap *soap, const struct __wsdd__Resolve *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wsdd__Resolve(soap, tag?tag:"-wsdd:Resolve", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Resolve * SOAP_FMAC4 soap_get___wsdd__Resolve(struct soap *soap, struct __wsdd__Resolve *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Resolve(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __wsdd__Resolve * SOAP_FMAC2 soap_instantiate___wsdd__Resolve(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsdd__Resolve(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___wsdd__Resolve, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __wsdd__Resolve);
		if (size)
			*size = sizeof(struct __wsdd__Resolve);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __wsdd__Resolve, n);
		if (size)
			*size = n * sizeof(struct __wsdd__Resolve);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __wsdd__Resolve*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___wsdd__Resolve(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __wsdd__Resolve %p -> %p\n", q, p));
	*(struct __wsdd__Resolve*)p = *(struct __wsdd__Resolve*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__ProbeMatches(struct soap *soap, struct __wsdd__ProbeMatches *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__ProbeMatches = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__ProbeMatches(struct soap *soap, const struct __wsdd__ProbeMatches *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsdd__ProbeMatchesType(soap, &a->wsdd__ProbeMatches);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__ProbeMatches(struct soap *soap, const char *tag, int id, const struct __wsdd__ProbeMatches *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTowsdd__ProbeMatchesType(soap, "wsdd:ProbeMatches", -1, &a->wsdd__ProbeMatches, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ProbeMatches * SOAP_FMAC4 soap_in___wsdd__ProbeMatches(struct soap *soap, const char *tag, struct __wsdd__ProbeMatches *a, const char *type)
{
	size_t soap_flag_wsdd__ProbeMatches = 1;
	short soap_flag;
	a = (struct __wsdd__ProbeMatches *)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__ProbeMatches, sizeof(struct __wsdd__ProbeMatches), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__ProbeMatches(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__ProbeMatches && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsdd__ProbeMatchesType(soap, "wsdd:ProbeMatches", &a->wsdd__ProbeMatches, "wsdd:ProbeMatchesType"))
				{	soap_flag_wsdd__ProbeMatches--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__ProbeMatches(struct soap *soap, const struct __wsdd__ProbeMatches *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wsdd__ProbeMatches(soap, tag?tag:"-wsdd:ProbeMatches", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__ProbeMatches * SOAP_FMAC4 soap_get___wsdd__ProbeMatches(struct soap *soap, struct __wsdd__ProbeMatches *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__ProbeMatches(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __wsdd__ProbeMatches * SOAP_FMAC2 soap_instantiate___wsdd__ProbeMatches(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsdd__ProbeMatches(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___wsdd__ProbeMatches, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __wsdd__ProbeMatches);
		if (size)
			*size = sizeof(struct __wsdd__ProbeMatches);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __wsdd__ProbeMatches, n);
		if (size)
			*size = n * sizeof(struct __wsdd__ProbeMatches);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __wsdd__ProbeMatches*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___wsdd__ProbeMatches(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __wsdd__ProbeMatches %p -> %p\n", q, p));
	*(struct __wsdd__ProbeMatches*)p = *(struct __wsdd__ProbeMatches*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Probe(struct soap *soap, struct __wsdd__Probe *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Probe = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Probe(struct soap *soap, const struct __wsdd__Probe *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsdd__ProbeType(soap, &a->wsdd__Probe);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Probe(struct soap *soap, const char *tag, int id, const struct __wsdd__Probe *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTowsdd__ProbeType(soap, "wsdd:Probe", -1, &a->wsdd__Probe, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Probe * SOAP_FMAC4 soap_in___wsdd__Probe(struct soap *soap, const char *tag, struct __wsdd__Probe *a, const char *type)
{
	size_t soap_flag_wsdd__Probe = 1;
	short soap_flag;
	a = (struct __wsdd__Probe *)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Probe, sizeof(struct __wsdd__Probe), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Probe(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Probe && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsdd__ProbeType(soap, "wsdd:Probe", &a->wsdd__Probe, "wsdd:ProbeType"))
				{	soap_flag_wsdd__Probe--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Probe(struct soap *soap, const struct __wsdd__Probe *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wsdd__Probe(soap, tag?tag:"-wsdd:Probe", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Probe * SOAP_FMAC4 soap_get___wsdd__Probe(struct soap *soap, struct __wsdd__Probe *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Probe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __wsdd__Probe * SOAP_FMAC2 soap_instantiate___wsdd__Probe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsdd__Probe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___wsdd__Probe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __wsdd__Probe);
		if (size)
			*size = sizeof(struct __wsdd__Probe);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __wsdd__Probe, n);
		if (size)
			*size = n * sizeof(struct __wsdd__Probe);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __wsdd__Probe*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___wsdd__Probe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __wsdd__Probe %p -> %p\n", q, p));
	*(struct __wsdd__Probe*)p = *(struct __wsdd__Probe*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Bye(struct soap *soap, struct __wsdd__Bye *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Bye = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Bye(struct soap *soap, const struct __wsdd__Bye *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsdd__ByeType(soap, &a->wsdd__Bye);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Bye(struct soap *soap, const char *tag, int id, const struct __wsdd__Bye *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTowsdd__ByeType(soap, "wsdd:Bye", -1, &a->wsdd__Bye, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Bye * SOAP_FMAC4 soap_in___wsdd__Bye(struct soap *soap, const char *tag, struct __wsdd__Bye *a, const char *type)
{
	size_t soap_flag_wsdd__Bye = 1;
	short soap_flag;
	a = (struct __wsdd__Bye *)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Bye, sizeof(struct __wsdd__Bye), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Bye(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Bye && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsdd__ByeType(soap, "wsdd:Bye", &a->wsdd__Bye, "wsdd:ByeType"))
				{	soap_flag_wsdd__Bye--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Bye(struct soap *soap, const struct __wsdd__Bye *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wsdd__Bye(soap, tag?tag:"-wsdd:Bye", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Bye * SOAP_FMAC4 soap_get___wsdd__Bye(struct soap *soap, struct __wsdd__Bye *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Bye(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __wsdd__Bye * SOAP_FMAC2 soap_instantiate___wsdd__Bye(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsdd__Bye(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___wsdd__Bye, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __wsdd__Bye);
		if (size)
			*size = sizeof(struct __wsdd__Bye);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __wsdd__Bye, n);
		if (size)
			*size = n * sizeof(struct __wsdd__Bye);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __wsdd__Bye*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___wsdd__Bye(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __wsdd__Bye %p -> %p\n", q, p));
	*(struct __wsdd__Bye*)p = *(struct __wsdd__Bye*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsdd__Hello(struct soap *soap, struct __wsdd__Hello *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsdd__Hello = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsdd__Hello(struct soap *soap, const struct __wsdd__Hello *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsdd__HelloType(soap, &a->wsdd__Hello);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsdd__Hello(struct soap *soap, const char *tag, int id, const struct __wsdd__Hello *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerTowsdd__HelloType(soap, "wsdd:Hello", -1, &a->wsdd__Hello, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Hello * SOAP_FMAC4 soap_in___wsdd__Hello(struct soap *soap, const char *tag, struct __wsdd__Hello *a, const char *type)
{
	size_t soap_flag_wsdd__Hello = 1;
	short soap_flag;
	a = (struct __wsdd__Hello *)soap_id_enter(soap, "", a, SOAP_TYPE___wsdd__Hello, sizeof(struct __wsdd__Hello), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsdd__Hello(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsdd__Hello && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsdd__HelloType(soap, "wsdd:Hello", &a->wsdd__Hello, "wsdd:HelloType"))
				{	soap_flag_wsdd__Hello--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsdd__Hello(struct soap *soap, const struct __wsdd__Hello *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wsdd__Hello(soap, tag?tag:"-wsdd:Hello", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsdd__Hello * SOAP_FMAC4 soap_get___wsdd__Hello(struct soap *soap, struct __wsdd__Hello *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsdd__Hello(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __wsdd__Hello * SOAP_FMAC2 soap_instantiate___wsdd__Hello(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsdd__Hello(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___wsdd__Hello, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __wsdd__Hello);
		if (size)
			*size = sizeof(struct __wsdd__Hello);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __wsdd__Hello, n);
		if (size)
			*size = n * sizeof(struct __wsdd__Hello);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __wsdd__Hello*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___wsdd__Hello(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __wsdd__Hello %p -> %p\n", q, p));
	*(struct __wsdd__Hello*)p = *(struct __wsdd__Hello*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_unsignedInt(soap, &a->InstanceId);
	soap_default_string(soap, &a->SequenceId);
	soap_default_unsignedInt(soap, &a->MessageNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__AppSequenceType(struct soap *soap, const struct wsdd__AppSequenceType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__AppSequenceType(struct soap *soap, const char *tag, int id, const struct wsdd__AppSequenceType *a, const char *type)
{
	soap_set_attr(soap, "InstanceId", soap_unsignedInt2s(soap, a->InstanceId), 1);
	if (a->SequenceId)
		soap_set_attr(soap, "SequenceId", a->SequenceId, 1);
	soap_set_attr(soap, "MessageNumber", soap_unsignedInt2s(soap, a->MessageNumber), 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__AppSequenceType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__AppSequenceType * SOAP_FMAC4 soap_in_wsdd__AppSequenceType(struct soap *soap, const char *tag, struct wsdd__AppSequenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsdd__AppSequenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__AppSequenceType, sizeof(struct wsdd__AppSequenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__AppSequenceType(soap, a);
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "InstanceId", 1), &a->InstanceId))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SequenceId", 0), &a->SequenceId, 0, -1))
		return NULL;
	if (soap_s2unsignedInt(soap, soap_attr_value(soap, "MessageNumber", 1), &a->MessageNumber))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__AppSequenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__AppSequenceType, 0, sizeof(struct wsdd__AppSequenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__AppSequenceType(struct soap *soap, const struct wsdd__AppSequenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsdd__AppSequenceType);
	if (soap_out_wsdd__AppSequenceType(soap, tag?tag:"wsdd:AppSequenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__AppSequenceType * SOAP_FMAC4 soap_get_wsdd__AppSequenceType(struct soap *soap, struct wsdd__AppSequenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__AppSequenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsdd__AppSequenceType * SOAP_FMAC2 soap_instantiate_wsdd__AppSequenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__AppSequenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsdd__AppSequenceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsdd__AppSequenceType);
		if (size)
			*size = sizeof(struct wsdd__AppSequenceType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsdd__AppSequenceType, n);
		if (size)
			*size = n * sizeof(struct wsdd__AppSequenceType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsdd__AppSequenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsdd__AppSequenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsdd__AppSequenceType %p -> %p\n", q, p));
	*(struct wsdd__AppSequenceType*)p = *(struct wsdd__AppSequenceType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__SigType(struct soap *soap, struct wsdd__SigType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Scheme);
	soap_default_string(soap, &a->KeyId);
	soap_default_string(soap, &a->Refs);
	soap_default_string(soap, &a->Sig);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__SigType(struct soap *soap, const struct wsdd__SigType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__SigType(struct soap *soap, const char *tag, int id, const struct wsdd__SigType *a, const char *type)
{
	if (a->Scheme)
		soap_set_attr(soap, "Scheme", a->Scheme, 1);
	if (a->KeyId)
		soap_set_attr(soap, "KeyId", a->KeyId, 1);
	if (a->Refs)
		soap_set_attr(soap, "Refs", a->Refs, 1);
	if (a->Sig)
		soap_set_attr(soap, "Sig", a->Sig, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__SigType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__SigType * SOAP_FMAC4 soap_in_wsdd__SigType(struct soap *soap, const char *tag, struct wsdd__SigType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsdd__SigType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__SigType, sizeof(struct wsdd__SigType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__SigType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Scheme", 1), &a->Scheme, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "KeyId", 0), &a->KeyId, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Refs", 1), &a->Refs, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Sig", 1), &a->Sig, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__SigType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__SigType, 0, sizeof(struct wsdd__SigType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__SigType(struct soap *soap, const struct wsdd__SigType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsdd__SigType);
	if (soap_out_wsdd__SigType(soap, tag?tag:"wsdd:SigType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__SigType * SOAP_FMAC4 soap_get_wsdd__SigType(struct soap *soap, struct wsdd__SigType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__SigType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsdd__SigType * SOAP_FMAC2 soap_instantiate_wsdd__SigType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__SigType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsdd__SigType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsdd__SigType);
		if (size)
			*size = sizeof(struct wsdd__SigType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsdd__SigType, n);
		if (size)
			*size = n * sizeof(struct wsdd__SigType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsdd__SigType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsdd__SigType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsdd__SigType %p -> %p\n", q, p));
	*(struct wsdd__SigType*)p = *(struct wsdd__SigType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__SecurityType(struct soap *soap, struct wsdd__SecurityType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Sig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__SecurityType(struct soap *soap, const struct wsdd__SecurityType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsdd__SigType(soap, &a->Sig);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__SecurityType(struct soap *soap, const char *tag, int id, const struct wsdd__SecurityType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__SecurityType), type))
		return soap->error;
	if (soap_out_PointerTowsdd__SigType(soap, "wsdd:Sig", -1, &a->Sig, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__SecurityType * SOAP_FMAC4 soap_in_wsdd__SecurityType(struct soap *soap, const char *tag, struct wsdd__SecurityType *a, const char *type)
{
	size_t soap_flag_Sig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsdd__SecurityType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__SecurityType, sizeof(struct wsdd__SecurityType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__SecurityType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Sig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsdd__SigType(soap, "wsdd:Sig", &a->Sig, "wsdd:SigType"))
				{	soap_flag_Sig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__SecurityType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__SecurityType, 0, sizeof(struct wsdd__SecurityType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__SecurityType(struct soap *soap, const struct wsdd__SecurityType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsdd__SecurityType);
	if (soap_out_wsdd__SecurityType(soap, tag?tag:"wsdd:SecurityType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__SecurityType * SOAP_FMAC4 soap_get_wsdd__SecurityType(struct soap *soap, struct wsdd__SecurityType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__SecurityType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsdd__SecurityType * SOAP_FMAC2 soap_instantiate_wsdd__SecurityType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__SecurityType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsdd__SecurityType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsdd__SecurityType);
		if (size)
			*size = sizeof(struct wsdd__SecurityType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsdd__SecurityType, n);
		if (size)
			*size = n * sizeof(struct wsdd__SecurityType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsdd__SecurityType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsdd__SecurityType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsdd__SecurityType %p -> %p\n", q, p));
	*(struct wsdd__SecurityType*)p = *(struct wsdd__SecurityType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__UriListType(soap, &a->__item);
	soap_default_string(soap, &a->MatchBy);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ScopesType(struct soap *soap, const struct wsdd__ScopesType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wsdd__UriListType(soap, &a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ScopesType(struct soap *soap, const char *tag, int id, const struct wsdd__ScopesType *a, const char *type)
{
	if (a->MatchBy)
		soap_set_attr(soap, "MatchBy", a->MatchBy, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	return soap_out_wsdd__UriListType(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsdd__ScopesType * SOAP_FMAC4 soap_in_wsdd__ScopesType(struct soap *soap, const char *tag, struct wsdd__ScopesType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsdd__ScopesType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ScopesType, sizeof(struct wsdd__ScopesType), soap->type, soap->arrayType)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsdd__ScopesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "MatchBy", 0), &a->MatchBy, 0, -1))
		return NULL;
	if (!soap_in_wsdd__UriListType(soap, tag, &a->__item, "wsdd:ScopesType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ScopesType(struct soap *soap, const struct wsdd__ScopesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsdd__ScopesType);
	if (soap_out_wsdd__ScopesType(soap, tag?tag:"wsdd:ScopesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ScopesType * SOAP_FMAC4 soap_get_wsdd__ScopesType(struct soap *soap, struct wsdd__ScopesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ScopesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsdd__ScopesType * SOAP_FMAC2 soap_instantiate_wsdd__ScopesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__ScopesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsdd__ScopesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsdd__ScopesType);
		if (size)
			*size = sizeof(struct wsdd__ScopesType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsdd__ScopesType, n);
		if (size)
			*size = n * sizeof(struct wsdd__ScopesType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsdd__ScopesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsdd__ScopesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsdd__ScopesType %p -> %p\n", q, p));
	*(struct wsdd__ScopesType*)p = *(struct wsdd__ScopesType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ResolveMatchType(struct soap *soap, const struct wsdd__ResolveMatchType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, &a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, &a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ResolveMatchType(struct soap *soap, const char *tag, int id, const struct wsdd__ResolveMatchType *a, const char *type)
{
	const char *soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ResolveMatchType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, &a->XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType * SOAP_FMAC4 soap_in_wsdd__ResolveMatchType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsdd__ResolveMatchType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ResolveMatchType, sizeof(struct wsdd__ResolveMatchType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ResolveMatchType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", &a->Types, "wsdd:QNameListType"))
				{	soap_flag_Types--;
					continue;
				}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", &a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ResolveMatchType, 0, sizeof(struct wsdd__ResolveMatchType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ResolveMatchType(struct soap *soap, const struct wsdd__ResolveMatchType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsdd__ResolveMatchType);
	if (soap_out_wsdd__ResolveMatchType(soap, tag?tag:"wsdd:ResolveMatchType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchType * SOAP_FMAC4 soap_get_wsdd__ResolveMatchType(struct soap *soap, struct wsdd__ResolveMatchType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ResolveMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsdd__ResolveMatchType * SOAP_FMAC2 soap_instantiate_wsdd__ResolveMatchType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__ResolveMatchType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsdd__ResolveMatchType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsdd__ResolveMatchType);
		if (size)
			*size = sizeof(struct wsdd__ResolveMatchType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsdd__ResolveMatchType, n);
		if (size)
			*size = n * sizeof(struct wsdd__ResolveMatchType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsdd__ResolveMatchType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsdd__ResolveMatchType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsdd__ResolveMatchType %p -> %p\n", q, p));
	*(struct wsdd__ResolveMatchType*)p = *(struct wsdd__ResolveMatchType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ResolveMatch = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ResolveMatchesType(struct soap *soap, const struct wsdd__ResolveMatchesType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsdd__ResolveMatchType(soap, &a->ResolveMatch);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ResolveMatchesType(struct soap *soap, const char *tag, int id, const struct wsdd__ResolveMatchesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ResolveMatchesType), type))
		return soap->error;
	if (soap_out_PointerTowsdd__ResolveMatchType(soap, "wsdd:ResolveMatch", -1, &a->ResolveMatch, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType * SOAP_FMAC4 soap_in_wsdd__ResolveMatchesType(struct soap *soap, const char *tag, struct wsdd__ResolveMatchesType *a, const char *type)
{
	size_t soap_flag_ResolveMatch = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsdd__ResolveMatchesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ResolveMatchesType, sizeof(struct wsdd__ResolveMatchesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ResolveMatchesType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResolveMatch && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsdd__ResolveMatchType(soap, "wsdd:ResolveMatch", &a->ResolveMatch, "wsdd:ResolveMatchType"))
				{	soap_flag_ResolveMatch--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveMatchesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ResolveMatchesType, 0, sizeof(struct wsdd__ResolveMatchesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ResolveMatchesType(struct soap *soap, const struct wsdd__ResolveMatchesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsdd__ResolveMatchesType);
	if (soap_out_wsdd__ResolveMatchesType(soap, tag?tag:"wsdd:ResolveMatchesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveMatchesType * SOAP_FMAC4 soap_get_wsdd__ResolveMatchesType(struct soap *soap, struct wsdd__ResolveMatchesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ResolveMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsdd__ResolveMatchesType * SOAP_FMAC2 soap_instantiate_wsdd__ResolveMatchesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__ResolveMatchesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsdd__ResolveMatchesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsdd__ResolveMatchesType);
		if (size)
			*size = sizeof(struct wsdd__ResolveMatchesType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsdd__ResolveMatchesType, n);
		if (size)
			*size = n * sizeof(struct wsdd__ResolveMatchesType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsdd__ResolveMatchesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsdd__ResolveMatchesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsdd__ResolveMatchesType %p -> %p\n", q, p));
	*(struct wsdd__ResolveMatchesType*)p = *(struct wsdd__ResolveMatchesType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ResolveType(struct soap *soap, const struct wsdd__ResolveType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ResolveType(struct soap *soap, const char *tag, int id, const struct wsdd__ResolveType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ResolveType), type))
		return soap->error;
	soap_element_result(soap, "wsa:EndpointReference");
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ResolveType * SOAP_FMAC4 soap_in_wsdd__ResolveType(struct soap *soap, const char *tag, struct wsdd__ResolveType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsdd__ResolveType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ResolveType, sizeof(struct wsdd__ResolveType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ResolveType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			soap_check_result(soap, "wsa:EndpointReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__ResolveType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ResolveType, 0, sizeof(struct wsdd__ResolveType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ResolveType(struct soap *soap, const struct wsdd__ResolveType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsdd__ResolveType);
	if (soap_out_wsdd__ResolveType(soap, tag?tag:"wsdd:ResolveType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ResolveType * SOAP_FMAC4 soap_get_wsdd__ResolveType(struct soap *soap, struct wsdd__ResolveType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ResolveType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsdd__ResolveType * SOAP_FMAC2 soap_instantiate_wsdd__ResolveType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__ResolveType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsdd__ResolveType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsdd__ResolveType);
		if (size)
			*size = sizeof(struct wsdd__ResolveType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsdd__ResolveType, n);
		if (size)
			*size = n * sizeof(struct wsdd__ResolveType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsdd__ResolveType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsdd__ResolveType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsdd__ResolveType %p -> %p\n", q, p));
	*(struct wsdd__ResolveType*)p = *(struct wsdd__ResolveType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ProbeMatchType(struct soap *soap, const struct wsdd__ProbeMatchType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, &a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, &a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ProbeMatchType(struct soap *soap, const char *tag, int id, const struct wsdd__ProbeMatchType *a, const char *type)
{
	const char *soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ProbeMatchType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, &a->XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType * SOAP_FMAC4 soap_in_wsdd__ProbeMatchType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsdd__ProbeMatchType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ProbeMatchType, sizeof(struct wsdd__ProbeMatchType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ProbeMatchType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", &a->Types, "wsdd:QNameListType"))
				{	soap_flag_Types--;
					continue;
				}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", &a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ProbeMatchType, 0, sizeof(struct wsdd__ProbeMatchType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ProbeMatchType(struct soap *soap, const struct wsdd__ProbeMatchType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsdd__ProbeMatchType);
	if (soap_out_wsdd__ProbeMatchType(soap, tag?tag:"wsdd:ProbeMatchType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchType * SOAP_FMAC4 soap_get_wsdd__ProbeMatchType(struct soap *soap, struct wsdd__ProbeMatchType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ProbeMatchType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsdd__ProbeMatchType * SOAP_FMAC2 soap_instantiate_wsdd__ProbeMatchType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__ProbeMatchType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsdd__ProbeMatchType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsdd__ProbeMatchType);
		if (size)
			*size = sizeof(struct wsdd__ProbeMatchType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsdd__ProbeMatchType, n);
		if (size)
			*size = n * sizeof(struct wsdd__ProbeMatchType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsdd__ProbeMatchType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsdd__ProbeMatchType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsdd__ProbeMatchType %p -> %p\n", q, p));
	*(struct wsdd__ProbeMatchType*)p = *(struct wsdd__ProbeMatchType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeProbeMatch = 0;
	a->ProbeMatch = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ProbeMatchesType(struct soap *soap, const struct wsdd__ProbeMatchesType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->ProbeMatch)
	{	int i;
		for (i = 0; i < a->__sizeProbeMatch; i++)
		{
			soap_embedded(soap, a->ProbeMatch + i, SOAP_TYPE_wsdd__ProbeMatchType);
			soap_serialize_wsdd__ProbeMatchType(soap, a->ProbeMatch + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ProbeMatchesType(struct soap *soap, const char *tag, int id, const struct wsdd__ProbeMatchesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ProbeMatchesType), type))
		return soap->error;
	soap_element_result(soap, "-sizeProbeMatch");
	if (a->ProbeMatch)
	{	int i;
		for (i = 0; i < a->__sizeProbeMatch; i++)
			if (soap_out_wsdd__ProbeMatchType(soap, "wsdd:ProbeMatch", -1, a->ProbeMatch + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType * SOAP_FMAC4 soap_in_wsdd__ProbeMatchesType(struct soap *soap, const char *tag, struct wsdd__ProbeMatchesType *a, const char *type)
{
	struct soap_blist *soap_blist_ProbeMatch = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsdd__ProbeMatchesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ProbeMatchesType, sizeof(struct wsdd__ProbeMatchesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ProbeMatchesType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsdd:ProbeMatch", 1, NULL))
			{	if (a->ProbeMatch == NULL)
				{	if (soap_blist_ProbeMatch == NULL)
						soap_blist_ProbeMatch = soap_new_block(soap);
					a->ProbeMatch = (struct wsdd__ProbeMatchType *)soap_push_block(soap, soap_blist_ProbeMatch, sizeof(struct wsdd__ProbeMatchType));
					if (a->ProbeMatch == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->ProbeMatch, struct wsdd__ProbeMatchType);
					soap_default_wsdd__ProbeMatchType(soap, a->ProbeMatch);
				}
				soap_revert(soap);
				if (soap_in_wsdd__ProbeMatchType(soap, "wsdd:ProbeMatch", a->ProbeMatch, "wsdd:ProbeMatchType"))
				{	a->__sizeProbeMatch++;
					a->ProbeMatch = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeProbeMatch");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->ProbeMatch)
			soap_pop_block(soap, soap_blist_ProbeMatch);
		if (a->__sizeProbeMatch)
			a->ProbeMatch = (struct wsdd__ProbeMatchType *)soap_save_block(soap, soap_blist_ProbeMatch, NULL, 1);
		else
		{	a->ProbeMatch = NULL;
			if (soap_blist_ProbeMatch)
				soap_end_block(soap, soap_blist_ProbeMatch);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeMatchesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ProbeMatchesType, 0, sizeof(struct wsdd__ProbeMatchesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ProbeMatchesType(struct soap *soap, const struct wsdd__ProbeMatchesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsdd__ProbeMatchesType);
	if (soap_out_wsdd__ProbeMatchesType(soap, tag?tag:"wsdd:ProbeMatchesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeMatchesType * SOAP_FMAC4 soap_get_wsdd__ProbeMatchesType(struct soap *soap, struct wsdd__ProbeMatchesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ProbeMatchesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsdd__ProbeMatchesType * SOAP_FMAC2 soap_instantiate_wsdd__ProbeMatchesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__ProbeMatchesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsdd__ProbeMatchesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsdd__ProbeMatchesType);
		if (size)
			*size = sizeof(struct wsdd__ProbeMatchesType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsdd__ProbeMatchesType, n);
		if (size)
			*size = n * sizeof(struct wsdd__ProbeMatchesType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsdd__ProbeMatchesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsdd__ProbeMatchesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsdd__ProbeMatchesType %p -> %p\n", q, p));
	*(struct wsdd__ProbeMatchesType*)p = *(struct wsdd__ProbeMatchesType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ProbeType(struct soap *soap, const struct wsdd__ProbeType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_wsdd__QNameListType(soap, &a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ProbeType(struct soap *soap, const char *tag, int id, const struct wsdd__ProbeType *a, const char *type)
{
	const char *soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ProbeType), type))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ProbeType * SOAP_FMAC4 soap_in_wsdd__ProbeType(struct soap *soap, const char *tag, struct wsdd__ProbeType *a, const char *type)
{
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsdd__ProbeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ProbeType, sizeof(struct wsdd__ProbeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ProbeType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", &a->Types, "wsdd:QNameListType"))
				{	soap_flag_Types--;
					continue;
				}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__ProbeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ProbeType, 0, sizeof(struct wsdd__ProbeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ProbeType(struct soap *soap, const struct wsdd__ProbeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsdd__ProbeType);
	if (soap_out_wsdd__ProbeType(soap, tag?tag:"wsdd:ProbeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ProbeType * SOAP_FMAC4 soap_get_wsdd__ProbeType(struct soap *soap, struct wsdd__ProbeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ProbeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsdd__ProbeType * SOAP_FMAC2 soap_instantiate_wsdd__ProbeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__ProbeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsdd__ProbeType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsdd__ProbeType);
		if (size)
			*size = sizeof(struct wsdd__ProbeType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsdd__ProbeType, n);
		if (size)
			*size = n * sizeof(struct wsdd__ProbeType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsdd__ProbeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsdd__ProbeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsdd__ProbeType %p -> %p\n", q, p));
	*(struct wsdd__ProbeType*)p = *(struct wsdd__ProbeType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__ByeType(struct soap *soap, struct wsdd__ByeType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	a->MetadataVersion = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__ByeType(struct soap *soap, const struct wsdd__ByeType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, &a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, &a->XAddrs);
	soap_serialize_PointerTounsignedInt(soap, &a->MetadataVersion);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__ByeType(struct soap *soap, const char *tag, int id, const struct wsdd__ByeType *a, const char *type)
{
	const char *soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__ByeType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, &a->XAddrs, ""))
		return soap->error;
	if (soap_out_PointerTounsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__ByeType * SOAP_FMAC4 soap_in_wsdd__ByeType(struct soap *soap, const char *tag, struct wsdd__ByeType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsdd__ByeType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__ByeType, sizeof(struct wsdd__ByeType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__ByeType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", &a->Types, "wsdd:QNameListType"))
				{	soap_flag_Types--;
					continue;
				}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", &a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__ByeType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__ByeType, 0, sizeof(struct wsdd__ByeType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__ByeType(struct soap *soap, const struct wsdd__ByeType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsdd__ByeType);
	if (soap_out_wsdd__ByeType(soap, tag?tag:"wsdd:ByeType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__ByeType * SOAP_FMAC4 soap_get_wsdd__ByeType(struct soap *soap, struct wsdd__ByeType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__ByeType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsdd__ByeType * SOAP_FMAC2 soap_instantiate_wsdd__ByeType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__ByeType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsdd__ByeType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsdd__ByeType);
		if (size)
			*size = sizeof(struct wsdd__ByeType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsdd__ByeType, n);
		if (size)
			*size = n * sizeof(struct wsdd__ByeType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsdd__ByeType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsdd__ByeType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsdd__ByeType %p -> %p\n", q, p));
	*(struct wsdd__ByeType*)p = *(struct wsdd__ByeType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsdd__HelloType(struct soap *soap, struct wsdd__HelloType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_default_wsdd__QNameListType(soap, &a->Types);
	a->Scopes = NULL;
	soap_default_wsdd__UriListType(soap, &a->XAddrs);
	soap_default_unsignedInt(soap, &a->MetadataVersion);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsdd__HelloType(struct soap *soap, const struct wsdd__HelloType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsa__EndpointReference(soap, &a->wsa__EndpointReference);
	soap_serialize_wsdd__QNameListType(soap, &a->Types);
	soap_serialize_PointerTowsdd__ScopesType(soap, &a->Scopes);
	soap_serialize_wsdd__UriListType(soap, &a->XAddrs);
	soap_embedded(soap, &a->MetadataVersion, SOAP_TYPE_unsignedInt);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsdd__HelloType(struct soap *soap, const char *tag, int id, const struct wsdd__HelloType *a, const char *type)
{
	const char *soap_tmp_Types = soap_QName2s(soap, a->Types);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsdd__HelloType), type))
		return soap->error;
	if (soap_out__wsa__EndpointReference(soap, "wsa:EndpointReference", -1, &a->wsa__EndpointReference, ""))
		return soap->error;
	if (soap_out_wsdd__QNameListType(soap, "wsdd:Types", -1, (char*const*)&soap_tmp_Types, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", -1, &a->Scopes, ""))
		return soap->error;
	if (soap_out_wsdd__UriListType(soap, "wsdd:XAddrs", -1, &a->XAddrs, ""))
		return soap->error;
	if (soap_out_unsignedInt(soap, "wsdd:MetadataVersion", -1, &a->MetadataVersion, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsdd__HelloType * SOAP_FMAC4 soap_in_wsdd__HelloType(struct soap *soap, const char *tag, struct wsdd__HelloType *a, const char *type)
{
	size_t soap_flag_wsa__EndpointReference = 1;
	size_t soap_flag_Types = 1;
	size_t soap_flag_Scopes = 1;
	size_t soap_flag_XAddrs = 1;
	size_t soap_flag_MetadataVersion = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsdd__HelloType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsdd__HelloType, sizeof(struct wsdd__HelloType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsdd__HelloType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsa__EndpointReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsa__EndpointReference(soap, "wsa:EndpointReference", &a->wsa__EndpointReference, ""))
				{	soap_flag_wsa__EndpointReference--;
					continue;
				}
			if (soap_flag_Types && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wsdd__QNameListType(soap, "wsdd:Types", &a->Types, "wsdd:QNameListType"))
				{	soap_flag_Types--;
					continue;
				}
			if (soap_flag_Scopes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsdd__ScopesType(soap, "wsdd:Scopes", &a->Scopes, "wsdd:ScopesType"))
				{	soap_flag_Scopes--;
					continue;
				}
			if (soap_flag_XAddrs && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wsdd__UriListType(soap, "wsdd:XAddrs", &a->XAddrs, "wsdd:UriListType"))
				{	soap_flag_XAddrs--;
					continue;
				}
			if (soap_flag_MetadataVersion && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_unsignedInt(soap, "wsdd:MetadataVersion", &a->MetadataVersion, "xsd:unsignedInt"))
				{	soap_flag_MetadataVersion--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsdd__HelloType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsdd__HelloType, 0, sizeof(struct wsdd__HelloType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_wsa__EndpointReference > 0 || soap_flag_MetadataVersion > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__HelloType(struct soap *soap, const struct wsdd__HelloType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsdd__HelloType);
	if (soap_out_wsdd__HelloType(soap, tag?tag:"wsdd:HelloType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__HelloType * SOAP_FMAC4 soap_get_wsdd__HelloType(struct soap *soap, struct wsdd__HelloType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__HelloType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsdd__HelloType * SOAP_FMAC2 soap_instantiate_wsdd__HelloType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsdd__HelloType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsdd__HelloType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsdd__HelloType);
		if (size)
			*size = sizeof(struct wsdd__HelloType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsdd__HelloType, n);
		if (size)
			*size = n * sizeof(struct wsdd__HelloType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsdd__HelloType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsdd__HelloType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsdd__HelloType %p -> %p\n", q, p));
	*(struct wsdd__HelloType*)p = *(struct wsdd__HelloType*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Fault);
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Fault, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Reason);
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Reason, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Code);
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Code, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Code*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Detail);
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Detail, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__Relationship(struct soap *soap, struct wsa__Relationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__QName(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__Relationship(struct soap *soap, const char *tag, int id, const struct wsa__Relationship *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap_QName2s(soap, a->RelationshipType), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_in_wsa__Relationship(struct soap *soap, const char *tag, struct wsa__Relationship *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__Relationship *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__Relationship, sizeof(struct wsa__Relationship), soap->type, soap->arrayType)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__Relationship(soap, a);
	if (soap_s2QName(soap, soap_attr_value(soap, "RelationshipType", 0), &a->RelationshipType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "wsa:Relationship"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__Relationship);
	if (soap_out_wsa__Relationship(soap, tag?tag:"wsa:Relationship", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_get_wsa__Relationship(struct soap *soap, struct wsa__Relationship *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__Relationship(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa__Relationship * SOAP_FMAC2 soap_instantiate_wsa__Relationship(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa__Relationship(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa__Relationship, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa__Relationship);
		if (size)
			*size = sizeof(struct wsa__Relationship);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsa__Relationship, n);
		if (size)
			*size = n * sizeof(struct wsa__Relationship);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsa__Relationship*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa__Relationship(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa__Relationship %p -> %p\n", q, p));
	*(struct wsa__Relationship*)p = *(struct wsa__Relationship*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->__item);
	soap_default_string(soap, &a->PortName);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ServiceNameType(struct soap *soap, const char *tag, int id, const struct wsa__ServiceNameType *a, const char *type)
{
	const char *soap_tmp___item = soap_QName2s(soap, a->__item);
	if (a->PortName)
		soap_set_attr(soap, "PortName", a->PortName, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	return soap_out__QName(soap, tag, id, (char*const*)&soap_tmp___item, "");
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_in_wsa__ServiceNameType(struct soap *soap, const char *tag, struct wsa__ServiceNameType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__ServiceNameType *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ServiceNameType, sizeof(struct wsa__ServiceNameType), soap->type, soap->arrayType)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__ServiceNameType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PortName", 0), &a->PortName, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (!soap_in__QName(soap, tag, &a->__item, "wsa:ServiceNameType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__ServiceNameType);
	if (soap_out_wsa__ServiceNameType(soap, tag?tag:"wsa:ServiceNameType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_get_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa__ServiceNameType * SOAP_FMAC2 soap_instantiate_wsa__ServiceNameType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa__ServiceNameType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa__ServiceNameType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa__ServiceNameType);
		if (size)
			*size = sizeof(struct wsa__ServiceNameType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsa__ServiceNameType, n);
		if (size)
			*size = n * sizeof(struct wsa__ServiceNameType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsa__ServiceNameType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa__ServiceNameType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa__ServiceNameType %p -> %p\n", q, p));
	*(struct wsa__ServiceNameType*)p = *(struct wsa__ServiceNameType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa__ReferenceParametersType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferenceParametersType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferenceParametersType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferenceParametersType, 0, sizeof(struct wsa__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__ReferenceParametersType);
	if (soap_out_wsa__ReferenceParametersType(soap, tag?tag:"wsa:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa__ReferenceParametersType * SOAP_FMAC2 soap_instantiate_wsa__ReferenceParametersType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa__ReferenceParametersType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa__ReferenceParametersType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa__ReferenceParametersType);
		if (size)
			*size = sizeof(struct wsa__ReferenceParametersType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsa__ReferenceParametersType, n);
		if (size)
			*size = n * sizeof(struct wsa__ReferenceParametersType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsa__ReferenceParametersType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa__ReferenceParametersType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa__ReferenceParametersType %p -> %p\n", q, p));
	*(struct wsa__ReferenceParametersType*)p = *(struct wsa__ReferenceParametersType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, int id, const struct wsa__ReferencePropertiesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferencePropertiesType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_in_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, struct wsa__ReferencePropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ReferencePropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferencePropertiesType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferencePropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferencePropertiesType, 0, sizeof(struct wsa__ReferencePropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__ReferencePropertiesType);
	if (soap_out_wsa__ReferencePropertiesType(soap, tag?tag:"wsa:ReferencePropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_get_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa__ReferencePropertiesType * SOAP_FMAC2 soap_instantiate_wsa__ReferencePropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa__ReferencePropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa__ReferencePropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa__ReferencePropertiesType);
		if (size)
			*size = sizeof(struct wsa__ReferencePropertiesType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsa__ReferencePropertiesType, n);
		if (size)
			*size = n * sizeof(struct wsa__ReferencePropertiesType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsa__ReferencePropertiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa__ReferencePropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa__ReferencePropertiesType %p -> %p\n", q, p));
	*(struct wsa__ReferencePropertiesType*)p = *(struct wsa__ReferencePropertiesType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceProperties = NULL;
	a->ReferenceParameters = NULL;
	a->PortType = NULL;
	a->ServiceName = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Address);
	soap_serialize_PointerTowsa__ReferencePropertiesType(soap, &a->ReferenceProperties);
	soap_serialize_PointerTowsa__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTo_QName(soap, &a->PortType);
	soap_serialize_PointerTowsa__ServiceNameType(soap, &a->ServiceName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	const char *soap_tmp_PortType = a->PortType ? soap_QName2s(soap, *a->PortType) : NULL;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__EndpointReferenceType), type))
		return soap->error;
	if (a->Address)
	{	if (soap_out_string(soap, "wsa:Address", -1, &a->Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsa:Address"))
		return soap->error;
	if (soap_out_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", -1, &a->ReferenceProperties, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out__QName(soap, "wsa:PortType", -1, (char*const*)&soap_tmp_PortType, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", -1, &a->ServiceName, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceProperties = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_PortType = 1;
	size_t soap_flag_ServiceName = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__EndpointReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa:Address", &a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_ReferenceProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", &a->ReferenceProperties, "wsa:ReferencePropertiesType"))
				{	soap_flag_ReferenceProperties--;
					continue;
				}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->ReferenceParameters, "wsa:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			if (soap_flag_PortType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_QName(soap, "wsa:PortType", &a->PortType, ""))
				{	soap_flag_PortType--;
					continue;
				}
			if (soap_flag_ServiceName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", &a->ServiceName, "wsa:ServiceNameType"))
				{	soap_flag_ServiceName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__EndpointReferenceType, 0, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__EndpointReferenceType);
	if (soap_out_wsa__EndpointReferenceType(soap, tag?tag:"wsa:EndpointReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsa__EndpointReferenceType * SOAP_FMAC2 soap_instantiate_wsa__EndpointReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsa__EndpointReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsa__EndpointReferenceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsa__EndpointReferenceType);
		if (size)
			*size = sizeof(struct wsa__EndpointReferenceType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsa__EndpointReferenceType, n);
		if (size)
			*size = n * sizeof(struct wsa__EndpointReferenceType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsa__EndpointReferenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsa__EndpointReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsa__EndpointReferenceType %p -> %p\n", q, p));
	*(struct wsa__EndpointReferenceType*)p = *(struct wsa__EndpointReferenceType*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsse__Security = NULL;
	soap_default__wsa__MessageID(soap, &a->wsa__MessageID);
	a->wsa__RelatesTo = NULL;
	a->wsa__From = NULL;
	a->wsa__ReplyTo = NULL;
	a->wsa__FaultTo = NULL;
	soap_default__wsa__To(soap, &a->wsa__To);
	soap_default__wsa__Action(soap, &a->wsa__Action);
	a->wsdd__AppSequence = NULL;
	soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
	a->wsa5__RelatesTo = NULL;
	a->wsa5__From = NULL;
	a->wsa5__ReplyTo = NULL;
	a->wsa5__FaultTo = NULL;
	soap_default__wsa5__To(soap, &a->wsa5__To);
	soap_default__wsa5__Action(soap, &a->wsa5__Action);
	a->chan__ChannelInstance = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__Security(soap, &a->wsse__Security);
	soap_serialize__wsa__MessageID(soap, &a->wsa__MessageID);
	soap_serialize_PointerTo_wsa__RelatesTo(soap, &a->wsa__RelatesTo);
	soap_serialize_PointerTo_wsa__From(soap, &a->wsa__From);
	soap_serialize_PointerTo_wsa__ReplyTo(soap, &a->wsa__ReplyTo);
	soap_serialize_PointerTo_wsa__FaultTo(soap, &a->wsa__FaultTo);
	soap_serialize__wsa__To(soap, &a->wsa__To);
	soap_serialize__wsa__Action(soap, &a->wsa__Action);
	soap_serialize_PointerTowsdd__AppSequenceType(soap, &a->wsdd__AppSequence);
	soap_serialize__wsa5__MessageID(soap, &a->wsa5__MessageID);
	soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
	soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
	soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
	soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
	soap_serialize__wsa5__To(soap, &a->wsa5__To);
	soap_serialize__wsa5__Action(soap, &a->wsa5__Action);
	soap_serialize_PointerTochan__ChannelInstanceType(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsse__Security(soap, "wsse:Security", -1, &a->wsse__Security, ""))
		return soap->error;
	if (soap_out__wsa__MessageID(soap, "wsa:MessageID", -1, &a->wsa__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", -1, &a->wsa__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__From(soap, "wsa:From", -1, &a->wsa__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", -1, &a->wsa__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", -1, &a->wsa__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__To(soap, "wsa:To", -1, &a->wsa__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__Action(soap, "wsa:Action", -1, &a->wsa__Action, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__AppSequenceType(soap, "wsdd:AppSequence", -1, &a->wsdd__AppSequence, ""))
		return soap->error;
	if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, &a->wsa5__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__To(soap, "wsa5:To", -1, &a->wsa5__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, &a->wsa5__Action, ""))
		return soap->error;
	if (soap_out_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsse__Security = 1;
	size_t soap_flag_wsa__MessageID = 1;
	size_t soap_flag_wsa__RelatesTo = 1;
	size_t soap_flag_wsa__From = 1;
	size_t soap_flag_wsa__ReplyTo = 1;
	size_t soap_flag_wsa__FaultTo = 1;
	size_t soap_flag_wsa__To = 1;
	size_t soap_flag_wsa__Action = 1;
	size_t soap_flag_wsdd__AppSequence = 1;
	size_t soap_flag_wsa5__MessageID = 1;
	size_t soap_flag_wsa5__RelatesTo = 1;
	size_t soap_flag_wsa5__From = 1;
	size_t soap_flag_wsa5__ReplyTo = 1;
	size_t soap_flag_wsa5__FaultTo = 1;
	size_t soap_flag_wsa5__To = 1;
	size_t soap_flag_wsa5__Action = 1;
	size_t soap_flag_chan__ChannelInstance = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Security(soap, "wsse:Security", &a->wsse__Security, ""))
				{	soap_flag_wsse__Security--;
					continue;
				}
			if (soap_flag_wsa__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa__MessageID(soap, "wsa:MessageID", &a->wsa__MessageID, ""))
				{	soap_flag_wsa__MessageID--;
					continue;
				}
			if (soap_flag_wsa__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", &a->wsa__RelatesTo, ""))
				{	soap_flag_wsa__RelatesTo--;
					continue;
				}
			if (soap_flag_wsa__From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__From(soap, "wsa:From", &a->wsa__From, ""))
				{	soap_flag_wsa__From--;
					continue;
				}
			if (soap_flag_wsa__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", &a->wsa__ReplyTo, ""))
				{	soap_flag_wsa__ReplyTo--;
					continue;
				}
			if (soap_flag_wsa__FaultTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", &a->wsa__FaultTo, ""))
				{	soap_flag_wsa__FaultTo--;
					continue;
				}
			if (soap_flag_wsa__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa__To(soap, "wsa:To", &a->wsa__To, ""))
				{	soap_flag_wsa__To--;
					continue;
				}
			if (soap_flag_wsa__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa__Action(soap, "wsa:Action", &a->wsa__Action, ""))
				{	soap_flag_wsa__Action--;
					continue;
				}
			if (soap_flag_wsdd__AppSequence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsdd__AppSequenceType(soap, "wsdd:AppSequence", &a->wsdd__AppSequence, "wsdd:AppSequenceType"))
				{	soap_flag_wsdd__AppSequence--;
					continue;
				}
			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", &a->wsa5__MessageID, ""))
				{	soap_flag_wsa5__MessageID--;
					continue;
				}
			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, ""))
				{	soap_flag_wsa5__RelatesTo--;
					continue;
				}
			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, ""))
				{	soap_flag_wsa5__From--;
					continue;
				}
			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, ""))
				{	soap_flag_wsa5__ReplyTo--;
					continue;
				}
			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, ""))
				{	soap_flag_wsa5__FaultTo--;
					continue;
				}
			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__To(soap, "wsa5:To", &a->wsa5__To, ""))
				{	soap_flag_wsa5__To--;
					continue;
				}
			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__Action(soap, "wsa5:Action", &a->wsa5__Action, ""))
				{	soap_flag_wsa5__Action--;
					continue;
				}
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "chan:ChannelInstanceType"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct SOAP_ENV__Header);
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct SOAP_ENV__Header, n);
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct SOAP_ENV__Header*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Security(struct soap *soap, struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsu__Timestamp = NULL;
	a->UsernameToken = NULL;
	a->BinarySecurityToken = NULL;
	a->xenc__EncryptedKey = NULL;
	a->xenc__ReferenceList = NULL;
	a->wsc__SecurityContextToken = NULL;
	a->ds__Signature = NULL;
	soap_default_string(soap, &a->SOAP_ENV__actor);
	soap_default_string(soap, &a->SOAP_ENV__role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Security(struct soap *soap, const struct _wsse__Security *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsu__Timestamp(soap, &a->wsu__Timestamp);
	soap_serialize_PointerTo_wsse__UsernameToken(soap, &a->UsernameToken);
	soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, &a->BinarySecurityToken);
	soap_serialize_PointerToxenc__EncryptedKeyType(soap, &a->xenc__EncryptedKey);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->xenc__ReferenceList);
	soap_serialize_PointerTowsc__SecurityContextTokenType(soap, &a->wsc__SecurityContextToken);
	soap_serialize_PointerTods__SignatureType(soap, &a->ds__Signature);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Security(struct soap *soap, const char *tag, int id, const struct _wsse__Security *a, const char *type)
{
	if (a->SOAP_ENV__actor)
		soap_set_attr(soap, "SOAP-ENV:actor", a->SOAP_ENV__actor, 1);
	if (a->SOAP_ENV__role)
		soap_set_attr(soap, "SOAP-ENV:role", a->SOAP_ENV__role, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Security), type))
		return soap->error;
	if (soap_out_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", -1, &a->wsu__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", -1, &a->UsernameToken, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", -1, &a->BinarySecurityToken, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", -1, &a->xenc__EncryptedKey, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->xenc__ReferenceList, ""))
		return soap->error;
	if (soap_out_PointerTowsc__SecurityContextTokenType(soap, "wsc:SecurityContextToken", -1, &a->wsc__SecurityContextToken, ""))
		return soap->error;
	if (soap_out_PointerTods__SignatureType(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_in__wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security *a, const char *type)
{
	size_t soap_flag_wsu__Timestamp = 1;
	size_t soap_flag_UsernameToken = 1;
	size_t soap_flag_BinarySecurityToken = 1;
	size_t soap_flag_xenc__EncryptedKey = 1;
	size_t soap_flag_xenc__ReferenceList = 1;
	size_t soap_flag_wsc__SecurityContextToken = 1;
	size_t soap_flag_ds__Signature = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Security *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Security(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:actor", 0), &a->SOAP_ENV__actor, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:role", 0), &a->SOAP_ENV__role, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsu__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", &a->wsu__Timestamp, ""))
				{	soap_flag_wsu__Timestamp--;
					continue;
				}
			if (soap_flag_UsernameToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", &a->UsernameToken, ""))
				{	soap_flag_UsernameToken--;
					continue;
				}
			if (soap_flag_BinarySecurityToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", &a->BinarySecurityToken, ""))
				{	soap_flag_BinarySecurityToken--;
					continue;
				}
			if (soap_flag_xenc__EncryptedKey && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", &a->xenc__EncryptedKey, "xenc:EncryptedKeyType"))
				{	soap_flag_xenc__EncryptedKey--;
					continue;
				}
			if (soap_flag_xenc__ReferenceList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->xenc__ReferenceList, ""))
				{	soap_flag_xenc__ReferenceList--;
					continue;
				}
			if (soap_flag_wsc__SecurityContextToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsc__SecurityContextTokenType(soap, "wsc:SecurityContextToken", &a->wsc__SecurityContextToken, "wsc:SecurityContextTokenType"))
				{	soap_flag_wsc__SecurityContextToken--;
					continue;
				}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureType(soap, "ds:Signature", &a->ds__Signature, "ds:SignatureType"))
				{	soap_flag_ds__Signature--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Security, 0, sizeof(struct _wsse__Security), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Security(struct soap *soap, const struct _wsse__Security *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Security);
	if (soap_out__wsse__Security(soap, tag?tag:"wsse:Security", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_get__wsse__Security(struct soap *soap, struct _wsse__Security *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__Security * SOAP_FMAC2 soap_instantiate__wsse__Security(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Security(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__Security, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Security);
		if (size)
			*size = sizeof(struct _wsse__Security);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct _wsse__Security, n);
		if (size)
			*size = n * sizeof(struct _wsse__Security);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct _wsse__Security*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__Security(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__Security %p -> %p\n", q, p));
	*(struct _wsse__Security*)p = *(struct _wsse__Security*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_DerivedKeyTokenType = 0;
	a->Length = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const struct __wsc__DerivedKeyTokenType_sequence *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsc__union_DerivedKeyTokenType(soap, a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType);
	soap_serialize_PointerTounsignedLONG64(soap, &a->Length);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, int id, const struct __wsc__DerivedKeyTokenType_sequence *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out__wsc__union_DerivedKeyTokenType(soap, a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "wsc:Length", -1, &a->Length, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC4 soap_in___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, struct __wsc__DerivedKeyTokenType_sequence *a, const char *type)
{
	size_t soap_flag_union_DerivedKeyTokenType = 1;
	size_t soap_flag_Length = 1;
	short soap_flag;
	a = (struct __wsc__DerivedKeyTokenType_sequence *)soap_id_enter(soap, "", a, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, sizeof(struct __wsc__DerivedKeyTokenType_sequence), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsc__DerivedKeyTokenType_sequence(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_DerivedKeyTokenType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsc__union_DerivedKeyTokenType(soap, &a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType))
				{	soap_flag_union_DerivedKeyTokenType = 0;
					continue;
				}
			if (soap_flag_Length && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "wsc:Length", &a->Length, "xsd:unsignedLong"))
				{	soap_flag_Length--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_DerivedKeyTokenType))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const struct __wsc__DerivedKeyTokenType_sequence *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wsc__DerivedKeyTokenType_sequence(soap, tag?tag:"-wsc:DerivedKeyTokenType-sequence", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC4 soap_get___wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsc__DerivedKeyTokenType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC2 soap_instantiate___wsc__DerivedKeyTokenType_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___wsc__DerivedKeyTokenType_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __wsc__DerivedKeyTokenType_sequence);
		if (size)
			*size = sizeof(struct __wsc__DerivedKeyTokenType_sequence);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __wsc__DerivedKeyTokenType_sequence, n);
		if (size)
			*size = n * sizeof(struct __wsc__DerivedKeyTokenType_sequence);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __wsc__DerivedKeyTokenType_sequence*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___wsc__DerivedKeyTokenType_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __wsc__DerivedKeyTokenType_sequence %p -> %p\n", q, p));
	*(struct __wsc__DerivedKeyTokenType_sequence*)p = *(struct __wsc__DerivedKeyTokenType_sequence*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__PropertiesType(struct soap *soap, const struct wsc__PropertiesType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__PropertiesType(struct soap *soap, const char *tag, int id, const struct wsc__PropertiesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__PropertiesType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__PropertiesType * SOAP_FMAC4 soap_in_wsc__PropertiesType(struct soap *soap, const char *tag, struct wsc__PropertiesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsc__PropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__PropertiesType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__PropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__PropertiesType, 0, sizeof(struct wsc__PropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__PropertiesType(struct soap *soap, const struct wsc__PropertiesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsc__PropertiesType);
	if (soap_out_wsc__PropertiesType(soap, tag?tag:"wsc:PropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__PropertiesType * SOAP_FMAC4 soap_get_wsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__PropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsc__PropertiesType * SOAP_FMAC2 soap_instantiate_wsc__PropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsc__PropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsc__PropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsc__PropertiesType);
		if (size)
			*size = sizeof(struct wsc__PropertiesType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsc__PropertiesType, n);
		if (size)
			*size = n * sizeof(struct wsc__PropertiesType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsc__PropertiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsc__PropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsc__PropertiesType %p -> %p\n", q, p));
	*(struct wsc__PropertiesType*)p = *(struct wsc__PropertiesType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__DerivedKeyTokenType(struct soap *soap, struct wsc__DerivedKeyTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsse__SecurityTokenReference = NULL;
	a->Properties = NULL;
	a->__size_DerivedKeyTokenType_sequence = 0;
	a->__DerivedKeyTokenType_sequence = NULL;
	soap_default_string(soap, &a->Label);
	soap_default_string(soap, &a->Nonce);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__DerivedKeyTokenType(struct soap *soap, const struct wsc__DerivedKeyTokenType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
	soap_serialize_PointerTowsc__PropertiesType(soap, &a->Properties);
	if (a->__DerivedKeyTokenType_sequence)
	{	int i;
		for (i = 0; i < a->__size_DerivedKeyTokenType_sequence; i++)
		{
			soap_serialize___wsc__DerivedKeyTokenType_sequence(soap, a->__DerivedKeyTokenType_sequence + i);
		}
	}
	soap_serialize_string(soap, &a->Label);
	soap_serialize_string(soap, &a->Nonce);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__DerivedKeyTokenType(struct soap *soap, const char *tag, int id, const struct wsc__DerivedKeyTokenType *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__DerivedKeyTokenType), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	if (soap_out_PointerTowsc__PropertiesType(soap, "wsc:Properties", -1, &a->Properties, ""))
		return soap->error;
	if (a->__DerivedKeyTokenType_sequence)
	{	int i;
		for (i = 0; i < a->__size_DerivedKeyTokenType_sequence; i++)
			if (soap_out___wsc__DerivedKeyTokenType_sequence(soap, "-DerivedKeyTokenType-sequence", -1, a->__DerivedKeyTokenType_sequence + i, ""))
				return soap->error;
	}
	if (soap_out_string(soap, "wsc:Label", -1, &a->Label, ""))
		return soap->error;
	if (soap_out_string(soap, "wsc:Nonce", -1, &a->Nonce, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__DerivedKeyTokenType * SOAP_FMAC4 soap_in_wsc__DerivedKeyTokenType(struct soap *soap, const char *tag, struct wsc__DerivedKeyTokenType *a, const char *type)
{
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	size_t soap_flag_Properties = 1;
	struct soap_blist *soap_blist___DerivedKeyTokenType_sequence = NULL;
	size_t soap_flag_Label = 1;
	size_t soap_flag_Nonce = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsc__DerivedKeyTokenType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__DerivedKeyTokenType, sizeof(struct wsc__DerivedKeyTokenType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__DerivedKeyTokenType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 0), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsc__PropertiesType(soap, "wsc:Properties", &a->Properties, "wsc:PropertiesType"))
				{	soap_flag_Properties--;
					continue;
				}
			if (soap_flag_Label && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsc:Label", &a->Label, "xsd:string"))
				{	soap_flag_Label--;
					continue;
				}
			if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsc:Nonce", &a->Nonce, "xsd:string"))
				{	soap_flag_Nonce--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__DerivedKeyTokenType_sequence == NULL)
				{	if (soap_blist___DerivedKeyTokenType_sequence == NULL)
						soap_blist___DerivedKeyTokenType_sequence = soap_new_block(soap);
					a->__DerivedKeyTokenType_sequence = (struct __wsc__DerivedKeyTokenType_sequence *)soap_push_block(soap, soap_blist___DerivedKeyTokenType_sequence, sizeof(struct __wsc__DerivedKeyTokenType_sequence));
					if (a->__DerivedKeyTokenType_sequence == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->__DerivedKeyTokenType_sequence, struct __wsc__DerivedKeyTokenType_sequence);
					soap_default___wsc__DerivedKeyTokenType_sequence(soap, a->__DerivedKeyTokenType_sequence);
				}
				if (soap_in___wsc__DerivedKeyTokenType_sequence(soap, "-DerivedKeyTokenType-sequence", a->__DerivedKeyTokenType_sequence, "-wsc:DerivedKeyTokenType-sequence"))
				{	a->__size_DerivedKeyTokenType_sequence++;
					a->__DerivedKeyTokenType_sequence = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__DerivedKeyTokenType_sequence)
			soap_pop_block(soap, soap_blist___DerivedKeyTokenType_sequence);
		if (a->__size_DerivedKeyTokenType_sequence)
			a->__DerivedKeyTokenType_sequence = (struct __wsc__DerivedKeyTokenType_sequence *)soap_save_block(soap, soap_blist___DerivedKeyTokenType_sequence, NULL, 1);
		else
		{	a->__DerivedKeyTokenType_sequence = NULL;
			if (soap_blist___DerivedKeyTokenType_sequence)
				soap_end_block(soap, soap_blist___DerivedKeyTokenType_sequence);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__DerivedKeyTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__DerivedKeyTokenType, 0, sizeof(struct wsc__DerivedKeyTokenType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__DerivedKeyTokenType(struct soap *soap, const struct wsc__DerivedKeyTokenType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsc__DerivedKeyTokenType);
	if (soap_out_wsc__DerivedKeyTokenType(soap, tag?tag:"wsc:DerivedKeyTokenType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__DerivedKeyTokenType * SOAP_FMAC4 soap_get_wsc__DerivedKeyTokenType(struct soap *soap, struct wsc__DerivedKeyTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__DerivedKeyTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsc__DerivedKeyTokenType * SOAP_FMAC2 soap_instantiate_wsc__DerivedKeyTokenType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsc__DerivedKeyTokenType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsc__DerivedKeyTokenType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsc__DerivedKeyTokenType);
		if (size)
			*size = sizeof(struct wsc__DerivedKeyTokenType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsc__DerivedKeyTokenType, n);
		if (size)
			*size = n * sizeof(struct wsc__DerivedKeyTokenType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsc__DerivedKeyTokenType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsc__DerivedKeyTokenType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsc__DerivedKeyTokenType %p -> %p\n", q, p));
	*(struct wsc__DerivedKeyTokenType*)p = *(struct wsc__DerivedKeyTokenType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Identifier);
	soap_default_string(soap, &a->Instance);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__SecurityContextTokenType(struct soap *soap, const struct wsc__SecurityContextTokenType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Identifier);
	soap_serialize_string(soap, &a->Instance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__SecurityContextTokenType(struct soap *soap, const char *tag, int id, const struct wsc__SecurityContextTokenType *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__SecurityContextTokenType), type))
		return soap->error;
	if (soap_out_string(soap, "wsc:Identifier", -1, &a->Identifier, ""))
		return soap->error;
	if (soap_out_string(soap, "wsc:Instance", -1, &a->Instance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType * SOAP_FMAC4 soap_in_wsc__SecurityContextTokenType(struct soap *soap, const char *tag, struct wsc__SecurityContextTokenType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	size_t soap_flag_Instance = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsc__SecurityContextTokenType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__SecurityContextTokenType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsc:Identifier", &a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			if (soap_flag_Instance && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsc:Instance", &a->Instance, "xsd:string"))
				{	soap_flag_Instance--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__SecurityContextTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__SecurityContextTokenType, 0, sizeof(struct wsc__SecurityContextTokenType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__SecurityContextTokenType(struct soap *soap, const struct wsc__SecurityContextTokenType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsc__SecurityContextTokenType);
	if (soap_out_wsc__SecurityContextTokenType(soap, tag?tag:"wsc:SecurityContextTokenType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType * SOAP_FMAC4 soap_get_wsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__SecurityContextTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct wsc__SecurityContextTokenType * SOAP_FMAC2 soap_instantiate_wsc__SecurityContextTokenType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_wsc__SecurityContextTokenType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_wsc__SecurityContextTokenType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct wsc__SecurityContextTokenType);
		if (size)
			*size = sizeof(struct wsc__SecurityContextTokenType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct wsc__SecurityContextTokenType, n);
		if (size)
			*size = n * sizeof(struct wsc__SecurityContextTokenType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct wsc__SecurityContextTokenType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_wsc__SecurityContextTokenType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct wsc__SecurityContextTokenType %p -> %p\n", q, p));
	*(struct wsc__SecurityContextTokenType*)p = *(struct wsc__SecurityContextTokenType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DataReference = NULL;
	a->KeyReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->DataReference);
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->KeyReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___xenc__union_ReferenceList(struct soap *soap, const char *tag, int id, const struct __xenc__union_ReferenceList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:DataReference", -1, &a->DataReference, ""))
		return soap->error;
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", -1, &a->KeyReference, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_in___xenc__union_ReferenceList(struct soap *soap, const char *tag, struct __xenc__union_ReferenceList *a, const char *type)
{
	size_t soap_flag_DataReference = 1;
	size_t soap_flag_KeyReference = 1;
	short soap_flag;
	a = (struct __xenc__union_ReferenceList *)soap_id_enter(soap, "", a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___xenc__union_ReferenceList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DataReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:DataReference", &a->DataReference, "xenc:ReferenceType"))
				{	soap_flag_DataReference--;
					continue;
				}
			if (soap_flag_KeyReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", &a->KeyReference, "xenc:ReferenceType"))
				{	soap_flag_KeyReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___xenc__union_ReferenceList(soap, tag?tag:"-xenc:union-ReferenceList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_get___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in___xenc__union_ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct __xenc__union_ReferenceList * SOAP_FMAC2 soap_instantiate___xenc__union_ReferenceList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___xenc__union_ReferenceList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___xenc__union_ReferenceList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct __xenc__union_ReferenceList);
		if (size)
			*size = sizeof(struct __xenc__union_ReferenceList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct __xenc__union_ReferenceList, n);
		if (size)
			*size = n * sizeof(struct __xenc__union_ReferenceList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct __xenc__union_ReferenceList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy___xenc__union_ReferenceList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct __xenc__union_ReferenceList %p -> %p\n", q, p));
	*(struct __xenc__union_ReferenceList*)p = *(struct __xenc__union_ReferenceList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_ReferenceList = 0;
	a->__union_ReferenceList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__union_ReferenceList)
	{	int i;
		for (i = 0; i < a->__size_ReferenceList; i++)
		{
			soap_serialize___xenc__union_ReferenceList(soap, a->__union_ReferenceList + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xenc__ReferenceList(struct soap *soap, const char *tag, int id, const struct _xenc__ReferenceList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__xenc__ReferenceList), type))
		return soap->error;
	if (a->__union_ReferenceList)
	{	int i;
		for (i = 0; i < a->__size_ReferenceList; i++)
			if (soap_out___xenc__union_ReferenceList(soap, "-union-ReferenceList", -1, a->__union_ReferenceList + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_in__xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList *a, const char *type)
{
	struct soap_blist *soap_blist___union_ReferenceList = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _xenc__ReferenceList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xenc__ReferenceList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_ReferenceList == NULL)
				{	if (soap_blist___union_ReferenceList == NULL)
						soap_blist___union_ReferenceList = soap_new_block(soap);
					a->__union_ReferenceList = (struct __xenc__union_ReferenceList *)soap_push_block(soap, soap_blist___union_ReferenceList, sizeof(struct __xenc__union_ReferenceList));
					if (a->__union_ReferenceList == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->__union_ReferenceList, struct __xenc__union_ReferenceList);
					soap_default___xenc__union_ReferenceList(soap, a->__union_ReferenceList);
				}
				if (soap_in___xenc__union_ReferenceList(soap, "-union-ReferenceList", a->__union_ReferenceList, "-xenc:union-ReferenceList"))
				{	a->__size_ReferenceList++;
					a->__union_ReferenceList = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_ReferenceList)
			soap_pop_block(soap, soap_blist___union_ReferenceList);
		if (a->__size_ReferenceList)
			a->__union_ReferenceList = (struct __xenc__union_ReferenceList *)soap_save_block(soap, soap_blist___union_ReferenceList, NULL, 1);
		else
		{	a->__union_ReferenceList = NULL;
			if (soap_blist___union_ReferenceList)
				soap_end_block(soap, soap_blist___union_ReferenceList);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _xenc__ReferenceList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xenc__ReferenceList, 0, sizeof(struct _xenc__ReferenceList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__size_ReferenceList < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__xenc__ReferenceList);
	if (soap_out__xenc__ReferenceList(soap, tag?tag:"xenc:ReferenceList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_get__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in__xenc__ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _xenc__ReferenceList * SOAP_FMAC2 soap_instantiate__xenc__ReferenceList(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__xenc__ReferenceList(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__xenc__ReferenceList, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _xenc__ReferenceList);
		if (size)
			*size = sizeof(struct _xenc__ReferenceList);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct _xenc__ReferenceList, n);
		if (size)
			*size = n * sizeof(struct _xenc__ReferenceList);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct _xenc__ReferenceList*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__xenc__ReferenceList(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _xenc__ReferenceList %p -> %p\n", q, p));
	*(struct _xenc__ReferenceList*)p = *(struct _xenc__ReferenceList*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Target);
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertyType *a, const char *type)
{
	if (a->Target)
		soap_set_attr(soap, "Target", a->Target, 1);
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertyType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionPropertyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Target", 0), &a->Target, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertyType, 0, sizeof(struct xenc__EncryptionPropertyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptionPropertyType);
	if (soap_out_xenc__EncryptionPropertyType(soap, tag?tag:"xenc:EncryptionPropertyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct xenc__EncryptionPropertyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptionPropertyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xenc__EncryptionPropertyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct xenc__EncryptionPropertyType);
		if (size)
			*size = sizeof(struct xenc__EncryptionPropertyType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct xenc__EncryptionPropertyType, n);
		if (size)
			*size = n * sizeof(struct xenc__EncryptionPropertyType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct xenc__EncryptionPropertyType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xenc__EncryptionPropertyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xenc__EncryptionPropertyType %p -> %p\n", q, p));
	*(struct xenc__EncryptionPropertyType*)p = *(struct xenc__EncryptionPropertyType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeEncryptionProperty = 0;
	a->EncryptionProperty = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->EncryptionProperty)
	{	int i;
		for (i = 0; i < a->__sizeEncryptionProperty; i++)
		{
			soap_embedded(soap, a->EncryptionProperty + i, SOAP_TYPE_xenc__EncryptionPropertyType);
			soap_serialize_xenc__EncryptionPropertyType(soap, a->EncryptionProperty + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertiesType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertiesType), type))
		return soap->error;
	if (a->EncryptionProperty)
	{	int i;
		for (i = 0; i < a->__sizeEncryptionProperty; i++)
			if (soap_out_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", -1, a->EncryptionProperty + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist_EncryptionProperty = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionPropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertiesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "xenc:EncryptionProperty", 1, NULL))
			{	if (a->EncryptionProperty == NULL)
				{	if (soap_blist_EncryptionProperty == NULL)
						soap_blist_EncryptionProperty = soap_new_block(soap);
					a->EncryptionProperty = (struct xenc__EncryptionPropertyType *)soap_push_block(soap, soap_blist_EncryptionProperty, sizeof(struct xenc__EncryptionPropertyType));
					if (a->EncryptionProperty == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->EncryptionProperty, struct xenc__EncryptionPropertyType);
					soap_default_xenc__EncryptionPropertyType(soap, a->EncryptionProperty);
				}
				soap_revert(soap);
				if (soap_in_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", a->EncryptionProperty, "xenc:EncryptionPropertyType"))
				{	a->__sizeEncryptionProperty++;
					a->EncryptionProperty = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->EncryptionProperty)
			soap_pop_block(soap, soap_blist_EncryptionProperty);
		if (a->__sizeEncryptionProperty)
			a->EncryptionProperty = (struct xenc__EncryptionPropertyType *)soap_save_block(soap, soap_blist_EncryptionProperty, NULL, 1);
		else
		{	a->EncryptionProperty = NULL;
			if (soap_blist_EncryptionProperty)
				soap_end_block(soap, soap_blist_EncryptionProperty);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertiesType, 0, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeEncryptionProperty < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptionPropertiesType);
	if (soap_out_xenc__EncryptionPropertiesType(soap, tag?tag:"xenc:EncryptionPropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct xenc__EncryptionPropertiesType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertiesType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptionPropertiesType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xenc__EncryptionPropertiesType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct xenc__EncryptionPropertiesType);
		if (size)
			*size = sizeof(struct xenc__EncryptionPropertiesType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct xenc__EncryptionPropertiesType, n);
		if (size)
			*size = n * sizeof(struct xenc__EncryptionPropertiesType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct xenc__EncryptionPropertiesType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xenc__EncryptionPropertiesType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xenc__EncryptionPropertiesType %p -> %p\n", q, p));
	*(struct xenc__EncryptionPropertiesType*)p = *(struct xenc__EncryptionPropertiesType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__ReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__ReferenceType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__ReferenceType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_in_xenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1), &a->URI, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__ReferenceType, 0, sizeof(struct xenc__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__ReferenceType);
	if (soap_out_xenc__ReferenceType(soap, tag?tag:"xenc:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_get_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct xenc__ReferenceType * SOAP_FMAC2 soap_instantiate_xenc__ReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__ReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xenc__ReferenceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct xenc__ReferenceType);
		if (size)
			*size = sizeof(struct xenc__ReferenceType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct xenc__ReferenceType, n);
		if (size)
			*size = n * sizeof(struct xenc__ReferenceType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct xenc__ReferenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xenc__ReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xenc__ReferenceType %p -> %p\n", q, p));
	*(struct xenc__ReferenceType*)p = *(struct xenc__ReferenceType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KA_Nonce);
	a->OriginatorKeyInfo = NULL;
	a->RecipientKeyInfo = NULL;
	soap_default_string(soap, &a->Algorithm);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->KA_Nonce);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->OriginatorKeyInfo);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->RecipientKeyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__AgreementMethodType(struct soap *soap, const char *tag, int id, const struct xenc__AgreementMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__AgreementMethodType), type))
		return soap->error;
	if (soap_out_string(soap, "xenc:KA-Nonce", -1, &a->KA_Nonce, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", -1, &a->OriginatorKeyInfo, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", -1, &a->RecipientKeyInfo, ""))
		return soap->error;
	soap_outliteral(soap, "-mixed", &a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_in_xenc__AgreementMethodType(struct soap *soap, const char *tag, struct xenc__AgreementMethodType *a, const char *type)
{
	size_t soap_flag_KA_Nonce = 1;
	size_t soap_flag_OriginatorKeyInfo = 1;
	size_t soap_flag_RecipientKeyInfo = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__AgreementMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__AgreementMethodType, sizeof(struct xenc__AgreementMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__AgreementMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KA_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:KA-Nonce", &a->KA_Nonce, "xsd:string"))
				{	soap_flag_KA_Nonce--;
					continue;
				}
			if (soap_flag_OriginatorKeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", &a->OriginatorKeyInfo, "ds:KeyInfoType"))
				{	soap_flag_OriginatorKeyInfo--;
					continue;
				}
			if (soap_flag_RecipientKeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", &a->RecipientKeyInfo, "ds:KeyInfoType"))
				{	soap_flag_RecipientKeyInfo--;
					continue;
				}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__AgreementMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__AgreementMethodType, 0, sizeof(struct xenc__AgreementMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__AgreementMethodType);
	if (soap_out_xenc__AgreementMethodType(soap, tag?tag:"xenc:AgreementMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_get_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__AgreementMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct xenc__AgreementMethodType * SOAP_FMAC2 soap_instantiate_xenc__AgreementMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__AgreementMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xenc__AgreementMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct xenc__AgreementMethodType);
		if (size)
			*size = sizeof(struct xenc__AgreementMethodType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct xenc__AgreementMethodType, n);
		if (size)
			*size = n * sizeof(struct xenc__AgreementMethodType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct xenc__AgreementMethodType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xenc__AgreementMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xenc__AgreementMethodType %p -> %p\n", q, p));
	*(struct xenc__AgreementMethodType*)p = *(struct xenc__AgreementMethodType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
	a->ReferenceList = NULL;
	soap_default_string(soap, &a->CarriedKeyName);
	soap_default_string(soap, &a->Recipient);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->ReferenceList);
	soap_serialize_string(soap, &a->CarriedKeyName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedKeyType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", a->MimeType, 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", a->Encoding, 1);
	if (a->Recipient)
		soap_set_attr(soap, "Recipient", a->Recipient, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedKeyType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (a->CipherData)
	{	if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "xenc:CipherData"))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->ReferenceList, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:CarriedKeyName", -1, &a->CarriedKeyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_in_xenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	size_t soap_flag_ReferenceList = 1;
	size_t soap_flag_CarriedKeyName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptedKeyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedKeyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Recipient", 0), &a->Recipient, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			if (soap_flag_ReferenceList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->ReferenceList, ""))
				{	soap_flag_ReferenceList--;
					continue;
				}
			if (soap_flag_CarriedKeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:CarriedKeyName", &a->CarriedKeyName, "xsd:string"))
				{	soap_flag_CarriedKeyName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedKeyType, 0, sizeof(struct xenc__EncryptedKeyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptedKeyType);
	if (soap_out_xenc__EncryptedKeyType(soap, tag?tag:"xenc:EncryptedKeyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_get_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct xenc__EncryptedKeyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedKeyType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptedKeyType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xenc__EncryptedKeyType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct xenc__EncryptedKeyType);
		if (size)
			*size = sizeof(struct xenc__EncryptedKeyType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct xenc__EncryptedKeyType, n);
		if (size)
			*size = n * sizeof(struct xenc__EncryptedKeyType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct xenc__EncryptedKeyType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xenc__EncryptedKeyType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xenc__EncryptedKeyType %p -> %p\n", q, p));
	*(struct xenc__EncryptedKeyType*)p = *(struct xenc__EncryptedKeyType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedDataType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedDataType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", a->MimeType, 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", a->Encoding, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedDataType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (a->CipherData)
	{	if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "xenc:CipherData"))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_in_xenc__EncryptedDataType(struct soap *soap, const char *tag, struct xenc__EncryptedDataType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptedDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedDataType, sizeof(struct xenc__EncryptedDataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedDataType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedDataType, 0, sizeof(struct xenc__EncryptedDataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptedDataType);
	if (soap_out_xenc__EncryptedDataType(soap, tag?tag:"xenc:EncryptedDataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_get_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct xenc__EncryptedDataType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptedDataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xenc__EncryptedDataType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct xenc__EncryptedDataType);
		if (size)
			*size = sizeof(struct xenc__EncryptedDataType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct xenc__EncryptedDataType, n);
		if (size)
			*size = n * sizeof(struct xenc__EncryptedDataType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct xenc__EncryptedDataType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xenc__EncryptedDataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xenc__EncryptedDataType %p -> %p\n", q, p));
	*(struct xenc__EncryptedDataType*)p = *(struct xenc__EncryptedDataType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__ds__Transform(soap, &a->ds__Transform);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__ds__Transform(soap, &a->ds__Transform);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__TransformsType(struct soap *soap, const char *tag, int id, const struct xenc__TransformsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__TransformsType), type))
		return soap->error;
	if (soap_out__ds__Transform(soap, "ds:Transform", -1, &a->ds__Transform, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_in_xenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType *a, const char *type)
{
	size_t soap_flag_ds__Transform = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__TransformsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ds__Transform && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ds__Transform(soap, "ds:Transform", &a->ds__Transform, ""))
				{	soap_flag_ds__Transform--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__TransformsType, 0, sizeof(struct xenc__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ds__Transform > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__TransformsType);
	if (soap_out_xenc__TransformsType(soap, tag?tag:"xenc:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_get_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct xenc__TransformsType * SOAP_FMAC2 soap_instantiate_xenc__TransformsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__TransformsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xenc__TransformsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct xenc__TransformsType);
		if (size)
			*size = sizeof(struct xenc__TransformsType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct xenc__TransformsType, n);
		if (size)
			*size = n * sizeof(struct xenc__TransformsType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct xenc__TransformsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xenc__TransformsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xenc__TransformsType %p -> %p\n", q, p));
	*(struct xenc__TransformsType*)p = *(struct xenc__TransformsType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__TransformsType(soap, &a->Transforms);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__CipherReferenceType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherReferenceType), type))
		return soap->error;
	if (soap_out_PointerToxenc__TransformsType(soap, "xenc:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_in_xenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__CipherReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1), &a->URI, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__TransformsType(soap, "xenc:Transforms", &a->Transforms, "xenc:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherReferenceType, 0, sizeof(struct xenc__CipherReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__CipherReferenceType);
	if (soap_out_xenc__CipherReferenceType(soap, tag?tag:"xenc:CipherReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_get_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct xenc__CipherReferenceType * SOAP_FMAC2 soap_instantiate_xenc__CipherReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__CipherReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xenc__CipherReferenceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct xenc__CipherReferenceType);
		if (size)
			*size = sizeof(struct xenc__CipherReferenceType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct xenc__CipherReferenceType, n);
		if (size)
			*size = n * sizeof(struct xenc__CipherReferenceType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct xenc__CipherReferenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xenc__CipherReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xenc__CipherReferenceType %p -> %p\n", q, p));
	*(struct xenc__CipherReferenceType*)p = *(struct xenc__CipherReferenceType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->CipherValue);
	a->CipherReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->CipherValue);
	soap_serialize_PointerToxenc__CipherReferenceType(soap, &a->CipherReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherDataType(struct soap *soap, const char *tag, int id, const struct xenc__CipherDataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherDataType), type))
		return soap->error;
	if (soap_out_string(soap, "xenc:CipherValue", -1, &a->CipherValue, ""))
		return soap->error;
	if (soap_out_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", -1, &a->CipherReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_in_xenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType *a, const char *type)
{
	size_t soap_flag_CipherValue = 1;
	size_t soap_flag_CipherReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__CipherDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherDataType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CipherValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:CipherValue", &a->CipherValue, "xsd:string"))
				{	soap_flag_CipherValue--;
					continue;
				}
			if (soap_flag_CipherReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", &a->CipherReference, "xenc:CipherReferenceType"))
				{	soap_flag_CipherReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherDataType, 0, sizeof(struct xenc__CipherDataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__CipherDataType);
	if (soap_out_xenc__CipherDataType(soap, tag?tag:"xenc:CipherDataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_get_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct xenc__CipherDataType * SOAP_FMAC2 soap_instantiate_xenc__CipherDataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__CipherDataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xenc__CipherDataType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct xenc__CipherDataType);
		if (size)
			*size = sizeof(struct xenc__CipherDataType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct xenc__CipherDataType, n);
		if (size)
			*size = n * sizeof(struct xenc__CipherDataType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct xenc__CipherDataType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xenc__CipherDataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xenc__CipherDataType %p -> %p\n", q, p));
	*(struct xenc__CipherDataType*)p = *(struct xenc__CipherDataType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->KeySize = NULL;
	soap_default_string(soap, &a->OAEPparams);
	soap_default_string(soap, &a->Algorithm);
	a->ds__DigestMethod = NULL;
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->KeySize);
	soap_serialize_string(soap, &a->OAEPparams);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->ds__DigestMethod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "xenc:KeySize", -1, &a->KeySize, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:OAEPparams", -1, &a->OAEPparams, ""))
		return soap->error;
	if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->ds__DigestMethod, ""))
		return soap->error;
	soap_outliteral(soap, "-mixed", &a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_in_xenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType *a, const char *type)
{
	size_t soap_flag_KeySize = 1;
	size_t soap_flag_OAEPparams = 1;
	size_t soap_flag_ds__DigestMethod = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeySize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "xenc:KeySize", &a->KeySize, "xsd:int"))
				{	soap_flag_KeySize--;
					continue;
				}
			if (soap_flag_OAEPparams && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:OAEPparams", &a->OAEPparams, "xsd:string"))
				{	soap_flag_OAEPparams--;
					continue;
				}
			if (soap_flag_ds__DigestMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->ds__DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_ds__DigestMethod--;
					continue;
				}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionMethodType, 0, sizeof(struct xenc__EncryptionMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptionMethodType);
	if (soap_out_xenc__EncryptionMethodType(soap, tag?tag:"xenc:EncryptionMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_get_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct xenc__EncryptionMethodType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptionMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xenc__EncryptionMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct xenc__EncryptionMethodType);
		if (size)
			*size = sizeof(struct xenc__EncryptionMethodType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct xenc__EncryptionMethodType, n);
		if (size)
			*size = n * sizeof(struct xenc__EncryptionMethodType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct xenc__EncryptionMethodType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xenc__EncryptionMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xenc__EncryptionMethodType %p -> %p\n", q, p));
	*(struct xenc__EncryptionMethodType*)p = *(struct xenc__EncryptionMethodType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", a->MimeType, 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", a->Encoding, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (a->CipherData)
	{	if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "xenc:CipherData"))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_in_xenc__EncryptedType(struct soap *soap, const char *tag, struct xenc__EncryptedType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptedType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedType, sizeof(struct xenc__EncryptedType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedType, 0, sizeof(struct xenc__EncryptedType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptedType);
	if (soap_out_xenc__EncryptedType(soap, tag?tag:"xenc:EncryptedType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_get_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct xenc__EncryptedType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xenc__EncryptedType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xenc__EncryptedType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct xenc__EncryptedType);
		if (size)
			*size = sizeof(struct xenc__EncryptedType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct xenc__EncryptedType, n);
		if (size)
			*size = n * sizeof(struct xenc__EncryptedType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct xenc__EncryptedType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xenc__EncryptedType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct xenc__EncryptedType %p -> %p\n", q, p));
	*(struct xenc__EncryptedType*)p = *(struct xenc__EncryptedType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Modulus);
	soap_default_string(soap, &a->Exponent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Modulus);
	soap_serialize_string(soap, &a->Exponent);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__RSAKeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RSAKeyValueType), type))
		return soap->error;
	if (a->Modulus)
	{	if (soap_out_string(soap, "ds:Modulus", -1, &a->Modulus, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Modulus"))
		return soap->error;
	if (a->Exponent)
	{	if (soap_out_string(soap, "ds:Exponent", -1, &a->Exponent, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Exponent"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_in_ds__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType *a, const char *type)
{
	size_t soap_flag_Modulus = 1;
	size_t soap_flag_Exponent = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Modulus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Modulus", &a->Modulus, "xsd:string"))
				{	soap_flag_Modulus--;
					continue;
				}
			if (soap_flag_Exponent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Exponent", &a->Exponent, "xsd:string"))
				{	soap_flag_Exponent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RSAKeyValueType, 0, sizeof(struct ds__RSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Modulus > 0 || soap_flag_Exponent > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RSAKeyValueType);
	if (soap_out_ds__RSAKeyValueType(soap, tag?tag:"ds:RSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_get_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__RSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__RSAKeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__RSAKeyValueType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__RSAKeyValueType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__RSAKeyValueType);
		if (size)
			*size = sizeof(struct ds__RSAKeyValueType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ds__RSAKeyValueType, n);
		if (size)
			*size = n * sizeof(struct ds__RSAKeyValueType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ds__RSAKeyValueType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__RSAKeyValueType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__RSAKeyValueType %p -> %p\n", q, p));
	*(struct ds__RSAKeyValueType*)p = *(struct ds__RSAKeyValueType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->G);
	soap_default_string(soap, &a->Y);
	soap_default_string(soap, &a->J);
	soap_default_string(soap, &a->P);
	soap_default_string(soap, &a->Q);
	soap_default_string(soap, &a->Seed);
	soap_default_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->G);
	soap_serialize_string(soap, &a->Y);
	soap_serialize_string(soap, &a->J);
	soap_serialize_string(soap, &a->P);
	soap_serialize_string(soap, &a->Q);
	soap_serialize_string(soap, &a->Seed);
	soap_serialize_string(soap, &a->PgenCounter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__DSAKeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DSAKeyValueType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:G", -1, &a->G, ""))
		return soap->error;
	if (a->Y)
	{	if (soap_out_string(soap, "ds:Y", -1, &a->Y, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Y"))
		return soap->error;
	if (soap_out_string(soap, "ds:J", -1, &a->J, ""))
		return soap->error;
	if (a->P)
	{	if (soap_out_string(soap, "ds:P", -1, &a->P, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:P"))
		return soap->error;
	if (a->Q)
	{	if (soap_out_string(soap, "ds:Q", -1, &a->Q, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Q"))
		return soap->error;
	if (a->Seed)
	{	if (soap_out_string(soap, "ds:Seed", -1, &a->Seed, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Seed"))
		return soap->error;
	if (a->PgenCounter)
	{	if (soap_out_string(soap, "ds:PgenCounter", -1, &a->PgenCounter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:PgenCounter"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_in_ds__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType *a, const char *type)
{
	size_t soap_flag_G = 1;
	size_t soap_flag_Y = 1;
	size_t soap_flag_J = 1;
	size_t soap_flag_P = 1;
	size_t soap_flag_Q = 1;
	size_t soap_flag_Seed = 1;
	size_t soap_flag_PgenCounter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_G && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:G", &a->G, "xsd:string"))
				{	soap_flag_G--;
					continue;
				}
			if (soap_flag_Y && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Y", &a->Y, "xsd:string"))
				{	soap_flag_Y--;
					continue;
				}
			if (soap_flag_J && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:J", &a->J, "xsd:string"))
				{	soap_flag_J--;
					continue;
				}
			if (soap_flag_P && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:P", &a->P, "xsd:string"))
				{	soap_flag_P--;
					continue;
				}
			if (soap_flag_Q && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Q", &a->Q, "xsd:string"))
				{	soap_flag_Q--;
					continue;
				}
			if (soap_flag_Seed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Seed", &a->Seed, "xsd:string"))
				{	soap_flag_Seed--;
					continue;
				}
			if (soap_flag_PgenCounter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:PgenCounter", &a->PgenCounter, "xsd:string"))
				{	soap_flag_PgenCounter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DSAKeyValueType, 0, sizeof(struct ds__DSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Y > 0 || soap_flag_P > 0 || soap_flag_Q > 0 || soap_flag_Seed > 0 || soap_flag_PgenCounter > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DSAKeyValueType);
	if (soap_out_ds__DSAKeyValueType(soap, tag?tag:"ds:DSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_get_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__DSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__DSAKeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__DSAKeyValueType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__DSAKeyValueType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__DSAKeyValueType);
		if (size)
			*size = sizeof(struct ds__DSAKeyValueType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ds__DSAKeyValueType, n);
		if (size)
			*size = n * sizeof(struct ds__DSAKeyValueType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ds__DSAKeyValueType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__DSAKeyValueType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__DSAKeyValueType %p -> %p\n", q, p));
	*(struct ds__DSAKeyValueType*)p = *(struct ds__DSAKeyValueType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->X509IssuerName);
	soap_default_string(soap, &a->X509SerialNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->X509IssuerName);
	soap_serialize_string(soap, &a->X509SerialNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509IssuerSerialType(struct soap *soap, const char *tag, int id, const struct ds__X509IssuerSerialType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509IssuerSerialType), type))
		return soap->error;
	if (a->X509IssuerName)
	{	if (soap_out_string(soap, "ds:X509IssuerName", -1, &a->X509IssuerName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509IssuerName"))
		return soap->error;
	if (a->X509SerialNumber)
	{	if (soap_out_string(soap, "ds:X509SerialNumber", -1, &a->X509SerialNumber, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509SerialNumber"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_in_ds__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType *a, const char *type)
{
	size_t soap_flag_X509IssuerName = 1;
	size_t soap_flag_X509SerialNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509IssuerSerialType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509IssuerSerialType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509IssuerName", &a->X509IssuerName, "xsd:string"))
				{	soap_flag_X509IssuerName--;
					continue;
				}
			if (soap_flag_X509SerialNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SerialNumber", &a->X509SerialNumber, "xsd:string"))
				{	soap_flag_X509SerialNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509IssuerSerialType, 0, sizeof(struct ds__X509IssuerSerialType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerName > 0 || soap_flag_X509SerialNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509IssuerSerialType);
	if (soap_out_ds__X509IssuerSerialType(soap, tag?tag:"ds:X509IssuerSerialType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_get_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__X509IssuerSerialType * SOAP_FMAC2 soap_instantiate_ds__X509IssuerSerialType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__X509IssuerSerialType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__X509IssuerSerialType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__X509IssuerSerialType);
		if (size)
			*size = sizeof(struct ds__X509IssuerSerialType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ds__X509IssuerSerialType, n);
		if (size)
			*size = n * sizeof(struct ds__X509IssuerSerialType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ds__X509IssuerSerialType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__X509IssuerSerialType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__X509IssuerSerialType %p -> %p\n", q, p));
	*(struct ds__X509IssuerSerialType*)p = *(struct ds__X509IssuerSerialType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RetrievalMethodType(struct soap *soap, const char *tag, int id, const struct ds__RetrievalMethodType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RetrievalMethodType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_in_ds__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RetrievalMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RetrievalMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RetrievalMethodType, 0, sizeof(struct ds__RetrievalMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RetrievalMethodType);
	if (soap_out_ds__RetrievalMethodType(soap, tag?tag:"ds:RetrievalMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_get_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__RetrievalMethodType * SOAP_FMAC2 soap_instantiate_ds__RetrievalMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__RetrievalMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__RetrievalMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__RetrievalMethodType);
		if (size)
			*size = sizeof(struct ds__RetrievalMethodType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ds__RetrievalMethodType, n);
		if (size)
			*size = n * sizeof(struct ds__RetrievalMethodType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ds__RetrievalMethodType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__RetrievalMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__RetrievalMethodType %p -> %p\n", q, p));
	*(struct ds__RetrievalMethodType*)p = *(struct ds__RetrievalMethodType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DSAKeyValue = NULL;
	a->RSAKeyValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__DSAKeyValueType(soap, &a->DSAKeyValue);
	soap_serialize_PointerTods__RSAKeyValueType(soap, &a->RSAKeyValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyValueType(struct soap *soap, const char *tag, int id, const struct ds__KeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyValueType), type))
		return soap->error;
	if (soap_out_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", -1, &a->DSAKeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", -1, &a->RSAKeyValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_in_ds__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType *a, const char *type)
{
	size_t soap_flag_DSAKeyValue = 1;
	size_t soap_flag_RSAKeyValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", &a->DSAKeyValue, "ds:DSAKeyValueType"))
				{	soap_flag_DSAKeyValue--;
					continue;
				}
			if (soap_flag_RSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", &a->RSAKeyValue, "ds:RSAKeyValueType"))
				{	soap_flag_RSAKeyValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyValueType, 0, sizeof(struct ds__KeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyValueType);
	if (soap_out_ds__KeyValueType(soap, tag?tag:"ds:KeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_get_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__KeyValueType * SOAP_FMAC2 soap_instantiate_ds__KeyValueType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__KeyValueType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__KeyValueType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__KeyValueType);
		if (size)
			*size = sizeof(struct ds__KeyValueType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ds__KeyValueType, n);
		if (size)
			*size = n * sizeof(struct ds__KeyValueType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ds__KeyValueType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__KeyValueType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__KeyValueType %p -> %p\n", q, p));
	*(struct ds__KeyValueType*)p = *(struct ds__KeyValueType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DigestMethodType(struct soap *soap, const char *tag, int id, const struct ds__DigestMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DigestMethodType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_in_ds__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DigestMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DigestMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DigestMethodType, 0, sizeof(struct ds__DigestMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DigestMethodType);
	if (soap_out_ds__DigestMethodType(soap, tag?tag:"ds:DigestMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_get_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__DigestMethodType * SOAP_FMAC2 soap_instantiate_ds__DigestMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__DigestMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__DigestMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__DigestMethodType);
		if (size)
			*size = sizeof(struct ds__DigestMethodType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ds__DigestMethodType, n);
		if (size)
			*size = n * sizeof(struct ds__DigestMethodType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ds__DigestMethodType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__DigestMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__DigestMethodType %p -> %p\n", q, p));
	*(struct ds__DigestMethodType*)p = *(struct ds__DigestMethodType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformType(struct soap *soap, struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->c14n__InclusiveNamespaces = NULL;
	a->__any = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformType(struct soap *soap, const struct ds__TransformType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformType(struct soap *soap, const char *tag, int id, const struct ds__TransformType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_in_ds__TransformType(struct soap *soap, const char *tag, struct ds__TransformType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 0), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformType, 0, sizeof(struct ds__TransformType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformType(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformType);
	if (soap_out_ds__TransformType(soap, tag?tag:"ds:TransformType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_get_ds__TransformType(struct soap *soap, struct ds__TransformType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__TransformType * SOAP_FMAC2 soap_instantiate_ds__TransformType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__TransformType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__TransformType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__TransformType);
		if (size)
			*size = sizeof(struct ds__TransformType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ds__TransformType, n);
		if (size)
			*size = n * sizeof(struct ds__TransformType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ds__TransformType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__TransformType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__TransformType %p -> %p\n", q, p));
	*(struct ds__TransformType*)p = *(struct ds__TransformType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PrefixList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, const struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (a->PrefixList)
		soap_set_attr(soap, "PrefixList", a->PrefixList, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__c14n__InclusiveNamespaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_in__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _c14n__InclusiveNamespaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__c14n__InclusiveNamespaces(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PrefixList", 0), &a->PrefixList, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__c14n__InclusiveNamespaces, 0, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (soap_out__c14n__InclusiveNamespaces(soap, tag?tag:"c14n:InclusiveNamespaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_get__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _c14n__InclusiveNamespaces * SOAP_FMAC2 soap_instantiate__c14n__InclusiveNamespaces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__c14n__InclusiveNamespaces(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__c14n__InclusiveNamespaces, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _c14n__InclusiveNamespaces);
		if (size)
			*size = sizeof(struct _c14n__InclusiveNamespaces);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct _c14n__InclusiveNamespaces, n);
		if (size)
			*size = n * sizeof(struct _c14n__InclusiveNamespaces);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct _c14n__InclusiveNamespaces*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__c14n__InclusiveNamespaces(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _c14n__InclusiveNamespaces %p -> %p\n", q, p));
	*(struct _c14n__InclusiveNamespaces*)p = *(struct _c14n__InclusiveNamespaces*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformsType(struct soap *soap, struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTransform = 0;
	a->Transform = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Transform)
	{	int i;
		for (i = 0; i < a->__sizeTransform; i++)
		{
			soap_embedded(soap, a->Transform + i, SOAP_TYPE_ds__TransformType);
			soap_serialize_ds__TransformType(soap, a->Transform + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformsType(struct soap *soap, const char *tag, int id, const struct ds__TransformsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformsType), type))
		return soap->error;
	if (a->Transform)
	{	int i;
		for (i = 0; i < a->__sizeTransform; i++)
			if (soap_out_ds__TransformType(soap, "ds:Transform", -1, a->Transform + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_in_ds__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType *a, const char *type)
{
	struct soap_blist *soap_blist_Transform = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Transform", 1, NULL))
			{	if (a->Transform == NULL)
				{	if (soap_blist_Transform == NULL)
						soap_blist_Transform = soap_new_block(soap);
					a->Transform = (struct ds__TransformType *)soap_push_block(soap, soap_blist_Transform, sizeof(struct ds__TransformType));
					if (a->Transform == NULL)
						return NULL;
					SOAP_PLACEMENT_NEW(a->Transform, struct ds__TransformType);
					soap_default_ds__TransformType(soap, a->Transform);
				}
				soap_revert(soap);
				if (soap_in_ds__TransformType(soap, "ds:Transform", a->Transform, "ds:TransformType"))
				{	a->__sizeTransform++;
					a->Transform = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Transform)
			soap_pop_block(soap, soap_blist_Transform);
		if (a->__sizeTransform)
			a->Transform = (struct ds__TransformType *)soap_save_block(soap, soap_blist_Transform, NULL, 1);
		else
		{	a->Transform = NULL;
			if (soap_blist_Transform)
				soap_end_block(soap, soap_blist_Transform);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformsType, 0, sizeof(struct ds__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformsType);
	if (soap_out_ds__TransformsType(soap, tag?tag:"ds:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_get_ds__TransformsType(struct soap *soap, struct ds__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__TransformsType * SOAP_FMAC2 soap_instantiate_ds__TransformsType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__TransformsType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__TransformsType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__TransformsType);
		if (size)
			*size = sizeof(struct ds__TransformsType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ds__TransformsType, n);
		if (size)
			*size = n * sizeof(struct ds__TransformsType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ds__TransformsType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__TransformsType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__TransformsType %p -> %p\n", q, p));
	*(struct ds__TransformsType*)p = *(struct ds__TransformsType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	a->DigestMethod = NULL;
	soap_default_string(soap, &a->DigestValue);
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->DigestMethod);
	soap_serialize_string(soap, &a->DigestValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__ReferenceType(struct soap *soap, const char *tag, int id, const struct ds__ReferenceType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__ReferenceType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	if (a->DigestMethod)
	{	if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->DigestMethod, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:DigestMethod"))
		return soap->error;
	if (a->DigestValue)
	{	if (soap_out_string(soap, "ds:DigestValue", -1, &a->DigestValue, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:DigestValue"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_in_ds__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	size_t soap_flag_DigestMethod = 1;
	size_t soap_flag_DigestValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap_flag_DigestMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_DigestMethod--;
					continue;
				}
			if (soap_flag_DigestValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:DigestValue", &a->DigestValue, "xsd:string"))
				{	soap_flag_DigestValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__ReferenceType, 0, sizeof(struct ds__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DigestMethod > 0 || soap_flag_DigestValue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__ReferenceType);
	if (soap_out_ds__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_get_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__ReferenceType * SOAP_FMAC2 soap_instantiate_ds__ReferenceType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__ReferenceType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__ReferenceType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__ReferenceType);
		if (size)
			*size = sizeof(struct ds__ReferenceType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ds__ReferenceType, n);
		if (size)
			*size = n * sizeof(struct ds__ReferenceType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ds__ReferenceType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__ReferenceType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__ReferenceType %p -> %p\n", q, p));
	*(struct ds__ReferenceType*)p = *(struct ds__ReferenceType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HMACOutputLength = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->HMACOutputLength);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureMethodType(struct soap *soap, const char *tag, int id, const struct ds__SignatureMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ds:HMACOutputLength", -1, &a->HMACOutputLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_in_ds__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType *a, const char *type)
{
	size_t soap_flag_HMACOutputLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HMACOutputLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ds:HMACOutputLength", &a->HMACOutputLength, "xsd:int"))
				{	soap_flag_HMACOutputLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureMethodType, 0, sizeof(struct ds__SignatureMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureMethodType);
	if (soap_out_ds__SignatureMethodType(soap, tag?tag:"ds:SignatureMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_get_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__SignatureMethodType * SOAP_FMAC2 soap_instantiate_ds__SignatureMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignatureMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__SignatureMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__SignatureMethodType);
		if (size)
			*size = sizeof(struct ds__SignatureMethodType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ds__SignatureMethodType, n);
		if (size)
			*size = n * sizeof(struct ds__SignatureMethodType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ds__SignatureMethodType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__SignatureMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__SignatureMethodType %p -> %p\n", q, p));
	*(struct ds__SignatureMethodType*)p = *(struct ds__SignatureMethodType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
	a->c14n__InclusiveNamespaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, const struct ds__CanonicalizationMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__CanonicalizationMethodType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_in_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__CanonicalizationMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__CanonicalizationMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__CanonicalizationMethodType, 0, sizeof(struct ds__CanonicalizationMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (soap_out_ds__CanonicalizationMethodType(soap, tag?tag:"ds:CanonicalizationMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_get_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__CanonicalizationMethodType * SOAP_FMAC2 soap_instantiate_ds__CanonicalizationMethodType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__CanonicalizationMethodType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__CanonicalizationMethodType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__CanonicalizationMethodType);
		if (size)
			*size = sizeof(struct ds__CanonicalizationMethodType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ds__CanonicalizationMethodType, n);
		if (size)
			*size = n * sizeof(struct ds__CanonicalizationMethodType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ds__CanonicalizationMethodType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__CanonicalizationMethodType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__CanonicalizationMethodType %p -> %p\n", q, p));
	*(struct ds__CanonicalizationMethodType*)p = *(struct ds__CanonicalizationMethodType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KeyName);
	a->KeyValue = NULL;
	a->RetrievalMethod = NULL;
	a->X509Data = NULL;
	a->wsse__SecurityTokenReference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->KeyName);
	soap_serialize_PointerTods__KeyValueType(soap, &a->KeyValue);
	soap_serialize_PointerTods__RetrievalMethodType(soap, &a->RetrievalMethod);
	soap_serialize_PointerTods__X509DataType(soap, &a->X509Data);
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyInfoType(struct soap *soap, const char *tag, int id, const struct ds__KeyInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyInfoType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:KeyName", -1, &a->KeyName, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyValueType(soap, "ds:KeyValue", -1, &a->KeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", -1, &a->RetrievalMethod, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->X509Data, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_in_ds__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType *a, const char *type)
{
	size_t soap_flag_KeyName = 1;
	size_t soap_flag_KeyValue = 1;
	size_t soap_flag_RetrievalMethod = 1;
	size_t soap_flag_X509Data = 1;
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:KeyName", &a->KeyName, "xsd:string"))
				{	soap_flag_KeyName--;
					continue;
				}
			if (soap_flag_KeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyValueType(soap, "ds:KeyValue", &a->KeyValue, "ds:KeyValueType"))
				{	soap_flag_KeyValue--;
					continue;
				}
			if (soap_flag_RetrievalMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", &a->RetrievalMethod, "ds:RetrievalMethodType"))
				{	soap_flag_RetrievalMethod--;
					continue;
				}
			if (soap_flag_X509Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->X509Data, "ds:X509DataType"))
				{	soap_flag_X509Data--;
					continue;
				}
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyInfoType, 0, sizeof(struct ds__KeyInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyInfoType);
	if (soap_out_ds__KeyInfoType(soap, tag?tag:"ds:KeyInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_get_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__KeyInfoType * SOAP_FMAC2 soap_instantiate_ds__KeyInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__KeyInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__KeyInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__KeyInfoType);
		if (size)
			*size = sizeof(struct ds__KeyInfoType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ds__KeyInfoType, n);
		if (size)
			*size = n * sizeof(struct ds__KeyInfoType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ds__KeyInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__KeyInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__KeyInfoType %p -> %p\n", q, p));
	*(struct ds__KeyInfoType*)p = *(struct ds__KeyInfoType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CanonicalizationMethod = NULL;
	a->SignatureMethod = NULL;
	a->__sizeReference = 0;
	a->Reference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__CanonicalizationMethodType(soap, &a->CanonicalizationMethod);
	soap_serialize_PointerTods__SignatureMethodType(soap, &a->SignatureMethod);
	if (a->Reference)
	{	int i;
		for (i = 0; i < a->__sizeReference; i++)
		{
			soap_serialize_PointerTods__ReferenceType(soap, a->Reference + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignedInfoType(struct soap *soap, const char *tag, int id, const struct ds__SignedInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignedInfoType), type))
		return soap->error;
	if (a->CanonicalizationMethod)
	{	if (soap_out_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", -1, &a->CanonicalizationMethod, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:CanonicalizationMethod"))
		return soap->error;
	if (a->SignatureMethod)
	{	if (soap_out_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", -1, &a->SignatureMethod, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:SignatureMethod"))
		return soap->error;
	if (a->Reference)
	{	int i;
		for (i = 0; i < a->__sizeReference; i++)
			if (soap_out_PointerTods__ReferenceType(soap, "ds:Reference", -1, a->Reference + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_in_ds__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType *a, const char *type)
{
	size_t soap_flag_CanonicalizationMethod = 1;
	size_t soap_flag_SignatureMethod = 1;
	struct soap_blist *soap_blist_Reference = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignedInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignedInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanonicalizationMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", &a->CanonicalizationMethod, "ds:CanonicalizationMethodType"))
				{	soap_flag_CanonicalizationMethod--;
					continue;
				}
			if (soap_flag_SignatureMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", &a->SignatureMethod, "ds:SignatureMethodType"))
				{	soap_flag_SignatureMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Reference", 1, NULL))
			{	if (a->Reference == NULL)
				{	if (soap_blist_Reference == NULL)
						soap_blist_Reference = soap_new_block(soap);
					a->Reference = (struct ds__ReferenceType **)soap_push_block(soap, soap_blist_Reference, sizeof(struct ds__ReferenceType *));
					if (a->Reference == NULL)
						return NULL;
					*a->Reference = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTods__ReferenceType(soap, "ds:Reference", a->Reference, "ds:ReferenceType"))
				{	a->__sizeReference++;
					a->Reference = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Reference)
			soap_pop_block(soap, soap_blist_Reference);
		if (a->__sizeReference)
			a->Reference = (struct ds__ReferenceType **)soap_save_block(soap, soap_blist_Reference, NULL, 1);
		else
		{	a->Reference = NULL;
			if (soap_blist_Reference)
				soap_end_block(soap, soap_blist_Reference);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignedInfoType, 0, sizeof(struct ds__SignedInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CanonicalizationMethod > 0 || soap_flag_SignatureMethod > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignedInfoType);
	if (soap_out_ds__SignedInfoType(soap, tag?tag:"ds:SignedInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_get_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__SignedInfoType * SOAP_FMAC2 soap_instantiate_ds__SignedInfoType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignedInfoType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__SignedInfoType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__SignedInfoType);
		if (size)
			*size = sizeof(struct ds__SignedInfoType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ds__SignedInfoType, n);
		if (size)
			*size = n * sizeof(struct ds__SignedInfoType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ds__SignedInfoType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__SignedInfoType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__SignedInfoType %p -> %p\n", q, p));
	*(struct ds__SignedInfoType*)p = *(struct ds__SignedInfoType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureType(struct soap *soap, struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SignedInfo = NULL;
	soap_default_string(soap, &a->SignatureValue);
	a->KeyInfo = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__SignedInfoType(soap, &a->SignedInfo);
	soap_serialize_string(soap, &a->SignatureValue);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->KeyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureType(struct soap *soap, const char *tag, int id, const struct ds__SignatureType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureType), type))
		return soap->error;
	if (soap_out_PointerTods__SignedInfoType(soap, "ds:SignedInfo", -1, &a->SignedInfo, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:SignatureValue", -1, &a->SignatureValue, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "ds:KeyInfo", -1, &a->KeyInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_in_ds__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType *a, const char *type)
{
	size_t soap_flag_SignedInfo = 1;
	size_t soap_flag_SignatureValue = 1;
	size_t soap_flag_KeyInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SignedInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignedInfoType(soap, "ds:SignedInfo", &a->SignedInfo, "ds:SignedInfoType"))
				{	soap_flag_SignedInfo--;
					continue;
				}
			if (soap_flag_SignatureValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:SignatureValue", &a->SignatureValue, "xsd:string"))
				{	soap_flag_SignatureValue--;
					continue;
				}
			if (soap_flag_KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "ds:KeyInfo", &a->KeyInfo, "ds:KeyInfoType"))
				{	soap_flag_KeyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureType, 0, sizeof(struct ds__SignatureType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureType);
	if (soap_out_ds__SignatureType(soap, tag?tag:"ds:SignatureType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_get_ds__SignatureType(struct soap *soap, struct ds__SignatureType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__SignatureType * SOAP_FMAC2 soap_instantiate_ds__SignatureType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__SignatureType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__SignatureType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__SignatureType);
		if (size)
			*size = sizeof(struct ds__SignatureType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ds__SignatureType, n);
		if (size)
			*size = n * sizeof(struct ds__SignatureType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ds__SignatureType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__SignatureType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__SignatureType %p -> %p\n", q, p));
	*(struct ds__SignatureType*)p = *(struct ds__SignatureType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509DataType(struct soap *soap, struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->X509IssuerSerial = NULL;
	soap_default_string(soap, &a->X509SKI);
	soap_default_string(soap, &a->X509SubjectName);
	soap_default_string(soap, &a->X509Certificate);
	soap_default_string(soap, &a->X509CRL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__X509IssuerSerialType(soap, &a->X509IssuerSerial);
	soap_serialize_string(soap, &a->X509SKI);
	soap_serialize_string(soap, &a->X509SubjectName);
	soap_serialize_string(soap, &a->X509Certificate);
	soap_serialize_string(soap, &a->X509CRL);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509DataType(struct soap *soap, const char *tag, int id, const struct ds__X509DataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509DataType), type))
		return soap->error;
	if (soap_out_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", -1, &a->X509IssuerSerial, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SKI", -1, &a->X509SKI, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SubjectName", -1, &a->X509SubjectName, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509Certificate", -1, &a->X509Certificate, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509CRL", -1, &a->X509CRL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_in_ds__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType *a, const char *type)
{
	size_t soap_flag_X509IssuerSerial = 1;
	size_t soap_flag_X509SKI = 1;
	size_t soap_flag_X509SubjectName = 1;
	size_t soap_flag_X509Certificate = 1;
	size_t soap_flag_X509CRL = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509DataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509DataType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerSerial && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", &a->X509IssuerSerial, "ds:X509IssuerSerialType"))
				{	soap_flag_X509IssuerSerial--;
					continue;
				}
			if (soap_flag_X509SKI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SKI", &a->X509SKI, "xsd:string"))
				{	soap_flag_X509SKI--;
					continue;
				}
			if (soap_flag_X509SubjectName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SubjectName", &a->X509SubjectName, "xsd:string"))
				{	soap_flag_X509SubjectName--;
					continue;
				}
			if (soap_flag_X509Certificate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509Certificate", &a->X509Certificate, "xsd:string"))
				{	soap_flag_X509Certificate--;
					continue;
				}
			if (soap_flag_X509CRL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509CRL", &a->X509CRL, "xsd:string"))
				{	soap_flag_X509CRL--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509DataType, 0, sizeof(struct ds__X509DataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509DataType);
	if (soap_out_ds__X509DataType(soap, tag?tag:"ds:X509DataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_get_ds__X509DataType(struct soap *soap, struct ds__X509DataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct ds__X509DataType * SOAP_FMAC2 soap_instantiate_ds__X509DataType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ds__X509DataType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ds__X509DataType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct ds__X509DataType);
		if (size)
			*size = sizeof(struct ds__X509DataType);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct ds__X509DataType, n);
		if (size)
			*size = n * sizeof(struct ds__X509DataType);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct ds__X509DataType*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ds__X509DataType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct ds__X509DataType %p -> %p\n", q, p));
	*(struct ds__X509DataType*)p = *(struct ds__X509DataType*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Reference = NULL;
	a->KeyIdentifier = NULL;
	a->Embedded = NULL;
	a->ds__X509Data = NULL;
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->wsc__Instance);
	soap_default_string(soap, &a->Usage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__Reference(soap, &a->Reference);
	soap_serialize_PointerTo_wsse__KeyIdentifier(soap, &a->KeyIdentifier);
	soap_serialize_PointerTo_wsse__Embedded(soap, &a->Embedded);
	soap_serialize_PointerTods__X509DataType(soap, &a->ds__X509Data);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, const struct _wsse__SecurityTokenReference *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->wsc__Instance)
		soap_set_attr(soap, "wsc:Instance", a->wsc__Instance, 1);
	if (a->Usage)
		soap_set_attr(soap, "Usage", a->Usage, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__SecurityTokenReference), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__Reference(soap, "wsse:Reference", -1, &a->Reference, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", -1, &a->KeyIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Embedded(soap, "wsse:Embedded", -1, &a->Embedded, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->ds__X509Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_in__wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference *a, const char *type)
{
	size_t soap_flag_Reference = 1;
	size_t soap_flag_KeyIdentifier = 1;
	size_t soap_flag_Embedded = 1;
	size_t soap_flag_ds__X509Data = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__SecurityTokenReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__SecurityTokenReference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "wsc:Instance", 0), &a->wsc__Instance, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Usage", 0), &a->Usage, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Reference(soap, "wsse:Reference", &a->Reference, ""))
				{	soap_flag_Reference--;
					continue;
				}
			if (soap_flag_KeyIdentifier && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", &a->KeyIdentifier, ""))
				{	soap_flag_KeyIdentifier--;
					continue;
				}
			if (soap_flag_Embedded && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Embedded(soap, "wsse:Embedded", &a->Embedded, ""))
				{	soap_flag_Embedded--;
					continue;
				}
			if (soap_flag_ds__X509Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->ds__X509Data, "ds:X509DataType"))
				{	soap_flag_ds__X509Data--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__SecurityTokenReference, 0, sizeof(struct _wsse__SecurityTokenReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__SecurityTokenReference);
	if (soap_out__wsse__SecurityTokenReference(soap, tag?tag:"wsse:SecurityTokenReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_get__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__SecurityTokenReference * SOAP_FMAC2 soap_instantiate__wsse__SecurityTokenReference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__SecurityTokenReference(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__SecurityTokenReference, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__SecurityTokenReference);
		if (size)
			*size = sizeof(struct _wsse__SecurityTokenReference);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct _wsse__SecurityTokenReference, n);
		if (size)
			*size = n * sizeof(struct _wsse__SecurityTokenReference);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct _wsse__SecurityTokenReference*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__SecurityTokenReference(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__SecurityTokenReference %p -> %p\n", q, p));
	*(struct _wsse__SecurityTokenReference*)p = *(struct _wsse__SecurityTokenReference*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, const struct _wsse__KeyIdentifier *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_in__wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__KeyIdentifier *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), soap->type, soap->arrayType)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__KeyIdentifier(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__KeyIdentifier);
	if (soap_out__wsse__KeyIdentifier(soap, tag?tag:"wsse:KeyIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_get__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__KeyIdentifier * SOAP_FMAC2 soap_instantiate__wsse__KeyIdentifier(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__KeyIdentifier(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__KeyIdentifier, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__KeyIdentifier);
		if (size)
			*size = sizeof(struct _wsse__KeyIdentifier);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct _wsse__KeyIdentifier, n);
		if (size)
			*size = n * sizeof(struct _wsse__KeyIdentifier);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct _wsse__KeyIdentifier*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__KeyIdentifier(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__KeyIdentifier %p -> %p\n", q, p));
	*(struct _wsse__KeyIdentifier*)p = *(struct _wsse__KeyIdentifier*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Embedded(struct soap *soap, const char *tag, int id, const struct _wsse__Embedded *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Embedded), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_in__wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Embedded *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Embedded(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Embedded, 0, sizeof(struct _wsse__Embedded), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Embedded);
	if (soap_out__wsse__Embedded(soap, tag?tag:"wsse:Embedded", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_get__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__Embedded * SOAP_FMAC2 soap_instantiate__wsse__Embedded(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Embedded(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__Embedded, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Embedded);
		if (size)
			*size = sizeof(struct _wsse__Embedded);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct _wsse__Embedded, n);
		if (size)
			*size = n * sizeof(struct _wsse__Embedded);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct _wsse__Embedded*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__Embedded(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__Embedded %p -> %p\n", q, p));
	*(struct _wsse__Embedded*)p = *(struct _wsse__Embedded*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Reference(struct soap *soap, struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Reference(struct soap *soap, const char *tag, int id, const struct _wsse__Reference *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Reference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_in__wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Reference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Reference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Reference, 0, sizeof(struct _wsse__Reference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Reference);
	if (soap_out__wsse__Reference(soap, tag?tag:"wsse:Reference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_get__wsse__Reference(struct soap *soap, struct _wsse__Reference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__Reference * SOAP_FMAC2 soap_instantiate__wsse__Reference(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Reference(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__Reference, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Reference);
		if (size)
			*size = sizeof(struct _wsse__Reference);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct _wsse__Reference, n);
		if (size)
			*size = n * sizeof(struct _wsse__Reference);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct _wsse__Reference*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__Reference(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__Reference %p -> %p\n", q, p));
	*(struct _wsse__Reference*)p = *(struct _wsse__Reference*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, const struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_in__wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__BinarySecurityToken *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), soap->type, soap->arrayType)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__BinarySecurityToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__BinarySecurityToken);
	if (soap_out__wsse__BinarySecurityToken(soap, tag?tag:"wsse:BinarySecurityToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_get__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__BinarySecurityToken * SOAP_FMAC2 soap_instantiate__wsse__BinarySecurityToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__BinarySecurityToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__BinarySecurityToken, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__BinarySecurityToken);
		if (size)
			*size = sizeof(struct _wsse__BinarySecurityToken);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct _wsse__BinarySecurityToken, n);
		if (size)
			*size = n * sizeof(struct _wsse__BinarySecurityToken);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct _wsse__BinarySecurityToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__BinarySecurityToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__BinarySecurityToken %p -> %p\n", q, p));
	*(struct _wsse__BinarySecurityToken*)p = *(struct _wsse__BinarySecurityToken*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Password(struct soap *soap, struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Password(struct soap *soap, const struct _wsse__Password *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Password(struct soap *soap, const char *tag, int id, const struct _wsse__Password *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_in__wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__Password *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), soap->type, soap->arrayType)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__Password(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Password(struct soap *soap, const struct _wsse__Password *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Password);
	if (soap_out__wsse__Password(soap, tag?tag:"wsse:Password", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_get__wsse__Password(struct soap *soap, struct _wsse__Password *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__Password * SOAP_FMAC2 soap_instantiate__wsse__Password(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__Password(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__Password, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__Password);
		if (size)
			*size = sizeof(struct _wsse__Password);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct _wsse__Password, n);
		if (size)
			*size = n * sizeof(struct _wsse__Password);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct _wsse__Password*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__Password(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__Password %p -> %p\n", q, p));
	*(struct _wsse__Password*)p = *(struct _wsse__Password*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	a->Password = NULL;
	soap_default_string(soap, &a->Nonce);
	soap_default_string(soap, &a->wsu__Created);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Username);
	soap_serialize_PointerTo_wsse__Password(soap, &a->Password);
	soap_serialize_string(soap, &a->Nonce);
	soap_serialize_string(soap, &a->wsu__Created);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__UsernameToken(struct soap *soap, const char *tag, int id, const struct _wsse__UsernameToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__UsernameToken), type))
		return soap->error;
	if (soap_out_string(soap, "wsse:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Password(soap, "wsse:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "wsse:Nonce", -1, &a->Nonce, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->wsu__Created, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_in__wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Nonce = 1;
	size_t soap_flag_wsu__Created = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__UsernameToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__UsernameToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Password(soap, "wsse:Password", &a->Password, ""))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Nonce", &a->Nonce, "xsd:string"))
				{	soap_flag_Nonce--;
					continue;
				}
			if (soap_flag_wsu__Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->wsu__Created, "xsd:string"))
				{	soap_flag_wsu__Created--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__UsernameToken, 0, sizeof(struct _wsse__UsernameToken), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__UsernameToken);
	if (soap_out__wsse__UsernameToken(soap, tag?tag:"wsse:UsernameToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_get__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsse__UsernameToken * SOAP_FMAC2 soap_instantiate__wsse__UsernameToken(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsse__UsernameToken(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsse__UsernameToken, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsse__UsernameToken);
		if (size)
			*size = sizeof(struct _wsse__UsernameToken);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct _wsse__UsernameToken, n);
		if (size)
			*size = n * sizeof(struct _wsse__UsernameToken);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct _wsse__UsernameToken*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsse__UsernameToken(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsse__UsernameToken %p -> %p\n", q, p));
	*(struct _wsse__UsernameToken*)p = *(struct _wsse__UsernameToken*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Created);
	soap_default_string(soap, &a->Expires);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Created);
	soap_serialize_string(soap, &a->Expires);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsu__Timestamp(struct soap *soap, const char *tag, int id, const struct _wsu__Timestamp *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsu__Timestamp), type))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->Created, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Expires", -1, &a->Expires, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_in__wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp *a, const char *type)
{
	size_t soap_flag_Created = 1;
	size_t soap_flag_Expires = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsu__Timestamp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsu__Timestamp(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->Created, "xsd:string"))
				{	soap_flag_Created--;
					continue;
				}
			if (soap_flag_Expires && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Expires", &a->Expires, "xsd:string"))
				{	soap_flag_Expires--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsu__Timestamp, 0, sizeof(struct _wsu__Timestamp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsu__Timestamp);
	if (soap_out__wsu__Timestamp(soap, tag?tag:"wsu:Timestamp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_get__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 struct _wsu__Timestamp * SOAP_FMAC2 soap_instantiate__wsu__Timestamp(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	(void)type; (void)arrayType; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__wsu__Timestamp(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__wsu__Timestamp, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)SOAP_NEW(struct _wsu__Timestamp);
		if (size)
			*size = sizeof(struct _wsu__Timestamp);
	}
	else
	{	cp->ptr = (void*)SOAP_NEW_ARRAY(struct _wsu__Timestamp, n);
		if (size)
			*size = n * sizeof(struct _wsu__Timestamp);
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	if (!cp->ptr)
		soap->error = SOAP_EOM;
	return (struct _wsu__Timestamp*)cp->ptr;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_copy__wsu__Timestamp(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	(void)soap; (void)tt; (void)st; (void)len; (void)n; /* appease -Wall -Werror */
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct _wsu__Timestamp %p -> %p\n", q, p));
	*(struct _wsu__Timestamp*)p = *(struct _wsu__Timestamp*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_EventStream(struct soap *soap, int choice, const union _tt__union_EventStream *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_EventStream_wsnt__NotificationMessage:
		soap_serialize_PointerTowsnt__NotificationMessageHolderType(soap, &a->wsnt__NotificationMessage);
		break;
	case SOAP_UNION__tt__union_EventStream_Extension:
		soap_serialize_PointerTott__EventStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_EventStream(struct soap *soap, int choice, const union _tt__union_EventStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__tt__union_EventStream_wsnt__NotificationMessage:
		return soap_out_PointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, &a->wsnt__NotificationMessage, "");
	case SOAP_UNION__tt__union_EventStream_Extension:
		return soap_out_PointerTott__EventStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_EventStream * SOAP_FMAC4 soap_in__tt__union_EventStream(struct soap *soap, int *choice, union _tt__union_EventStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->wsnt__NotificationMessage = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", &a->wsnt__NotificationMessage, "wsnt:NotificationMessageHolderType"))
	{	*choice = SOAP_UNION__tt__union_EventStream_wsnt__NotificationMessage;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__EventStreamExtension(soap, "tt:Extension", &a->Extension, "tt:EventStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_EventStream_Extension;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_PTZStream(struct soap *soap, int choice, const union _tt__union_PTZStream *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZStream_PTZStatus:
		soap_serialize_PointerTott__PTZStatus(soap, &a->PTZStatus);
		break;
	case SOAP_UNION__tt__union_PTZStream_Extension:
		soap_serialize_PointerTott__PTZStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_PTZStream(struct soap *soap, int choice, const union _tt__union_PTZStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZStream_PTZStatus:
		return soap_out_PointerTott__PTZStatus(soap, "tt:PTZStatus", -1, &a->PTZStatus, "");
	case SOAP_UNION__tt__union_PTZStream_Extension:
		return soap_out_PointerTott__PTZStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_PTZStream * SOAP_FMAC4 soap_in__tt__union_PTZStream(struct soap *soap, int *choice, union _tt__union_PTZStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->PTZStatus = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZStatus(soap, "tt:PTZStatus", &a->PTZStatus, "tt:PTZStatus"))
	{	*choice = SOAP_UNION__tt__union_PTZStream_PTZStatus;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZStreamExtension(soap, "tt:Extension", &a->Extension, "tt:PTZStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_PTZStream_Extension;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_VideoAnalyticsStream(struct soap *soap, int choice, const union _tt__union_VideoAnalyticsStream *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Frame:
		soap_serialize_PointerTott__Frame(soap, &a->Frame);
		break;
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Extension:
		soap_serialize_PointerTott__VideoAnalyticsStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_VideoAnalyticsStream(struct soap *soap, int choice, const union _tt__union_VideoAnalyticsStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Frame:
		return soap_out_PointerTott__Frame(soap, "tt:Frame", -1, &a->Frame, "");
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Extension:
		return soap_out_PointerTott__VideoAnalyticsStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_VideoAnalyticsStream * SOAP_FMAC4 soap_in__tt__union_VideoAnalyticsStream(struct soap *soap, int *choice, union _tt__union_VideoAnalyticsStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->Frame = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__Frame(soap, "tt:Frame", &a->Frame, "tt:Frame"))
	{	*choice = SOAP_UNION__tt__union_VideoAnalyticsStream_Frame;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__VideoAnalyticsStreamExtension(soap, "tt:Extension", &a->Extension, "tt:VideoAnalyticsStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_VideoAnalyticsStream_Extension;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_MetadataStream(struct soap *soap, int choice, const union _tt__union_MetadataStream *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_MetadataStream_VideoAnalytics:
		soap_serialize_PointerTott__VideoAnalyticsStream(soap, &a->VideoAnalytics);
		break;
	case SOAP_UNION__tt__union_MetadataStream_PTZ:
		soap_serialize_PointerTott__PTZStream(soap, &a->PTZ);
		break;
	case SOAP_UNION__tt__union_MetadataStream_Event:
		soap_serialize_PointerTott__EventStream(soap, &a->Event);
		break;
	case SOAP_UNION__tt__union_MetadataStream_Extension:
		soap_serialize_PointerTott__MetadataStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_MetadataStream(struct soap *soap, int choice, const union _tt__union_MetadataStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__tt__union_MetadataStream_VideoAnalytics:
		return soap_out_PointerTott__VideoAnalyticsStream(soap, "tt:VideoAnalytics", -1, &a->VideoAnalytics, "");
	case SOAP_UNION__tt__union_MetadataStream_PTZ:
		return soap_out_PointerTott__PTZStream(soap, "tt:PTZ", -1, &a->PTZ, "");
	case SOAP_UNION__tt__union_MetadataStream_Event:
		return soap_out_PointerTott__EventStream(soap, "tt:Event", -1, &a->Event, "");
	case SOAP_UNION__tt__union_MetadataStream_Extension:
		return soap_out_PointerTott__MetadataStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_MetadataStream * SOAP_FMAC4 soap_in__tt__union_MetadataStream(struct soap *soap, int *choice, union _tt__union_MetadataStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->VideoAnalytics = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__VideoAnalyticsStream(soap, "tt:VideoAnalytics", &a->VideoAnalytics, "tt:VideoAnalyticsStream"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_VideoAnalytics;
		return a;
	}
	a->PTZ = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZStream(soap, "tt:PTZ", &a->PTZ, "tt:PTZStream"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_PTZ;
		return a;
	}
	a->Event = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__EventStream(soap, "tt:Event", &a->Event, "tt:EventStream"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_Event;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__MetadataStreamExtension(soap, "tt:Extension", &a->Extension, "tt:MetadataStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_Extension;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_PTZPresetTourPresetDetail(struct soap *soap, int choice, const union _tt__union_PTZPresetTourPresetDetail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken:
		soap_serialize_tt__ReferenceToken(soap, &a->PresetToken);
		break;
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home:
		soap_embedded(soap, &a->Home, SOAP_TYPE_bool);
		break;
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition:
		soap_serialize_PointerTott__PTZVector(soap, &a->PTZPosition);
		break;
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension:
		soap_serialize_PointerTott__PTZPresetTourTypeExtension(soap, &a->TypeExtension);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_PTZPresetTourPresetDetail(struct soap *soap, int choice, const union _tt__union_PTZPresetTourPresetDetail *a)
{
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken:
		return soap_out_tt__ReferenceToken(soap, "tt:PresetToken", -1, &a->PresetToken, "");
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home:
		return soap_out_bool(soap, "tt:Home", -1, &a->Home, "");
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition:
		return soap_out_PointerTott__PTZVector(soap, "tt:PTZPosition", -1, &a->PTZPosition, "");
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension:
		return soap_out_PointerTott__PTZPresetTourTypeExtension(soap, "tt:TypeExtension", -1, &a->TypeExtension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_PTZPresetTourPresetDetail * SOAP_FMAC4 soap_in__tt__union_PTZPresetTourPresetDetail(struct soap *soap, int *choice, union _tt__union_PTZPresetTourPresetDetail *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->PresetToken = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_tt__ReferenceToken(soap, "tt:PresetToken", &a->PresetToken, "tt:ReferenceToken"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_bool(soap, "tt:Home", &a->Home, "xsd:boolean"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home;
		return a;
	}
	a->PTZPosition = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZVector(soap, "tt:PTZPosition", &a->PTZPosition, "tt:PTZVector"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition;
		return a;
	}
	a->TypeExtension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZPresetTourTypeExtension(soap, "tt:TypeExtension", &a->TypeExtension, "tt:PTZPresetTourTypeExtension"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsc__union_DerivedKeyTokenType(struct soap *soap, int choice, const union _wsc__union_DerivedKeyTokenType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation:
		soap_embedded(soap, &a->Generation, SOAP_TYPE_unsignedLONG64);
		break;
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset:
		soap_embedded(soap, &a->Offset, SOAP_TYPE_unsignedLONG64);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsc__union_DerivedKeyTokenType(struct soap *soap, int choice, const union _wsc__union_DerivedKeyTokenType *a)
{
	switch (choice)
	{
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation:
		return soap_out_unsignedLONG64(soap, "wsc:Generation", -1, &a->Generation, "");
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset:
		return soap_out_unsignedLONG64(soap, "wsc:Offset", -1, &a->Offset, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _wsc__union_DerivedKeyTokenType * SOAP_FMAC4 soap_in__wsc__union_DerivedKeyTokenType(struct soap *soap, int *choice, union _wsc__union_DerivedKeyTokenType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_unsignedLONG64(soap, "wsc:Generation", &a->Generation, "xsd:unsignedLong"))
	{	*choice = SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_unsignedLONG64(soap, "wsc:Offset", &a->Offset, "xsd:unsignedLong"))
	{	*choice = SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, _trt__GetSnapshotUriResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetSnapshotUriResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, int id, _trt__GetSnapshotUriResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetSnapshotUriResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetSnapshotUriResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, _trt__GetSnapshotUriResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetSnapshotUriResponse **)soap_malloc(soap, sizeof(_trt__GetSnapshotUriResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetSnapshotUriResponse *)soap_instantiate__trt__GetSnapshotUriResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetSnapshotUriResponse ** p = (_trt__GetSnapshotUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetSnapshotUriResponse, sizeof(_trt__GetSnapshotUriResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, _trt__GetSnapshotUriResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetSnapshotUriResponse);
	if (soap_out_PointerTo_trt__GetSnapshotUriResponse(soap, tag?tag:"trt:GetSnapshotUriResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetSnapshotUriResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, _trt__GetSnapshotUriResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetSnapshotUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetSnapshotUri(struct soap *soap, _trt__GetSnapshotUri *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetSnapshotUri))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetSnapshotUri(struct soap *soap, const char *tag, int id, _trt__GetSnapshotUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetSnapshotUri);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetSnapshotUri ** SOAP_FMAC4 soap_in_PointerTo_trt__GetSnapshotUri(struct soap *soap, const char *tag, _trt__GetSnapshotUri **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetSnapshotUri **)soap_malloc(soap, sizeof(_trt__GetSnapshotUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetSnapshotUri *)soap_instantiate__trt__GetSnapshotUri(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetSnapshotUri ** p = (_trt__GetSnapshotUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetSnapshotUri, sizeof(_trt__GetSnapshotUri), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetSnapshotUri(struct soap *soap, _trt__GetSnapshotUri *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetSnapshotUri);
	if (soap_out_PointerTo_trt__GetSnapshotUri(soap, tag?tag:"trt:GetSnapshotUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetSnapshotUri ** SOAP_FMAC4 soap_get_PointerTo_trt__GetSnapshotUri(struct soap *soap, _trt__GetSnapshotUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetSnapshotUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, _trt__SetSynchronizationPointResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetSynchronizationPointResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, const char *tag, int id, _trt__SetSynchronizationPointResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetSynchronizationPointResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__SetSynchronizationPointResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, const char *tag, _trt__SetSynchronizationPointResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetSynchronizationPointResponse **)soap_malloc(soap, sizeof(_trt__SetSynchronizationPointResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetSynchronizationPointResponse *)soap_instantiate__trt__SetSynchronizationPointResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__SetSynchronizationPointResponse ** p = (_trt__SetSynchronizationPointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetSynchronizationPointResponse, sizeof(_trt__SetSynchronizationPointResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, _trt__SetSynchronizationPointResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetSynchronizationPointResponse);
	if (soap_out_PointerTo_trt__SetSynchronizationPointResponse(soap, tag?tag:"trt:SetSynchronizationPointResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetSynchronizationPointResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, _trt__SetSynchronizationPointResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetSynchronizationPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, _trt__SetSynchronizationPoint *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetSynchronizationPoint))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, _trt__SetSynchronizationPoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetSynchronizationPoint);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__SetSynchronizationPoint ** SOAP_FMAC4 soap_in_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, const char *tag, _trt__SetSynchronizationPoint **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__SetSynchronizationPoint **)soap_malloc(soap, sizeof(_trt__SetSynchronizationPoint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__SetSynchronizationPoint *)soap_instantiate__trt__SetSynchronizationPoint(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__SetSynchronizationPoint ** p = (_trt__SetSynchronizationPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetSynchronizationPoint, sizeof(_trt__SetSynchronizationPoint), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, _trt__SetSynchronizationPoint *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetSynchronizationPoint);
	if (soap_out_PointerTo_trt__SetSynchronizationPoint(soap, tag?tag:"trt:SetSynchronizationPoint", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__SetSynchronizationPoint ** SOAP_FMAC4 soap_get_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, _trt__SetSynchronizationPoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetSynchronizationPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, _trt__StopMulticastStreamingResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StopMulticastStreamingResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, const char *tag, int id, _trt__StopMulticastStreamingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StopMulticastStreamingResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__StopMulticastStreamingResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, const char *tag, _trt__StopMulticastStreamingResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__StopMulticastStreamingResponse **)soap_malloc(soap, sizeof(_trt__StopMulticastStreamingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__StopMulticastStreamingResponse *)soap_instantiate__trt__StopMulticastStreamingResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__StopMulticastStreamingResponse ** p = (_trt__StopMulticastStreamingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StopMulticastStreamingResponse, sizeof(_trt__StopMulticastStreamingResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, _trt__StopMulticastStreamingResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__StopMulticastStreamingResponse);
	if (soap_out_PointerTo_trt__StopMulticastStreamingResponse(soap, tag?tag:"trt:StopMulticastStreamingResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__StopMulticastStreamingResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, _trt__StopMulticastStreamingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StopMulticastStreamingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StopMulticastStreaming(struct soap *soap, _trt__StopMulticastStreaming *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StopMulticastStreaming))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StopMulticastStreaming(struct soap *soap, const char *tag, int id, _trt__StopMulticastStreaming *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StopMulticastStreaming);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__StopMulticastStreaming ** SOAP_FMAC4 soap_in_PointerTo_trt__StopMulticastStreaming(struct soap *soap, const char *tag, _trt__StopMulticastStreaming **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__StopMulticastStreaming **)soap_malloc(soap, sizeof(_trt__StopMulticastStreaming *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__StopMulticastStreaming *)soap_instantiate__trt__StopMulticastStreaming(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__StopMulticastStreaming ** p = (_trt__StopMulticastStreaming **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StopMulticastStreaming, sizeof(_trt__StopMulticastStreaming), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StopMulticastStreaming(struct soap *soap, _trt__StopMulticastStreaming *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__StopMulticastStreaming);
	if (soap_out_PointerTo_trt__StopMulticastStreaming(soap, tag?tag:"trt:StopMulticastStreaming", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__StopMulticastStreaming ** SOAP_FMAC4 soap_get_PointerTo_trt__StopMulticastStreaming(struct soap *soap, _trt__StopMulticastStreaming **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StopMulticastStreaming(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, _trt__StartMulticastStreamingResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StartMulticastStreamingResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, const char *tag, int id, _trt__StartMulticastStreamingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StartMulticastStreamingResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__StartMulticastStreamingResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, const char *tag, _trt__StartMulticastStreamingResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__StartMulticastStreamingResponse **)soap_malloc(soap, sizeof(_trt__StartMulticastStreamingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__StartMulticastStreamingResponse *)soap_instantiate__trt__StartMulticastStreamingResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__StartMulticastStreamingResponse ** p = (_trt__StartMulticastStreamingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StartMulticastStreamingResponse, sizeof(_trt__StartMulticastStreamingResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, _trt__StartMulticastStreamingResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__StartMulticastStreamingResponse);
	if (soap_out_PointerTo_trt__StartMulticastStreamingResponse(soap, tag?tag:"trt:StartMulticastStreamingResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__StartMulticastStreamingResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, _trt__StartMulticastStreamingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StartMulticastStreamingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StartMulticastStreaming(struct soap *soap, _trt__StartMulticastStreaming *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StartMulticastStreaming))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StartMulticastStreaming(struct soap *soap, const char *tag, int id, _trt__StartMulticastStreaming *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StartMulticastStreaming);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__StartMulticastStreaming ** SOAP_FMAC4 soap_in_PointerTo_trt__StartMulticastStreaming(struct soap *soap, const char *tag, _trt__StartMulticastStreaming **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__StartMulticastStreaming **)soap_malloc(soap, sizeof(_trt__StartMulticastStreaming *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__StartMulticastStreaming *)soap_instantiate__trt__StartMulticastStreaming(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__StartMulticastStreaming ** p = (_trt__StartMulticastStreaming **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StartMulticastStreaming, sizeof(_trt__StartMulticastStreaming), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StartMulticastStreaming(struct soap *soap, _trt__StartMulticastStreaming *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__StartMulticastStreaming);
	if (soap_out_PointerTo_trt__StartMulticastStreaming(soap, tag?tag:"trt:StartMulticastStreaming", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__StartMulticastStreaming ** SOAP_FMAC4 soap_get_PointerTo_trt__StartMulticastStreaming(struct soap *soap, _trt__StartMulticastStreaming **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StartMulticastStreaming(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetStreamUriResponse(struct soap *soap, _trt__GetStreamUriResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetStreamUriResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetStreamUriResponse(struct soap *soap, const char *tag, int id, _trt__GetStreamUriResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetStreamUriResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetStreamUriResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetStreamUriResponse(struct soap *soap, const char *tag, _trt__GetStreamUriResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetStreamUriResponse **)soap_malloc(soap, sizeof(_trt__GetStreamUriResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetStreamUriResponse *)soap_instantiate__trt__GetStreamUriResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetStreamUriResponse ** p = (_trt__GetStreamUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetStreamUriResponse, sizeof(_trt__GetStreamUriResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetStreamUriResponse(struct soap *soap, _trt__GetStreamUriResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetStreamUriResponse);
	if (soap_out_PointerTo_trt__GetStreamUriResponse(soap, tag?tag:"trt:GetStreamUriResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetStreamUriResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetStreamUriResponse(struct soap *soap, _trt__GetStreamUriResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetStreamUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetStreamUri(struct soap *soap, _trt__GetStreamUri *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetStreamUri))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetStreamUri(struct soap *soap, const char *tag, int id, _trt__GetStreamUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetStreamUri);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetStreamUri ** SOAP_FMAC4 soap_in_PointerTo_trt__GetStreamUri(struct soap *soap, const char *tag, _trt__GetStreamUri **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetStreamUri **)soap_malloc(soap, sizeof(_trt__GetStreamUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetStreamUri *)soap_instantiate__trt__GetStreamUri(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetStreamUri ** p = (_trt__GetStreamUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetStreamUri, sizeof(_trt__GetStreamUri), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetStreamUri(struct soap *soap, _trt__GetStreamUri *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetStreamUri);
	if (soap_out_PointerTo_trt__GetStreamUri(soap, tag?tag:"trt:GetStreamUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetStreamUri ** SOAP_FMAC4 soap_get_PointerTo_trt__GetStreamUri(struct soap *soap, _trt__GetStreamUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetStreamUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, const char *tag, int id, _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, const char *tag, _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse **)soap_malloc(soap, sizeof(_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *)soap_instantiate__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse ** p = (_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse, sizeof(_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse);
	if (soap_out_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, tag?tag:"trt:GetGuaranteedNumberOfVideoEncoderInstancesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, _trt__GetGuaranteedNumberOfVideoEncoderInstances *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const char *tag, int id, _trt__GetGuaranteedNumberOfVideoEncoderInstances *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetGuaranteedNumberOfVideoEncoderInstances ** SOAP_FMAC4 soap_in_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const char *tag, _trt__GetGuaranteedNumberOfVideoEncoderInstances **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetGuaranteedNumberOfVideoEncoderInstances **)soap_malloc(soap, sizeof(_trt__GetGuaranteedNumberOfVideoEncoderInstances *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetGuaranteedNumberOfVideoEncoderInstances *)soap_instantiate__trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetGuaranteedNumberOfVideoEncoderInstances ** p = (_trt__GetGuaranteedNumberOfVideoEncoderInstances **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances, sizeof(_trt__GetGuaranteedNumberOfVideoEncoderInstances), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, _trt__GetGuaranteedNumberOfVideoEncoderInstances *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances);
	if (soap_out_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag?tag:"trt:GetGuaranteedNumberOfVideoEncoderInstances", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetGuaranteedNumberOfVideoEncoderInstances ** SOAP_FMAC4 soap_get_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, _trt__GetGuaranteedNumberOfVideoEncoderInstances **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, _trt__GetAudioDecoderConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, _trt__GetAudioDecoderConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioDecoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, const char *tag, _trt__GetAudioDecoderConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioDecoderConfigurationOptionsResponse **)soap_malloc(soap, sizeof(_trt__GetAudioDecoderConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioDecoderConfigurationOptionsResponse *)soap_instantiate__trt__GetAudioDecoderConfigurationOptionsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioDecoderConfigurationOptionsResponse ** p = (_trt__GetAudioDecoderConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse, sizeof(_trt__GetAudioDecoderConfigurationOptionsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, _trt__GetAudioDecoderConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(soap, tag?tag:"trt:GetAudioDecoderConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioDecoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, _trt__GetAudioDecoderConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, _trt__GetAudioDecoderConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, _trt__GetAudioDecoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioDecoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const char *tag, _trt__GetAudioDecoderConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioDecoderConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetAudioDecoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioDecoderConfigurationOptions *)soap_instantiate__trt__GetAudioDecoderConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioDecoderConfigurationOptions ** p = (_trt__GetAudioDecoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions, sizeof(_trt__GetAudioDecoderConfigurationOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, _trt__GetAudioDecoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfigurationOptions);
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurationOptions(soap, tag?tag:"trt:GetAudioDecoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioDecoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, _trt__GetAudioDecoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, _trt__GetAudioOutputConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, _trt__GetAudioOutputConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioOutputConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, _trt__GetAudioOutputConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioOutputConfigurationOptionsResponse **)soap_malloc(soap, sizeof(_trt__GetAudioOutputConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioOutputConfigurationOptionsResponse *)soap_instantiate__trt__GetAudioOutputConfigurationOptionsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioOutputConfigurationOptionsResponse ** p = (_trt__GetAudioOutputConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse, sizeof(_trt__GetAudioOutputConfigurationOptionsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, _trt__GetAudioOutputConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(soap, tag?tag:"trt:GetAudioOutputConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioOutputConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, _trt__GetAudioOutputConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, _trt__GetAudioOutputConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, _trt__GetAudioOutputConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioOutputConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, _trt__GetAudioOutputConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioOutputConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetAudioOutputConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioOutputConfigurationOptions *)soap_instantiate__trt__GetAudioOutputConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioOutputConfigurationOptions ** p = (_trt__GetAudioOutputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions, sizeof(_trt__GetAudioOutputConfigurationOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, _trt__GetAudioOutputConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputConfigurationOptions);
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurationOptions(soap, tag?tag:"trt:GetAudioOutputConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioOutputConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, _trt__GetAudioOutputConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, _trt__GetMetadataConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, _trt__GetMetadataConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetMetadataConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, const char *tag, _trt__GetMetadataConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetMetadataConfigurationOptionsResponse **)soap_malloc(soap, sizeof(_trt__GetMetadataConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetMetadataConfigurationOptionsResponse *)soap_instantiate__trt__GetMetadataConfigurationOptionsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetMetadataConfigurationOptionsResponse ** p = (_trt__GetMetadataConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse, sizeof(_trt__GetMetadataConfigurationOptionsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, _trt__GetMetadataConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetMetadataConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetMetadataConfigurationOptionsResponse(soap, tag?tag:"trt:GetMetadataConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetMetadataConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, _trt__GetMetadataConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, _trt__GetMetadataConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, const char *tag, int id, _trt__GetMetadataConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfigurationOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetMetadataConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, const char *tag, _trt__GetMetadataConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetMetadataConfigurationOptions **)soap_malloc(soap, sizeof(_trt__GetMetadataConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetMetadataConfigurationOptions *)soap_instantiate__trt__GetMetadataConfigurationOptions(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetMetadataConfigurationOptions ** p = (_trt__GetMetadataConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurationOptions, sizeof(_trt__GetMetadataConfigurationOptions), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, _trt__GetMetadataConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetMetadataConfigurationOptions);
	if (soap_out_PointerTo_trt__GetMetadataConfigurationOptions(soap, tag?tag:"trt:GetMetadataConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetMetadataConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, _trt__GetMetadataConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, _trt__GetAudioEncoderConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, _trt__GetAudioEncoderConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _trt__GetAudioEncoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, _trt__GetAudioEncoderConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_trt__GetAudioEncoderConfigurationOptionsResponse **)soap_malloc(soap, sizeof(_trt__GetAudioEncoderConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_trt__GetAudioEncoderConfigurationOptionsResponse *)soap_instantiate__trt__GetAudioEncoderConfigurationOptionsResponse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_trt__GetAudioEncoderConfigurationOptionsResponse ** p = (_trt__GetAudioEncoderConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse, sizeof(_trt__GetAudioEncoderConfigurationOptionsResponse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, _trt__GetAudioEncoderConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(soap, tag?tag:"trt:GetAudioEncoderConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 _trt__GetAudioEncoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, _trt__GetAudioEncoderConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, _trt__GetAudioEncoderConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions))
		(*a)->soap_serialize(soap);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, _trt__GetAudioEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

