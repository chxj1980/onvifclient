#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__PauseSubscriptionResponse(struct soap *soap, struct _wsnt__PauseSubscriptionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__PauseSubscriptionResponse);
	if (soap_out_PointerTo_wsnt__PauseSubscriptionResponse(soap, tag?tag:"wsnt:PauseSubscriptionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseSubscriptionResponse ** SOAP_FMAC4 soap_get_PointerTo_wsnt__PauseSubscriptionResponse(struct soap *soap, struct _wsnt__PauseSubscriptionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__PauseSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__PauseSubscription(struct soap *soap, struct _wsnt__PauseSubscription *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__PauseSubscription))
		soap_serialize__wsnt__PauseSubscription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__PauseSubscription(struct soap *soap, const char *tag, int id, struct _wsnt__PauseSubscription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__PauseSubscription);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__PauseSubscription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__PauseSubscription ** SOAP_FMAC4 soap_in_PointerTo_wsnt__PauseSubscription(struct soap *soap, const char *tag, struct _wsnt__PauseSubscription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__PauseSubscription **)soap_malloc(soap, sizeof(struct _wsnt__PauseSubscription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__PauseSubscription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseSubscription, sizeof(struct _wsnt__PauseSubscription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__PauseSubscription(struct soap *soap, struct _wsnt__PauseSubscription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__PauseSubscription);
	if (soap_out_PointerTo_wsnt__PauseSubscription(soap, tag?tag:"wsnt:PauseSubscription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseSubscription ** SOAP_FMAC4 soap_get_PointerTo_wsnt__PauseSubscription(struct soap *soap, struct _wsnt__PauseSubscription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__PauseSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__CreatePullPointResponse(struct soap *soap, struct _wsnt__CreatePullPointResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__CreatePullPointResponse))
		soap_serialize__wsnt__CreatePullPointResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__CreatePullPointResponse(struct soap *soap, const char *tag, int id, struct _wsnt__CreatePullPointResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__CreatePullPointResponse);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__CreatePullPointResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__CreatePullPointResponse ** SOAP_FMAC4 soap_in_PointerTo_wsnt__CreatePullPointResponse(struct soap *soap, const char *tag, struct _wsnt__CreatePullPointResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__CreatePullPointResponse **)soap_malloc(soap, sizeof(struct _wsnt__CreatePullPointResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__CreatePullPointResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__CreatePullPointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__CreatePullPointResponse, sizeof(struct _wsnt__CreatePullPointResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__CreatePullPointResponse(struct soap *soap, struct _wsnt__CreatePullPointResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__CreatePullPointResponse);
	if (soap_out_PointerTo_wsnt__CreatePullPointResponse(soap, tag?tag:"wsnt:CreatePullPointResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__CreatePullPointResponse ** SOAP_FMAC4 soap_get_PointerTo_wsnt__CreatePullPointResponse(struct soap *soap, struct _wsnt__CreatePullPointResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__CreatePullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__CreatePullPoint(struct soap *soap, struct _wsnt__CreatePullPoint *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__CreatePullPoint))
		soap_serialize__wsnt__CreatePullPoint(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__CreatePullPoint(struct soap *soap, const char *tag, int id, struct _wsnt__CreatePullPoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__CreatePullPoint);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__CreatePullPoint(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__CreatePullPoint ** SOAP_FMAC4 soap_in_PointerTo_wsnt__CreatePullPoint(struct soap *soap, const char *tag, struct _wsnt__CreatePullPoint **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__CreatePullPoint **)soap_malloc(soap, sizeof(struct _wsnt__CreatePullPoint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__CreatePullPoint(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__CreatePullPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__CreatePullPoint, sizeof(struct _wsnt__CreatePullPoint), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__CreatePullPoint(struct soap *soap, struct _wsnt__CreatePullPoint *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__CreatePullPoint);
	if (soap_out_PointerTo_wsnt__CreatePullPoint(soap, tag?tag:"wsnt:CreatePullPoint", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__CreatePullPoint ** SOAP_FMAC4 soap_get_PointerTo_wsnt__CreatePullPoint(struct soap *soap, struct _wsnt__CreatePullPoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__CreatePullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__DestroyPullPointResponse(struct soap *soap, struct _wsnt__DestroyPullPointResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__DestroyPullPointResponse))
		soap_serialize__wsnt__DestroyPullPointResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__DestroyPullPointResponse(struct soap *soap, const char *tag, int id, struct _wsnt__DestroyPullPointResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__DestroyPullPointResponse);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__DestroyPullPointResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPointResponse ** SOAP_FMAC4 soap_in_PointerTo_wsnt__DestroyPullPointResponse(struct soap *soap, const char *tag, struct _wsnt__DestroyPullPointResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__DestroyPullPointResponse **)soap_malloc(soap, sizeof(struct _wsnt__DestroyPullPointResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__DestroyPullPointResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__DestroyPullPointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__DestroyPullPointResponse, sizeof(struct _wsnt__DestroyPullPointResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__DestroyPullPointResponse(struct soap *soap, struct _wsnt__DestroyPullPointResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__DestroyPullPointResponse);
	if (soap_out_PointerTo_wsnt__DestroyPullPointResponse(soap, tag?tag:"wsnt:DestroyPullPointResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPointResponse ** SOAP_FMAC4 soap_get_PointerTo_wsnt__DestroyPullPointResponse(struct soap *soap, struct _wsnt__DestroyPullPointResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__DestroyPullPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__DestroyPullPoint(struct soap *soap, struct _wsnt__DestroyPullPoint *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__DestroyPullPoint))
		soap_serialize__wsnt__DestroyPullPoint(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__DestroyPullPoint(struct soap *soap, const char *tag, int id, struct _wsnt__DestroyPullPoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__DestroyPullPoint);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__DestroyPullPoint(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPoint ** SOAP_FMAC4 soap_in_PointerTo_wsnt__DestroyPullPoint(struct soap *soap, const char *tag, struct _wsnt__DestroyPullPoint **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__DestroyPullPoint **)soap_malloc(soap, sizeof(struct _wsnt__DestroyPullPoint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__DestroyPullPoint(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__DestroyPullPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__DestroyPullPoint, sizeof(struct _wsnt__DestroyPullPoint), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__DestroyPullPoint(struct soap *soap, struct _wsnt__DestroyPullPoint *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__DestroyPullPoint);
	if (soap_out_PointerTo_wsnt__DestroyPullPoint(soap, tag?tag:"wsnt:DestroyPullPoint", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__DestroyPullPoint ** SOAP_FMAC4 soap_get_PointerTo_wsnt__DestroyPullPoint(struct soap *soap, struct _wsnt__DestroyPullPoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__DestroyPullPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__GetMessagesResponse(struct soap *soap, struct _wsnt__GetMessagesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__GetMessagesResponse))
		soap_serialize__wsnt__GetMessagesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__GetMessagesResponse(struct soap *soap, const char *tag, int id, struct _wsnt__GetMessagesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__GetMessagesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__GetMessagesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__GetMessagesResponse ** SOAP_FMAC4 soap_in_PointerTo_wsnt__GetMessagesResponse(struct soap *soap, const char *tag, struct _wsnt__GetMessagesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__GetMessagesResponse **)soap_malloc(soap, sizeof(struct _wsnt__GetMessagesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__GetMessagesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetMessagesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__GetMessagesResponse, sizeof(struct _wsnt__GetMessagesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__GetMessagesResponse(struct soap *soap, struct _wsnt__GetMessagesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__GetMessagesResponse);
	if (soap_out_PointerTo_wsnt__GetMessagesResponse(soap, tag?tag:"wsnt:GetMessagesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetMessagesResponse ** SOAP_FMAC4 soap_get_PointerTo_wsnt__GetMessagesResponse(struct soap *soap, struct _wsnt__GetMessagesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__GetMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__GetMessages(struct soap *soap, struct _wsnt__GetMessages *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__GetMessages))
		soap_serialize__wsnt__GetMessages(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__GetMessages(struct soap *soap, const char *tag, int id, struct _wsnt__GetMessages *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__GetMessages);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__GetMessages(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__GetMessages ** SOAP_FMAC4 soap_in_PointerTo_wsnt__GetMessages(struct soap *soap, const char *tag, struct _wsnt__GetMessages **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__GetMessages **)soap_malloc(soap, sizeof(struct _wsnt__GetMessages *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__GetMessages(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetMessages **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__GetMessages, sizeof(struct _wsnt__GetMessages), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__GetMessages(struct soap *soap, struct _wsnt__GetMessages *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__GetMessages);
	if (soap_out_PointerTo_wsnt__GetMessages(soap, tag?tag:"wsnt:GetMessages", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetMessages ** SOAP_FMAC4 soap_get_PointerTo_wsnt__GetMessages(struct soap *soap, struct _wsnt__GetMessages **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__GetMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Notify(struct soap *soap, struct _wsnt__Notify *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Notify))
		soap_serialize__wsnt__Notify(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Notify(struct soap *soap, const char *tag, int id, struct _wsnt__Notify *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Notify);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__Notify(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__Notify ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Notify(struct soap *soap, const char *tag, struct _wsnt__Notify **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__Notify **)soap_malloc(soap, sizeof(struct _wsnt__Notify *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__Notify(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Notify **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Notify, sizeof(struct _wsnt__Notify), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Notify(struct soap *soap, struct _wsnt__Notify *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__Notify);
	if (soap_out_PointerTo_wsnt__Notify(soap, tag?tag:"wsnt:Notify", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Notify ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Notify(struct soap *soap, struct _wsnt__Notify **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Notify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__GetCurrentMessageResponse(struct soap *soap, struct _wsnt__GetCurrentMessageResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__GetCurrentMessageResponse))
		soap_serialize__wsnt__GetCurrentMessageResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__GetCurrentMessageResponse(struct soap *soap, const char *tag, int id, struct _wsnt__GetCurrentMessageResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__GetCurrentMessageResponse);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__GetCurrentMessageResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessageResponse ** SOAP_FMAC4 soap_in_PointerTo_wsnt__GetCurrentMessageResponse(struct soap *soap, const char *tag, struct _wsnt__GetCurrentMessageResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__GetCurrentMessageResponse **)soap_malloc(soap, sizeof(struct _wsnt__GetCurrentMessageResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__GetCurrentMessageResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetCurrentMessageResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__GetCurrentMessageResponse, sizeof(struct _wsnt__GetCurrentMessageResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__GetCurrentMessageResponse(struct soap *soap, struct _wsnt__GetCurrentMessageResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__GetCurrentMessageResponse);
	if (soap_out_PointerTo_wsnt__GetCurrentMessageResponse(soap, tag?tag:"wsnt:GetCurrentMessageResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessageResponse ** SOAP_FMAC4 soap_get_PointerTo_wsnt__GetCurrentMessageResponse(struct soap *soap, struct _wsnt__GetCurrentMessageResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__GetCurrentMessageResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__GetCurrentMessage(struct soap *soap, struct _wsnt__GetCurrentMessage *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__GetCurrentMessage))
		soap_serialize__wsnt__GetCurrentMessage(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__GetCurrentMessage(struct soap *soap, const char *tag, int id, struct _wsnt__GetCurrentMessage *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__GetCurrentMessage);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__GetCurrentMessage(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessage ** SOAP_FMAC4 soap_in_PointerTo_wsnt__GetCurrentMessage(struct soap *soap, const char *tag, struct _wsnt__GetCurrentMessage **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__GetCurrentMessage **)soap_malloc(soap, sizeof(struct _wsnt__GetCurrentMessage *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__GetCurrentMessage(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__GetCurrentMessage **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__GetCurrentMessage, sizeof(struct _wsnt__GetCurrentMessage), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__GetCurrentMessage(struct soap *soap, struct _wsnt__GetCurrentMessage *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__GetCurrentMessage);
	if (soap_out_PointerTo_wsnt__GetCurrentMessage(soap, tag?tag:"wsnt:GetCurrentMessage", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__GetCurrentMessage ** SOAP_FMAC4 soap_get_PointerTo_wsnt__GetCurrentMessage(struct soap *soap, struct _wsnt__GetCurrentMessage **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__GetCurrentMessage(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeResponse(struct soap *soap, struct _wsnt__SubscribeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeResponse))
		soap_serialize__wsnt__SubscribeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeResponse(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeResponse ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeResponse(struct soap *soap, const char *tag, struct _wsnt__SubscribeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeResponse **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeResponse, sizeof(struct _wsnt__SubscribeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeResponse(struct soap *soap, struct _wsnt__SubscribeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__SubscribeResponse);
	if (soap_out_PointerTo_wsnt__SubscribeResponse(soap, tag?tag:"wsnt:SubscribeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeResponse ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeResponse(struct soap *soap, struct _wsnt__SubscribeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Subscribe(struct soap *soap, struct _wsnt__Subscribe *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Subscribe))
		soap_serialize__wsnt__Subscribe(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Subscribe(struct soap *soap, const char *tag, int id, struct _wsnt__Subscribe *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Subscribe);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__Subscribe(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__Subscribe ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Subscribe(struct soap *soap, const char *tag, struct _wsnt__Subscribe **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__Subscribe **)soap_malloc(soap, sizeof(struct _wsnt__Subscribe *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__Subscribe(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Subscribe **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Subscribe, sizeof(struct _wsnt__Subscribe), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Subscribe(struct soap *soap, struct _wsnt__Subscribe *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__Subscribe);
	if (soap_out_PointerTo_wsnt__Subscribe(soap, tag?tag:"wsnt:Subscribe", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Subscribe ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Subscribe(struct soap *soap, struct _wsnt__Subscribe **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Subscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnsubscribeResponse(struct soap *soap, struct _wsnt__UnsubscribeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnsubscribeResponse))
		soap_serialize__wsnt__UnsubscribeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnsubscribeResponse(struct soap *soap, const char *tag, int id, struct _wsnt__UnsubscribeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnsubscribeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnsubscribeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnsubscribeResponse ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnsubscribeResponse(struct soap *soap, const char *tag, struct _wsnt__UnsubscribeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnsubscribeResponse **)soap_malloc(soap, sizeof(struct _wsnt__UnsubscribeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnsubscribeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsubscribeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsubscribeResponse, sizeof(struct _wsnt__UnsubscribeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnsubscribeResponse(struct soap *soap, struct _wsnt__UnsubscribeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnsubscribeResponse);
	if (soap_out_PointerTo_wsnt__UnsubscribeResponse(soap, tag?tag:"wsnt:UnsubscribeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsubscribeResponse ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnsubscribeResponse(struct soap *soap, struct _wsnt__UnsubscribeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnsubscribeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Unsubscribe(struct soap *soap, struct _wsnt__Unsubscribe *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Unsubscribe))
		soap_serialize__wsnt__Unsubscribe(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Unsubscribe(struct soap *soap, const char *tag, int id, struct _wsnt__Unsubscribe *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Unsubscribe);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__Unsubscribe(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__Unsubscribe ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Unsubscribe(struct soap *soap, const char *tag, struct _wsnt__Unsubscribe **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__Unsubscribe **)soap_malloc(soap, sizeof(struct _wsnt__Unsubscribe *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__Unsubscribe(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Unsubscribe **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Unsubscribe, sizeof(struct _wsnt__Unsubscribe), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Unsubscribe(struct soap *soap, struct _wsnt__Unsubscribe *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__Unsubscribe);
	if (soap_out_PointerTo_wsnt__Unsubscribe(soap, tag?tag:"wsnt:Unsubscribe", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Unsubscribe ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Unsubscribe(struct soap *soap, struct _wsnt__Unsubscribe **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Unsubscribe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__RenewResponse(struct soap *soap, struct _wsnt__RenewResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__RenewResponse))
		soap_serialize__wsnt__RenewResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__RenewResponse(struct soap *soap, const char *tag, int id, struct _wsnt__RenewResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__RenewResponse);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__RenewResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__RenewResponse ** SOAP_FMAC4 soap_in_PointerTo_wsnt__RenewResponse(struct soap *soap, const char *tag, struct _wsnt__RenewResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__RenewResponse **)soap_malloc(soap, sizeof(struct _wsnt__RenewResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__RenewResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__RenewResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__RenewResponse, sizeof(struct _wsnt__RenewResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__RenewResponse(struct soap *soap, struct _wsnt__RenewResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__RenewResponse);
	if (soap_out_PointerTo_wsnt__RenewResponse(soap, tag?tag:"wsnt:RenewResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__RenewResponse ** SOAP_FMAC4 soap_get_PointerTo_wsnt__RenewResponse(struct soap *soap, struct _wsnt__RenewResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__RenewResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__Renew(struct soap *soap, struct _wsnt__Renew *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__Renew))
		soap_serialize__wsnt__Renew(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__Renew(struct soap *soap, const char *tag, int id, struct _wsnt__Renew *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__Renew);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__Renew(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__Renew ** SOAP_FMAC4 soap_in_PointerTo_wsnt__Renew(struct soap *soap, const char *tag, struct _wsnt__Renew **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__Renew **)soap_malloc(soap, sizeof(struct _wsnt__Renew *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__Renew(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__Renew **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__Renew, sizeof(struct _wsnt__Renew), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__Renew(struct soap *soap, struct _wsnt__Renew *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__Renew);
	if (soap_out_PointerTo_wsnt__Renew(soap, tag?tag:"wsnt:Renew", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__Renew ** SOAP_FMAC4 soap_get_PointerTo_wsnt__Renew(struct soap *soap, struct _wsnt__Renew **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__Renew(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__GetEventPropertiesResponse(struct soap *soap, struct _tev__GetEventPropertiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__GetEventPropertiesResponse))
		soap_serialize__tev__GetEventPropertiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__GetEventPropertiesResponse(struct soap *soap, const char *tag, int id, struct _tev__GetEventPropertiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__GetEventPropertiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tev__GetEventPropertiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__GetEventPropertiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tev__GetEventPropertiesResponse(struct soap *soap, const char *tag, struct _tev__GetEventPropertiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__GetEventPropertiesResponse **)soap_malloc(soap, sizeof(struct _tev__GetEventPropertiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__GetEventPropertiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__GetEventPropertiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__GetEventPropertiesResponse, sizeof(struct _tev__GetEventPropertiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__GetEventPropertiesResponse(struct soap *soap, struct _tev__GetEventPropertiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tev__GetEventPropertiesResponse);
	if (soap_out_PointerTo_tev__GetEventPropertiesResponse(soap, tag?tag:"tev:GetEventPropertiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetEventPropertiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tev__GetEventPropertiesResponse(struct soap *soap, struct _tev__GetEventPropertiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__GetEventPropertiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__GetEventProperties(struct soap *soap, struct _tev__GetEventProperties *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__GetEventProperties))
		soap_serialize__tev__GetEventProperties(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__GetEventProperties(struct soap *soap, const char *tag, int id, struct _tev__GetEventProperties *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__GetEventProperties);
	if (id < 0)
		return soap->error;
	return soap_out__tev__GetEventProperties(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__GetEventProperties ** SOAP_FMAC4 soap_in_PointerTo_tev__GetEventProperties(struct soap *soap, const char *tag, struct _tev__GetEventProperties **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__GetEventProperties **)soap_malloc(soap, sizeof(struct _tev__GetEventProperties *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__GetEventProperties(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__GetEventProperties **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__GetEventProperties, sizeof(struct _tev__GetEventProperties), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__GetEventProperties(struct soap *soap, struct _tev__GetEventProperties *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tev__GetEventProperties);
	if (soap_out_PointerTo_tev__GetEventProperties(soap, tag?tag:"tev:GetEventProperties", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetEventProperties ** SOAP_FMAC4 soap_get_PointerTo_tev__GetEventProperties(struct soap *soap, struct _tev__GetEventProperties **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__GetEventProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__CreatePullPointSubscriptionResponse(struct soap *soap, struct _tev__CreatePullPointSubscriptionResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse))
		soap_serialize__tev__CreatePullPointSubscriptionResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__CreatePullPointSubscriptionResponse(struct soap *soap, const char *tag, int id, struct _tev__CreatePullPointSubscriptionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tev__CreatePullPointSubscriptionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscriptionResponse ** SOAP_FMAC4 soap_in_PointerTo_tev__CreatePullPointSubscriptionResponse(struct soap *soap, const char *tag, struct _tev__CreatePullPointSubscriptionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__CreatePullPointSubscriptionResponse **)soap_malloc(soap, sizeof(struct _tev__CreatePullPointSubscriptionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__CreatePullPointSubscriptionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__CreatePullPointSubscriptionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, sizeof(struct _tev__CreatePullPointSubscriptionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__CreatePullPointSubscriptionResponse(struct soap *soap, struct _tev__CreatePullPointSubscriptionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tev__CreatePullPointSubscriptionResponse);
	if (soap_out_PointerTo_tev__CreatePullPointSubscriptionResponse(soap, tag?tag:"tev:CreatePullPointSubscriptionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscriptionResponse ** SOAP_FMAC4 soap_get_PointerTo_tev__CreatePullPointSubscriptionResponse(struct soap *soap, struct _tev__CreatePullPointSubscriptionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__CreatePullPointSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__CreatePullPointSubscription(struct soap *soap, struct _tev__CreatePullPointSubscription *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__CreatePullPointSubscription))
		soap_serialize__tev__CreatePullPointSubscription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__CreatePullPointSubscription(struct soap *soap, const char *tag, int id, struct _tev__CreatePullPointSubscription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__CreatePullPointSubscription);
	if (id < 0)
		return soap->error;
	return soap_out__tev__CreatePullPointSubscription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription ** SOAP_FMAC4 soap_in_PointerTo_tev__CreatePullPointSubscription(struct soap *soap, const char *tag, struct _tev__CreatePullPointSubscription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__CreatePullPointSubscription **)soap_malloc(soap, sizeof(struct _tev__CreatePullPointSubscription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__CreatePullPointSubscription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__CreatePullPointSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__CreatePullPointSubscription, sizeof(struct _tev__CreatePullPointSubscription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__CreatePullPointSubscription(struct soap *soap, struct _tev__CreatePullPointSubscription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription);
	if (soap_out_PointerTo_tev__CreatePullPointSubscription(soap, tag?tag:"tev:CreatePullPointSubscription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription ** SOAP_FMAC4 soap_get_PointerTo_tev__CreatePullPointSubscription(struct soap *soap, struct _tev__CreatePullPointSubscription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__CreatePullPointSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__GetServiceCapabilitiesResponse(struct soap *soap, struct _tev__GetServiceCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__GetServiceCapabilitiesResponse))
		soap_serialize__tev__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tev__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tev__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tev__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tev__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tev__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, sizeof(struct _tev__GetServiceCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__GetServiceCapabilitiesResponse(struct soap *soap, struct _tev__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tev__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_tev__GetServiceCapabilitiesResponse(soap, tag?tag:"tev:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tev__GetServiceCapabilitiesResponse(struct soap *soap, struct _tev__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__GetServiceCapabilities(struct soap *soap, struct _tev__GetServiceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__GetServiceCapabilities))
		soap_serialize__tev__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _tev__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__tev__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tev__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tev__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _tev__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__GetServiceCapabilities, sizeof(struct _tev__GetServiceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__GetServiceCapabilities(struct soap *soap, struct _tev__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tev__GetServiceCapabilities);
	if (soap_out_PointerTo_tev__GetServiceCapabilities(soap, tag?tag:"tev:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tev__GetServiceCapabilities(struct soap *soap, struct _tev__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__SetSynchronizationPointResponse(struct soap *soap, struct _tev__SetSynchronizationPointResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__SetSynchronizationPointResponse))
		soap_serialize__tev__SetSynchronizationPointResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__SetSynchronizationPointResponse(struct soap *soap, const char *tag, int id, struct _tev__SetSynchronizationPointResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__SetSynchronizationPointResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tev__SetSynchronizationPointResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPointResponse ** SOAP_FMAC4 soap_in_PointerTo_tev__SetSynchronizationPointResponse(struct soap *soap, const char *tag, struct _tev__SetSynchronizationPointResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__SetSynchronizationPointResponse **)soap_malloc(soap, sizeof(struct _tev__SetSynchronizationPointResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__SetSynchronizationPointResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__SetSynchronizationPointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__SetSynchronizationPointResponse, sizeof(struct _tev__SetSynchronizationPointResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__SetSynchronizationPointResponse(struct soap *soap, struct _tev__SetSynchronizationPointResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tev__SetSynchronizationPointResponse);
	if (soap_out_PointerTo_tev__SetSynchronizationPointResponse(soap, tag?tag:"tev:SetSynchronizationPointResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPointResponse ** SOAP_FMAC4 soap_get_PointerTo_tev__SetSynchronizationPointResponse(struct soap *soap, struct _tev__SetSynchronizationPointResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__SetSynchronizationPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__SetSynchronizationPoint(struct soap *soap, struct _tev__SetSynchronizationPoint *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__SetSynchronizationPoint))
		soap_serialize__tev__SetSynchronizationPoint(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, struct _tev__SetSynchronizationPoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__SetSynchronizationPoint);
	if (id < 0)
		return soap->error;
	return soap_out__tev__SetSynchronizationPoint(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPoint ** SOAP_FMAC4 soap_in_PointerTo_tev__SetSynchronizationPoint(struct soap *soap, const char *tag, struct _tev__SetSynchronizationPoint **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__SetSynchronizationPoint **)soap_malloc(soap, sizeof(struct _tev__SetSynchronizationPoint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__SetSynchronizationPoint(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__SetSynchronizationPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__SetSynchronizationPoint, sizeof(struct _tev__SetSynchronizationPoint), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__SetSynchronizationPoint(struct soap *soap, struct _tev__SetSynchronizationPoint *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tev__SetSynchronizationPoint);
	if (soap_out_PointerTo_tev__SetSynchronizationPoint(soap, tag?tag:"tev:SetSynchronizationPoint", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPoint ** SOAP_FMAC4 soap_get_PointerTo_tev__SetSynchronizationPoint(struct soap *soap, struct _tev__SetSynchronizationPoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__SetSynchronizationPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__PullMessagesResponse(struct soap *soap, struct _tev__PullMessagesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__PullMessagesResponse))
		soap_serialize__tev__PullMessagesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__PullMessagesResponse(struct soap *soap, const char *tag, int id, struct _tev__PullMessagesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__PullMessagesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tev__PullMessagesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__PullMessagesResponse ** SOAP_FMAC4 soap_in_PointerTo_tev__PullMessagesResponse(struct soap *soap, const char *tag, struct _tev__PullMessagesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__PullMessagesResponse **)soap_malloc(soap, sizeof(struct _tev__PullMessagesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__PullMessagesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__PullMessagesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__PullMessagesResponse, sizeof(struct _tev__PullMessagesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__PullMessagesResponse(struct soap *soap, struct _tev__PullMessagesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tev__PullMessagesResponse);
	if (soap_out_PointerTo_tev__PullMessagesResponse(soap, tag?tag:"tev:PullMessagesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__PullMessagesResponse ** SOAP_FMAC4 soap_get_PointerTo_tev__PullMessagesResponse(struct soap *soap, struct _tev__PullMessagesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__PullMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__PullMessages(struct soap *soap, struct _tev__PullMessages *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__PullMessages))
		soap_serialize__tev__PullMessages(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__PullMessages(struct soap *soap, const char *tag, int id, struct _tev__PullMessages *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__PullMessages);
	if (id < 0)
		return soap->error;
	return soap_out__tev__PullMessages(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__PullMessages ** SOAP_FMAC4 soap_in_PointerTo_tev__PullMessages(struct soap *soap, const char *tag, struct _tev__PullMessages **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__PullMessages **)soap_malloc(soap, sizeof(struct _tev__PullMessages *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__PullMessages(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__PullMessages **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__PullMessages, sizeof(struct _tev__PullMessages), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__PullMessages(struct soap *soap, struct _tev__PullMessages *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tev__PullMessages);
	if (soap_out_PointerTo_tev__PullMessages(soap, tag?tag:"tev:PullMessages", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__PullMessages ** SOAP_FMAC4 soap_get_PointerTo_tev__PullMessages(struct soap *soap, struct _tev__PullMessages **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__PullMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StartSystemRestoreResponse(struct soap *soap, struct _tds__StartSystemRestoreResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StartSystemRestoreResponse))
		soap_serialize__tds__StartSystemRestoreResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, int id, struct _tds__StartSystemRestoreResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StartSystemRestoreResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__StartSystemRestoreResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__StartSystemRestoreResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, struct _tds__StartSystemRestoreResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__StartSystemRestoreResponse **)soap_malloc(soap, sizeof(struct _tds__StartSystemRestoreResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__StartSystemRestoreResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__StartSystemRestoreResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartSystemRestoreResponse, sizeof(struct _tds__StartSystemRestoreResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StartSystemRestoreResponse(struct soap *soap, struct _tds__StartSystemRestoreResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__StartSystemRestoreResponse);
	if (soap_out_PointerTo_tds__StartSystemRestoreResponse(soap, tag?tag:"tds:StartSystemRestoreResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartSystemRestoreResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__StartSystemRestoreResponse(struct soap *soap, struct _tds__StartSystemRestoreResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StartSystemRestoreResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StartSystemRestore(struct soap *soap, struct _tds__StartSystemRestore *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StartSystemRestore))
		soap_serialize__tds__StartSystemRestore(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StartSystemRestore(struct soap *soap, const char *tag, int id, struct _tds__StartSystemRestore *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StartSystemRestore);
	if (id < 0)
		return soap->error;
	return soap_out__tds__StartSystemRestore(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__StartSystemRestore ** SOAP_FMAC4 soap_in_PointerTo_tds__StartSystemRestore(struct soap *soap, const char *tag, struct _tds__StartSystemRestore **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__StartSystemRestore **)soap_malloc(soap, sizeof(struct _tds__StartSystemRestore *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__StartSystemRestore(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__StartSystemRestore **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartSystemRestore, sizeof(struct _tds__StartSystemRestore), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StartSystemRestore(struct soap *soap, struct _tds__StartSystemRestore *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__StartSystemRestore);
	if (soap_out_PointerTo_tds__StartSystemRestore(soap, tag?tag:"tds:StartSystemRestore", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartSystemRestore ** SOAP_FMAC4 soap_get_PointerTo_tds__StartSystemRestore(struct soap *soap, struct _tds__StartSystemRestore **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StartSystemRestore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StartFirmwareUpgradeResponse(struct soap *soap, struct _tds__StartFirmwareUpgradeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse))
		soap_serialize__tds__StartFirmwareUpgradeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, int id, struct _tds__StartFirmwareUpgradeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StartFirmwareUpgradeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__StartFirmwareUpgradeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgradeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, struct _tds__StartFirmwareUpgradeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__StartFirmwareUpgradeResponse **)soap_malloc(soap, sizeof(struct _tds__StartFirmwareUpgradeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__StartFirmwareUpgradeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__StartFirmwareUpgradeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, sizeof(struct _tds__StartFirmwareUpgradeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StartFirmwareUpgradeResponse(struct soap *soap, struct _tds__StartFirmwareUpgradeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__StartFirmwareUpgradeResponse);
	if (soap_out_PointerTo_tds__StartFirmwareUpgradeResponse(soap, tag?tag:"tds:StartFirmwareUpgradeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgradeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__StartFirmwareUpgradeResponse(struct soap *soap, struct _tds__StartFirmwareUpgradeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StartFirmwareUpgradeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, struct _tds__StartFirmwareUpgrade *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__StartFirmwareUpgrade))
		soap_serialize__tds__StartFirmwareUpgrade(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, int id, struct _tds__StartFirmwareUpgrade *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__StartFirmwareUpgrade);
	if (id < 0)
		return soap->error;
	return soap_out__tds__StartFirmwareUpgrade(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgrade ** SOAP_FMAC4 soap_in_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, struct _tds__StartFirmwareUpgrade **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__StartFirmwareUpgrade **)soap_malloc(soap, sizeof(struct _tds__StartFirmwareUpgrade *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__StartFirmwareUpgrade(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__StartFirmwareUpgrade **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(struct _tds__StartFirmwareUpgrade), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, struct _tds__StartFirmwareUpgrade *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__StartFirmwareUpgrade);
	if (soap_out_PointerTo_tds__StartFirmwareUpgrade(soap, tag?tag:"tds:StartFirmwareUpgrade", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgrade ** SOAP_FMAC4 soap_get_PointerTo_tds__StartFirmwareUpgrade(struct soap *soap, struct _tds__StartFirmwareUpgrade **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__StartFirmwareUpgrade(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemUrisResponse(struct soap *soap, struct _tds__GetSystemUrisResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemUrisResponse))
		soap_serialize__tds__GetSystemUrisResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemUrisResponse(struct soap *soap, const char *tag, int id, struct _tds__GetSystemUrisResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemUrisResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemUrisResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemUrisResponse(struct soap *soap, const char *tag, struct _tds__GetSystemUrisResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemUrisResponse **)soap_malloc(soap, sizeof(struct _tds__GetSystemUrisResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemUrisResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUrisResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemUrisResponse, sizeof(struct _tds__GetSystemUrisResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemUrisResponse(struct soap *soap, struct _tds__GetSystemUrisResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemUrisResponse);
	if (soap_out_PointerTo_tds__GetSystemUrisResponse(soap, tag?tag:"tds:GetSystemUrisResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemUrisResponse(struct soap *soap, struct _tds__GetSystemUrisResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemUrisResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemUris(struct soap *soap, struct _tds__GetSystemUris *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemUris))
		soap_serialize__tds__GetSystemUris(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemUris(struct soap *soap, const char *tag, int id, struct _tds__GetSystemUris *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemUris);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemUris(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemUris ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemUris(struct soap *soap, const char *tag, struct _tds__GetSystemUris **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemUris **)soap_malloc(soap, sizeof(struct _tds__GetSystemUris *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemUris(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUris **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemUris, sizeof(struct _tds__GetSystemUris), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemUris(struct soap *soap, struct _tds__GetSystemUris *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemUris);
	if (soap_out_PointerTo_tds__GetSystemUris(soap, tag?tag:"tds:GetSystemUris", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUris ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemUris(struct soap *soap, struct _tds__GetSystemUris **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemUris(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__ScanAvailableDot11NetworksResponse(struct soap *soap, struct _tds__ScanAvailableDot11NetworksResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse))
		soap_serialize__tds__ScanAvailableDot11NetworksResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, int id, struct _tds__ScanAvailableDot11NetworksResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__ScanAvailableDot11NetworksResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11NetworksResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, struct _tds__ScanAvailableDot11NetworksResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__ScanAvailableDot11NetworksResponse **)soap_malloc(soap, sizeof(struct _tds__ScanAvailableDot11NetworksResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__ScanAvailableDot11NetworksResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__ScanAvailableDot11NetworksResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, sizeof(struct _tds__ScanAvailableDot11NetworksResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__ScanAvailableDot11NetworksResponse(struct soap *soap, struct _tds__ScanAvailableDot11NetworksResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__ScanAvailableDot11NetworksResponse);
	if (soap_out_PointerTo_tds__ScanAvailableDot11NetworksResponse(soap, tag?tag:"tds:ScanAvailableDot11NetworksResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11NetworksResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__ScanAvailableDot11NetworksResponse(struct soap *soap, struct _tds__ScanAvailableDot11NetworksResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__ScanAvailableDot11NetworksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, struct _tds__ScanAvailableDot11Networks *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__ScanAvailableDot11Networks))
		soap_serialize__tds__ScanAvailableDot11Networks(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, int id, struct _tds__ScanAvailableDot11Networks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__ScanAvailableDot11Networks);
	if (id < 0)
		return soap->error;
	return soap_out__tds__ScanAvailableDot11Networks(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11Networks ** SOAP_FMAC4 soap_in_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, struct _tds__ScanAvailableDot11Networks **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__ScanAvailableDot11Networks **)soap_malloc(soap, sizeof(struct _tds__ScanAvailableDot11Networks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__ScanAvailableDot11Networks(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__ScanAvailableDot11Networks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(struct _tds__ScanAvailableDot11Networks), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, struct _tds__ScanAvailableDot11Networks *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__ScanAvailableDot11Networks);
	if (soap_out_PointerTo_tds__ScanAvailableDot11Networks(soap, tag?tag:"tds:ScanAvailableDot11Networks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11Networks ** SOAP_FMAC4 soap_get_PointerTo_tds__ScanAvailableDot11Networks(struct soap *soap, struct _tds__ScanAvailableDot11Networks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__ScanAvailableDot11Networks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot11StatusResponse(struct soap *soap, struct _tds__GetDot11StatusResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot11StatusResponse))
		soap_serialize__tds__GetDot11StatusResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot11StatusResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDot11StatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot11StatusResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDot11StatusResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDot11StatusResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot11StatusResponse(struct soap *soap, const char *tag, struct _tds__GetDot11StatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDot11StatusResponse **)soap_malloc(soap, sizeof(struct _tds__GetDot11StatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDot11StatusResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot11StatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11StatusResponse, sizeof(struct _tds__GetDot11StatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot11StatusResponse(struct soap *soap, struct _tds__GetDot11StatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot11StatusResponse);
	if (soap_out_PointerTo_tds__GetDot11StatusResponse(soap, tag?tag:"tds:GetDot11StatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11StatusResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot11StatusResponse(struct soap *soap, struct _tds__GetDot11StatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot11StatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot11Status(struct soap *soap, struct _tds__GetDot11Status *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot11Status))
		soap_serialize__tds__GetDot11Status(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot11Status(struct soap *soap, const char *tag, int id, struct _tds__GetDot11Status *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot11Status);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDot11Status(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDot11Status ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot11Status(struct soap *soap, const char *tag, struct _tds__GetDot11Status **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDot11Status **)soap_malloc(soap, sizeof(struct _tds__GetDot11Status *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDot11Status(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot11Status **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11Status, sizeof(struct _tds__GetDot11Status), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot11Status(struct soap *soap, struct _tds__GetDot11Status *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot11Status);
	if (soap_out_PointerTo_tds__GetDot11Status(soap, tag?tag:"tds:GetDot11Status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11Status ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot11Status(struct soap *soap, struct _tds__GetDot11Status **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot11CapabilitiesResponse(struct soap *soap, struct _tds__GetDot11CapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse))
		soap_serialize__tds__GetDot11CapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDot11CapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot11CapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDot11CapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDot11CapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetDot11CapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDot11CapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tds__GetDot11CapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDot11CapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot11CapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, sizeof(struct _tds__GetDot11CapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot11CapabilitiesResponse(struct soap *soap, struct _tds__GetDot11CapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot11CapabilitiesResponse);
	if (soap_out_PointerTo_tds__GetDot11CapabilitiesResponse(soap, tag?tag:"tds:GetDot11CapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11CapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot11CapabilitiesResponse(struct soap *soap, struct _tds__GetDot11CapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot11CapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot11Capabilities(struct soap *soap, struct _tds__GetDot11Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot11Capabilities))
		soap_serialize__tds__GetDot11Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot11Capabilities(struct soap *soap, const char *tag, int id, struct _tds__GetDot11Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot11Capabilities);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDot11Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDot11Capabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot11Capabilities(struct soap *soap, const char *tag, struct _tds__GetDot11Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDot11Capabilities **)soap_malloc(soap, sizeof(struct _tds__GetDot11Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDot11Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot11Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(struct _tds__GetDot11Capabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot11Capabilities(struct soap *soap, struct _tds__GetDot11Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot11Capabilities);
	if (soap_out_PointerTo_tds__GetDot11Capabilities(soap, tag?tag:"tds:GetDot11Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11Capabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot11Capabilities(struct soap *soap, struct _tds__GetDot11Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteDot1XConfigurationResponse(struct soap *soap, struct _tds__DeleteDot1XConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse))
		soap_serialize__tds__DeleteDot1XConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tds__DeleteDot1XConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__DeleteDot1XConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__DeleteDot1XConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__DeleteDot1XConfigurationResponse **)soap_malloc(soap, sizeof(struct _tds__DeleteDot1XConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__DeleteDot1XConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, sizeof(struct _tds__DeleteDot1XConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteDot1XConfigurationResponse(struct soap *soap, struct _tds__DeleteDot1XConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteDot1XConfigurationResponse);
	if (soap_out_PointerTo_tds__DeleteDot1XConfigurationResponse(soap, tag?tag:"tds:DeleteDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteDot1XConfigurationResponse(struct soap *soap, struct _tds__DeleteDot1XConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, struct _tds__DeleteDot1XConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteDot1XConfiguration))
		soap_serialize__tds__DeleteDot1XConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, int id, struct _tds__DeleteDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteDot1XConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tds__DeleteDot1XConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__DeleteDot1XConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__DeleteDot1XConfiguration **)soap_malloc(soap, sizeof(struct _tds__DeleteDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__DeleteDot1XConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(struct _tds__DeleteDot1XConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, struct _tds__DeleteDot1XConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteDot1XConfiguration);
	if (soap_out_PointerTo_tds__DeleteDot1XConfiguration(soap, tag?tag:"tds:DeleteDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteDot1XConfiguration(struct soap *soap, struct _tds__DeleteDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot1XConfigurationsResponse(struct soap *soap, struct _tds__GetDot1XConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse))
		soap_serialize__tds__GetDot1XConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDot1XConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot1XConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDot1XConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, struct _tds__GetDot1XConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDot1XConfigurationsResponse **)soap_malloc(soap, sizeof(struct _tds__GetDot1XConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDot1XConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, sizeof(struct _tds__GetDot1XConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot1XConfigurationsResponse(struct soap *soap, struct _tds__GetDot1XConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot1XConfigurationsResponse);
	if (soap_out_PointerTo_tds__GetDot1XConfigurationsResponse(soap, tag?tag:"tds:GetDot1XConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot1XConfigurationsResponse(struct soap *soap, struct _tds__GetDot1XConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot1XConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, struct _tds__GetDot1XConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot1XConfigurations))
		soap_serialize__tds__GetDot1XConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, const char *tag, int id, struct _tds__GetDot1XConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot1XConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDot1XConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurations ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, const char *tag, struct _tds__GetDot1XConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDot1XConfigurations **)soap_malloc(soap, sizeof(struct _tds__GetDot1XConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDot1XConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfigurations, sizeof(struct _tds__GetDot1XConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, struct _tds__GetDot1XConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot1XConfigurations);
	if (soap_out_PointerTo_tds__GetDot1XConfigurations(soap, tag?tag:"tds:GetDot1XConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurations ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot1XConfigurations(struct soap *soap, struct _tds__GetDot1XConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot1XConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot1XConfigurationResponse(struct soap *soap, struct _tds__GetDot1XConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot1XConfigurationResponse))
		soap_serialize__tds__GetDot1XConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDot1XConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot1XConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDot1XConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__GetDot1XConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDot1XConfigurationResponse **)soap_malloc(soap, sizeof(struct _tds__GetDot1XConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDot1XConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfigurationResponse, sizeof(struct _tds__GetDot1XConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot1XConfigurationResponse(struct soap *soap, struct _tds__GetDot1XConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot1XConfigurationResponse);
	if (soap_out_PointerTo_tds__GetDot1XConfigurationResponse(soap, tag?tag:"tds:GetDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot1XConfigurationResponse(struct soap *soap, struct _tds__GetDot1XConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, struct _tds__GetDot1XConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDot1XConfiguration))
		soap_serialize__tds__GetDot1XConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, const char *tag, int id, struct _tds__GetDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDot1XConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDot1XConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__GetDot1XConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDot1XConfiguration **)soap_malloc(soap, sizeof(struct _tds__GetDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDot1XConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDot1XConfiguration, sizeof(struct _tds__GetDot1XConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, struct _tds__GetDot1XConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDot1XConfiguration);
	if (soap_out_PointerTo_tds__GetDot1XConfiguration(soap, tag?tag:"tds:GetDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDot1XConfiguration(struct soap *soap, struct _tds__GetDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDot1XConfigurationResponse(struct soap *soap, struct _tds__SetDot1XConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDot1XConfigurationResponse))
		soap_serialize__tds__SetDot1XConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tds__SetDot1XConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDot1XConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDot1XConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDot1XConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__SetDot1XConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDot1XConfigurationResponse **)soap_malloc(soap, sizeof(struct _tds__SetDot1XConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDot1XConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDot1XConfigurationResponse, sizeof(struct _tds__SetDot1XConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDot1XConfigurationResponse(struct soap *soap, struct _tds__SetDot1XConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDot1XConfigurationResponse);
	if (soap_out_PointerTo_tds__SetDot1XConfigurationResponse(soap, tag?tag:"tds:SetDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDot1XConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDot1XConfigurationResponse(struct soap *soap, struct _tds__SetDot1XConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, struct _tds__SetDot1XConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDot1XConfiguration))
		soap_serialize__tds__SetDot1XConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, const char *tag, int id, struct _tds__SetDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDot1XConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDot1XConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__SetDot1XConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDot1XConfiguration **)soap_malloc(soap, sizeof(struct _tds__SetDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDot1XConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDot1XConfiguration, sizeof(struct _tds__SetDot1XConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, struct _tds__SetDot1XConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDot1XConfiguration);
	if (soap_out_PointerTo_tds__SetDot1XConfiguration(soap, tag?tag:"tds:SetDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDot1XConfiguration(struct soap *soap, struct _tds__SetDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateDot1XConfigurationResponse(struct soap *soap, struct _tds__CreateDot1XConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse))
		soap_serialize__tds__CreateDot1XConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tds__CreateDot1XConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateDot1XConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__CreateDot1XConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__CreateDot1XConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__CreateDot1XConfigurationResponse **)soap_malloc(soap, sizeof(struct _tds__CreateDot1XConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__CreateDot1XConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateDot1XConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, sizeof(struct _tds__CreateDot1XConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateDot1XConfigurationResponse(struct soap *soap, struct _tds__CreateDot1XConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateDot1XConfigurationResponse);
	if (soap_out_PointerTo_tds__CreateDot1XConfigurationResponse(soap, tag?tag:"tds:CreateDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateDot1XConfigurationResponse(struct soap *soap, struct _tds__CreateDot1XConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, struct _tds__CreateDot1XConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateDot1XConfiguration))
		soap_serialize__tds__CreateDot1XConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, int id, struct _tds__CreateDot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateDot1XConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tds__CreateDot1XConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__CreateDot1XConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__CreateDot1XConfiguration **)soap_malloc(soap, sizeof(struct _tds__CreateDot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__CreateDot1XConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateDot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateDot1XConfiguration, sizeof(struct _tds__CreateDot1XConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, struct _tds__CreateDot1XConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateDot1XConfiguration);
	if (soap_out_PointerTo_tds__CreateDot1XConfiguration(soap, tag?tag:"tds:CreateDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateDot1XConfiguration(struct soap *soap, struct _tds__CreateDot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCACertificatesResponse(struct soap *soap, struct _tds__LoadCACertificatesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCACertificatesResponse))
		soap_serialize__tds__LoadCACertificatesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, int id, struct _tds__LoadCACertificatesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCACertificatesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__LoadCACertificatesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__LoadCACertificatesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, struct _tds__LoadCACertificatesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__LoadCACertificatesResponse **)soap_malloc(soap, sizeof(struct _tds__LoadCACertificatesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__LoadCACertificatesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCACertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCACertificatesResponse, sizeof(struct _tds__LoadCACertificatesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCACertificatesResponse(struct soap *soap, struct _tds__LoadCACertificatesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__LoadCACertificatesResponse);
	if (soap_out_PointerTo_tds__LoadCACertificatesResponse(soap, tag?tag:"tds:LoadCACertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCACertificatesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCACertificatesResponse(struct soap *soap, struct _tds__LoadCACertificatesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCACertificates(struct soap *soap, struct _tds__LoadCACertificates *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCACertificates))
		soap_serialize__tds__LoadCACertificates(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCACertificates(struct soap *soap, const char *tag, int id, struct _tds__LoadCACertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCACertificates);
	if (id < 0)
		return soap->error;
	return soap_out__tds__LoadCACertificates(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__LoadCACertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCACertificates(struct soap *soap, const char *tag, struct _tds__LoadCACertificates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__LoadCACertificates **)soap_malloc(soap, sizeof(struct _tds__LoadCACertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__LoadCACertificates(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCACertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCACertificates, sizeof(struct _tds__LoadCACertificates), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCACertificates(struct soap *soap, struct _tds__LoadCACertificates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__LoadCACertificates);
	if (soap_out_PointerTo_tds__LoadCACertificates(soap, tag?tag:"tds:LoadCACertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCACertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCACertificates(struct soap *soap, struct _tds__LoadCACertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificateInformationResponse(struct soap *soap, struct _tds__GetCertificateInformationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificateInformationResponse))
		soap_serialize__tds__GetCertificateInformationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, int id, struct _tds__GetCertificateInformationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificateInformationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCertificateInformationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCertificateInformationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, struct _tds__GetCertificateInformationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCertificateInformationResponse **)soap_malloc(soap, sizeof(struct _tds__GetCertificateInformationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCertificateInformationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificateInformationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificateInformationResponse, sizeof(struct _tds__GetCertificateInformationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificateInformationResponse(struct soap *soap, struct _tds__GetCertificateInformationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCertificateInformationResponse);
	if (soap_out_PointerTo_tds__GetCertificateInformationResponse(soap, tag?tag:"tds:GetCertificateInformationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificateInformationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificateInformationResponse(struct soap *soap, struct _tds__GetCertificateInformationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificateInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificateInformation(struct soap *soap, struct _tds__GetCertificateInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificateInformation))
		soap_serialize__tds__GetCertificateInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificateInformation(struct soap *soap, const char *tag, int id, struct _tds__GetCertificateInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificateInformation);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCertificateInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCertificateInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificateInformation(struct soap *soap, const char *tag, struct _tds__GetCertificateInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCertificateInformation **)soap_malloc(soap, sizeof(struct _tds__GetCertificateInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCertificateInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificateInformation, sizeof(struct _tds__GetCertificateInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificateInformation(struct soap *soap, struct _tds__GetCertificateInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCertificateInformation);
	if (soap_out_PointerTo_tds__GetCertificateInformation(soap, tag?tag:"tds:GetCertificateInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificateInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificateInformation(struct soap *soap, struct _tds__GetCertificateInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, struct _tds__LoadCertificateWithPrivateKeyResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse))
		soap_serialize__tds__LoadCertificateWithPrivateKeyResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, int id, struct _tds__LoadCertificateWithPrivateKeyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__LoadCertificateWithPrivateKeyResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKeyResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, struct _tds__LoadCertificateWithPrivateKeyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__LoadCertificateWithPrivateKeyResponse **)soap_malloc(soap, sizeof(struct _tds__LoadCertificateWithPrivateKeyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__LoadCertificateWithPrivateKeyResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificateWithPrivateKeyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, sizeof(struct _tds__LoadCertificateWithPrivateKeyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, struct _tds__LoadCertificateWithPrivateKeyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__LoadCertificateWithPrivateKeyResponse);
	if (soap_out_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(soap, tag?tag:"tds:LoadCertificateWithPrivateKeyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKeyResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, struct _tds__LoadCertificateWithPrivateKeyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCertificateWithPrivateKeyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, struct _tds__LoadCertificateWithPrivateKey *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey))
		soap_serialize__tds__LoadCertificateWithPrivateKey(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, int id, struct _tds__LoadCertificateWithPrivateKey *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCertificateWithPrivateKey);
	if (id < 0)
		return soap->error;
	return soap_out__tds__LoadCertificateWithPrivateKey(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKey ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, struct _tds__LoadCertificateWithPrivateKey **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__LoadCertificateWithPrivateKey **)soap_malloc(soap, sizeof(struct _tds__LoadCertificateWithPrivateKey *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__LoadCertificateWithPrivateKey(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificateWithPrivateKey **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, sizeof(struct _tds__LoadCertificateWithPrivateKey), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, struct _tds__LoadCertificateWithPrivateKey *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__LoadCertificateWithPrivateKey);
	if (soap_out_PointerTo_tds__LoadCertificateWithPrivateKey(soap, tag?tag:"tds:LoadCertificateWithPrivateKey", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKey ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCertificateWithPrivateKey(struct soap *soap, struct _tds__LoadCertificateWithPrivateKey **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCACertificatesResponse(struct soap *soap, struct _tds__GetCACertificatesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCACertificatesResponse))
		soap_serialize__tds__GetCACertificatesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCACertificatesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetCACertificatesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCACertificatesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCACertificatesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCACertificatesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCACertificatesResponse(struct soap *soap, const char *tag, struct _tds__GetCACertificatesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCACertificatesResponse **)soap_malloc(soap, sizeof(struct _tds__GetCACertificatesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCACertificatesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCACertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCACertificatesResponse, sizeof(struct _tds__GetCACertificatesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCACertificatesResponse(struct soap *soap, struct _tds__GetCACertificatesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCACertificatesResponse);
	if (soap_out_PointerTo_tds__GetCACertificatesResponse(soap, tag?tag:"tds:GetCACertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCACertificatesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCACertificatesResponse(struct soap *soap, struct _tds__GetCACertificatesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCACertificates(struct soap *soap, struct _tds__GetCACertificates *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCACertificates))
		soap_serialize__tds__GetCACertificates(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCACertificates(struct soap *soap, const char *tag, int id, struct _tds__GetCACertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCACertificates);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCACertificates(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCACertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCACertificates(struct soap *soap, const char *tag, struct _tds__GetCACertificates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCACertificates **)soap_malloc(soap, sizeof(struct _tds__GetCACertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCACertificates(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCACertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCACertificates, sizeof(struct _tds__GetCACertificates), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCACertificates(struct soap *soap, struct _tds__GetCACertificates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCACertificates);
	if (soap_out_PointerTo_tds__GetCACertificates(soap, tag?tag:"tds:GetCACertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCACertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCACertificates(struct soap *soap, struct _tds__GetCACertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, struct _tds__SendAuxiliaryCommandResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse))
		soap_serialize__tds__SendAuxiliaryCommandResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, struct _tds__SendAuxiliaryCommandResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SendAuxiliaryCommandResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SendAuxiliaryCommandResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommandResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, struct _tds__SendAuxiliaryCommandResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SendAuxiliaryCommandResponse **)soap_malloc(soap, sizeof(struct _tds__SendAuxiliaryCommandResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SendAuxiliaryCommandResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SendAuxiliaryCommandResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(struct _tds__SendAuxiliaryCommandResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, struct _tds__SendAuxiliaryCommandResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SendAuxiliaryCommandResponse);
	if (soap_out_PointerTo_tds__SendAuxiliaryCommandResponse(soap, tag?tag:"tds:SendAuxiliaryCommandResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommandResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SendAuxiliaryCommandResponse(struct soap *soap, struct _tds__SendAuxiliaryCommandResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SendAuxiliaryCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, struct _tds__SendAuxiliaryCommand *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SendAuxiliaryCommand))
		soap_serialize__tds__SendAuxiliaryCommand(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, struct _tds__SendAuxiliaryCommand *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SendAuxiliaryCommand);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SendAuxiliaryCommand(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommand ** SOAP_FMAC4 soap_in_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct _tds__SendAuxiliaryCommand **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SendAuxiliaryCommand **)soap_malloc(soap, sizeof(struct _tds__SendAuxiliaryCommand *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SendAuxiliaryCommand(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SendAuxiliaryCommand **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(struct _tds__SendAuxiliaryCommand), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, struct _tds__SendAuxiliaryCommand *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SendAuxiliaryCommand);
	if (soap_out_PointerTo_tds__SendAuxiliaryCommand(soap, tag?tag:"tds:SendAuxiliaryCommand", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommand ** SOAP_FMAC4 soap_get_PointerTo_tds__SendAuxiliaryCommand(struct soap *soap, struct _tds__SendAuxiliaryCommand **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, struct _tds__SetRelayOutputStateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputStateResponse))
		soap_serialize__tds__SetRelayOutputStateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, int id, struct _tds__SetRelayOutputStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputStateResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetRelayOutputStateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRelayOutputStateResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, struct _tds__SetRelayOutputStateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetRelayOutputStateResponse **)soap_malloc(soap, sizeof(struct _tds__SetRelayOutputStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetRelayOutputStateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(struct _tds__SetRelayOutputStateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, struct _tds__SetRelayOutputStateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRelayOutputStateResponse);
	if (soap_out_PointerTo_tds__SetRelayOutputStateResponse(soap, tag?tag:"tds:SetRelayOutputStateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputStateResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputStateResponse(struct soap *soap, struct _tds__SetRelayOutputStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputState(struct soap *soap, struct _tds__SetRelayOutputState *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputState))
		soap_serialize__tds__SetRelayOutputState(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputState(struct soap *soap, const char *tag, int id, struct _tds__SetRelayOutputState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputState);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetRelayOutputState(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRelayOutputState ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputState(struct soap *soap, const char *tag, struct _tds__SetRelayOutputState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetRelayOutputState **)soap_malloc(soap, sizeof(struct _tds__SetRelayOutputState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetRelayOutputState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputState, sizeof(struct _tds__SetRelayOutputState), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputState(struct soap *soap, struct _tds__SetRelayOutputState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRelayOutputState);
	if (soap_out_PointerTo_tds__SetRelayOutputState(soap, tag?tag:"tds:SetRelayOutputState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputState ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputState(struct soap *soap, struct _tds__SetRelayOutputState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, struct _tds__SetRelayOutputSettingsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse))
		soap_serialize__tds__SetRelayOutputSettingsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, int id, struct _tds__SetRelayOutputSettingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputSettingsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetRelayOutputSettingsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettingsResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, struct _tds__SetRelayOutputSettingsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetRelayOutputSettingsResponse **)soap_malloc(soap, sizeof(struct _tds__SetRelayOutputSettingsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetRelayOutputSettingsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputSettingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(struct _tds__SetRelayOutputSettingsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, struct _tds__SetRelayOutputSettingsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRelayOutputSettingsResponse);
	if (soap_out_PointerTo_tds__SetRelayOutputSettingsResponse(soap, tag?tag:"tds:SetRelayOutputSettingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettingsResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputSettingsResponse(struct soap *soap, struct _tds__SetRelayOutputSettingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, struct _tds__SetRelayOutputSettings *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRelayOutputSettings))
		soap_serialize__tds__SetRelayOutputSettings(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, struct _tds__SetRelayOutputSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRelayOutputSettings);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetRelayOutputSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettings ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, const char *tag, struct _tds__SetRelayOutputSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetRelayOutputSettings **)soap_malloc(soap, sizeof(struct _tds__SetRelayOutputSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetRelayOutputSettings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(struct _tds__SetRelayOutputSettings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, struct _tds__SetRelayOutputSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRelayOutputSettings);
	if (soap_out_PointerTo_tds__SetRelayOutputSettings(soap, tag?tag:"tds:SetRelayOutputSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettings ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRelayOutputSettings(struct soap *soap, struct _tds__SetRelayOutputSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, struct _tds__GetRelayOutputsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRelayOutputsResponse))
		soap_serialize__tds__GetRelayOutputsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, int id, struct _tds__GetRelayOutputsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRelayOutputsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetRelayOutputsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetRelayOutputsResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, struct _tds__GetRelayOutputsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetRelayOutputsResponse **)soap_malloc(soap, sizeof(struct _tds__GetRelayOutputsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetRelayOutputsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRelayOutputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(struct _tds__GetRelayOutputsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, struct _tds__GetRelayOutputsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRelayOutputsResponse);
	if (soap_out_PointerTo_tds__GetRelayOutputsResponse(soap, tag?tag:"tds:GetRelayOutputsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRelayOutputsResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRelayOutputsResponse(struct soap *soap, struct _tds__GetRelayOutputsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRelayOutputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRelayOutputs(struct soap *soap, struct _tds__GetRelayOutputs *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRelayOutputs))
		soap_serialize__tds__GetRelayOutputs(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRelayOutputs(struct soap *soap, const char *tag, int id, struct _tds__GetRelayOutputs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRelayOutputs);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetRelayOutputs(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetRelayOutputs ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRelayOutputs(struct soap *soap, const char *tag, struct _tds__GetRelayOutputs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetRelayOutputs **)soap_malloc(soap, sizeof(struct _tds__GetRelayOutputs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetRelayOutputs(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRelayOutputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRelayOutputs, sizeof(struct _tds__GetRelayOutputs), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRelayOutputs(struct soap *soap, struct _tds__GetRelayOutputs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRelayOutputs);
	if (soap_out_PointerTo_tds__GetRelayOutputs(soap, tag?tag:"tds:GetRelayOutputs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRelayOutputs ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRelayOutputs(struct soap *soap, struct _tds__GetRelayOutputs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRelayOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetClientCertificateModeResponse(struct soap *soap, struct _tds__SetClientCertificateModeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetClientCertificateModeResponse))
		soap_serialize__tds__SetClientCertificateModeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, struct _tds__SetClientCertificateModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetClientCertificateModeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetClientCertificateModeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetClientCertificateModeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, struct _tds__SetClientCertificateModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetClientCertificateModeResponse **)soap_malloc(soap, sizeof(struct _tds__SetClientCertificateModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetClientCertificateModeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetClientCertificateModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetClientCertificateModeResponse, sizeof(struct _tds__SetClientCertificateModeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetClientCertificateModeResponse(struct soap *soap, struct _tds__SetClientCertificateModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetClientCertificateModeResponse);
	if (soap_out_PointerTo_tds__SetClientCertificateModeResponse(soap, tag?tag:"tds:SetClientCertificateModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetClientCertificateModeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetClientCertificateModeResponse(struct soap *soap, struct _tds__SetClientCertificateModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetClientCertificateMode(struct soap *soap, struct _tds__SetClientCertificateMode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetClientCertificateMode))
		soap_serialize__tds__SetClientCertificateMode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetClientCertificateMode(struct soap *soap, const char *tag, int id, struct _tds__SetClientCertificateMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetClientCertificateMode);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetClientCertificateMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetClientCertificateMode ** SOAP_FMAC4 soap_in_PointerTo_tds__SetClientCertificateMode(struct soap *soap, const char *tag, struct _tds__SetClientCertificateMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetClientCertificateMode **)soap_malloc(soap, sizeof(struct _tds__SetClientCertificateMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetClientCertificateMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetClientCertificateMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetClientCertificateMode, sizeof(struct _tds__SetClientCertificateMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetClientCertificateMode(struct soap *soap, struct _tds__SetClientCertificateMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetClientCertificateMode);
	if (soap_out_PointerTo_tds__SetClientCertificateMode(soap, tag?tag:"tds:SetClientCertificateMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetClientCertificateMode ** SOAP_FMAC4 soap_get_PointerTo_tds__SetClientCertificateMode(struct soap *soap, struct _tds__SetClientCertificateMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetClientCertificateModeResponse(struct soap *soap, struct _tds__GetClientCertificateModeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetClientCertificateModeResponse))
		soap_serialize__tds__GetClientCertificateModeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, struct _tds__GetClientCertificateModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetClientCertificateModeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetClientCertificateModeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetClientCertificateModeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, struct _tds__GetClientCertificateModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetClientCertificateModeResponse **)soap_malloc(soap, sizeof(struct _tds__GetClientCertificateModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetClientCertificateModeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetClientCertificateModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetClientCertificateModeResponse, sizeof(struct _tds__GetClientCertificateModeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetClientCertificateModeResponse(struct soap *soap, struct _tds__GetClientCertificateModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetClientCertificateModeResponse);
	if (soap_out_PointerTo_tds__GetClientCertificateModeResponse(soap, tag?tag:"tds:GetClientCertificateModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetClientCertificateModeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetClientCertificateModeResponse(struct soap *soap, struct _tds__GetClientCertificateModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetClientCertificateMode(struct soap *soap, struct _tds__GetClientCertificateMode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetClientCertificateMode))
		soap_serialize__tds__GetClientCertificateMode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetClientCertificateMode(struct soap *soap, const char *tag, int id, struct _tds__GetClientCertificateMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetClientCertificateMode);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetClientCertificateMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetClientCertificateMode ** SOAP_FMAC4 soap_in_PointerTo_tds__GetClientCertificateMode(struct soap *soap, const char *tag, struct _tds__GetClientCertificateMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetClientCertificateMode **)soap_malloc(soap, sizeof(struct _tds__GetClientCertificateMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetClientCertificateMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetClientCertificateMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetClientCertificateMode, sizeof(struct _tds__GetClientCertificateMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetClientCertificateMode(struct soap *soap, struct _tds__GetClientCertificateMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetClientCertificateMode);
	if (soap_out_PointerTo_tds__GetClientCertificateMode(soap, tag?tag:"tds:GetClientCertificateMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetClientCertificateMode ** SOAP_FMAC4 soap_get_PointerTo_tds__GetClientCertificateMode(struct soap *soap, struct _tds__GetClientCertificateMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCertificatesResponse(struct soap *soap, struct _tds__LoadCertificatesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCertificatesResponse))
		soap_serialize__tds__LoadCertificatesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCertificatesResponse(struct soap *soap, const char *tag, int id, struct _tds__LoadCertificatesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCertificatesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__LoadCertificatesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__LoadCertificatesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCertificatesResponse(struct soap *soap, const char *tag, struct _tds__LoadCertificatesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__LoadCertificatesResponse **)soap_malloc(soap, sizeof(struct _tds__LoadCertificatesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__LoadCertificatesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificatesResponse, sizeof(struct _tds__LoadCertificatesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCertificatesResponse(struct soap *soap, struct _tds__LoadCertificatesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__LoadCertificatesResponse);
	if (soap_out_PointerTo_tds__LoadCertificatesResponse(soap, tag?tag:"tds:LoadCertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificatesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCertificatesResponse(struct soap *soap, struct _tds__LoadCertificatesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__LoadCertificates(struct soap *soap, struct _tds__LoadCertificates *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__LoadCertificates))
		soap_serialize__tds__LoadCertificates(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__LoadCertificates(struct soap *soap, const char *tag, int id, struct _tds__LoadCertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__LoadCertificates);
	if (id < 0)
		return soap->error;
	return soap_out__tds__LoadCertificates(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__LoadCertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__LoadCertificates(struct soap *soap, const char *tag, struct _tds__LoadCertificates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__LoadCertificates **)soap_malloc(soap, sizeof(struct _tds__LoadCertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__LoadCertificates(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__LoadCertificates, sizeof(struct _tds__LoadCertificates), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__LoadCertificates(struct soap *soap, struct _tds__LoadCertificates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__LoadCertificates);
	if (soap_out_PointerTo_tds__LoadCertificates(soap, tag?tag:"tds:LoadCertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__LoadCertificates(struct soap *soap, struct _tds__LoadCertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__LoadCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetPkcs10RequestResponse(struct soap *soap, struct _tds__GetPkcs10RequestResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetPkcs10RequestResponse))
		soap_serialize__tds__GetPkcs10RequestResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, int id, struct _tds__GetPkcs10RequestResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetPkcs10RequestResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetPkcs10RequestResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetPkcs10RequestResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, struct _tds__GetPkcs10RequestResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetPkcs10RequestResponse **)soap_malloc(soap, sizeof(struct _tds__GetPkcs10RequestResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetPkcs10RequestResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetPkcs10RequestResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetPkcs10RequestResponse, sizeof(struct _tds__GetPkcs10RequestResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetPkcs10RequestResponse(struct soap *soap, struct _tds__GetPkcs10RequestResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetPkcs10RequestResponse);
	if (soap_out_PointerTo_tds__GetPkcs10RequestResponse(soap, tag?tag:"tds:GetPkcs10RequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetPkcs10RequestResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetPkcs10RequestResponse(struct soap *soap, struct _tds__GetPkcs10RequestResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetPkcs10RequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetPkcs10Request(struct soap *soap, struct _tds__GetPkcs10Request *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetPkcs10Request))
		soap_serialize__tds__GetPkcs10Request(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetPkcs10Request(struct soap *soap, const char *tag, int id, struct _tds__GetPkcs10Request *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetPkcs10Request);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetPkcs10Request(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetPkcs10Request ** SOAP_FMAC4 soap_in_PointerTo_tds__GetPkcs10Request(struct soap *soap, const char *tag, struct _tds__GetPkcs10Request **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetPkcs10Request **)soap_malloc(soap, sizeof(struct _tds__GetPkcs10Request *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetPkcs10Request(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetPkcs10Request **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetPkcs10Request, sizeof(struct _tds__GetPkcs10Request), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetPkcs10Request(struct soap *soap, struct _tds__GetPkcs10Request *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetPkcs10Request);
	if (soap_out_PointerTo_tds__GetPkcs10Request(soap, tag?tag:"tds:GetPkcs10Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetPkcs10Request ** SOAP_FMAC4 soap_get_PointerTo_tds__GetPkcs10Request(struct soap *soap, struct _tds__GetPkcs10Request **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetPkcs10Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteCertificatesResponse(struct soap *soap, struct _tds__DeleteCertificatesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteCertificatesResponse))
		soap_serialize__tds__DeleteCertificatesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, int id, struct _tds__DeleteCertificatesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteCertificatesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__DeleteCertificatesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__DeleteCertificatesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, struct _tds__DeleteCertificatesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__DeleteCertificatesResponse **)soap_malloc(soap, sizeof(struct _tds__DeleteCertificatesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__DeleteCertificatesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteCertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteCertificatesResponse, sizeof(struct _tds__DeleteCertificatesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteCertificatesResponse(struct soap *soap, struct _tds__DeleteCertificatesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteCertificatesResponse);
	if (soap_out_PointerTo_tds__DeleteCertificatesResponse(soap, tag?tag:"tds:DeleteCertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteCertificatesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteCertificatesResponse(struct soap *soap, struct _tds__DeleteCertificatesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteCertificates(struct soap *soap, struct _tds__DeleteCertificates *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteCertificates))
		soap_serialize__tds__DeleteCertificates(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteCertificates(struct soap *soap, const char *tag, int id, struct _tds__DeleteCertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteCertificates);
	if (id < 0)
		return soap->error;
	return soap_out__tds__DeleteCertificates(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__DeleteCertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteCertificates(struct soap *soap, const char *tag, struct _tds__DeleteCertificates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__DeleteCertificates **)soap_malloc(soap, sizeof(struct _tds__DeleteCertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__DeleteCertificates(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteCertificates, sizeof(struct _tds__DeleteCertificates), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteCertificates(struct soap *soap, struct _tds__DeleteCertificates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteCertificates);
	if (soap_out_PointerTo_tds__DeleteCertificates(soap, tag?tag:"tds:DeleteCertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteCertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteCertificates(struct soap *soap, struct _tds__DeleteCertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetCertificatesStatusResponse(struct soap *soap, struct _tds__SetCertificatesStatusResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetCertificatesStatusResponse))
		soap_serialize__tds__SetCertificatesStatusResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, struct _tds__SetCertificatesStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetCertificatesStatusResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetCertificatesStatusResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, struct _tds__SetCertificatesStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetCertificatesStatusResponse **)soap_malloc(soap, sizeof(struct _tds__SetCertificatesStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetCertificatesStatusResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetCertificatesStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetCertificatesStatusResponse, sizeof(struct _tds__SetCertificatesStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetCertificatesStatusResponse(struct soap *soap, struct _tds__SetCertificatesStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetCertificatesStatusResponse);
	if (soap_out_PointerTo_tds__SetCertificatesStatusResponse(soap, tag?tag:"tds:SetCertificatesStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetCertificatesStatusResponse(struct soap *soap, struct _tds__SetCertificatesStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetCertificatesStatus(struct soap *soap, struct _tds__SetCertificatesStatus *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetCertificatesStatus))
		soap_serialize__tds__SetCertificatesStatus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetCertificatesStatus(struct soap *soap, const char *tag, int id, struct _tds__SetCertificatesStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetCertificatesStatus);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetCertificatesStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatus ** SOAP_FMAC4 soap_in_PointerTo_tds__SetCertificatesStatus(struct soap *soap, const char *tag, struct _tds__SetCertificatesStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetCertificatesStatus **)soap_malloc(soap, sizeof(struct _tds__SetCertificatesStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetCertificatesStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetCertificatesStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetCertificatesStatus, sizeof(struct _tds__SetCertificatesStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetCertificatesStatus(struct soap *soap, struct _tds__SetCertificatesStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetCertificatesStatus);
	if (soap_out_PointerTo_tds__SetCertificatesStatus(soap, tag?tag:"tds:SetCertificatesStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatus ** SOAP_FMAC4 soap_get_PointerTo_tds__SetCertificatesStatus(struct soap *soap, struct _tds__SetCertificatesStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificatesStatusResponse(struct soap *soap, struct _tds__GetCertificatesStatusResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificatesStatusResponse))
		soap_serialize__tds__GetCertificatesStatusResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, struct _tds__GetCertificatesStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificatesStatusResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCertificatesStatusResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, struct _tds__GetCertificatesStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCertificatesStatusResponse **)soap_malloc(soap, sizeof(struct _tds__GetCertificatesStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCertificatesStatusResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificatesStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificatesStatusResponse, sizeof(struct _tds__GetCertificatesStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificatesStatusResponse(struct soap *soap, struct _tds__GetCertificatesStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCertificatesStatusResponse);
	if (soap_out_PointerTo_tds__GetCertificatesStatusResponse(soap, tag?tag:"tds:GetCertificatesStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificatesStatusResponse(struct soap *soap, struct _tds__GetCertificatesStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificatesStatus(struct soap *soap, struct _tds__GetCertificatesStatus *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificatesStatus))
		soap_serialize__tds__GetCertificatesStatus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificatesStatus(struct soap *soap, const char *tag, int id, struct _tds__GetCertificatesStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificatesStatus);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCertificatesStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatus ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificatesStatus(struct soap *soap, const char *tag, struct _tds__GetCertificatesStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCertificatesStatus **)soap_malloc(soap, sizeof(struct _tds__GetCertificatesStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCertificatesStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificatesStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificatesStatus, sizeof(struct _tds__GetCertificatesStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificatesStatus(struct soap *soap, struct _tds__GetCertificatesStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCertificatesStatus);
	if (soap_out_PointerTo_tds__GetCertificatesStatus(soap, tag?tag:"tds:GetCertificatesStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatus ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificatesStatus(struct soap *soap, struct _tds__GetCertificatesStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificatesResponse(struct soap *soap, struct _tds__GetCertificatesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificatesResponse))
		soap_serialize__tds__GetCertificatesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificatesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetCertificatesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificatesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCertificatesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCertificatesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificatesResponse(struct soap *soap, const char *tag, struct _tds__GetCertificatesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCertificatesResponse **)soap_malloc(soap, sizeof(struct _tds__GetCertificatesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCertificatesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificatesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificatesResponse, sizeof(struct _tds__GetCertificatesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificatesResponse(struct soap *soap, struct _tds__GetCertificatesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCertificatesResponse);
	if (soap_out_PointerTo_tds__GetCertificatesResponse(soap, tag?tag:"tds:GetCertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificatesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificatesResponse(struct soap *soap, struct _tds__GetCertificatesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCertificates(struct soap *soap, struct _tds__GetCertificates *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCertificates))
		soap_serialize__tds__GetCertificates(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCertificates(struct soap *soap, const char *tag, int id, struct _tds__GetCertificates *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCertificates);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCertificates(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCertificates ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCertificates(struct soap *soap, const char *tag, struct _tds__GetCertificates **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCertificates **)soap_malloc(soap, sizeof(struct _tds__GetCertificates *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCertificates(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificates **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCertificates, sizeof(struct _tds__GetCertificates), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCertificates(struct soap *soap, struct _tds__GetCertificates *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCertificates);
	if (soap_out_PointerTo_tds__GetCertificates(soap, tag?tag:"tds:GetCertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificates ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCertificates(struct soap *soap, struct _tds__GetCertificates **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateCertificateResponse(struct soap *soap, struct _tds__CreateCertificateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateCertificateResponse))
		soap_serialize__tds__CreateCertificateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateCertificateResponse(struct soap *soap, const char *tag, int id, struct _tds__CreateCertificateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateCertificateResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__CreateCertificateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__CreateCertificateResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateCertificateResponse(struct soap *soap, const char *tag, struct _tds__CreateCertificateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__CreateCertificateResponse **)soap_malloc(soap, sizeof(struct _tds__CreateCertificateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__CreateCertificateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateCertificateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateCertificateResponse, sizeof(struct _tds__CreateCertificateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateCertificateResponse(struct soap *soap, struct _tds__CreateCertificateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateCertificateResponse);
	if (soap_out_PointerTo_tds__CreateCertificateResponse(soap, tag?tag:"tds:CreateCertificateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateCertificateResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateCertificateResponse(struct soap *soap, struct _tds__CreateCertificateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateCertificateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateCertificate(struct soap *soap, struct _tds__CreateCertificate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateCertificate))
		soap_serialize__tds__CreateCertificate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateCertificate(struct soap *soap, const char *tag, int id, struct _tds__CreateCertificate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateCertificate);
	if (id < 0)
		return soap->error;
	return soap_out__tds__CreateCertificate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__CreateCertificate ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateCertificate(struct soap *soap, const char *tag, struct _tds__CreateCertificate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__CreateCertificate **)soap_malloc(soap, sizeof(struct _tds__CreateCertificate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__CreateCertificate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateCertificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateCertificate, sizeof(struct _tds__CreateCertificate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateCertificate(struct soap *soap, struct _tds__CreateCertificate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateCertificate);
	if (soap_out_PointerTo_tds__CreateCertificate(soap, tag?tag:"tds:CreateCertificate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateCertificate ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateCertificate(struct soap *soap, struct _tds__CreateCertificate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetAccessPolicyResponse(struct soap *soap, struct _tds__SetAccessPolicyResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetAccessPolicyResponse))
		soap_serialize__tds__SetAccessPolicyResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, int id, struct _tds__SetAccessPolicyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetAccessPolicyResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetAccessPolicyResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetAccessPolicyResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, struct _tds__SetAccessPolicyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetAccessPolicyResponse **)soap_malloc(soap, sizeof(struct _tds__SetAccessPolicyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetAccessPolicyResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetAccessPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetAccessPolicyResponse, sizeof(struct _tds__SetAccessPolicyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetAccessPolicyResponse(struct soap *soap, struct _tds__SetAccessPolicyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetAccessPolicyResponse);
	if (soap_out_PointerTo_tds__SetAccessPolicyResponse(soap, tag?tag:"tds:SetAccessPolicyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetAccessPolicyResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetAccessPolicyResponse(struct soap *soap, struct _tds__SetAccessPolicyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetAccessPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetAccessPolicy(struct soap *soap, struct _tds__SetAccessPolicy *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetAccessPolicy))
		soap_serialize__tds__SetAccessPolicy(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetAccessPolicy(struct soap *soap, const char *tag, int id, struct _tds__SetAccessPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetAccessPolicy);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetAccessPolicy(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetAccessPolicy ** SOAP_FMAC4 soap_in_PointerTo_tds__SetAccessPolicy(struct soap *soap, const char *tag, struct _tds__SetAccessPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetAccessPolicy **)soap_malloc(soap, sizeof(struct _tds__SetAccessPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetAccessPolicy(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetAccessPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetAccessPolicy, sizeof(struct _tds__SetAccessPolicy), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetAccessPolicy(struct soap *soap, struct _tds__SetAccessPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetAccessPolicy);
	if (soap_out_PointerTo_tds__SetAccessPolicy(soap, tag?tag:"tds:SetAccessPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetAccessPolicy ** SOAP_FMAC4 soap_get_PointerTo_tds__SetAccessPolicy(struct soap *soap, struct _tds__SetAccessPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetAccessPolicyResponse(struct soap *soap, struct _tds__GetAccessPolicyResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetAccessPolicyResponse))
		soap_serialize__tds__GetAccessPolicyResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetAccessPolicyResponse(struct soap *soap, const char *tag, int id, struct _tds__GetAccessPolicyResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetAccessPolicyResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetAccessPolicyResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetAccessPolicyResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetAccessPolicyResponse(struct soap *soap, const char *tag, struct _tds__GetAccessPolicyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetAccessPolicyResponse **)soap_malloc(soap, sizeof(struct _tds__GetAccessPolicyResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetAccessPolicyResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetAccessPolicyResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetAccessPolicyResponse, sizeof(struct _tds__GetAccessPolicyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetAccessPolicyResponse(struct soap *soap, struct _tds__GetAccessPolicyResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetAccessPolicyResponse);
	if (soap_out_PointerTo_tds__GetAccessPolicyResponse(soap, tag?tag:"tds:GetAccessPolicyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetAccessPolicyResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetAccessPolicyResponse(struct soap *soap, struct _tds__GetAccessPolicyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetAccessPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetAccessPolicy(struct soap *soap, struct _tds__GetAccessPolicy *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetAccessPolicy))
		soap_serialize__tds__GetAccessPolicy(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetAccessPolicy(struct soap *soap, const char *tag, int id, struct _tds__GetAccessPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetAccessPolicy);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetAccessPolicy(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetAccessPolicy ** SOAP_FMAC4 soap_in_PointerTo_tds__GetAccessPolicy(struct soap *soap, const char *tag, struct _tds__GetAccessPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetAccessPolicy **)soap_malloc(soap, sizeof(struct _tds__GetAccessPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetAccessPolicy(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetAccessPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetAccessPolicy, sizeof(struct _tds__GetAccessPolicy), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetAccessPolicy(struct soap *soap, struct _tds__GetAccessPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetAccessPolicy);
	if (soap_out_PointerTo_tds__GetAccessPolicy(soap, tag?tag:"tds:GetAccessPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetAccessPolicy ** SOAP_FMAC4 soap_get_PointerTo_tds__GetAccessPolicy(struct soap *soap, struct _tds__GetAccessPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetAccessPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, struct _tds__RemoveIPAddressFilterResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse))
		soap_serialize__tds__RemoveIPAddressFilterResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, int id, struct _tds__RemoveIPAddressFilterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RemoveIPAddressFilterResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__RemoveIPAddressFilterResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilterResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__RemoveIPAddressFilterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__RemoveIPAddressFilterResponse **)soap_malloc(soap, sizeof(struct _tds__RemoveIPAddressFilterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__RemoveIPAddressFilterResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__RemoveIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveIPAddressFilterResponse, sizeof(struct _tds__RemoveIPAddressFilterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, struct _tds__RemoveIPAddressFilterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RemoveIPAddressFilterResponse);
	if (soap_out_PointerTo_tds__RemoveIPAddressFilterResponse(soap, tag?tag:"tds:RemoveIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilterResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__RemoveIPAddressFilterResponse(struct soap *soap, struct _tds__RemoveIPAddressFilterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RemoveIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, struct _tds__RemoveIPAddressFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RemoveIPAddressFilter))
		soap_serialize__tds__RemoveIPAddressFilter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, int id, struct _tds__RemoveIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RemoveIPAddressFilter);
	if (id < 0)
		return soap->error;
	return soap_out__tds__RemoveIPAddressFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, const char *tag, struct _tds__RemoveIPAddressFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__RemoveIPAddressFilter **)soap_malloc(soap, sizeof(struct _tds__RemoveIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__RemoveIPAddressFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__RemoveIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveIPAddressFilter, sizeof(struct _tds__RemoveIPAddressFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, struct _tds__RemoveIPAddressFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RemoveIPAddressFilter);
	if (soap_out_PointerTo_tds__RemoveIPAddressFilter(soap, tag?tag:"tds:RemoveIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__RemoveIPAddressFilter(struct soap *soap, struct _tds__RemoveIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RemoveIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, struct _tds__AddIPAddressFilterResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__AddIPAddressFilterResponse))
		soap_serialize__tds__AddIPAddressFilterResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, int id, struct _tds__AddIPAddressFilterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__AddIPAddressFilterResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__AddIPAddressFilterResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilterResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__AddIPAddressFilterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__AddIPAddressFilterResponse **)soap_malloc(soap, sizeof(struct _tds__AddIPAddressFilterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__AddIPAddressFilterResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__AddIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddIPAddressFilterResponse, sizeof(struct _tds__AddIPAddressFilterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, struct _tds__AddIPAddressFilterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__AddIPAddressFilterResponse);
	if (soap_out_PointerTo_tds__AddIPAddressFilterResponse(soap, tag?tag:"tds:AddIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilterResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__AddIPAddressFilterResponse(struct soap *soap, struct _tds__AddIPAddressFilterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__AddIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__AddIPAddressFilter(struct soap *soap, struct _tds__AddIPAddressFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__AddIPAddressFilter))
		soap_serialize__tds__AddIPAddressFilter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__AddIPAddressFilter(struct soap *soap, const char *tag, int id, struct _tds__AddIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__AddIPAddressFilter);
	if (id < 0)
		return soap->error;
	return soap_out__tds__AddIPAddressFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__AddIPAddressFilter(struct soap *soap, const char *tag, struct _tds__AddIPAddressFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__AddIPAddressFilter **)soap_malloc(soap, sizeof(struct _tds__AddIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__AddIPAddressFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__AddIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddIPAddressFilter, sizeof(struct _tds__AddIPAddressFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__AddIPAddressFilter(struct soap *soap, struct _tds__AddIPAddressFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__AddIPAddressFilter);
	if (soap_out_PointerTo_tds__AddIPAddressFilter(soap, tag?tag:"tds:AddIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__AddIPAddressFilter(struct soap *soap, struct _tds__AddIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__AddIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, struct _tds__SetIPAddressFilterResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetIPAddressFilterResponse))
		soap_serialize__tds__SetIPAddressFilterResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, struct _tds__SetIPAddressFilterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetIPAddressFilterResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetIPAddressFilterResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilterResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__SetIPAddressFilterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetIPAddressFilterResponse **)soap_malloc(soap, sizeof(struct _tds__SetIPAddressFilterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetIPAddressFilterResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetIPAddressFilterResponse, sizeof(struct _tds__SetIPAddressFilterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, struct _tds__SetIPAddressFilterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetIPAddressFilterResponse);
	if (soap_out_PointerTo_tds__SetIPAddressFilterResponse(soap, tag?tag:"tds:SetIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilterResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetIPAddressFilterResponse(struct soap *soap, struct _tds__SetIPAddressFilterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetIPAddressFilter(struct soap *soap, struct _tds__SetIPAddressFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetIPAddressFilter))
		soap_serialize__tds__SetIPAddressFilter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetIPAddressFilter(struct soap *soap, const char *tag, int id, struct _tds__SetIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetIPAddressFilter);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetIPAddressFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__SetIPAddressFilter(struct soap *soap, const char *tag, struct _tds__SetIPAddressFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetIPAddressFilter **)soap_malloc(soap, sizeof(struct _tds__SetIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetIPAddressFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetIPAddressFilter, sizeof(struct _tds__SetIPAddressFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetIPAddressFilter(struct soap *soap, struct _tds__SetIPAddressFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetIPAddressFilter);
	if (soap_out_PointerTo_tds__SetIPAddressFilter(soap, tag?tag:"tds:SetIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__SetIPAddressFilter(struct soap *soap, struct _tds__SetIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, struct _tds__GetIPAddressFilterResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetIPAddressFilterResponse))
		soap_serialize__tds__GetIPAddressFilterResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, int id, struct _tds__GetIPAddressFilterResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetIPAddressFilterResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetIPAddressFilterResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilterResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, const char *tag, struct _tds__GetIPAddressFilterResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetIPAddressFilterResponse **)soap_malloc(soap, sizeof(struct _tds__GetIPAddressFilterResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetIPAddressFilterResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetIPAddressFilterResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetIPAddressFilterResponse, sizeof(struct _tds__GetIPAddressFilterResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, struct _tds__GetIPAddressFilterResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetIPAddressFilterResponse);
	if (soap_out_PointerTo_tds__GetIPAddressFilterResponse(soap, tag?tag:"tds:GetIPAddressFilterResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilterResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetIPAddressFilterResponse(struct soap *soap, struct _tds__GetIPAddressFilterResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetIPAddressFilterResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetIPAddressFilter(struct soap *soap, struct _tds__GetIPAddressFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetIPAddressFilter))
		soap_serialize__tds__GetIPAddressFilter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetIPAddressFilter(struct soap *soap, const char *tag, int id, struct _tds__GetIPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetIPAddressFilter);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetIPAddressFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilter ** SOAP_FMAC4 soap_in_PointerTo_tds__GetIPAddressFilter(struct soap *soap, const char *tag, struct _tds__GetIPAddressFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetIPAddressFilter **)soap_malloc(soap, sizeof(struct _tds__GetIPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetIPAddressFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetIPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetIPAddressFilter, sizeof(struct _tds__GetIPAddressFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetIPAddressFilter(struct soap *soap, struct _tds__GetIPAddressFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetIPAddressFilter);
	if (soap_out_PointerTo_tds__GetIPAddressFilter(soap, tag?tag:"tds:GetIPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetIPAddressFilter ** SOAP_FMAC4 soap_get_PointerTo_tds__GetIPAddressFilter(struct soap *soap, struct _tds__GetIPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetIPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetZeroConfigurationResponse(struct soap *soap, struct _tds__SetZeroConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetZeroConfigurationResponse))
		soap_serialize__tds__SetZeroConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetZeroConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tds__SetZeroConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetZeroConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetZeroConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetZeroConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetZeroConfigurationResponse(struct soap *soap, const char *tag, struct _tds__SetZeroConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetZeroConfigurationResponse **)soap_malloc(soap, sizeof(struct _tds__SetZeroConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetZeroConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetZeroConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetZeroConfigurationResponse, sizeof(struct _tds__SetZeroConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetZeroConfigurationResponse(struct soap *soap, struct _tds__SetZeroConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetZeroConfigurationResponse);
	if (soap_out_PointerTo_tds__SetZeroConfigurationResponse(soap, tag?tag:"tds:SetZeroConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetZeroConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetZeroConfigurationResponse(struct soap *soap, struct _tds__SetZeroConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetZeroConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetZeroConfiguration(struct soap *soap, struct _tds__SetZeroConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetZeroConfiguration))
		soap_serialize__tds__SetZeroConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetZeroConfiguration(struct soap *soap, const char *tag, int id, struct _tds__SetZeroConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetZeroConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetZeroConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetZeroConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__SetZeroConfiguration(struct soap *soap, const char *tag, struct _tds__SetZeroConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetZeroConfiguration **)soap_malloc(soap, sizeof(struct _tds__SetZeroConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetZeroConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetZeroConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetZeroConfiguration, sizeof(struct _tds__SetZeroConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetZeroConfiguration(struct soap *soap, struct _tds__SetZeroConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetZeroConfiguration);
	if (soap_out_PointerTo_tds__SetZeroConfiguration(soap, tag?tag:"tds:SetZeroConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetZeroConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__SetZeroConfiguration(struct soap *soap, struct _tds__SetZeroConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetZeroConfigurationResponse(struct soap *soap, struct _tds__GetZeroConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetZeroConfigurationResponse))
		soap_serialize__tds__GetZeroConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetZeroConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tds__GetZeroConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetZeroConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetZeroConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetZeroConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetZeroConfigurationResponse(struct soap *soap, const char *tag, struct _tds__GetZeroConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetZeroConfigurationResponse **)soap_malloc(soap, sizeof(struct _tds__GetZeroConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetZeroConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetZeroConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetZeroConfigurationResponse, sizeof(struct _tds__GetZeroConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetZeroConfigurationResponse(struct soap *soap, struct _tds__GetZeroConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetZeroConfigurationResponse);
	if (soap_out_PointerTo_tds__GetZeroConfigurationResponse(soap, tag?tag:"tds:GetZeroConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetZeroConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetZeroConfigurationResponse(struct soap *soap, struct _tds__GetZeroConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetZeroConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetZeroConfiguration(struct soap *soap, struct _tds__GetZeroConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetZeroConfiguration))
		soap_serialize__tds__GetZeroConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetZeroConfiguration(struct soap *soap, const char *tag, int id, struct _tds__GetZeroConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetZeroConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetZeroConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetZeroConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tds__GetZeroConfiguration(struct soap *soap, const char *tag, struct _tds__GetZeroConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetZeroConfiguration **)soap_malloc(soap, sizeof(struct _tds__GetZeroConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetZeroConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetZeroConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetZeroConfiguration, sizeof(struct _tds__GetZeroConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetZeroConfiguration(struct soap *soap, struct _tds__GetZeroConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetZeroConfiguration);
	if (soap_out_PointerTo_tds__GetZeroConfiguration(soap, tag?tag:"tds:GetZeroConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetZeroConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tds__GetZeroConfiguration(struct soap *soap, struct _tds__GetZeroConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetZeroConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__SetNetworkDefaultGatewayResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse))
		soap_serialize__tds__SetNetworkDefaultGatewayResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, struct _tds__SetNetworkDefaultGatewayResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNetworkDefaultGatewayResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGatewayResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkDefaultGatewayResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetNetworkDefaultGatewayResponse **)soap_malloc(soap, sizeof(struct _tds__SetNetworkDefaultGatewayResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetNetworkDefaultGatewayResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkDefaultGatewayResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkDefaultGatewayResponse, sizeof(struct _tds__SetNetworkDefaultGatewayResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__SetNetworkDefaultGatewayResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkDefaultGatewayResponse);
	if (soap_out_PointerTo_tds__SetNetworkDefaultGatewayResponse(soap, tag?tag:"tds:SetNetworkDefaultGatewayResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGatewayResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__SetNetworkDefaultGatewayResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, struct _tds__SetNetworkDefaultGateway *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkDefaultGateway))
		soap_serialize__tds__SetNetworkDefaultGateway(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, struct _tds__SetNetworkDefaultGateway *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkDefaultGateway);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNetworkDefaultGateway(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGateway ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, const char *tag, struct _tds__SetNetworkDefaultGateway **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetNetworkDefaultGateway **)soap_malloc(soap, sizeof(struct _tds__SetNetworkDefaultGateway *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetNetworkDefaultGateway(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkDefaultGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkDefaultGateway, sizeof(struct _tds__SetNetworkDefaultGateway), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, struct _tds__SetNetworkDefaultGateway *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkDefaultGateway);
	if (soap_out_PointerTo_tds__SetNetworkDefaultGateway(soap, tag?tag:"tds:SetNetworkDefaultGateway", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkDefaultGateway ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkDefaultGateway(struct soap *soap, struct _tds__SetNetworkDefaultGateway **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__GetNetworkDefaultGatewayResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse))
		soap_serialize__tds__GetNetworkDefaultGatewayResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, int id, struct _tds__GetNetworkDefaultGatewayResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNetworkDefaultGatewayResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGatewayResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkDefaultGatewayResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetNetworkDefaultGatewayResponse **)soap_malloc(soap, sizeof(struct _tds__GetNetworkDefaultGatewayResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetNetworkDefaultGatewayResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkDefaultGatewayResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkDefaultGatewayResponse, sizeof(struct _tds__GetNetworkDefaultGatewayResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__GetNetworkDefaultGatewayResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkDefaultGatewayResponse);
	if (soap_out_PointerTo_tds__GetNetworkDefaultGatewayResponse(soap, tag?tag:"tds:GetNetworkDefaultGatewayResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGatewayResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkDefaultGatewayResponse(struct soap *soap, struct _tds__GetNetworkDefaultGatewayResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkDefaultGatewayResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, struct _tds__GetNetworkDefaultGateway *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkDefaultGateway))
		soap_serialize__tds__GetNetworkDefaultGateway(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, int id, struct _tds__GetNetworkDefaultGateway *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkDefaultGateway);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNetworkDefaultGateway(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGateway ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, const char *tag, struct _tds__GetNetworkDefaultGateway **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetNetworkDefaultGateway **)soap_malloc(soap, sizeof(struct _tds__GetNetworkDefaultGateway *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetNetworkDefaultGateway(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkDefaultGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkDefaultGateway, sizeof(struct _tds__GetNetworkDefaultGateway), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, struct _tds__GetNetworkDefaultGateway *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkDefaultGateway);
	if (soap_out_PointerTo_tds__GetNetworkDefaultGateway(soap, tag?tag:"tds:GetNetworkDefaultGateway", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkDefaultGateway ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkDefaultGateway(struct soap *soap, struct _tds__GetNetworkDefaultGateway **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkDefaultGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, struct _tds__SetNetworkProtocolsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkProtocolsResponse))
		soap_serialize__tds__SetNetworkProtocolsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, struct _tds__SetNetworkProtocolsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkProtocolsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNetworkProtocolsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocolsResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkProtocolsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetNetworkProtocolsResponse **)soap_malloc(soap, sizeof(struct _tds__SetNetworkProtocolsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetNetworkProtocolsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkProtocolsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkProtocolsResponse, sizeof(struct _tds__SetNetworkProtocolsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, struct _tds__SetNetworkProtocolsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkProtocolsResponse);
	if (soap_out_PointerTo_tds__SetNetworkProtocolsResponse(soap, tag?tag:"tds:SetNetworkProtocolsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocolsResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkProtocolsResponse(struct soap *soap, struct _tds__SetNetworkProtocolsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkProtocols(struct soap *soap, struct _tds__SetNetworkProtocols *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkProtocols))
		soap_serialize__tds__SetNetworkProtocols(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkProtocols(struct soap *soap, const char *tag, int id, struct _tds__SetNetworkProtocols *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkProtocols);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNetworkProtocols(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocols ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkProtocols(struct soap *soap, const char *tag, struct _tds__SetNetworkProtocols **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetNetworkProtocols **)soap_malloc(soap, sizeof(struct _tds__SetNetworkProtocols *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetNetworkProtocols(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkProtocols **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkProtocols, sizeof(struct _tds__SetNetworkProtocols), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkProtocols(struct soap *soap, struct _tds__SetNetworkProtocols *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkProtocols);
	if (soap_out_PointerTo_tds__SetNetworkProtocols(soap, tag?tag:"tds:SetNetworkProtocols", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkProtocols ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkProtocols(struct soap *soap, struct _tds__SetNetworkProtocols **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, struct _tds__GetNetworkProtocolsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkProtocolsResponse))
		soap_serialize__tds__GetNetworkProtocolsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, int id, struct _tds__GetNetworkProtocolsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkProtocolsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNetworkProtocolsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocolsResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkProtocolsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetNetworkProtocolsResponse **)soap_malloc(soap, sizeof(struct _tds__GetNetworkProtocolsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetNetworkProtocolsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkProtocolsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkProtocolsResponse, sizeof(struct _tds__GetNetworkProtocolsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, struct _tds__GetNetworkProtocolsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkProtocolsResponse);
	if (soap_out_PointerTo_tds__GetNetworkProtocolsResponse(soap, tag?tag:"tds:GetNetworkProtocolsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocolsResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkProtocolsResponse(struct soap *soap, struct _tds__GetNetworkProtocolsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkProtocolsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkProtocols(struct soap *soap, struct _tds__GetNetworkProtocols *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkProtocols))
		soap_serialize__tds__GetNetworkProtocols(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkProtocols(struct soap *soap, const char *tag, int id, struct _tds__GetNetworkProtocols *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkProtocols);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNetworkProtocols(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocols ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkProtocols(struct soap *soap, const char *tag, struct _tds__GetNetworkProtocols **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetNetworkProtocols **)soap_malloc(soap, sizeof(struct _tds__GetNetworkProtocols *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetNetworkProtocols(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkProtocols **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkProtocols, sizeof(struct _tds__GetNetworkProtocols), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkProtocols(struct soap *soap, struct _tds__GetNetworkProtocols *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkProtocols);
	if (soap_out_PointerTo_tds__GetNetworkProtocols(soap, tag?tag:"tds:GetNetworkProtocols", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkProtocols ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkProtocols(struct soap *soap, struct _tds__GetNetworkProtocols **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkProtocols(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, struct _tds__SetNetworkInterfacesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkInterfacesResponse))
		soap_serialize__tds__SetNetworkInterfacesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, struct _tds__SetNetworkInterfacesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkInterfacesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNetworkInterfacesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfacesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, const char *tag, struct _tds__SetNetworkInterfacesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetNetworkInterfacesResponse **)soap_malloc(soap, sizeof(struct _tds__SetNetworkInterfacesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetNetworkInterfacesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkInterfacesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkInterfacesResponse, sizeof(struct _tds__SetNetworkInterfacesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, struct _tds__SetNetworkInterfacesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkInterfacesResponse);
	if (soap_out_PointerTo_tds__SetNetworkInterfacesResponse(soap, tag?tag:"tds:SetNetworkInterfacesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfacesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkInterfacesResponse(struct soap *soap, struct _tds__SetNetworkInterfacesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, struct _tds__SetNetworkInterfaces *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNetworkInterfaces))
		soap_serialize__tds__SetNetworkInterfaces(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, const char *tag, int id, struct _tds__SetNetworkInterfaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNetworkInterfaces);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNetworkInterfaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfaces ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, const char *tag, struct _tds__SetNetworkInterfaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetNetworkInterfaces **)soap_malloc(soap, sizeof(struct _tds__SetNetworkInterfaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetNetworkInterfaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNetworkInterfaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNetworkInterfaces, sizeof(struct _tds__SetNetworkInterfaces), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, struct _tds__SetNetworkInterfaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNetworkInterfaces);
	if (soap_out_PointerTo_tds__SetNetworkInterfaces(soap, tag?tag:"tds:SetNetworkInterfaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNetworkInterfaces ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNetworkInterfaces(struct soap *soap, struct _tds__SetNetworkInterfaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, struct _tds__GetNetworkInterfacesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkInterfacesResponse))
		soap_serialize__tds__GetNetworkInterfacesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetNetworkInterfacesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkInterfacesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNetworkInterfacesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfacesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, const char *tag, struct _tds__GetNetworkInterfacesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetNetworkInterfacesResponse **)soap_malloc(soap, sizeof(struct _tds__GetNetworkInterfacesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetNetworkInterfacesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkInterfacesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkInterfacesResponse, sizeof(struct _tds__GetNetworkInterfacesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, struct _tds__GetNetworkInterfacesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkInterfacesResponse);
	if (soap_out_PointerTo_tds__GetNetworkInterfacesResponse(soap, tag?tag:"tds:GetNetworkInterfacesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfacesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkInterfacesResponse(struct soap *soap, struct _tds__GetNetworkInterfacesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkInterfacesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, struct _tds__GetNetworkInterfaces *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNetworkInterfaces))
		soap_serialize__tds__GetNetworkInterfaces(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, const char *tag, int id, struct _tds__GetNetworkInterfaces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNetworkInterfaces);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNetworkInterfaces(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfaces ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, const char *tag, struct _tds__GetNetworkInterfaces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetNetworkInterfaces **)soap_malloc(soap, sizeof(struct _tds__GetNetworkInterfaces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetNetworkInterfaces(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNetworkInterfaces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNetworkInterfaces, sizeof(struct _tds__GetNetworkInterfaces), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, struct _tds__GetNetworkInterfaces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNetworkInterfaces);
	if (soap_out_PointerTo_tds__GetNetworkInterfaces(soap, tag?tag:"tds:GetNetworkInterfaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNetworkInterfaces ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNetworkInterfaces(struct soap *soap, struct _tds__GetNetworkInterfaces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNetworkInterfaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, struct _tds__SetDynamicDNSResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDynamicDNSResponse))
		soap_serialize__tds__SetDynamicDNSResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, int id, struct _tds__SetDynamicDNSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDynamicDNSResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDynamicDNSResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDynamicDNSResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, const char *tag, struct _tds__SetDynamicDNSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDynamicDNSResponse **)soap_malloc(soap, sizeof(struct _tds__SetDynamicDNSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDynamicDNSResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDynamicDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDynamicDNSResponse, sizeof(struct _tds__SetDynamicDNSResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, struct _tds__SetDynamicDNSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDynamicDNSResponse);
	if (soap_out_PointerTo_tds__SetDynamicDNSResponse(soap, tag?tag:"tds:SetDynamicDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDynamicDNSResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDynamicDNSResponse(struct soap *soap, struct _tds__SetDynamicDNSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDynamicDNS(struct soap *soap, struct _tds__SetDynamicDNS *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDynamicDNS))
		soap_serialize__tds__SetDynamicDNS(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDynamicDNS(struct soap *soap, const char *tag, int id, struct _tds__SetDynamicDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDynamicDNS);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDynamicDNS(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDynamicDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDynamicDNS(struct soap *soap, const char *tag, struct _tds__SetDynamicDNS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDynamicDNS **)soap_malloc(soap, sizeof(struct _tds__SetDynamicDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDynamicDNS(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDynamicDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDynamicDNS, sizeof(struct _tds__SetDynamicDNS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDynamicDNS(struct soap *soap, struct _tds__SetDynamicDNS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDynamicDNS);
	if (soap_out_PointerTo_tds__SetDynamicDNS(soap, tag?tag:"tds:SetDynamicDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDynamicDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDynamicDNS(struct soap *soap, struct _tds__SetDynamicDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, struct _tds__GetDynamicDNSResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDynamicDNSResponse))
		soap_serialize__tds__GetDynamicDNSResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDynamicDNSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDynamicDNSResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDynamicDNSResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDynamicDNSResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, const char *tag, struct _tds__GetDynamicDNSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDynamicDNSResponse **)soap_malloc(soap, sizeof(struct _tds__GetDynamicDNSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDynamicDNSResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDynamicDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDynamicDNSResponse, sizeof(struct _tds__GetDynamicDNSResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, struct _tds__GetDynamicDNSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDynamicDNSResponse);
	if (soap_out_PointerTo_tds__GetDynamicDNSResponse(soap, tag?tag:"tds:GetDynamicDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDynamicDNSResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDynamicDNSResponse(struct soap *soap, struct _tds__GetDynamicDNSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDynamicDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDynamicDNS(struct soap *soap, struct _tds__GetDynamicDNS *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDynamicDNS))
		soap_serialize__tds__GetDynamicDNS(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDynamicDNS(struct soap *soap, const char *tag, int id, struct _tds__GetDynamicDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDynamicDNS);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDynamicDNS(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDynamicDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDynamicDNS(struct soap *soap, const char *tag, struct _tds__GetDynamicDNS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDynamicDNS **)soap_malloc(soap, sizeof(struct _tds__GetDynamicDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDynamicDNS(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDynamicDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDynamicDNS, sizeof(struct _tds__GetDynamicDNS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDynamicDNS(struct soap *soap, struct _tds__GetDynamicDNS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDynamicDNS);
	if (soap_out_PointerTo_tds__GetDynamicDNS(soap, tag?tag:"tds:GetDynamicDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDynamicDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDynamicDNS(struct soap *soap, struct _tds__GetDynamicDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDynamicDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNTPResponse(struct soap *soap, struct _tds__SetNTPResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNTPResponse))
		soap_serialize__tds__SetNTPResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNTPResponse(struct soap *soap, const char *tag, int id, struct _tds__SetNTPResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNTPResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNTPResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNTPResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNTPResponse(struct soap *soap, const char *tag, struct _tds__SetNTPResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetNTPResponse **)soap_malloc(soap, sizeof(struct _tds__SetNTPResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetNTPResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNTPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNTPResponse, sizeof(struct _tds__SetNTPResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNTPResponse(struct soap *soap, struct _tds__SetNTPResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNTPResponse);
	if (soap_out_PointerTo_tds__SetNTPResponse(soap, tag?tag:"tds:SetNTPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNTPResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNTPResponse(struct soap *soap, struct _tds__SetNTPResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetNTP(struct soap *soap, struct _tds__SetNTP *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetNTP))
		soap_serialize__tds__SetNTP(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetNTP(struct soap *soap, const char *tag, int id, struct _tds__SetNTP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetNTP);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetNTP(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetNTP ** SOAP_FMAC4 soap_in_PointerTo_tds__SetNTP(struct soap *soap, const char *tag, struct _tds__SetNTP **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetNTP **)soap_malloc(soap, sizeof(struct _tds__SetNTP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetNTP(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetNTP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetNTP, sizeof(struct _tds__SetNTP), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetNTP(struct soap *soap, struct _tds__SetNTP *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetNTP);
	if (soap_out_PointerTo_tds__SetNTP(soap, tag?tag:"tds:SetNTP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetNTP ** SOAP_FMAC4 soap_get_PointerTo_tds__SetNTP(struct soap *soap, struct _tds__SetNTP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNTPResponse(struct soap *soap, struct _tds__GetNTPResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNTPResponse))
		soap_serialize__tds__GetNTPResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNTPResponse(struct soap *soap, const char *tag, int id, struct _tds__GetNTPResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNTPResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNTPResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNTPResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNTPResponse(struct soap *soap, const char *tag, struct _tds__GetNTPResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetNTPResponse **)soap_malloc(soap, sizeof(struct _tds__GetNTPResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetNTPResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNTPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNTPResponse, sizeof(struct _tds__GetNTPResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNTPResponse(struct soap *soap, struct _tds__GetNTPResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNTPResponse);
	if (soap_out_PointerTo_tds__GetNTPResponse(soap, tag?tag:"tds:GetNTPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNTPResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNTPResponse(struct soap *soap, struct _tds__GetNTPResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNTPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetNTP(struct soap *soap, struct _tds__GetNTP *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetNTP))
		soap_serialize__tds__GetNTP(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetNTP(struct soap *soap, const char *tag, int id, struct _tds__GetNTP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetNTP);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetNTP(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetNTP ** SOAP_FMAC4 soap_in_PointerTo_tds__GetNTP(struct soap *soap, const char *tag, struct _tds__GetNTP **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetNTP **)soap_malloc(soap, sizeof(struct _tds__GetNTP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetNTP(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetNTP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetNTP, sizeof(struct _tds__GetNTP), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetNTP(struct soap *soap, struct _tds__GetNTP *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetNTP);
	if (soap_out_PointerTo_tds__GetNTP(soap, tag?tag:"tds:GetNTP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetNTP ** SOAP_FMAC4 soap_get_PointerTo_tds__GetNTP(struct soap *soap, struct _tds__GetNTP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetNTP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDNSResponse(struct soap *soap, struct _tds__SetDNSResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDNSResponse))
		soap_serialize__tds__SetDNSResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDNSResponse(struct soap *soap, const char *tag, int id, struct _tds__SetDNSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDNSResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDNSResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDNSResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDNSResponse(struct soap *soap, const char *tag, struct _tds__SetDNSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDNSResponse **)soap_malloc(soap, sizeof(struct _tds__SetDNSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDNSResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDNSResponse, sizeof(struct _tds__SetDNSResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDNSResponse(struct soap *soap, struct _tds__SetDNSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDNSResponse);
	if (soap_out_PointerTo_tds__SetDNSResponse(soap, tag?tag:"tds:SetDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDNSResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDNSResponse(struct soap *soap, struct _tds__SetDNSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDNS(struct soap *soap, struct _tds__SetDNS *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDNS))
		soap_serialize__tds__SetDNS(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDNS(struct soap *soap, const char *tag, int id, struct _tds__SetDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDNS);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDNS(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDNS(struct soap *soap, const char *tag, struct _tds__SetDNS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDNS **)soap_malloc(soap, sizeof(struct _tds__SetDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDNS(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDNS, sizeof(struct _tds__SetDNS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDNS(struct soap *soap, struct _tds__SetDNS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDNS);
	if (soap_out_PointerTo_tds__SetDNS(soap, tag?tag:"tds:SetDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDNS(struct soap *soap, struct _tds__SetDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDNSResponse(struct soap *soap, struct _tds__GetDNSResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDNSResponse))
		soap_serialize__tds__GetDNSResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDNSResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDNSResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDNSResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDNSResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDNSResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDNSResponse(struct soap *soap, const char *tag, struct _tds__GetDNSResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDNSResponse **)soap_malloc(soap, sizeof(struct _tds__GetDNSResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDNSResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDNSResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDNSResponse, sizeof(struct _tds__GetDNSResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDNSResponse(struct soap *soap, struct _tds__GetDNSResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDNSResponse);
	if (soap_out_PointerTo_tds__GetDNSResponse(soap, tag?tag:"tds:GetDNSResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDNSResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDNSResponse(struct soap *soap, struct _tds__GetDNSResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDNSResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDNS(struct soap *soap, struct _tds__GetDNS *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDNS))
		soap_serialize__tds__GetDNS(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDNS(struct soap *soap, const char *tag, int id, struct _tds__GetDNS *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDNS);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDNS(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDNS ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDNS(struct soap *soap, const char *tag, struct _tds__GetDNS **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDNS **)soap_malloc(soap, sizeof(struct _tds__GetDNS *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDNS(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDNS **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDNS, sizeof(struct _tds__GetDNS), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDNS(struct soap *soap, struct _tds__GetDNS *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDNS);
	if (soap_out_PointerTo_tds__GetDNS(soap, tag?tag:"tds:GetDNS", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDNS ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDNS(struct soap *soap, struct _tds__GetDNS **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDNS(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, struct _tds__SetHostnameFromDHCPResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse))
		soap_serialize__tds__SetHostnameFromDHCPResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, int id, struct _tds__SetHostnameFromDHCPResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostnameFromDHCPResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetHostnameFromDHCPResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCPResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, const char *tag, struct _tds__SetHostnameFromDHCPResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetHostnameFromDHCPResponse **)soap_malloc(soap, sizeof(struct _tds__SetHostnameFromDHCPResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetHostnameFromDHCPResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetHostnameFromDHCPResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostnameFromDHCPResponse, sizeof(struct _tds__SetHostnameFromDHCPResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, struct _tds__SetHostnameFromDHCPResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetHostnameFromDHCPResponse);
	if (soap_out_PointerTo_tds__SetHostnameFromDHCPResponse(soap, tag?tag:"tds:SetHostnameFromDHCPResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCPResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostnameFromDHCPResponse(struct soap *soap, struct _tds__SetHostnameFromDHCPResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostnameFromDHCPResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, struct _tds__SetHostnameFromDHCP *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostnameFromDHCP))
		soap_serialize__tds__SetHostnameFromDHCP(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, int id, struct _tds__SetHostnameFromDHCP *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostnameFromDHCP);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetHostnameFromDHCP(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCP ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, const char *tag, struct _tds__SetHostnameFromDHCP **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetHostnameFromDHCP **)soap_malloc(soap, sizeof(struct _tds__SetHostnameFromDHCP *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetHostnameFromDHCP(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetHostnameFromDHCP **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostnameFromDHCP, sizeof(struct _tds__SetHostnameFromDHCP), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, struct _tds__SetHostnameFromDHCP *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetHostnameFromDHCP);
	if (soap_out_PointerTo_tds__SetHostnameFromDHCP(soap, tag?tag:"tds:SetHostnameFromDHCP", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameFromDHCP ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostnameFromDHCP(struct soap *soap, struct _tds__SetHostnameFromDHCP **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostnameFromDHCP(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostnameResponse(struct soap *soap, struct _tds__SetHostnameResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostnameResponse))
		soap_serialize__tds__SetHostnameResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostnameResponse(struct soap *soap, const char *tag, int id, struct _tds__SetHostnameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostnameResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetHostnameResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetHostnameResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostnameResponse(struct soap *soap, const char *tag, struct _tds__SetHostnameResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetHostnameResponse **)soap_malloc(soap, sizeof(struct _tds__SetHostnameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetHostnameResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetHostnameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostnameResponse, sizeof(struct _tds__SetHostnameResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostnameResponse(struct soap *soap, struct _tds__SetHostnameResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetHostnameResponse);
	if (soap_out_PointerTo_tds__SetHostnameResponse(soap, tag?tag:"tds:SetHostnameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostnameResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostnameResponse(struct soap *soap, struct _tds__SetHostnameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetHostname(struct soap *soap, struct _tds__SetHostname *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetHostname))
		soap_serialize__tds__SetHostname(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetHostname(struct soap *soap, const char *tag, int id, struct _tds__SetHostname *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetHostname);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetHostname(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetHostname ** SOAP_FMAC4 soap_in_PointerTo_tds__SetHostname(struct soap *soap, const char *tag, struct _tds__SetHostname **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetHostname **)soap_malloc(soap, sizeof(struct _tds__SetHostname *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetHostname(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetHostname **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetHostname, sizeof(struct _tds__SetHostname), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetHostname(struct soap *soap, struct _tds__SetHostname *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetHostname);
	if (soap_out_PointerTo_tds__SetHostname(soap, tag?tag:"tds:SetHostname", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetHostname ** SOAP_FMAC4 soap_get_PointerTo_tds__SetHostname(struct soap *soap, struct _tds__SetHostname **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetHostnameResponse(struct soap *soap, struct _tds__GetHostnameResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetHostnameResponse))
		soap_serialize__tds__GetHostnameResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetHostnameResponse(struct soap *soap, const char *tag, int id, struct _tds__GetHostnameResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetHostnameResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetHostnameResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetHostnameResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetHostnameResponse(struct soap *soap, const char *tag, struct _tds__GetHostnameResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetHostnameResponse **)soap_malloc(soap, sizeof(struct _tds__GetHostnameResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetHostnameResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetHostnameResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetHostnameResponse, sizeof(struct _tds__GetHostnameResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetHostnameResponse(struct soap *soap, struct _tds__GetHostnameResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetHostnameResponse);
	if (soap_out_PointerTo_tds__GetHostnameResponse(soap, tag?tag:"tds:GetHostnameResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetHostnameResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetHostnameResponse(struct soap *soap, struct _tds__GetHostnameResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetHostnameResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetHostname(struct soap *soap, struct _tds__GetHostname *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetHostname))
		soap_serialize__tds__GetHostname(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetHostname(struct soap *soap, const char *tag, int id, struct _tds__GetHostname *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetHostname);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetHostname(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetHostname ** SOAP_FMAC4 soap_in_PointerTo_tds__GetHostname(struct soap *soap, const char *tag, struct _tds__GetHostname **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetHostname **)soap_malloc(soap, sizeof(struct _tds__GetHostname *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetHostname(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetHostname **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetHostname, sizeof(struct _tds__GetHostname), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetHostname(struct soap *soap, struct _tds__GetHostname *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetHostname);
	if (soap_out_PointerTo_tds__GetHostname(soap, tag?tag:"tds:GetHostname", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetHostname ** SOAP_FMAC4 soap_get_PointerTo_tds__GetHostname(struct soap *soap, struct _tds__GetHostname **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetHostname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDPAddressesResponse(struct soap *soap, struct _tds__SetDPAddressesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDPAddressesResponse))
		soap_serialize__tds__SetDPAddressesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDPAddressesResponse(struct soap *soap, const char *tag, int id, struct _tds__SetDPAddressesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDPAddressesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDPAddressesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDPAddressesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDPAddressesResponse(struct soap *soap, const char *tag, struct _tds__SetDPAddressesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDPAddressesResponse **)soap_malloc(soap, sizeof(struct _tds__SetDPAddressesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDPAddressesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDPAddressesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDPAddressesResponse, sizeof(struct _tds__SetDPAddressesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDPAddressesResponse(struct soap *soap, struct _tds__SetDPAddressesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDPAddressesResponse);
	if (soap_out_PointerTo_tds__SetDPAddressesResponse(soap, tag?tag:"tds:SetDPAddressesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDPAddressesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDPAddressesResponse(struct soap *soap, struct _tds__SetDPAddressesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDPAddressesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDPAddresses(struct soap *soap, struct _tds__SetDPAddresses *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDPAddresses))
		soap_serialize__tds__SetDPAddresses(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDPAddresses(struct soap *soap, const char *tag, int id, struct _tds__SetDPAddresses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDPAddresses);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDPAddresses(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDPAddresses ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDPAddresses(struct soap *soap, const char *tag, struct _tds__SetDPAddresses **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDPAddresses **)soap_malloc(soap, sizeof(struct _tds__SetDPAddresses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDPAddresses(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDPAddresses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDPAddresses, sizeof(struct _tds__SetDPAddresses), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDPAddresses(struct soap *soap, struct _tds__SetDPAddresses *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDPAddresses);
	if (soap_out_PointerTo_tds__SetDPAddresses(soap, tag?tag:"tds:SetDPAddresses", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDPAddresses ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDPAddresses(struct soap *soap, struct _tds__SetDPAddresses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCapabilitiesResponse))
		soap_serialize__tds__GetCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tds__GetCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCapabilitiesResponse, sizeof(struct _tds__GetCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCapabilitiesResponse);
	if (soap_out_PointerTo_tds__GetCapabilitiesResponse(soap, tag?tag:"tds:GetCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCapabilitiesResponse(struct soap *soap, struct _tds__GetCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetCapabilities))
		soap_serialize__tds__GetCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetCapabilities(struct soap *soap, const char *tag, int id, struct _tds__GetCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetCapabilities(struct soap *soap, const char *tag, struct _tds__GetCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetCapabilities **)soap_malloc(soap, sizeof(struct _tds__GetCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetCapabilities, sizeof(struct _tds__GetCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetCapabilities);
	if (soap_out_PointerTo_tds__GetCapabilities(soap, tag?tag:"tds:GetCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetCapabilities(struct soap *soap, struct _tds__GetCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetWsdlUrlResponse(struct soap *soap, struct _tds__GetWsdlUrlResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetWsdlUrlResponse))
		soap_serialize__tds__GetWsdlUrlResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, int id, struct _tds__GetWsdlUrlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetWsdlUrlResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetWsdlUrlResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetWsdlUrlResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetWsdlUrlResponse(struct soap *soap, const char *tag, struct _tds__GetWsdlUrlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetWsdlUrlResponse **)soap_malloc(soap, sizeof(struct _tds__GetWsdlUrlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetWsdlUrlResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetWsdlUrlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetWsdlUrlResponse, sizeof(struct _tds__GetWsdlUrlResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetWsdlUrlResponse(struct soap *soap, struct _tds__GetWsdlUrlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetWsdlUrlResponse);
	if (soap_out_PointerTo_tds__GetWsdlUrlResponse(soap, tag?tag:"tds:GetWsdlUrlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetWsdlUrlResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetWsdlUrlResponse(struct soap *soap, struct _tds__GetWsdlUrlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetWsdlUrlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetWsdlUrl(struct soap *soap, struct _tds__GetWsdlUrl *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetWsdlUrl))
		soap_serialize__tds__GetWsdlUrl(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetWsdlUrl(struct soap *soap, const char *tag, int id, struct _tds__GetWsdlUrl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetWsdlUrl);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetWsdlUrl(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetWsdlUrl ** SOAP_FMAC4 soap_in_PointerTo_tds__GetWsdlUrl(struct soap *soap, const char *tag, struct _tds__GetWsdlUrl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetWsdlUrl **)soap_malloc(soap, sizeof(struct _tds__GetWsdlUrl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetWsdlUrl(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetWsdlUrl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetWsdlUrl, sizeof(struct _tds__GetWsdlUrl), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetWsdlUrl(struct soap *soap, struct _tds__GetWsdlUrl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetWsdlUrl);
	if (soap_out_PointerTo_tds__GetWsdlUrl(soap, tag?tag:"tds:GetWsdlUrl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetWsdlUrl ** SOAP_FMAC4 soap_get_PointerTo_tds__GetWsdlUrl(struct soap *soap, struct _tds__GetWsdlUrl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetWsdlUrl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetUserResponse(struct soap *soap, struct _tds__SetUserResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetUserResponse))
		soap_serialize__tds__SetUserResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetUserResponse(struct soap *soap, const char *tag, int id, struct _tds__SetUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetUserResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetUserResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetUserResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetUserResponse(struct soap *soap, const char *tag, struct _tds__SetUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetUserResponse **)soap_malloc(soap, sizeof(struct _tds__SetUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetUserResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetUserResponse, sizeof(struct _tds__SetUserResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetUserResponse(struct soap *soap, struct _tds__SetUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetUserResponse);
	if (soap_out_PointerTo_tds__SetUserResponse(soap, tag?tag:"tds:SetUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetUserResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetUserResponse(struct soap *soap, struct _tds__SetUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetUser(struct soap *soap, struct _tds__SetUser *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetUser))
		soap_serialize__tds__SetUser(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetUser(struct soap *soap, const char *tag, int id, struct _tds__SetUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetUser);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetUser(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetUser ** SOAP_FMAC4 soap_in_PointerTo_tds__SetUser(struct soap *soap, const char *tag, struct _tds__SetUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetUser **)soap_malloc(soap, sizeof(struct _tds__SetUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetUser(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetUser, sizeof(struct _tds__SetUser), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetUser(struct soap *soap, struct _tds__SetUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetUser);
	if (soap_out_PointerTo_tds__SetUser(soap, tag?tag:"tds:SetUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetUser ** SOAP_FMAC4 soap_get_PointerTo_tds__SetUser(struct soap *soap, struct _tds__SetUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteUsersResponse(struct soap *soap, struct _tds__DeleteUsersResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteUsersResponse))
		soap_serialize__tds__DeleteUsersResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteUsersResponse(struct soap *soap, const char *tag, int id, struct _tds__DeleteUsersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteUsersResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__DeleteUsersResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__DeleteUsersResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteUsersResponse(struct soap *soap, const char *tag, struct _tds__DeleteUsersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__DeleteUsersResponse **)soap_malloc(soap, sizeof(struct _tds__DeleteUsersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__DeleteUsersResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteUsersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteUsersResponse, sizeof(struct _tds__DeleteUsersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteUsersResponse(struct soap *soap, struct _tds__DeleteUsersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteUsersResponse);
	if (soap_out_PointerTo_tds__DeleteUsersResponse(soap, tag?tag:"tds:DeleteUsersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteUsersResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteUsersResponse(struct soap *soap, struct _tds__DeleteUsersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__DeleteUsers(struct soap *soap, struct _tds__DeleteUsers *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__DeleteUsers))
		soap_serialize__tds__DeleteUsers(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__DeleteUsers(struct soap *soap, const char *tag, int id, struct _tds__DeleteUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__DeleteUsers);
	if (id < 0)
		return soap->error;
	return soap_out__tds__DeleteUsers(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__DeleteUsers ** SOAP_FMAC4 soap_in_PointerTo_tds__DeleteUsers(struct soap *soap, const char *tag, struct _tds__DeleteUsers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__DeleteUsers **)soap_malloc(soap, sizeof(struct _tds__DeleteUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__DeleteUsers(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__DeleteUsers, sizeof(struct _tds__DeleteUsers), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__DeleteUsers(struct soap *soap, struct _tds__DeleteUsers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__DeleteUsers);
	if (soap_out_PointerTo_tds__DeleteUsers(soap, tag?tag:"tds:DeleteUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteUsers ** SOAP_FMAC4 soap_get_PointerTo_tds__DeleteUsers(struct soap *soap, struct _tds__DeleteUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__DeleteUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateUsersResponse(struct soap *soap, struct _tds__CreateUsersResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateUsersResponse))
		soap_serialize__tds__CreateUsersResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateUsersResponse(struct soap *soap, const char *tag, int id, struct _tds__CreateUsersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateUsersResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__CreateUsersResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__CreateUsersResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateUsersResponse(struct soap *soap, const char *tag, struct _tds__CreateUsersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__CreateUsersResponse **)soap_malloc(soap, sizeof(struct _tds__CreateUsersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__CreateUsersResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateUsersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateUsersResponse, sizeof(struct _tds__CreateUsersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateUsersResponse(struct soap *soap, struct _tds__CreateUsersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateUsersResponse);
	if (soap_out_PointerTo_tds__CreateUsersResponse(soap, tag?tag:"tds:CreateUsersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateUsersResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateUsersResponse(struct soap *soap, struct _tds__CreateUsersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__CreateUsers(struct soap *soap, struct _tds__CreateUsers *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__CreateUsers))
		soap_serialize__tds__CreateUsers(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__CreateUsers(struct soap *soap, const char *tag, int id, struct _tds__CreateUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__CreateUsers);
	if (id < 0)
		return soap->error;
	return soap_out__tds__CreateUsers(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__CreateUsers ** SOAP_FMAC4 soap_in_PointerTo_tds__CreateUsers(struct soap *soap, const char *tag, struct _tds__CreateUsers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__CreateUsers **)soap_malloc(soap, sizeof(struct _tds__CreateUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__CreateUsers(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__CreateUsers, sizeof(struct _tds__CreateUsers), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__CreateUsers(struct soap *soap, struct _tds__CreateUsers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__CreateUsers);
	if (soap_out_PointerTo_tds__CreateUsers(soap, tag?tag:"tds:CreateUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateUsers ** SOAP_FMAC4 soap_get_PointerTo_tds__CreateUsers(struct soap *soap, struct _tds__CreateUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__CreateUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetUsersResponse(struct soap *soap, struct _tds__GetUsersResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetUsersResponse))
		soap_serialize__tds__GetUsersResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetUsersResponse(struct soap *soap, const char *tag, int id, struct _tds__GetUsersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetUsersResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetUsersResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetUsersResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetUsersResponse(struct soap *soap, const char *tag, struct _tds__GetUsersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetUsersResponse **)soap_malloc(soap, sizeof(struct _tds__GetUsersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetUsersResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetUsersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetUsersResponse, sizeof(struct _tds__GetUsersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetUsersResponse(struct soap *soap, struct _tds__GetUsersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetUsersResponse);
	if (soap_out_PointerTo_tds__GetUsersResponse(soap, tag?tag:"tds:GetUsersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetUsersResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetUsersResponse(struct soap *soap, struct _tds__GetUsersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetUsersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetUsers(struct soap *soap, struct _tds__GetUsers *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetUsers))
		soap_serialize__tds__GetUsers(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetUsers(struct soap *soap, const char *tag, int id, struct _tds__GetUsers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetUsers);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetUsers(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetUsers ** SOAP_FMAC4 soap_in_PointerTo_tds__GetUsers(struct soap *soap, const char *tag, struct _tds__GetUsers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetUsers **)soap_malloc(soap, sizeof(struct _tds__GetUsers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetUsers(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetUsers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetUsers, sizeof(struct _tds__GetUsers), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetUsers(struct soap *soap, struct _tds__GetUsers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetUsers);
	if (soap_out_PointerTo_tds__GetUsers(soap, tag?tag:"tds:GetUsers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetUsers ** SOAP_FMAC4 soap_get_PointerTo_tds__GetUsers(struct soap *soap, struct _tds__GetUsers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetUsers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRemoteUserResponse(struct soap *soap, struct _tds__SetRemoteUserResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRemoteUserResponse))
		soap_serialize__tds__SetRemoteUserResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRemoteUserResponse(struct soap *soap, const char *tag, int id, struct _tds__SetRemoteUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRemoteUserResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetRemoteUserResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRemoteUserResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRemoteUserResponse(struct soap *soap, const char *tag, struct _tds__SetRemoteUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetRemoteUserResponse **)soap_malloc(soap, sizeof(struct _tds__SetRemoteUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetRemoteUserResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteUserResponse, sizeof(struct _tds__SetRemoteUserResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRemoteUserResponse(struct soap *soap, struct _tds__SetRemoteUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRemoteUserResponse);
	if (soap_out_PointerTo_tds__SetRemoteUserResponse(soap, tag?tag:"tds:SetRemoteUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteUserResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRemoteUserResponse(struct soap *soap, struct _tds__SetRemoteUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRemoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRemoteUser(struct soap *soap, struct _tds__SetRemoteUser *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRemoteUser))
		soap_serialize__tds__SetRemoteUser(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRemoteUser(struct soap *soap, const char *tag, int id, struct _tds__SetRemoteUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRemoteUser);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetRemoteUser(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRemoteUser ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRemoteUser(struct soap *soap, const char *tag, struct _tds__SetRemoteUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetRemoteUser **)soap_malloc(soap, sizeof(struct _tds__SetRemoteUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetRemoteUser(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteUser, sizeof(struct _tds__SetRemoteUser), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRemoteUser(struct soap *soap, struct _tds__SetRemoteUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRemoteUser);
	if (soap_out_PointerTo_tds__SetRemoteUser(soap, tag?tag:"tds:SetRemoteUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteUser ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRemoteUser(struct soap *soap, struct _tds__SetRemoteUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRemoteUserResponse(struct soap *soap, struct _tds__GetRemoteUserResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRemoteUserResponse))
		soap_serialize__tds__GetRemoteUserResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRemoteUserResponse(struct soap *soap, const char *tag, int id, struct _tds__GetRemoteUserResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRemoteUserResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetRemoteUserResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetRemoteUserResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRemoteUserResponse(struct soap *soap, const char *tag, struct _tds__GetRemoteUserResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetRemoteUserResponse **)soap_malloc(soap, sizeof(struct _tds__GetRemoteUserResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetRemoteUserResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteUserResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteUserResponse, sizeof(struct _tds__GetRemoteUserResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRemoteUserResponse(struct soap *soap, struct _tds__GetRemoteUserResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRemoteUserResponse);
	if (soap_out_PointerTo_tds__GetRemoteUserResponse(soap, tag?tag:"tds:GetRemoteUserResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteUserResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRemoteUserResponse(struct soap *soap, struct _tds__GetRemoteUserResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRemoteUserResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRemoteUser(struct soap *soap, struct _tds__GetRemoteUser *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRemoteUser))
		soap_serialize__tds__GetRemoteUser(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRemoteUser(struct soap *soap, const char *tag, int id, struct _tds__GetRemoteUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRemoteUser);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetRemoteUser(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetRemoteUser ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRemoteUser(struct soap *soap, const char *tag, struct _tds__GetRemoteUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetRemoteUser **)soap_malloc(soap, sizeof(struct _tds__GetRemoteUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetRemoteUser(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteUser, sizeof(struct _tds__GetRemoteUser), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRemoteUser(struct soap *soap, struct _tds__GetRemoteUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRemoteUser);
	if (soap_out_PointerTo_tds__GetRemoteUser(soap, tag?tag:"tds:GetRemoteUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteUser ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRemoteUser(struct soap *soap, struct _tds__GetRemoteUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetEndpointReferenceResponse(struct soap *soap, struct _tds__GetEndpointReferenceResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetEndpointReferenceResponse))
		soap_serialize__tds__GetEndpointReferenceResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetEndpointReferenceResponse(struct soap *soap, const char *tag, int id, struct _tds__GetEndpointReferenceResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetEndpointReferenceResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetEndpointReferenceResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetEndpointReferenceResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetEndpointReferenceResponse(struct soap *soap, const char *tag, struct _tds__GetEndpointReferenceResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetEndpointReferenceResponse **)soap_malloc(soap, sizeof(struct _tds__GetEndpointReferenceResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetEndpointReferenceResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetEndpointReferenceResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetEndpointReferenceResponse, sizeof(struct _tds__GetEndpointReferenceResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetEndpointReferenceResponse(struct soap *soap, struct _tds__GetEndpointReferenceResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetEndpointReferenceResponse);
	if (soap_out_PointerTo_tds__GetEndpointReferenceResponse(soap, tag?tag:"tds:GetEndpointReferenceResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetEndpointReferenceResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetEndpointReferenceResponse(struct soap *soap, struct _tds__GetEndpointReferenceResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetEndpointReferenceResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetEndpointReference(struct soap *soap, struct _tds__GetEndpointReference *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetEndpointReference))
		soap_serialize__tds__GetEndpointReference(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetEndpointReference(struct soap *soap, const char *tag, int id, struct _tds__GetEndpointReference *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetEndpointReference);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetEndpointReference(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetEndpointReference ** SOAP_FMAC4 soap_in_PointerTo_tds__GetEndpointReference(struct soap *soap, const char *tag, struct _tds__GetEndpointReference **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetEndpointReference **)soap_malloc(soap, sizeof(struct _tds__GetEndpointReference *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetEndpointReference(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetEndpointReference **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetEndpointReference, sizeof(struct _tds__GetEndpointReference), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetEndpointReference(struct soap *soap, struct _tds__GetEndpointReference *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetEndpointReference);
	if (soap_out_PointerTo_tds__GetEndpointReference(soap, tag?tag:"tds:GetEndpointReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetEndpointReference ** SOAP_FMAC4 soap_get_PointerTo_tds__GetEndpointReference(struct soap *soap, struct _tds__GetEndpointReference **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetEndpointReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDPAddressesResponse(struct soap *soap, struct _tds__GetDPAddressesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDPAddressesResponse))
		soap_serialize__tds__GetDPAddressesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDPAddressesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDPAddressesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDPAddressesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDPAddressesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDPAddressesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDPAddressesResponse(struct soap *soap, const char *tag, struct _tds__GetDPAddressesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDPAddressesResponse **)soap_malloc(soap, sizeof(struct _tds__GetDPAddressesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDPAddressesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDPAddressesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDPAddressesResponse, sizeof(struct _tds__GetDPAddressesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDPAddressesResponse(struct soap *soap, struct _tds__GetDPAddressesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDPAddressesResponse);
	if (soap_out_PointerTo_tds__GetDPAddressesResponse(soap, tag?tag:"tds:GetDPAddressesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDPAddressesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDPAddressesResponse(struct soap *soap, struct _tds__GetDPAddressesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDPAddressesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDPAddresses(struct soap *soap, struct _tds__GetDPAddresses *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDPAddresses))
		soap_serialize__tds__GetDPAddresses(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDPAddresses(struct soap *soap, const char *tag, int id, struct _tds__GetDPAddresses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDPAddresses);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDPAddresses(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDPAddresses ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDPAddresses(struct soap *soap, const char *tag, struct _tds__GetDPAddresses **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDPAddresses **)soap_malloc(soap, sizeof(struct _tds__GetDPAddresses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDPAddresses(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDPAddresses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDPAddresses, sizeof(struct _tds__GetDPAddresses), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDPAddresses(struct soap *soap, struct _tds__GetDPAddresses *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDPAddresses);
	if (soap_out_PointerTo_tds__GetDPAddresses(soap, tag?tag:"tds:GetDPAddresses", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDPAddresses ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDPAddresses(struct soap *soap, struct _tds__GetDPAddresses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDPAddresses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__SetRemoteDiscoveryModeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse))
		soap_serialize__tds__SetRemoteDiscoveryModeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, int id, struct _tds__SetRemoteDiscoveryModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetRemoteDiscoveryModeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryModeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__SetRemoteDiscoveryModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetRemoteDiscoveryModeResponse **)soap_malloc(soap, sizeof(struct _tds__SetRemoteDiscoveryModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetRemoteDiscoveryModeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteDiscoveryModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteDiscoveryModeResponse, sizeof(struct _tds__SetRemoteDiscoveryModeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__SetRemoteDiscoveryModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRemoteDiscoveryModeResponse);
	if (soap_out_PointerTo_tds__SetRemoteDiscoveryModeResponse(soap, tag?tag:"tds:SetRemoteDiscoveryModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryModeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__SetRemoteDiscoveryModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRemoteDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, struct _tds__SetRemoteDiscoveryMode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetRemoteDiscoveryMode))
		soap_serialize__tds__SetRemoteDiscoveryMode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, struct _tds__SetRemoteDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetRemoteDiscoveryMode);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetRemoteDiscoveryMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct _tds__SetRemoteDiscoveryMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetRemoteDiscoveryMode **)soap_malloc(soap, sizeof(struct _tds__SetRemoteDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetRemoteDiscoveryMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRemoteDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetRemoteDiscoveryMode, sizeof(struct _tds__SetRemoteDiscoveryMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, struct _tds__SetRemoteDiscoveryMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetRemoteDiscoveryMode);
	if (soap_out_PointerTo_tds__SetRemoteDiscoveryMode(soap, tag?tag:"tds:SetRemoteDiscoveryMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRemoteDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__SetRemoteDiscoveryMode(struct soap *soap, struct _tds__SetRemoteDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__GetRemoteDiscoveryModeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse))
		soap_serialize__tds__GetRemoteDiscoveryModeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, int id, struct _tds__GetRemoteDiscoveryModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetRemoteDiscoveryModeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryModeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRemoteDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__GetRemoteDiscoveryModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetRemoteDiscoveryModeResponse **)soap_malloc(soap, sizeof(struct _tds__GetRemoteDiscoveryModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetRemoteDiscoveryModeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteDiscoveryModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteDiscoveryModeResponse, sizeof(struct _tds__GetRemoteDiscoveryModeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__GetRemoteDiscoveryModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRemoteDiscoveryModeResponse);
	if (soap_out_PointerTo_tds__GetRemoteDiscoveryModeResponse(soap, tag?tag:"tds:GetRemoteDiscoveryModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryModeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRemoteDiscoveryModeResponse(struct soap *soap, struct _tds__GetRemoteDiscoveryModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRemoteDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, struct _tds__GetRemoteDiscoveryMode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetRemoteDiscoveryMode))
		soap_serialize__tds__GetRemoteDiscoveryMode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, int id, struct _tds__GetRemoteDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetRemoteDiscoveryMode);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetRemoteDiscoveryMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, const char *tag, struct _tds__GetRemoteDiscoveryMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetRemoteDiscoveryMode **)soap_malloc(soap, sizeof(struct _tds__GetRemoteDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetRemoteDiscoveryMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRemoteDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetRemoteDiscoveryMode, sizeof(struct _tds__GetRemoteDiscoveryMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, struct _tds__GetRemoteDiscoveryMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetRemoteDiscoveryMode);
	if (soap_out_PointerTo_tds__GetRemoteDiscoveryMode(soap, tag?tag:"tds:GetRemoteDiscoveryMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRemoteDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__GetRemoteDiscoveryMode(struct soap *soap, struct _tds__GetRemoteDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetRemoteDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDiscoveryModeResponse(struct soap *soap, struct _tds__SetDiscoveryModeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDiscoveryModeResponse))
		soap_serialize__tds__SetDiscoveryModeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDiscoveryModeResponse(struct soap *soap, const char *tag, int id, struct _tds__SetDiscoveryModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDiscoveryModeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDiscoveryModeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDiscoveryModeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__SetDiscoveryModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDiscoveryModeResponse **)soap_malloc(soap, sizeof(struct _tds__SetDiscoveryModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDiscoveryModeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDiscoveryModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDiscoveryModeResponse, sizeof(struct _tds__SetDiscoveryModeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDiscoveryModeResponse(struct soap *soap, struct _tds__SetDiscoveryModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDiscoveryModeResponse);
	if (soap_out_PointerTo_tds__SetDiscoveryModeResponse(soap, tag?tag:"tds:SetDiscoveryModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDiscoveryModeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDiscoveryModeResponse(struct soap *soap, struct _tds__SetDiscoveryModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetDiscoveryMode(struct soap *soap, struct _tds__SetDiscoveryMode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetDiscoveryMode))
		soap_serialize__tds__SetDiscoveryMode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetDiscoveryMode(struct soap *soap, const char *tag, int id, struct _tds__SetDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetDiscoveryMode);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetDiscoveryMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__SetDiscoveryMode(struct soap *soap, const char *tag, struct _tds__SetDiscoveryMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetDiscoveryMode **)soap_malloc(soap, sizeof(struct _tds__SetDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetDiscoveryMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetDiscoveryMode, sizeof(struct _tds__SetDiscoveryMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetDiscoveryMode(struct soap *soap, struct _tds__SetDiscoveryMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetDiscoveryMode);
	if (soap_out_PointerTo_tds__SetDiscoveryMode(soap, tag?tag:"tds:SetDiscoveryMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__SetDiscoveryMode(struct soap *soap, struct _tds__SetDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDiscoveryModeResponse(struct soap *soap, struct _tds__GetDiscoveryModeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDiscoveryModeResponse))
		soap_serialize__tds__GetDiscoveryModeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDiscoveryModeResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDiscoveryModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDiscoveryModeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDiscoveryModeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDiscoveryModeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDiscoveryModeResponse(struct soap *soap, const char *tag, struct _tds__GetDiscoveryModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDiscoveryModeResponse **)soap_malloc(soap, sizeof(struct _tds__GetDiscoveryModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDiscoveryModeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDiscoveryModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDiscoveryModeResponse, sizeof(struct _tds__GetDiscoveryModeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDiscoveryModeResponse(struct soap *soap, struct _tds__GetDiscoveryModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDiscoveryModeResponse);
	if (soap_out_PointerTo_tds__GetDiscoveryModeResponse(soap, tag?tag:"tds:GetDiscoveryModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDiscoveryModeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDiscoveryModeResponse(struct soap *soap, struct _tds__GetDiscoveryModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDiscoveryModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDiscoveryMode(struct soap *soap, struct _tds__GetDiscoveryMode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDiscoveryMode))
		soap_serialize__tds__GetDiscoveryMode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDiscoveryMode(struct soap *soap, const char *tag, int id, struct _tds__GetDiscoveryMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDiscoveryMode);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDiscoveryMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDiscoveryMode ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDiscoveryMode(struct soap *soap, const char *tag, struct _tds__GetDiscoveryMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDiscoveryMode **)soap_malloc(soap, sizeof(struct _tds__GetDiscoveryMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDiscoveryMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDiscoveryMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDiscoveryMode, sizeof(struct _tds__GetDiscoveryMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDiscoveryMode(struct soap *soap, struct _tds__GetDiscoveryMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDiscoveryMode);
	if (soap_out_PointerTo_tds__GetDiscoveryMode(soap, tag?tag:"tds:GetDiscoveryMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDiscoveryMode ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDiscoveryMode(struct soap *soap, struct _tds__GetDiscoveryMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDiscoveryMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RemoveScopesResponse(struct soap *soap, struct _tds__RemoveScopesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RemoveScopesResponse))
		soap_serialize__tds__RemoveScopesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RemoveScopesResponse(struct soap *soap, const char *tag, int id, struct _tds__RemoveScopesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RemoveScopesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__RemoveScopesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__RemoveScopesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__RemoveScopesResponse(struct soap *soap, const char *tag, struct _tds__RemoveScopesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__RemoveScopesResponse **)soap_malloc(soap, sizeof(struct _tds__RemoveScopesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__RemoveScopesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__RemoveScopesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveScopesResponse, sizeof(struct _tds__RemoveScopesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RemoveScopesResponse(struct soap *soap, struct _tds__RemoveScopesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RemoveScopesResponse);
	if (soap_out_PointerTo_tds__RemoveScopesResponse(soap, tag?tag:"tds:RemoveScopesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveScopesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__RemoveScopesResponse(struct soap *soap, struct _tds__RemoveScopesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RemoveScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RemoveScopes(struct soap *soap, struct _tds__RemoveScopes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RemoveScopes))
		soap_serialize__tds__RemoveScopes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RemoveScopes(struct soap *soap, const char *tag, int id, struct _tds__RemoveScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RemoveScopes);
	if (id < 0)
		return soap->error;
	return soap_out__tds__RemoveScopes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__RemoveScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__RemoveScopes(struct soap *soap, const char *tag, struct _tds__RemoveScopes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__RemoveScopes **)soap_malloc(soap, sizeof(struct _tds__RemoveScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__RemoveScopes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__RemoveScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RemoveScopes, sizeof(struct _tds__RemoveScopes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RemoveScopes(struct soap *soap, struct _tds__RemoveScopes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RemoveScopes);
	if (soap_out_PointerTo_tds__RemoveScopes(soap, tag?tag:"tds:RemoveScopes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RemoveScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__RemoveScopes(struct soap *soap, struct _tds__RemoveScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RemoveScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__AddScopesResponse(struct soap *soap, struct _tds__AddScopesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__AddScopesResponse))
		soap_serialize__tds__AddScopesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__AddScopesResponse(struct soap *soap, const char *tag, int id, struct _tds__AddScopesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__AddScopesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__AddScopesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__AddScopesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__AddScopesResponse(struct soap *soap, const char *tag, struct _tds__AddScopesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__AddScopesResponse **)soap_malloc(soap, sizeof(struct _tds__AddScopesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__AddScopesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__AddScopesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddScopesResponse, sizeof(struct _tds__AddScopesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__AddScopesResponse(struct soap *soap, struct _tds__AddScopesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__AddScopesResponse);
	if (soap_out_PointerTo_tds__AddScopesResponse(soap, tag?tag:"tds:AddScopesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddScopesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__AddScopesResponse(struct soap *soap, struct _tds__AddScopesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__AddScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__AddScopes(struct soap *soap, struct _tds__AddScopes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__AddScopes))
		soap_serialize__tds__AddScopes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__AddScopes(struct soap *soap, const char *tag, int id, struct _tds__AddScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__AddScopes);
	if (id < 0)
		return soap->error;
	return soap_out__tds__AddScopes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__AddScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__AddScopes(struct soap *soap, const char *tag, struct _tds__AddScopes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__AddScopes **)soap_malloc(soap, sizeof(struct _tds__AddScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__AddScopes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__AddScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__AddScopes, sizeof(struct _tds__AddScopes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__AddScopes(struct soap *soap, struct _tds__AddScopes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__AddScopes);
	if (soap_out_PointerTo_tds__AddScopes(soap, tag?tag:"tds:AddScopes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__AddScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__AddScopes(struct soap *soap, struct _tds__AddScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__AddScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetScopesResponse(struct soap *soap, struct _tds__SetScopesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetScopesResponse))
		soap_serialize__tds__SetScopesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetScopesResponse(struct soap *soap, const char *tag, int id, struct _tds__SetScopesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetScopesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetScopesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetScopesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetScopesResponse(struct soap *soap, const char *tag, struct _tds__SetScopesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetScopesResponse **)soap_malloc(soap, sizeof(struct _tds__SetScopesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetScopesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetScopesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetScopesResponse, sizeof(struct _tds__SetScopesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetScopesResponse(struct soap *soap, struct _tds__SetScopesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetScopesResponse);
	if (soap_out_PointerTo_tds__SetScopesResponse(soap, tag?tag:"tds:SetScopesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetScopesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetScopesResponse(struct soap *soap, struct _tds__SetScopesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetScopes(struct soap *soap, struct _tds__SetScopes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetScopes))
		soap_serialize__tds__SetScopes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetScopes(struct soap *soap, const char *tag, int id, struct _tds__SetScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetScopes);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetScopes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__SetScopes(struct soap *soap, const char *tag, struct _tds__SetScopes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetScopes **)soap_malloc(soap, sizeof(struct _tds__SetScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetScopes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetScopes, sizeof(struct _tds__SetScopes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetScopes(struct soap *soap, struct _tds__SetScopes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetScopes);
	if (soap_out_PointerTo_tds__SetScopes(soap, tag?tag:"tds:SetScopes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__SetScopes(struct soap *soap, struct _tds__SetScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetScopesResponse(struct soap *soap, struct _tds__GetScopesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetScopesResponse))
		soap_serialize__tds__GetScopesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetScopesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetScopesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetScopesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetScopesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetScopesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetScopesResponse(struct soap *soap, const char *tag, struct _tds__GetScopesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetScopesResponse **)soap_malloc(soap, sizeof(struct _tds__GetScopesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetScopesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetScopesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetScopesResponse, sizeof(struct _tds__GetScopesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetScopesResponse(struct soap *soap, struct _tds__GetScopesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetScopesResponse);
	if (soap_out_PointerTo_tds__GetScopesResponse(soap, tag?tag:"tds:GetScopesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetScopesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetScopesResponse(struct soap *soap, struct _tds__GetScopesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetScopesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetScopes(struct soap *soap, struct _tds__GetScopes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetScopes))
		soap_serialize__tds__GetScopes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetScopes(struct soap *soap, const char *tag, int id, struct _tds__GetScopes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetScopes);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetScopes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetScopes ** SOAP_FMAC4 soap_in_PointerTo_tds__GetScopes(struct soap *soap, const char *tag, struct _tds__GetScopes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetScopes **)soap_malloc(soap, sizeof(struct _tds__GetScopes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetScopes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetScopes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetScopes, sizeof(struct _tds__GetScopes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetScopes(struct soap *soap, struct _tds__GetScopes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetScopes);
	if (soap_out_PointerTo_tds__GetScopes(soap, tag?tag:"tds:GetScopes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetScopes ** SOAP_FMAC4 soap_get_PointerTo_tds__GetScopes(struct soap *soap, struct _tds__GetScopes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetScopes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemSupportInformationResponse(struct soap *soap, struct _tds__GetSystemSupportInformationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemSupportInformationResponse))
		soap_serialize__tds__GetSystemSupportInformationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemSupportInformationResponse(struct soap *soap, const char *tag, int id, struct _tds__GetSystemSupportInformationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemSupportInformationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemSupportInformationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemSupportInformationResponse(struct soap *soap, const char *tag, struct _tds__GetSystemSupportInformationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemSupportInformationResponse **)soap_malloc(soap, sizeof(struct _tds__GetSystemSupportInformationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemSupportInformationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemSupportInformationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemSupportInformationResponse, sizeof(struct _tds__GetSystemSupportInformationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemSupportInformationResponse(struct soap *soap, struct _tds__GetSystemSupportInformationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemSupportInformationResponse);
	if (soap_out_PointerTo_tds__GetSystemSupportInformationResponse(soap, tag?tag:"tds:GetSystemSupportInformationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemSupportInformationResponse(struct soap *soap, struct _tds__GetSystemSupportInformationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemSupportInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, struct _tds__GetSystemSupportInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemSupportInformation))
		soap_serialize__tds__GetSystemSupportInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, const char *tag, int id, struct _tds__GetSystemSupportInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemSupportInformation);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemSupportInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, const char *tag, struct _tds__GetSystemSupportInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemSupportInformation **)soap_malloc(soap, sizeof(struct _tds__GetSystemSupportInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemSupportInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemSupportInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemSupportInformation, sizeof(struct _tds__GetSystemSupportInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, struct _tds__GetSystemSupportInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemSupportInformation);
	if (soap_out_PointerTo_tds__GetSystemSupportInformation(soap, tag?tag:"tds:GetSystemSupportInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemSupportInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemSupportInformation(struct soap *soap, struct _tds__GetSystemSupportInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemSupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemLogResponse(struct soap *soap, struct _tds__GetSystemLogResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemLogResponse))
		soap_serialize__tds__GetSystemLogResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemLogResponse(struct soap *soap, const char *tag, int id, struct _tds__GetSystemLogResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemLogResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemLogResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemLogResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemLogResponse(struct soap *soap, const char *tag, struct _tds__GetSystemLogResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemLogResponse **)soap_malloc(soap, sizeof(struct _tds__GetSystemLogResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemLogResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemLogResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemLogResponse, sizeof(struct _tds__GetSystemLogResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemLogResponse(struct soap *soap, struct _tds__GetSystemLogResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemLogResponse);
	if (soap_out_PointerTo_tds__GetSystemLogResponse(soap, tag?tag:"tds:GetSystemLogResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemLogResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemLogResponse(struct soap *soap, struct _tds__GetSystemLogResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemLogResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemLog(struct soap *soap, struct _tds__GetSystemLog *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemLog))
		soap_serialize__tds__GetSystemLog(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemLog(struct soap *soap, const char *tag, int id, struct _tds__GetSystemLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemLog);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemLog ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemLog(struct soap *soap, const char *tag, struct _tds__GetSystemLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemLog **)soap_malloc(soap, sizeof(struct _tds__GetSystemLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemLog, sizeof(struct _tds__GetSystemLog), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemLog(struct soap *soap, struct _tds__GetSystemLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemLog);
	if (soap_out_PointerTo_tds__GetSystemLog(soap, tag?tag:"tds:GetSystemLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemLog ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemLog(struct soap *soap, struct _tds__GetSystemLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, struct _tds__GetSystemBackupResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemBackupResponse))
		soap_serialize__tds__GetSystemBackupResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, const char *tag, int id, struct _tds__GetSystemBackupResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemBackupResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemBackupResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemBackupResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, const char *tag, struct _tds__GetSystemBackupResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemBackupResponse **)soap_malloc(soap, sizeof(struct _tds__GetSystemBackupResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemBackupResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemBackupResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemBackupResponse, sizeof(struct _tds__GetSystemBackupResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, struct _tds__GetSystemBackupResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemBackupResponse);
	if (soap_out_PointerTo_tds__GetSystemBackupResponse(soap, tag?tag:"tds:GetSystemBackupResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemBackupResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemBackupResponse(struct soap *soap, struct _tds__GetSystemBackupResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemBackupResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemBackup(struct soap *soap, struct _tds__GetSystemBackup *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemBackup))
		soap_serialize__tds__GetSystemBackup(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemBackup(struct soap *soap, const char *tag, int id, struct _tds__GetSystemBackup *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemBackup);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemBackup(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemBackup ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemBackup(struct soap *soap, const char *tag, struct _tds__GetSystemBackup **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemBackup **)soap_malloc(soap, sizeof(struct _tds__GetSystemBackup *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemBackup(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemBackup **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemBackup, sizeof(struct _tds__GetSystemBackup), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemBackup(struct soap *soap, struct _tds__GetSystemBackup *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemBackup);
	if (soap_out_PointerTo_tds__GetSystemBackup(soap, tag?tag:"tds:GetSystemBackup", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemBackup ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemBackup(struct soap *soap, struct _tds__GetSystemBackup **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemBackup(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RestoreSystemResponse(struct soap *soap, struct _tds__RestoreSystemResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RestoreSystemResponse))
		soap_serialize__tds__RestoreSystemResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RestoreSystemResponse(struct soap *soap, const char *tag, int id, struct _tds__RestoreSystemResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RestoreSystemResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__RestoreSystemResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__RestoreSystemResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__RestoreSystemResponse(struct soap *soap, const char *tag, struct _tds__RestoreSystemResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__RestoreSystemResponse **)soap_malloc(soap, sizeof(struct _tds__RestoreSystemResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__RestoreSystemResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__RestoreSystemResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RestoreSystemResponse, sizeof(struct _tds__RestoreSystemResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RestoreSystemResponse(struct soap *soap, struct _tds__RestoreSystemResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RestoreSystemResponse);
	if (soap_out_PointerTo_tds__RestoreSystemResponse(soap, tag?tag:"tds:RestoreSystemResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RestoreSystemResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__RestoreSystemResponse(struct soap *soap, struct _tds__RestoreSystemResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RestoreSystemResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__RestoreSystem(struct soap *soap, struct _tds__RestoreSystem *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__RestoreSystem))
		soap_serialize__tds__RestoreSystem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__RestoreSystem(struct soap *soap, const char *tag, int id, struct _tds__RestoreSystem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__RestoreSystem);
	if (id < 0)
		return soap->error;
	return soap_out__tds__RestoreSystem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__RestoreSystem ** SOAP_FMAC4 soap_in_PointerTo_tds__RestoreSystem(struct soap *soap, const char *tag, struct _tds__RestoreSystem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__RestoreSystem **)soap_malloc(soap, sizeof(struct _tds__RestoreSystem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__RestoreSystem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__RestoreSystem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__RestoreSystem, sizeof(struct _tds__RestoreSystem), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__RestoreSystem(struct soap *soap, struct _tds__RestoreSystem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__RestoreSystem);
	if (soap_out_PointerTo_tds__RestoreSystem(soap, tag?tag:"tds:RestoreSystem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__RestoreSystem ** SOAP_FMAC4 soap_get_PointerTo_tds__RestoreSystem(struct soap *soap, struct _tds__RestoreSystem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__RestoreSystem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SystemRebootResponse))
		soap_serialize__tds__SystemRebootResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SystemRebootResponse(struct soap *soap, const char *tag, int id, struct _tds__SystemRebootResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SystemRebootResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SystemRebootResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SystemRebootResponse(struct soap *soap, const char *tag, struct _tds__SystemRebootResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SystemRebootResponse **)soap_malloc(soap, sizeof(struct _tds__SystemRebootResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SystemRebootResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SystemRebootResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SystemRebootResponse, sizeof(struct _tds__SystemRebootResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SystemRebootResponse);
	if (soap_out_PointerTo_tds__SystemRebootResponse(soap, tag?tag:"tds:SystemRebootResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemRebootResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SystemRebootResponse(struct soap *soap, struct _tds__SystemRebootResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SystemRebootResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SystemReboot))
		soap_serialize__tds__SystemReboot(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SystemReboot(struct soap *soap, const char *tag, int id, struct _tds__SystemReboot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SystemReboot);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SystemReboot(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SystemReboot ** SOAP_FMAC4 soap_in_PointerTo_tds__SystemReboot(struct soap *soap, const char *tag, struct _tds__SystemReboot **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SystemReboot **)soap_malloc(soap, sizeof(struct _tds__SystemReboot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SystemReboot(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SystemReboot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SystemReboot, sizeof(struct _tds__SystemReboot), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SystemReboot);
	if (soap_out_PointerTo_tds__SystemReboot(soap, tag?tag:"tds:SystemReboot", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SystemReboot ** SOAP_FMAC4 soap_get_PointerTo_tds__SystemReboot(struct soap *soap, struct _tds__SystemReboot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SystemReboot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, struct _tds__UpgradeSystemFirmwareResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse))
		soap_serialize__tds__UpgradeSystemFirmwareResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, const char *tag, int id, struct _tds__UpgradeSystemFirmwareResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__UpgradeSystemFirmwareResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmwareResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, const char *tag, struct _tds__UpgradeSystemFirmwareResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__UpgradeSystemFirmwareResponse **)soap_malloc(soap, sizeof(struct _tds__UpgradeSystemFirmwareResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__UpgradeSystemFirmwareResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__UpgradeSystemFirmwareResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__UpgradeSystemFirmwareResponse, sizeof(struct _tds__UpgradeSystemFirmwareResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, struct _tds__UpgradeSystemFirmwareResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__UpgradeSystemFirmwareResponse);
	if (soap_out_PointerTo_tds__UpgradeSystemFirmwareResponse(soap, tag?tag:"tds:UpgradeSystemFirmwareResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmwareResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__UpgradeSystemFirmwareResponse(struct soap *soap, struct _tds__UpgradeSystemFirmwareResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__UpgradeSystemFirmwareResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, struct _tds__UpgradeSystemFirmware *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__UpgradeSystemFirmware))
		soap_serialize__tds__UpgradeSystemFirmware(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, int id, struct _tds__UpgradeSystemFirmware *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__UpgradeSystemFirmware);
	if (id < 0)
		return soap->error;
	return soap_out__tds__UpgradeSystemFirmware(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmware ** SOAP_FMAC4 soap_in_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, const char *tag, struct _tds__UpgradeSystemFirmware **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__UpgradeSystemFirmware **)soap_malloc(soap, sizeof(struct _tds__UpgradeSystemFirmware *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__UpgradeSystemFirmware(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__UpgradeSystemFirmware **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__UpgradeSystemFirmware, sizeof(struct _tds__UpgradeSystemFirmware), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, struct _tds__UpgradeSystemFirmware *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__UpgradeSystemFirmware);
	if (soap_out_PointerTo_tds__UpgradeSystemFirmware(soap, tag?tag:"tds:UpgradeSystemFirmware", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__UpgradeSystemFirmware ** SOAP_FMAC4 soap_get_PointerTo_tds__UpgradeSystemFirmware(struct soap *soap, struct _tds__UpgradeSystemFirmware **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__UpgradeSystemFirmware(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse))
		soap_serialize__tds__SetSystemFactoryDefaultResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, int id, struct _tds__SetSystemFactoryDefaultResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetSystemFactoryDefaultResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefaultResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, const char *tag, struct _tds__SetSystemFactoryDefaultResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetSystemFactoryDefaultResponse **)soap_malloc(soap, sizeof(struct _tds__SetSystemFactoryDefaultResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetSystemFactoryDefaultResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemFactoryDefaultResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemFactoryDefaultResponse, sizeof(struct _tds__SetSystemFactoryDefaultResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetSystemFactoryDefaultResponse);
	if (soap_out_PointerTo_tds__SetSystemFactoryDefaultResponse(soap, tag?tag:"tds:SetSystemFactoryDefaultResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefaultResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemFactoryDefaultResponse(struct soap *soap, struct _tds__SetSystemFactoryDefaultResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemFactoryDefaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemFactoryDefault))
		soap_serialize__tds__SetSystemFactoryDefault(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, int id, struct _tds__SetSystemFactoryDefault *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemFactoryDefault);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetSystemFactoryDefault(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefault ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, const char *tag, struct _tds__SetSystemFactoryDefault **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetSystemFactoryDefault **)soap_malloc(soap, sizeof(struct _tds__SetSystemFactoryDefault *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetSystemFactoryDefault(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemFactoryDefault **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemFactoryDefault, sizeof(struct _tds__SetSystemFactoryDefault), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetSystemFactoryDefault);
	if (soap_out_PointerTo_tds__SetSystemFactoryDefault(soap, tag?tag:"tds:SetSystemFactoryDefault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemFactoryDefault ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemFactoryDefault(struct soap *soap, struct _tds__SetSystemFactoryDefault **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemFactoryDefault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse))
		soap_serialize__tds__GetSystemDateAndTimeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, struct _tds__GetSystemDateAndTimeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemDateAndTimeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemDateAndTimeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, const char *tag, struct _tds__GetSystemDateAndTimeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemDateAndTimeResponse **)soap_malloc(soap, sizeof(struct _tds__GetSystemDateAndTimeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemDateAndTimeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemDateAndTimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemDateAndTimeResponse, sizeof(struct _tds__GetSystemDateAndTimeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemDateAndTimeResponse);
	if (soap_out_PointerTo_tds__GetSystemDateAndTimeResponse(soap, tag?tag:"tds:GetSystemDateAndTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemDateAndTimeResponse(struct soap *soap, struct _tds__GetSystemDateAndTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemDateAndTime))
		soap_serialize__tds__GetSystemDateAndTime(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, const char *tag, int id, struct _tds__GetSystemDateAndTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemDateAndTime);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemDateAndTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTime ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, const char *tag, struct _tds__GetSystemDateAndTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemDateAndTime **)soap_malloc(soap, sizeof(struct _tds__GetSystemDateAndTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemDateAndTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemDateAndTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemDateAndTime, sizeof(struct _tds__GetSystemDateAndTime), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemDateAndTime);
	if (soap_out_PointerTo_tds__GetSystemDateAndTime(soap, tag?tag:"tds:GetSystemDateAndTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemDateAndTime ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemDateAndTime(struct soap *soap, struct _tds__GetSystemDateAndTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse))
		soap_serialize__tds__SetSystemDateAndTimeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, int id, struct _tds__SetSystemDateAndTimeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemDateAndTimeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetSystemDateAndTimeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, const char *tag, struct _tds__SetSystemDateAndTimeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetSystemDateAndTimeResponse **)soap_malloc(soap, sizeof(struct _tds__SetSystemDateAndTimeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetSystemDateAndTimeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemDateAndTimeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemDateAndTimeResponse, sizeof(struct _tds__SetSystemDateAndTimeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetSystemDateAndTimeResponse);
	if (soap_out_PointerTo_tds__SetSystemDateAndTimeResponse(soap, tag?tag:"tds:SetSystemDateAndTimeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTimeResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemDateAndTimeResponse(struct soap *soap, struct _tds__SetSystemDateAndTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemDateAndTimeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__SetSystemDateAndTime))
		soap_serialize__tds__SetSystemDateAndTime(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, const char *tag, int id, struct _tds__SetSystemDateAndTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__SetSystemDateAndTime);
	if (id < 0)
		return soap->error;
	return soap_out__tds__SetSystemDateAndTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTime ** SOAP_FMAC4 soap_in_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, const char *tag, struct _tds__SetSystemDateAndTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__SetSystemDateAndTime **)soap_malloc(soap, sizeof(struct _tds__SetSystemDateAndTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__SetSystemDateAndTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__SetSystemDateAndTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__SetSystemDateAndTime, sizeof(struct _tds__SetSystemDateAndTime), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__SetSystemDateAndTime);
	if (soap_out_PointerTo_tds__SetSystemDateAndTime(soap, tag?tag:"tds:SetSystemDateAndTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetSystemDateAndTime ** SOAP_FMAC4 soap_get_PointerTo_tds__SetSystemDateAndTime(struct soap *soap, struct _tds__SetSystemDateAndTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__SetSystemDateAndTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDeviceInformationResponse))
		soap_serialize__tds__GetDeviceInformationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, int id, struct _tds__GetDeviceInformationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDeviceInformationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDeviceInformationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, const char *tag, struct _tds__GetDeviceInformationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDeviceInformationResponse **)soap_malloc(soap, sizeof(struct _tds__GetDeviceInformationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDeviceInformationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDeviceInformationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDeviceInformationResponse, sizeof(struct _tds__GetDeviceInformationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDeviceInformationResponse);
	if (soap_out_PointerTo_tds__GetDeviceInformationResponse(soap, tag?tag:"tds:GetDeviceInformationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformationResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDeviceInformationResponse(struct soap *soap, struct _tds__GetDeviceInformationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDeviceInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetDeviceInformation))
		soap_serialize__tds__GetDeviceInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetDeviceInformation(struct soap *soap, const char *tag, int id, struct _tds__GetDeviceInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetDeviceInformation);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetDeviceInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation ** SOAP_FMAC4 soap_in_PointerTo_tds__GetDeviceInformation(struct soap *soap, const char *tag, struct _tds__GetDeviceInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetDeviceInformation **)soap_malloc(soap, sizeof(struct _tds__GetDeviceInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetDeviceInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDeviceInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetDeviceInformation, sizeof(struct _tds__GetDeviceInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetDeviceInformation);
	if (soap_out_PointerTo_tds__GetDeviceInformation(soap, tag?tag:"tds:GetDeviceInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDeviceInformation ** SOAP_FMAC4 soap_get_PointerTo_tds__GetDeviceInformation(struct soap *soap, struct _tds__GetDeviceInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetDeviceInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse))
		soap_serialize__tds__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tds__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServiceCapabilitiesResponse, sizeof(struct _tds__GetServiceCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_tds__GetServiceCapabilitiesResponse(soap, tag?tag:"tds:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServiceCapabilitiesResponse(struct soap *soap, struct _tds__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServiceCapabilities))
		soap_serialize__tds__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _tds__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tds__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _tds__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServiceCapabilities, sizeof(struct _tds__GetServiceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetServiceCapabilities);
	if (soap_out_PointerTo_tds__GetServiceCapabilities(soap, tag?tag:"tds:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServiceCapabilities(struct soap *soap, struct _tds__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServicesResponse))
		soap_serialize__tds__GetServicesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServicesResponse(struct soap *soap, const char *tag, int id, struct _tds__GetServicesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServicesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetServicesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetServicesResponse ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServicesResponse(struct soap *soap, const char *tag, struct _tds__GetServicesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetServicesResponse **)soap_malloc(soap, sizeof(struct _tds__GetServicesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetServicesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServicesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServicesResponse, sizeof(struct _tds__GetServicesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetServicesResponse);
	if (soap_out_PointerTo_tds__GetServicesResponse(soap, tag?tag:"tds:GetServicesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServicesResponse ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServicesResponse(struct soap *soap, struct _tds__GetServicesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServicesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetServices(struct soap *soap, struct _tds__GetServices *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetServices))
		soap_serialize__tds__GetServices(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetServices(struct soap *soap, const char *tag, int id, struct _tds__GetServices *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetServices);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetServices(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetServices ** SOAP_FMAC4 soap_in_PointerTo_tds__GetServices(struct soap *soap, const char *tag, struct _tds__GetServices **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetServices **)soap_malloc(soap, sizeof(struct _tds__GetServices *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetServices(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetServices **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetServices, sizeof(struct _tds__GetServices), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetServices(struct soap *soap, struct _tds__GetServices *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetServices);
	if (soap_out_PointerTo_tds__GetServices(soap, tag?tag:"tds:GetServices", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetServices ** SOAP_FMAC4 soap_get_PointerTo_tds__GetServices(struct soap *soap, struct _tds__GetServices **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetServices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__ModifyAnalyticsModulesResponse(struct soap *soap, struct _tan__ModifyAnalyticsModulesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse))
		soap_serialize__tan__ModifyAnalyticsModulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__ModifyAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, struct _tan__ModifyAnalyticsModulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tan__ModifyAnalyticsModulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__ModifyAnalyticsModulesResponse(struct soap *soap, const char *tag, struct _tan__ModifyAnalyticsModulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__ModifyAnalyticsModulesResponse **)soap_malloc(soap, sizeof(struct _tan__ModifyAnalyticsModulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__ModifyAnalyticsModulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__ModifyAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__ModifyAnalyticsModulesResponse, sizeof(struct _tan__ModifyAnalyticsModulesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__ModifyAnalyticsModulesResponse(struct soap *soap, struct _tan__ModifyAnalyticsModulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__ModifyAnalyticsModulesResponse);
	if (soap_out_PointerTo_tan__ModifyAnalyticsModulesResponse(soap, tag?tag:"tan:ModifyAnalyticsModulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__ModifyAnalyticsModulesResponse(struct soap *soap, struct _tan__ModifyAnalyticsModulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__ModifyAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__ModifyAnalyticsModules(struct soap *soap, struct _tan__ModifyAnalyticsModules *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__ModifyAnalyticsModules))
		soap_serialize__tan__ModifyAnalyticsModules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__ModifyAnalyticsModules(struct soap *soap, const char *tag, int id, struct _tan__ModifyAnalyticsModules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__ModifyAnalyticsModules);
	if (id < 0)
		return soap->error;
	return soap_out__tan__ModifyAnalyticsModules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModules ** SOAP_FMAC4 soap_in_PointerTo_tan__ModifyAnalyticsModules(struct soap *soap, const char *tag, struct _tan__ModifyAnalyticsModules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__ModifyAnalyticsModules **)soap_malloc(soap, sizeof(struct _tan__ModifyAnalyticsModules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__ModifyAnalyticsModules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__ModifyAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__ModifyAnalyticsModules, sizeof(struct _tan__ModifyAnalyticsModules), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__ModifyAnalyticsModules(struct soap *soap, struct _tan__ModifyAnalyticsModules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__ModifyAnalyticsModules);
	if (soap_out_PointerTo_tan__ModifyAnalyticsModules(soap, tag?tag:"tan:ModifyAnalyticsModules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__ModifyAnalyticsModules ** SOAP_FMAC4 soap_get_PointerTo_tan__ModifyAnalyticsModules(struct soap *soap, struct _tan__ModifyAnalyticsModules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__ModifyAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetAnalyticsModulesResponse(struct soap *soap, struct _tan__GetAnalyticsModulesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetAnalyticsModulesResponse))
		soap_serialize__tan__GetAnalyticsModulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, struct _tan__GetAnalyticsModulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetAnalyticsModulesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetAnalyticsModulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__GetAnalyticsModulesResponse(struct soap *soap, const char *tag, struct _tan__GetAnalyticsModulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetAnalyticsModulesResponse **)soap_malloc(soap, sizeof(struct _tan__GetAnalyticsModulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetAnalyticsModulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetAnalyticsModulesResponse, sizeof(struct _tan__GetAnalyticsModulesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetAnalyticsModulesResponse(struct soap *soap, struct _tan__GetAnalyticsModulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__GetAnalyticsModulesResponse);
	if (soap_out_PointerTo_tan__GetAnalyticsModulesResponse(soap, tag?tag:"tan:GetAnalyticsModulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__GetAnalyticsModulesResponse(struct soap *soap, struct _tan__GetAnalyticsModulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetAnalyticsModules(struct soap *soap, struct _tan__GetAnalyticsModules *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetAnalyticsModules))
		soap_serialize__tan__GetAnalyticsModules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetAnalyticsModules(struct soap *soap, const char *tag, int id, struct _tan__GetAnalyticsModules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetAnalyticsModules);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetAnalyticsModules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModules ** SOAP_FMAC4 soap_in_PointerTo_tan__GetAnalyticsModules(struct soap *soap, const char *tag, struct _tan__GetAnalyticsModules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetAnalyticsModules **)soap_malloc(soap, sizeof(struct _tan__GetAnalyticsModules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetAnalyticsModules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetAnalyticsModules, sizeof(struct _tan__GetAnalyticsModules), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetAnalyticsModules(struct soap *soap, struct _tan__GetAnalyticsModules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__GetAnalyticsModules);
	if (soap_out_PointerTo_tan__GetAnalyticsModules(soap, tag?tag:"tan:GetAnalyticsModules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetAnalyticsModules ** SOAP_FMAC4 soap_get_PointerTo_tan__GetAnalyticsModules(struct soap *soap, struct _tan__GetAnalyticsModules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__DeleteAnalyticsModulesResponse(struct soap *soap, struct _tan__DeleteAnalyticsModulesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse))
		soap_serialize__tan__DeleteAnalyticsModulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__DeleteAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, struct _tan__DeleteAnalyticsModulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tan__DeleteAnalyticsModulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__DeleteAnalyticsModulesResponse(struct soap *soap, const char *tag, struct _tan__DeleteAnalyticsModulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__DeleteAnalyticsModulesResponse **)soap_malloc(soap, sizeof(struct _tan__DeleteAnalyticsModulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__DeleteAnalyticsModulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__DeleteAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__DeleteAnalyticsModulesResponse, sizeof(struct _tan__DeleteAnalyticsModulesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__DeleteAnalyticsModulesResponse(struct soap *soap, struct _tan__DeleteAnalyticsModulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__DeleteAnalyticsModulesResponse);
	if (soap_out_PointerTo_tan__DeleteAnalyticsModulesResponse(soap, tag?tag:"tan:DeleteAnalyticsModulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__DeleteAnalyticsModulesResponse(struct soap *soap, struct _tan__DeleteAnalyticsModulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__DeleteAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__DeleteAnalyticsModules(struct soap *soap, struct _tan__DeleteAnalyticsModules *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__DeleteAnalyticsModules))
		soap_serialize__tan__DeleteAnalyticsModules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__DeleteAnalyticsModules(struct soap *soap, const char *tag, int id, struct _tan__DeleteAnalyticsModules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__DeleteAnalyticsModules);
	if (id < 0)
		return soap->error;
	return soap_out__tan__DeleteAnalyticsModules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModules ** SOAP_FMAC4 soap_in_PointerTo_tan__DeleteAnalyticsModules(struct soap *soap, const char *tag, struct _tan__DeleteAnalyticsModules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__DeleteAnalyticsModules **)soap_malloc(soap, sizeof(struct _tan__DeleteAnalyticsModules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__DeleteAnalyticsModules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__DeleteAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__DeleteAnalyticsModules, sizeof(struct _tan__DeleteAnalyticsModules), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__DeleteAnalyticsModules(struct soap *soap, struct _tan__DeleteAnalyticsModules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__DeleteAnalyticsModules);
	if (soap_out_PointerTo_tan__DeleteAnalyticsModules(soap, tag?tag:"tan:DeleteAnalyticsModules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__DeleteAnalyticsModules ** SOAP_FMAC4 soap_get_PointerTo_tan__DeleteAnalyticsModules(struct soap *soap, struct _tan__DeleteAnalyticsModules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__DeleteAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__CreateAnalyticsModulesResponse(struct soap *soap, struct _tan__CreateAnalyticsModulesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__CreateAnalyticsModulesResponse))
		soap_serialize__tan__CreateAnalyticsModulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__CreateAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, struct _tan__CreateAnalyticsModulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__CreateAnalyticsModulesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tan__CreateAnalyticsModulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__CreateAnalyticsModulesResponse(struct soap *soap, const char *tag, struct _tan__CreateAnalyticsModulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__CreateAnalyticsModulesResponse **)soap_malloc(soap, sizeof(struct _tan__CreateAnalyticsModulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__CreateAnalyticsModulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__CreateAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__CreateAnalyticsModulesResponse, sizeof(struct _tan__CreateAnalyticsModulesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__CreateAnalyticsModulesResponse(struct soap *soap, struct _tan__CreateAnalyticsModulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__CreateAnalyticsModulesResponse);
	if (soap_out_PointerTo_tan__CreateAnalyticsModulesResponse(soap, tag?tag:"tan:CreateAnalyticsModulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__CreateAnalyticsModulesResponse(struct soap *soap, struct _tan__CreateAnalyticsModulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__CreateAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__CreateAnalyticsModules(struct soap *soap, struct _tan__CreateAnalyticsModules *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__CreateAnalyticsModules))
		soap_serialize__tan__CreateAnalyticsModules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__CreateAnalyticsModules(struct soap *soap, const char *tag, int id, struct _tan__CreateAnalyticsModules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__CreateAnalyticsModules);
	if (id < 0)
		return soap->error;
	return soap_out__tan__CreateAnalyticsModules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModules ** SOAP_FMAC4 soap_in_PointerTo_tan__CreateAnalyticsModules(struct soap *soap, const char *tag, struct _tan__CreateAnalyticsModules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__CreateAnalyticsModules **)soap_malloc(soap, sizeof(struct _tan__CreateAnalyticsModules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__CreateAnalyticsModules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__CreateAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__CreateAnalyticsModules, sizeof(struct _tan__CreateAnalyticsModules), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__CreateAnalyticsModules(struct soap *soap, struct _tan__CreateAnalyticsModules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__CreateAnalyticsModules);
	if (soap_out_PointerTo_tan__CreateAnalyticsModules(soap, tag?tag:"tan:CreateAnalyticsModules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__CreateAnalyticsModules ** SOAP_FMAC4 soap_get_PointerTo_tan__CreateAnalyticsModules(struct soap *soap, struct _tan__CreateAnalyticsModules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__CreateAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, struct _tan__GetSupportedAnalyticsModulesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse))
		soap_serialize__tan__GetSupportedAnalyticsModulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, const char *tag, int id, struct _tan__GetSupportedAnalyticsModulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetSupportedAnalyticsModulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetSupportedAnalyticsModulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, const char *tag, struct _tan__GetSupportedAnalyticsModulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetSupportedAnalyticsModulesResponse **)soap_malloc(soap, sizeof(struct _tan__GetSupportedAnalyticsModulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetSupportedAnalyticsModulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetSupportedAnalyticsModulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetSupportedAnalyticsModulesResponse, sizeof(struct _tan__GetSupportedAnalyticsModulesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, struct _tan__GetSupportedAnalyticsModulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__GetSupportedAnalyticsModulesResponse);
	if (soap_out_PointerTo_tan__GetSupportedAnalyticsModulesResponse(soap, tag?tag:"tan:GetSupportedAnalyticsModulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetSupportedAnalyticsModulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__GetSupportedAnalyticsModulesResponse(struct soap *soap, struct _tan__GetSupportedAnalyticsModulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetSupportedAnalyticsModulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetSupportedAnalyticsModules(struct soap *soap, struct _tan__GetSupportedAnalyticsModules *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetSupportedAnalyticsModules))
		soap_serialize__tan__GetSupportedAnalyticsModules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetSupportedAnalyticsModules(struct soap *soap, const char *tag, int id, struct _tan__GetSupportedAnalyticsModules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetSupportedAnalyticsModules);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetSupportedAnalyticsModules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetSupportedAnalyticsModules ** SOAP_FMAC4 soap_in_PointerTo_tan__GetSupportedAnalyticsModules(struct soap *soap, const char *tag, struct _tan__GetSupportedAnalyticsModules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetSupportedAnalyticsModules **)soap_malloc(soap, sizeof(struct _tan__GetSupportedAnalyticsModules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetSupportedAnalyticsModules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetSupportedAnalyticsModules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetSupportedAnalyticsModules, sizeof(struct _tan__GetSupportedAnalyticsModules), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetSupportedAnalyticsModules(struct soap *soap, struct _tan__GetSupportedAnalyticsModules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__GetSupportedAnalyticsModules);
	if (soap_out_PointerTo_tan__GetSupportedAnalyticsModules(soap, tag?tag:"tan:GetSupportedAnalyticsModules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetSupportedAnalyticsModules ** SOAP_FMAC4 soap_get_PointerTo_tan__GetSupportedAnalyticsModules(struct soap *soap, struct _tan__GetSupportedAnalyticsModules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetSupportedAnalyticsModules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetServiceCapabilitiesResponse(struct soap *soap, struct _tan__GetServiceCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetServiceCapabilitiesResponse))
		soap_serialize__tan__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tan__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tan__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tan__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetServiceCapabilitiesResponse, sizeof(struct _tan__GetServiceCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetServiceCapabilitiesResponse(struct soap *soap, struct _tan__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_tan__GetServiceCapabilitiesResponse(soap, tag?tag:"tan:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__GetServiceCapabilitiesResponse(struct soap *soap, struct _tan__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetServiceCapabilities(struct soap *soap, struct _tan__GetServiceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetServiceCapabilities))
		soap_serialize__tan__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _tan__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tan__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tan__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _tan__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetServiceCapabilities, sizeof(struct _tan__GetServiceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetServiceCapabilities(struct soap *soap, struct _tan__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__GetServiceCapabilities);
	if (soap_out_PointerTo_tan__GetServiceCapabilities(soap, tag?tag:"tan:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tan__GetServiceCapabilities(struct soap *soap, struct _tan__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__ModifyRulesResponse(struct soap *soap, struct _tan__ModifyRulesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__ModifyRulesResponse))
		soap_serialize__tan__ModifyRulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__ModifyRulesResponse(struct soap *soap, const char *tag, int id, struct _tan__ModifyRulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__ModifyRulesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tan__ModifyRulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__ModifyRulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__ModifyRulesResponse(struct soap *soap, const char *tag, struct _tan__ModifyRulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__ModifyRulesResponse **)soap_malloc(soap, sizeof(struct _tan__ModifyRulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__ModifyRulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__ModifyRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__ModifyRulesResponse, sizeof(struct _tan__ModifyRulesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__ModifyRulesResponse(struct soap *soap, struct _tan__ModifyRulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__ModifyRulesResponse);
	if (soap_out_PointerTo_tan__ModifyRulesResponse(soap, tag?tag:"tan:ModifyRulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__ModifyRulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__ModifyRulesResponse(struct soap *soap, struct _tan__ModifyRulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__ModifyRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__ModifyRules(struct soap *soap, struct _tan__ModifyRules *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__ModifyRules))
		soap_serialize__tan__ModifyRules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__ModifyRules(struct soap *soap, const char *tag, int id, struct _tan__ModifyRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__ModifyRules);
	if (id < 0)
		return soap->error;
	return soap_out__tan__ModifyRules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__ModifyRules ** SOAP_FMAC4 soap_in_PointerTo_tan__ModifyRules(struct soap *soap, const char *tag, struct _tan__ModifyRules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__ModifyRules **)soap_malloc(soap, sizeof(struct _tan__ModifyRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__ModifyRules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__ModifyRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__ModifyRules, sizeof(struct _tan__ModifyRules), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__ModifyRules(struct soap *soap, struct _tan__ModifyRules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__ModifyRules);
	if (soap_out_PointerTo_tan__ModifyRules(soap, tag?tag:"tan:ModifyRules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__ModifyRules ** SOAP_FMAC4 soap_get_PointerTo_tan__ModifyRules(struct soap *soap, struct _tan__ModifyRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__ModifyRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetRulesResponse(struct soap *soap, struct _tan__GetRulesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetRulesResponse))
		soap_serialize__tan__GetRulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetRulesResponse(struct soap *soap, const char *tag, int id, struct _tan__GetRulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetRulesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetRulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetRulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__GetRulesResponse(struct soap *soap, const char *tag, struct _tan__GetRulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetRulesResponse **)soap_malloc(soap, sizeof(struct _tan__GetRulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetRulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetRulesResponse, sizeof(struct _tan__GetRulesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetRulesResponse(struct soap *soap, struct _tan__GetRulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__GetRulesResponse);
	if (soap_out_PointerTo_tan__GetRulesResponse(soap, tag?tag:"tan:GetRulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetRulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__GetRulesResponse(struct soap *soap, struct _tan__GetRulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetRules(struct soap *soap, struct _tan__GetRules *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetRules))
		soap_serialize__tan__GetRules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetRules(struct soap *soap, const char *tag, int id, struct _tan__GetRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetRules);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetRules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetRules ** SOAP_FMAC4 soap_in_PointerTo_tan__GetRules(struct soap *soap, const char *tag, struct _tan__GetRules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetRules **)soap_malloc(soap, sizeof(struct _tan__GetRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetRules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetRules, sizeof(struct _tan__GetRules), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetRules(struct soap *soap, struct _tan__GetRules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__GetRules);
	if (soap_out_PointerTo_tan__GetRules(soap, tag?tag:"tan:GetRules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetRules ** SOAP_FMAC4 soap_get_PointerTo_tan__GetRules(struct soap *soap, struct _tan__GetRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__DeleteRulesResponse(struct soap *soap, struct _tan__DeleteRulesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__DeleteRulesResponse))
		soap_serialize__tan__DeleteRulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__DeleteRulesResponse(struct soap *soap, const char *tag, int id, struct _tan__DeleteRulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__DeleteRulesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tan__DeleteRulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__DeleteRulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__DeleteRulesResponse(struct soap *soap, const char *tag, struct _tan__DeleteRulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__DeleteRulesResponse **)soap_malloc(soap, sizeof(struct _tan__DeleteRulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__DeleteRulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__DeleteRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__DeleteRulesResponse, sizeof(struct _tan__DeleteRulesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__DeleteRulesResponse(struct soap *soap, struct _tan__DeleteRulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__DeleteRulesResponse);
	if (soap_out_PointerTo_tan__DeleteRulesResponse(soap, tag?tag:"tan:DeleteRulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__DeleteRulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__DeleteRulesResponse(struct soap *soap, struct _tan__DeleteRulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__DeleteRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__DeleteRules(struct soap *soap, struct _tan__DeleteRules *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__DeleteRules))
		soap_serialize__tan__DeleteRules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__DeleteRules(struct soap *soap, const char *tag, int id, struct _tan__DeleteRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__DeleteRules);
	if (id < 0)
		return soap->error;
	return soap_out__tan__DeleteRules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__DeleteRules ** SOAP_FMAC4 soap_in_PointerTo_tan__DeleteRules(struct soap *soap, const char *tag, struct _tan__DeleteRules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__DeleteRules **)soap_malloc(soap, sizeof(struct _tan__DeleteRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__DeleteRules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__DeleteRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__DeleteRules, sizeof(struct _tan__DeleteRules), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__DeleteRules(struct soap *soap, struct _tan__DeleteRules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__DeleteRules);
	if (soap_out_PointerTo_tan__DeleteRules(soap, tag?tag:"tan:DeleteRules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__DeleteRules ** SOAP_FMAC4 soap_get_PointerTo_tan__DeleteRules(struct soap *soap, struct _tan__DeleteRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__DeleteRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__CreateRulesResponse(struct soap *soap, struct _tan__CreateRulesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__CreateRulesResponse))
		soap_serialize__tan__CreateRulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__CreateRulesResponse(struct soap *soap, const char *tag, int id, struct _tan__CreateRulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__CreateRulesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tan__CreateRulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__CreateRulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__CreateRulesResponse(struct soap *soap, const char *tag, struct _tan__CreateRulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__CreateRulesResponse **)soap_malloc(soap, sizeof(struct _tan__CreateRulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__CreateRulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__CreateRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__CreateRulesResponse, sizeof(struct _tan__CreateRulesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__CreateRulesResponse(struct soap *soap, struct _tan__CreateRulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__CreateRulesResponse);
	if (soap_out_PointerTo_tan__CreateRulesResponse(soap, tag?tag:"tan:CreateRulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__CreateRulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__CreateRulesResponse(struct soap *soap, struct _tan__CreateRulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__CreateRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__CreateRules(struct soap *soap, struct _tan__CreateRules *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__CreateRules))
		soap_serialize__tan__CreateRules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__CreateRules(struct soap *soap, const char *tag, int id, struct _tan__CreateRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__CreateRules);
	if (id < 0)
		return soap->error;
	return soap_out__tan__CreateRules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__CreateRules ** SOAP_FMAC4 soap_in_PointerTo_tan__CreateRules(struct soap *soap, const char *tag, struct _tan__CreateRules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__CreateRules **)soap_malloc(soap, sizeof(struct _tan__CreateRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__CreateRules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__CreateRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__CreateRules, sizeof(struct _tan__CreateRules), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__CreateRules(struct soap *soap, struct _tan__CreateRules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__CreateRules);
	if (soap_out_PointerTo_tan__CreateRules(soap, tag?tag:"tan:CreateRules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__CreateRules ** SOAP_FMAC4 soap_get_PointerTo_tan__CreateRules(struct soap *soap, struct _tan__CreateRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__CreateRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetSupportedRulesResponse(struct soap *soap, struct _tan__GetSupportedRulesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetSupportedRulesResponse))
		soap_serialize__tan__GetSupportedRulesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetSupportedRulesResponse(struct soap *soap, const char *tag, int id, struct _tan__GetSupportedRulesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetSupportedRulesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetSupportedRulesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetSupportedRulesResponse ** SOAP_FMAC4 soap_in_PointerTo_tan__GetSupportedRulesResponse(struct soap *soap, const char *tag, struct _tan__GetSupportedRulesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetSupportedRulesResponse **)soap_malloc(soap, sizeof(struct _tan__GetSupportedRulesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetSupportedRulesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetSupportedRulesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetSupportedRulesResponse, sizeof(struct _tan__GetSupportedRulesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetSupportedRulesResponse(struct soap *soap, struct _tan__GetSupportedRulesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__GetSupportedRulesResponse);
	if (soap_out_PointerTo_tan__GetSupportedRulesResponse(soap, tag?tag:"tan:GetSupportedRulesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetSupportedRulesResponse ** SOAP_FMAC4 soap_get_PointerTo_tan__GetSupportedRulesResponse(struct soap *soap, struct _tan__GetSupportedRulesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetSupportedRulesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tan__GetSupportedRules(struct soap *soap, struct _tan__GetSupportedRules *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tan__GetSupportedRules))
		soap_serialize__tan__GetSupportedRules(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tan__GetSupportedRules(struct soap *soap, const char *tag, int id, struct _tan__GetSupportedRules *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tan__GetSupportedRules);
	if (id < 0)
		return soap->error;
	return soap_out__tan__GetSupportedRules(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tan__GetSupportedRules ** SOAP_FMAC4 soap_in_PointerTo_tan__GetSupportedRules(struct soap *soap, const char *tag, struct _tan__GetSupportedRules **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tan__GetSupportedRules **)soap_malloc(soap, sizeof(struct _tan__GetSupportedRules *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tan__GetSupportedRules(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tan__GetSupportedRules **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tan__GetSupportedRules, sizeof(struct _tan__GetSupportedRules), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tan__GetSupportedRules(struct soap *soap, struct _tan__GetSupportedRules *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tan__GetSupportedRules);
	if (soap_out_PointerTo_tan__GetSupportedRules(soap, tag?tag:"tan:GetSupportedRules", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tan__GetSupportedRules ** SOAP_FMAC4 soap_get_PointerTo_tan__GetSupportedRules(struct soap *soap, struct _tan__GetSupportedRules **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tan__GetSupportedRules(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetAnalyticsStateResponse(struct soap *soap, struct _tad__GetAnalyticsStateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetAnalyticsStateResponse))
		soap_serialize__tad__GetAnalyticsStateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetAnalyticsStateResponse(struct soap *soap, const char *tag, int id, struct _tad__GetAnalyticsStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetAnalyticsStateResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetAnalyticsStateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetAnalyticsStateResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__GetAnalyticsStateResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsStateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetAnalyticsStateResponse **)soap_malloc(soap, sizeof(struct _tad__GetAnalyticsStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetAnalyticsStateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsStateResponse, sizeof(struct _tad__GetAnalyticsStateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetAnalyticsStateResponse(struct soap *soap, struct _tad__GetAnalyticsStateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetAnalyticsStateResponse);
	if (soap_out_PointerTo_tad__GetAnalyticsStateResponse(soap, tag?tag:"tad:GetAnalyticsStateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsStateResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__GetAnalyticsStateResponse(struct soap *soap, struct _tad__GetAnalyticsStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetAnalyticsStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetAnalyticsState(struct soap *soap, struct _tad__GetAnalyticsState *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetAnalyticsState))
		soap_serialize__tad__GetAnalyticsState(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetAnalyticsState(struct soap *soap, const char *tag, int id, struct _tad__GetAnalyticsState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetAnalyticsState);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetAnalyticsState(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetAnalyticsState ** SOAP_FMAC4 soap_in_PointerTo_tad__GetAnalyticsState(struct soap *soap, const char *tag, struct _tad__GetAnalyticsState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetAnalyticsState **)soap_malloc(soap, sizeof(struct _tad__GetAnalyticsState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetAnalyticsState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsState, sizeof(struct _tad__GetAnalyticsState), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetAnalyticsState(struct soap *soap, struct _tad__GetAnalyticsState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetAnalyticsState);
	if (soap_out_PointerTo_tad__GetAnalyticsState(soap, tag?tag:"tad:GetAnalyticsState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsState ** SOAP_FMAC4 soap_get_PointerTo_tad__GetAnalyticsState(struct soap *soap, struct _tad__GetAnalyticsState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetAnalyticsState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse))
		soap_serialize__tad__DeleteAnalyticsEngineInputsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, int id, struct _tad__DeleteAnalyticsEngineInputsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tad__DeleteAnalyticsEngineInputsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputsResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, struct _tad__DeleteAnalyticsEngineInputsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__DeleteAnalyticsEngineInputsResponse **)soap_malloc(soap, sizeof(struct _tad__DeleteAnalyticsEngineInputsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__DeleteAnalyticsEngineInputsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__DeleteAnalyticsEngineInputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputsResponse, sizeof(struct _tad__DeleteAnalyticsEngineInputsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__DeleteAnalyticsEngineInputsResponse);
	if (soap_out_PointerTo_tad__DeleteAnalyticsEngineInputsResponse(soap, tag?tag:"tad:DeleteAnalyticsEngineInputsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputsResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__DeleteAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__DeleteAnalyticsEngineInputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__DeleteAnalyticsEngineInputs(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputs *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputs))
		soap_serialize__tad__DeleteAnalyticsEngineInputs(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__DeleteAnalyticsEngineInputs(struct soap *soap, const char *tag, int id, struct _tad__DeleteAnalyticsEngineInputs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__DeleteAnalyticsEngineInputs);
	if (id < 0)
		return soap->error;
	return soap_out__tad__DeleteAnalyticsEngineInputs(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputs ** SOAP_FMAC4 soap_in_PointerTo_tad__DeleteAnalyticsEngineInputs(struct soap *soap, const char *tag, struct _tad__DeleteAnalyticsEngineInputs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__DeleteAnalyticsEngineInputs **)soap_malloc(soap, sizeof(struct _tad__DeleteAnalyticsEngineInputs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__DeleteAnalyticsEngineInputs(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__DeleteAnalyticsEngineInputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__DeleteAnalyticsEngineInputs, sizeof(struct _tad__DeleteAnalyticsEngineInputs), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__DeleteAnalyticsEngineInputs(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__DeleteAnalyticsEngineInputs);
	if (soap_out_PointerTo_tad__DeleteAnalyticsEngineInputs(soap, tag?tag:"tad:DeleteAnalyticsEngineInputs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineInputs ** SOAP_FMAC4 soap_get_PointerTo_tad__DeleteAnalyticsEngineInputs(struct soap *soap, struct _tad__DeleteAnalyticsEngineInputs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__DeleteAnalyticsEngineInputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__CreateAnalyticsEngineInputsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse))
		soap_serialize__tad__CreateAnalyticsEngineInputsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, int id, struct _tad__CreateAnalyticsEngineInputsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tad__CreateAnalyticsEngineInputsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputsResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, struct _tad__CreateAnalyticsEngineInputsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__CreateAnalyticsEngineInputsResponse **)soap_malloc(soap, sizeof(struct _tad__CreateAnalyticsEngineInputsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__CreateAnalyticsEngineInputsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__CreateAnalyticsEngineInputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__CreateAnalyticsEngineInputsResponse, sizeof(struct _tad__CreateAnalyticsEngineInputsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__CreateAnalyticsEngineInputsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__CreateAnalyticsEngineInputsResponse);
	if (soap_out_PointerTo_tad__CreateAnalyticsEngineInputsResponse(soap, tag?tag:"tad:CreateAnalyticsEngineInputsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputsResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__CreateAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__CreateAnalyticsEngineInputsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__CreateAnalyticsEngineInputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__CreateAnalyticsEngineInputs(struct soap *soap, struct _tad__CreateAnalyticsEngineInputs *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__CreateAnalyticsEngineInputs))
		soap_serialize__tad__CreateAnalyticsEngineInputs(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__CreateAnalyticsEngineInputs(struct soap *soap, const char *tag, int id, struct _tad__CreateAnalyticsEngineInputs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__CreateAnalyticsEngineInputs);
	if (id < 0)
		return soap->error;
	return soap_out__tad__CreateAnalyticsEngineInputs(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputs ** SOAP_FMAC4 soap_in_PointerTo_tad__CreateAnalyticsEngineInputs(struct soap *soap, const char *tag, struct _tad__CreateAnalyticsEngineInputs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__CreateAnalyticsEngineInputs **)soap_malloc(soap, sizeof(struct _tad__CreateAnalyticsEngineInputs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__CreateAnalyticsEngineInputs(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__CreateAnalyticsEngineInputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__CreateAnalyticsEngineInputs, sizeof(struct _tad__CreateAnalyticsEngineInputs), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__CreateAnalyticsEngineInputs(struct soap *soap, struct _tad__CreateAnalyticsEngineInputs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__CreateAnalyticsEngineInputs);
	if (soap_out_PointerTo_tad__CreateAnalyticsEngineInputs(soap, tag?tag:"tad:CreateAnalyticsEngineInputs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineInputs ** SOAP_FMAC4 soap_get_PointerTo_tad__CreateAnalyticsEngineInputs(struct soap *soap, struct _tad__CreateAnalyticsEngineInputs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__CreateAnalyticsEngineInputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _tad__GetVideoAnalyticsConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse))
		soap_serialize__tad__GetVideoAnalyticsConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tad__GetVideoAnalyticsConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetVideoAnalyticsConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _tad__GetVideoAnalyticsConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetVideoAnalyticsConfigurationResponse **)soap_malloc(soap, sizeof(struct _tad__GetVideoAnalyticsConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetVideoAnalyticsConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetVideoAnalyticsConfigurationResponse, sizeof(struct _tad__GetVideoAnalyticsConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _tad__GetVideoAnalyticsConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetVideoAnalyticsConfigurationResponse);
	if (soap_out_PointerTo_tad__GetVideoAnalyticsConfigurationResponse(soap, tag?tag:"tad:GetVideoAnalyticsConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__GetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _tad__GetVideoAnalyticsConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetVideoAnalyticsConfiguration(struct soap *soap, struct _tad__GetVideoAnalyticsConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetVideoAnalyticsConfiguration))
		soap_serialize__tad__GetVideoAnalyticsConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, struct _tad__GetVideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetVideoAnalyticsConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetVideoAnalyticsConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tad__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _tad__GetVideoAnalyticsConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(struct _tad__GetVideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetVideoAnalyticsConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetVideoAnalyticsConfiguration, sizeof(struct _tad__GetVideoAnalyticsConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetVideoAnalyticsConfiguration(struct soap *soap, struct _tad__GetVideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetVideoAnalyticsConfiguration);
	if (soap_out_PointerTo_tad__GetVideoAnalyticsConfiguration(soap, tag?tag:"tad:GetVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tad__GetVideoAnalyticsConfiguration(struct soap *soap, struct _tad__GetVideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetAnalyticsDeviceStreamUriResponse(struct soap *soap, struct _tad__GetAnalyticsDeviceStreamUriResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUriResponse))
		soap_serialize__tad__GetAnalyticsDeviceStreamUriResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetAnalyticsDeviceStreamUriResponse(struct soap *soap, const char *tag, int id, struct _tad__GetAnalyticsDeviceStreamUriResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUriResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetAnalyticsDeviceStreamUriResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetAnalyticsDeviceStreamUriResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__GetAnalyticsDeviceStreamUriResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsDeviceStreamUriResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetAnalyticsDeviceStreamUriResponse **)soap_malloc(soap, sizeof(struct _tad__GetAnalyticsDeviceStreamUriResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetAnalyticsDeviceStreamUriResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsDeviceStreamUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUriResponse, sizeof(struct _tad__GetAnalyticsDeviceStreamUriResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetAnalyticsDeviceStreamUriResponse(struct soap *soap, struct _tad__GetAnalyticsDeviceStreamUriResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetAnalyticsDeviceStreamUriResponse);
	if (soap_out_PointerTo_tad__GetAnalyticsDeviceStreamUriResponse(soap, tag?tag:"tad:GetAnalyticsDeviceStreamUriResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsDeviceStreamUriResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__GetAnalyticsDeviceStreamUriResponse(struct soap *soap, struct _tad__GetAnalyticsDeviceStreamUriResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetAnalyticsDeviceStreamUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetAnalyticsDeviceStreamUri(struct soap *soap, struct _tad__GetAnalyticsDeviceStreamUri *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUri))
		soap_serialize__tad__GetAnalyticsDeviceStreamUri(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetAnalyticsDeviceStreamUri(struct soap *soap, const char *tag, int id, struct _tad__GetAnalyticsDeviceStreamUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUri);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetAnalyticsDeviceStreamUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetAnalyticsDeviceStreamUri ** SOAP_FMAC4 soap_in_PointerTo_tad__GetAnalyticsDeviceStreamUri(struct soap *soap, const char *tag, struct _tad__GetAnalyticsDeviceStreamUri **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetAnalyticsDeviceStreamUri **)soap_malloc(soap, sizeof(struct _tad__GetAnalyticsDeviceStreamUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetAnalyticsDeviceStreamUri(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsDeviceStreamUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsDeviceStreamUri, sizeof(struct _tad__GetAnalyticsDeviceStreamUri), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetAnalyticsDeviceStreamUri(struct soap *soap, struct _tad__GetAnalyticsDeviceStreamUri *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetAnalyticsDeviceStreamUri);
	if (soap_out_PointerTo_tad__GetAnalyticsDeviceStreamUri(soap, tag?tag:"tad:GetAnalyticsDeviceStreamUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsDeviceStreamUri ** SOAP_FMAC4 soap_get_PointerTo_tad__GetAnalyticsDeviceStreamUri(struct soap *soap, struct _tad__GetAnalyticsDeviceStreamUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetAnalyticsDeviceStreamUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__GetAnalyticsEngineInputsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetAnalyticsEngineInputsResponse))
		soap_serialize__tad__GetAnalyticsEngineInputsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, int id, struct _tad__GetAnalyticsEngineInputsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetAnalyticsEngineInputsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetAnalyticsEngineInputsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputsResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__GetAnalyticsEngineInputsResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineInputsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetAnalyticsEngineInputsResponse **)soap_malloc(soap, sizeof(struct _tad__GetAnalyticsEngineInputsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetAnalyticsEngineInputsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineInputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngineInputsResponse, sizeof(struct _tad__GetAnalyticsEngineInputsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__GetAnalyticsEngineInputsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetAnalyticsEngineInputsResponse);
	if (soap_out_PointerTo_tad__GetAnalyticsEngineInputsResponse(soap, tag?tag:"tad:GetAnalyticsEngineInputsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputsResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__GetAnalyticsEngineInputsResponse(struct soap *soap, struct _tad__GetAnalyticsEngineInputsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetAnalyticsEngineInputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetAnalyticsEngineInputs(struct soap *soap, struct _tad__GetAnalyticsEngineInputs *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetAnalyticsEngineInputs))
		soap_serialize__tad__GetAnalyticsEngineInputs(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetAnalyticsEngineInputs(struct soap *soap, const char *tag, int id, struct _tad__GetAnalyticsEngineInputs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetAnalyticsEngineInputs);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetAnalyticsEngineInputs(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputs ** SOAP_FMAC4 soap_in_PointerTo_tad__GetAnalyticsEngineInputs(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineInputs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetAnalyticsEngineInputs **)soap_malloc(soap, sizeof(struct _tad__GetAnalyticsEngineInputs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetAnalyticsEngineInputs(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineInputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngineInputs, sizeof(struct _tad__GetAnalyticsEngineInputs), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetAnalyticsEngineInputs(struct soap *soap, struct _tad__GetAnalyticsEngineInputs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetAnalyticsEngineInputs);
	if (soap_out_PointerTo_tad__GetAnalyticsEngineInputs(soap, tag?tag:"tad:GetAnalyticsEngineInputs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputs ** SOAP_FMAC4 soap_get_PointerTo_tad__GetAnalyticsEngineInputs(struct soap *soap, struct _tad__GetAnalyticsEngineInputs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetAnalyticsEngineInputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetAnalyticsEngineInputResponse(struct soap *soap, struct _tad__GetAnalyticsEngineInputResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetAnalyticsEngineInputResponse))
		soap_serialize__tad__GetAnalyticsEngineInputResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetAnalyticsEngineInputResponse(struct soap *soap, const char *tag, int id, struct _tad__GetAnalyticsEngineInputResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetAnalyticsEngineInputResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetAnalyticsEngineInputResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__GetAnalyticsEngineInputResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineInputResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetAnalyticsEngineInputResponse **)soap_malloc(soap, sizeof(struct _tad__GetAnalyticsEngineInputResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetAnalyticsEngineInputResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineInputResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngineInputResponse, sizeof(struct _tad__GetAnalyticsEngineInputResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetAnalyticsEngineInputResponse(struct soap *soap, struct _tad__GetAnalyticsEngineInputResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetAnalyticsEngineInputResponse);
	if (soap_out_PointerTo_tad__GetAnalyticsEngineInputResponse(soap, tag?tag:"tad:GetAnalyticsEngineInputResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInputResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__GetAnalyticsEngineInputResponse(struct soap *soap, struct _tad__GetAnalyticsEngineInputResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetAnalyticsEngineInputResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetAnalyticsEngineInput(struct soap *soap, struct _tad__GetAnalyticsEngineInput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetAnalyticsEngineInput))
		soap_serialize__tad__GetAnalyticsEngineInput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetAnalyticsEngineInput(struct soap *soap, const char *tag, int id, struct _tad__GetAnalyticsEngineInput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetAnalyticsEngineInput);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetAnalyticsEngineInput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInput ** SOAP_FMAC4 soap_in_PointerTo_tad__GetAnalyticsEngineInput(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineInput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetAnalyticsEngineInput **)soap_malloc(soap, sizeof(struct _tad__GetAnalyticsEngineInput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetAnalyticsEngineInput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineInput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngineInput, sizeof(struct _tad__GetAnalyticsEngineInput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetAnalyticsEngineInput(struct soap *soap, struct _tad__GetAnalyticsEngineInput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetAnalyticsEngineInput);
	if (soap_out_PointerTo_tad__GetAnalyticsEngineInput(soap, tag?tag:"tad:GetAnalyticsEngineInput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineInput ** SOAP_FMAC4 soap_get_PointerTo_tad__GetAnalyticsEngineInput(struct soap *soap, struct _tad__GetAnalyticsEngineInput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetAnalyticsEngineInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__SetAnalyticsEngineInputResponse(struct soap *soap, struct _tad__SetAnalyticsEngineInputResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__SetAnalyticsEngineInputResponse))
		soap_serialize__tad__SetAnalyticsEngineInputResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__SetAnalyticsEngineInputResponse(struct soap *soap, const char *tag, int id, struct _tad__SetAnalyticsEngineInputResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__SetAnalyticsEngineInputResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tad__SetAnalyticsEngineInputResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineInputResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__SetAnalyticsEngineInputResponse(struct soap *soap, const char *tag, struct _tad__SetAnalyticsEngineInputResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__SetAnalyticsEngineInputResponse **)soap_malloc(soap, sizeof(struct _tad__SetAnalyticsEngineInputResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__SetAnalyticsEngineInputResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__SetAnalyticsEngineInputResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__SetAnalyticsEngineInputResponse, sizeof(struct _tad__SetAnalyticsEngineInputResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__SetAnalyticsEngineInputResponse(struct soap *soap, struct _tad__SetAnalyticsEngineInputResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__SetAnalyticsEngineInputResponse);
	if (soap_out_PointerTo_tad__SetAnalyticsEngineInputResponse(soap, tag?tag:"tad:SetAnalyticsEngineInputResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineInputResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__SetAnalyticsEngineInputResponse(struct soap *soap, struct _tad__SetAnalyticsEngineInputResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__SetAnalyticsEngineInputResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__SetAnalyticsEngineInput(struct soap *soap, struct _tad__SetAnalyticsEngineInput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__SetAnalyticsEngineInput))
		soap_serialize__tad__SetAnalyticsEngineInput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__SetAnalyticsEngineInput(struct soap *soap, const char *tag, int id, struct _tad__SetAnalyticsEngineInput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__SetAnalyticsEngineInput);
	if (id < 0)
		return soap->error;
	return soap_out__tad__SetAnalyticsEngineInput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineInput ** SOAP_FMAC4 soap_in_PointerTo_tad__SetAnalyticsEngineInput(struct soap *soap, const char *tag, struct _tad__SetAnalyticsEngineInput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__SetAnalyticsEngineInput **)soap_malloc(soap, sizeof(struct _tad__SetAnalyticsEngineInput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__SetAnalyticsEngineInput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__SetAnalyticsEngineInput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__SetAnalyticsEngineInput, sizeof(struct _tad__SetAnalyticsEngineInput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__SetAnalyticsEngineInput(struct soap *soap, struct _tad__SetAnalyticsEngineInput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__SetAnalyticsEngineInput);
	if (soap_out_PointerTo_tad__SetAnalyticsEngineInput(soap, tag?tag:"tad:SetAnalyticsEngineInput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineInput ** SOAP_FMAC4 soap_get_PointerTo_tad__SetAnalyticsEngineInput(struct soap *soap, struct _tad__SetAnalyticsEngineInput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__SetAnalyticsEngineInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__SetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _tad__SetVideoAnalyticsConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__SetVideoAnalyticsConfigurationResponse))
		soap_serialize__tad__SetVideoAnalyticsConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__SetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tad__SetVideoAnalyticsConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__SetVideoAnalyticsConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tad__SetVideoAnalyticsConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__SetVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__SetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _tad__SetVideoAnalyticsConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__SetVideoAnalyticsConfigurationResponse **)soap_malloc(soap, sizeof(struct _tad__SetVideoAnalyticsConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__SetVideoAnalyticsConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__SetVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__SetVideoAnalyticsConfigurationResponse, sizeof(struct _tad__SetVideoAnalyticsConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__SetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _tad__SetVideoAnalyticsConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__SetVideoAnalyticsConfigurationResponse);
	if (soap_out_PointerTo_tad__SetVideoAnalyticsConfigurationResponse(soap, tag?tag:"tad:SetVideoAnalyticsConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__SetVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__SetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _tad__SetVideoAnalyticsConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__SetVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__SetVideoAnalyticsConfiguration(struct soap *soap, struct _tad__SetVideoAnalyticsConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__SetVideoAnalyticsConfiguration))
		soap_serialize__tad__SetVideoAnalyticsConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, struct _tad__SetVideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__SetVideoAnalyticsConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tad__SetVideoAnalyticsConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__SetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tad__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _tad__SetVideoAnalyticsConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__SetVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(struct _tad__SetVideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__SetVideoAnalyticsConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__SetVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__SetVideoAnalyticsConfiguration, sizeof(struct _tad__SetVideoAnalyticsConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__SetVideoAnalyticsConfiguration(struct soap *soap, struct _tad__SetVideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__SetVideoAnalyticsConfiguration);
	if (soap_out_PointerTo_tad__SetVideoAnalyticsConfiguration(soap, tag?tag:"tad:SetVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__SetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tad__SetVideoAnalyticsConfiguration(struct soap *soap, struct _tad__SetVideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__SetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetAnalyticsEnginesResponse(struct soap *soap, struct _tad__GetAnalyticsEnginesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetAnalyticsEnginesResponse))
		soap_serialize__tad__GetAnalyticsEnginesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetAnalyticsEnginesResponse(struct soap *soap, const char *tag, int id, struct _tad__GetAnalyticsEnginesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetAnalyticsEnginesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetAnalyticsEnginesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEnginesResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__GetAnalyticsEnginesResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEnginesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetAnalyticsEnginesResponse **)soap_malloc(soap, sizeof(struct _tad__GetAnalyticsEnginesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetAnalyticsEnginesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEnginesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEnginesResponse, sizeof(struct _tad__GetAnalyticsEnginesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetAnalyticsEnginesResponse(struct soap *soap, struct _tad__GetAnalyticsEnginesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetAnalyticsEnginesResponse);
	if (soap_out_PointerTo_tad__GetAnalyticsEnginesResponse(soap, tag?tag:"tad:GetAnalyticsEnginesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEnginesResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__GetAnalyticsEnginesResponse(struct soap *soap, struct _tad__GetAnalyticsEnginesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetAnalyticsEnginesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetAnalyticsEngines(struct soap *soap, struct _tad__GetAnalyticsEngines *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetAnalyticsEngines))
		soap_serialize__tad__GetAnalyticsEngines(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetAnalyticsEngines(struct soap *soap, const char *tag, int id, struct _tad__GetAnalyticsEngines *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetAnalyticsEngines);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetAnalyticsEngines(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngines ** SOAP_FMAC4 soap_in_PointerTo_tad__GetAnalyticsEngines(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngines **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetAnalyticsEngines **)soap_malloc(soap, sizeof(struct _tad__GetAnalyticsEngines *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetAnalyticsEngines(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngines **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngines, sizeof(struct _tad__GetAnalyticsEngines), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetAnalyticsEngines(struct soap *soap, struct _tad__GetAnalyticsEngines *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetAnalyticsEngines);
	if (soap_out_PointerTo_tad__GetAnalyticsEngines(soap, tag?tag:"tad:GetAnalyticsEngines", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngines ** SOAP_FMAC4 soap_get_PointerTo_tad__GetAnalyticsEngines(struct soap *soap, struct _tad__GetAnalyticsEngines **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetAnalyticsEngines(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetAnalyticsEngineResponse(struct soap *soap, struct _tad__GetAnalyticsEngineResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetAnalyticsEngineResponse))
		soap_serialize__tad__GetAnalyticsEngineResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetAnalyticsEngineResponse(struct soap *soap, const char *tag, int id, struct _tad__GetAnalyticsEngineResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetAnalyticsEngineResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetAnalyticsEngineResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__GetAnalyticsEngineResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetAnalyticsEngineResponse **)soap_malloc(soap, sizeof(struct _tad__GetAnalyticsEngineResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetAnalyticsEngineResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngineResponse, sizeof(struct _tad__GetAnalyticsEngineResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetAnalyticsEngineResponse(struct soap *soap, struct _tad__GetAnalyticsEngineResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetAnalyticsEngineResponse);
	if (soap_out_PointerTo_tad__GetAnalyticsEngineResponse(soap, tag?tag:"tad:GetAnalyticsEngineResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__GetAnalyticsEngineResponse(struct soap *soap, struct _tad__GetAnalyticsEngineResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetAnalyticsEngineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetAnalyticsEngine(struct soap *soap, struct _tad__GetAnalyticsEngine *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetAnalyticsEngine))
		soap_serialize__tad__GetAnalyticsEngine(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetAnalyticsEngine(struct soap *soap, const char *tag, int id, struct _tad__GetAnalyticsEngine *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetAnalyticsEngine);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetAnalyticsEngine(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngine ** SOAP_FMAC4 soap_in_PointerTo_tad__GetAnalyticsEngine(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngine **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetAnalyticsEngine **)soap_malloc(soap, sizeof(struct _tad__GetAnalyticsEngine *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetAnalyticsEngine(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngine **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngine, sizeof(struct _tad__GetAnalyticsEngine), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetAnalyticsEngine(struct soap *soap, struct _tad__GetAnalyticsEngine *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetAnalyticsEngine);
	if (soap_out_PointerTo_tad__GetAnalyticsEngine(soap, tag?tag:"tad:GetAnalyticsEngine", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngine ** SOAP_FMAC4 soap_get_PointerTo_tad__GetAnalyticsEngine(struct soap *soap, struct _tad__GetAnalyticsEngine **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetAnalyticsEngine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetAnalyticsEngineControlsResponse(struct soap *soap, struct _tad__GetAnalyticsEngineControlsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetAnalyticsEngineControlsResponse))
		soap_serialize__tad__GetAnalyticsEngineControlsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetAnalyticsEngineControlsResponse(struct soap *soap, const char *tag, int id, struct _tad__GetAnalyticsEngineControlsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetAnalyticsEngineControlsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetAnalyticsEngineControlsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControlsResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__GetAnalyticsEngineControlsResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineControlsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetAnalyticsEngineControlsResponse **)soap_malloc(soap, sizeof(struct _tad__GetAnalyticsEngineControlsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetAnalyticsEngineControlsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineControlsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngineControlsResponse, sizeof(struct _tad__GetAnalyticsEngineControlsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetAnalyticsEngineControlsResponse(struct soap *soap, struct _tad__GetAnalyticsEngineControlsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetAnalyticsEngineControlsResponse);
	if (soap_out_PointerTo_tad__GetAnalyticsEngineControlsResponse(soap, tag?tag:"tad:GetAnalyticsEngineControlsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControlsResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__GetAnalyticsEngineControlsResponse(struct soap *soap, struct _tad__GetAnalyticsEngineControlsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetAnalyticsEngineControlsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetAnalyticsEngineControls(struct soap *soap, struct _tad__GetAnalyticsEngineControls *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetAnalyticsEngineControls))
		soap_serialize__tad__GetAnalyticsEngineControls(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetAnalyticsEngineControls(struct soap *soap, const char *tag, int id, struct _tad__GetAnalyticsEngineControls *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetAnalyticsEngineControls);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetAnalyticsEngineControls(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControls ** SOAP_FMAC4 soap_in_PointerTo_tad__GetAnalyticsEngineControls(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineControls **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetAnalyticsEngineControls **)soap_malloc(soap, sizeof(struct _tad__GetAnalyticsEngineControls *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetAnalyticsEngineControls(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineControls **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngineControls, sizeof(struct _tad__GetAnalyticsEngineControls), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetAnalyticsEngineControls(struct soap *soap, struct _tad__GetAnalyticsEngineControls *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetAnalyticsEngineControls);
	if (soap_out_PointerTo_tad__GetAnalyticsEngineControls(soap, tag?tag:"tad:GetAnalyticsEngineControls", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControls ** SOAP_FMAC4 soap_get_PointerTo_tad__GetAnalyticsEngineControls(struct soap *soap, struct _tad__GetAnalyticsEngineControls **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetAnalyticsEngineControls(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetAnalyticsEngineControlResponse(struct soap *soap, struct _tad__GetAnalyticsEngineControlResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetAnalyticsEngineControlResponse))
		soap_serialize__tad__GetAnalyticsEngineControlResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetAnalyticsEngineControlResponse(struct soap *soap, const char *tag, int id, struct _tad__GetAnalyticsEngineControlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetAnalyticsEngineControlResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetAnalyticsEngineControlResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControlResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__GetAnalyticsEngineControlResponse(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineControlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetAnalyticsEngineControlResponse **)soap_malloc(soap, sizeof(struct _tad__GetAnalyticsEngineControlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetAnalyticsEngineControlResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineControlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngineControlResponse, sizeof(struct _tad__GetAnalyticsEngineControlResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetAnalyticsEngineControlResponse(struct soap *soap, struct _tad__GetAnalyticsEngineControlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetAnalyticsEngineControlResponse);
	if (soap_out_PointerTo_tad__GetAnalyticsEngineControlResponse(soap, tag?tag:"tad:GetAnalyticsEngineControlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControlResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__GetAnalyticsEngineControlResponse(struct soap *soap, struct _tad__GetAnalyticsEngineControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetAnalyticsEngineControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetAnalyticsEngineControl(struct soap *soap, struct _tad__GetAnalyticsEngineControl *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetAnalyticsEngineControl))
		soap_serialize__tad__GetAnalyticsEngineControl(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetAnalyticsEngineControl(struct soap *soap, const char *tag, int id, struct _tad__GetAnalyticsEngineControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetAnalyticsEngineControl);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetAnalyticsEngineControl(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControl ** SOAP_FMAC4 soap_in_PointerTo_tad__GetAnalyticsEngineControl(struct soap *soap, const char *tag, struct _tad__GetAnalyticsEngineControl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetAnalyticsEngineControl **)soap_malloc(soap, sizeof(struct _tad__GetAnalyticsEngineControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetAnalyticsEngineControl(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetAnalyticsEngineControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetAnalyticsEngineControl, sizeof(struct _tad__GetAnalyticsEngineControl), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetAnalyticsEngineControl(struct soap *soap, struct _tad__GetAnalyticsEngineControl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetAnalyticsEngineControl);
	if (soap_out_PointerTo_tad__GetAnalyticsEngineControl(soap, tag?tag:"tad:GetAnalyticsEngineControl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetAnalyticsEngineControl ** SOAP_FMAC4 soap_get_PointerTo_tad__GetAnalyticsEngineControl(struct soap *soap, struct _tad__GetAnalyticsEngineControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetAnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__SetAnalyticsEngineControlResponse(struct soap *soap, struct _tad__SetAnalyticsEngineControlResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__SetAnalyticsEngineControlResponse))
		soap_serialize__tad__SetAnalyticsEngineControlResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__SetAnalyticsEngineControlResponse(struct soap *soap, const char *tag, int id, struct _tad__SetAnalyticsEngineControlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__SetAnalyticsEngineControlResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tad__SetAnalyticsEngineControlResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineControlResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__SetAnalyticsEngineControlResponse(struct soap *soap, const char *tag, struct _tad__SetAnalyticsEngineControlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__SetAnalyticsEngineControlResponse **)soap_malloc(soap, sizeof(struct _tad__SetAnalyticsEngineControlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__SetAnalyticsEngineControlResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__SetAnalyticsEngineControlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__SetAnalyticsEngineControlResponse, sizeof(struct _tad__SetAnalyticsEngineControlResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__SetAnalyticsEngineControlResponse(struct soap *soap, struct _tad__SetAnalyticsEngineControlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__SetAnalyticsEngineControlResponse);
	if (soap_out_PointerTo_tad__SetAnalyticsEngineControlResponse(soap, tag?tag:"tad:SetAnalyticsEngineControlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineControlResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__SetAnalyticsEngineControlResponse(struct soap *soap, struct _tad__SetAnalyticsEngineControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__SetAnalyticsEngineControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__SetAnalyticsEngineControl(struct soap *soap, struct _tad__SetAnalyticsEngineControl *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__SetAnalyticsEngineControl))
		soap_serialize__tad__SetAnalyticsEngineControl(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__SetAnalyticsEngineControl(struct soap *soap, const char *tag, int id, struct _tad__SetAnalyticsEngineControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__SetAnalyticsEngineControl);
	if (id < 0)
		return soap->error;
	return soap_out__tad__SetAnalyticsEngineControl(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineControl ** SOAP_FMAC4 soap_in_PointerTo_tad__SetAnalyticsEngineControl(struct soap *soap, const char *tag, struct _tad__SetAnalyticsEngineControl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__SetAnalyticsEngineControl **)soap_malloc(soap, sizeof(struct _tad__SetAnalyticsEngineControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__SetAnalyticsEngineControl(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__SetAnalyticsEngineControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__SetAnalyticsEngineControl, sizeof(struct _tad__SetAnalyticsEngineControl), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__SetAnalyticsEngineControl(struct soap *soap, struct _tad__SetAnalyticsEngineControl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__SetAnalyticsEngineControl);
	if (soap_out_PointerTo_tad__SetAnalyticsEngineControl(soap, tag?tag:"tad:SetAnalyticsEngineControl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__SetAnalyticsEngineControl ** SOAP_FMAC4 soap_get_PointerTo_tad__SetAnalyticsEngineControl(struct soap *soap, struct _tad__SetAnalyticsEngineControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__SetAnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__CreateAnalyticsEngineControlResponse(struct soap *soap, struct _tad__CreateAnalyticsEngineControlResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__CreateAnalyticsEngineControlResponse))
		soap_serialize__tad__CreateAnalyticsEngineControlResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__CreateAnalyticsEngineControlResponse(struct soap *soap, const char *tag, int id, struct _tad__CreateAnalyticsEngineControlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__CreateAnalyticsEngineControlResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tad__CreateAnalyticsEngineControlResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineControlResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__CreateAnalyticsEngineControlResponse(struct soap *soap, const char *tag, struct _tad__CreateAnalyticsEngineControlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__CreateAnalyticsEngineControlResponse **)soap_malloc(soap, sizeof(struct _tad__CreateAnalyticsEngineControlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__CreateAnalyticsEngineControlResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__CreateAnalyticsEngineControlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__CreateAnalyticsEngineControlResponse, sizeof(struct _tad__CreateAnalyticsEngineControlResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__CreateAnalyticsEngineControlResponse(struct soap *soap, struct _tad__CreateAnalyticsEngineControlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__CreateAnalyticsEngineControlResponse);
	if (soap_out_PointerTo_tad__CreateAnalyticsEngineControlResponse(soap, tag?tag:"tad:CreateAnalyticsEngineControlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineControlResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__CreateAnalyticsEngineControlResponse(struct soap *soap, struct _tad__CreateAnalyticsEngineControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__CreateAnalyticsEngineControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__CreateAnalyticsEngineControl(struct soap *soap, struct _tad__CreateAnalyticsEngineControl *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__CreateAnalyticsEngineControl))
		soap_serialize__tad__CreateAnalyticsEngineControl(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__CreateAnalyticsEngineControl(struct soap *soap, const char *tag, int id, struct _tad__CreateAnalyticsEngineControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__CreateAnalyticsEngineControl);
	if (id < 0)
		return soap->error;
	return soap_out__tad__CreateAnalyticsEngineControl(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineControl ** SOAP_FMAC4 soap_in_PointerTo_tad__CreateAnalyticsEngineControl(struct soap *soap, const char *tag, struct _tad__CreateAnalyticsEngineControl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__CreateAnalyticsEngineControl **)soap_malloc(soap, sizeof(struct _tad__CreateAnalyticsEngineControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__CreateAnalyticsEngineControl(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__CreateAnalyticsEngineControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__CreateAnalyticsEngineControl, sizeof(struct _tad__CreateAnalyticsEngineControl), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__CreateAnalyticsEngineControl(struct soap *soap, struct _tad__CreateAnalyticsEngineControl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__CreateAnalyticsEngineControl);
	if (soap_out_PointerTo_tad__CreateAnalyticsEngineControl(soap, tag?tag:"tad:CreateAnalyticsEngineControl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__CreateAnalyticsEngineControl ** SOAP_FMAC4 soap_get_PointerTo_tad__CreateAnalyticsEngineControl(struct soap *soap, struct _tad__CreateAnalyticsEngineControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__CreateAnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__DeleteAnalyticsEngineControlResponse(struct soap *soap, struct _tad__DeleteAnalyticsEngineControlResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__DeleteAnalyticsEngineControlResponse))
		soap_serialize__tad__DeleteAnalyticsEngineControlResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__DeleteAnalyticsEngineControlResponse(struct soap *soap, const char *tag, int id, struct _tad__DeleteAnalyticsEngineControlResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__DeleteAnalyticsEngineControlResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tad__DeleteAnalyticsEngineControlResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineControlResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__DeleteAnalyticsEngineControlResponse(struct soap *soap, const char *tag, struct _tad__DeleteAnalyticsEngineControlResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__DeleteAnalyticsEngineControlResponse **)soap_malloc(soap, sizeof(struct _tad__DeleteAnalyticsEngineControlResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__DeleteAnalyticsEngineControlResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__DeleteAnalyticsEngineControlResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__DeleteAnalyticsEngineControlResponse, sizeof(struct _tad__DeleteAnalyticsEngineControlResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__DeleteAnalyticsEngineControlResponse(struct soap *soap, struct _tad__DeleteAnalyticsEngineControlResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__DeleteAnalyticsEngineControlResponse);
	if (soap_out_PointerTo_tad__DeleteAnalyticsEngineControlResponse(soap, tag?tag:"tad:DeleteAnalyticsEngineControlResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineControlResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__DeleteAnalyticsEngineControlResponse(struct soap *soap, struct _tad__DeleteAnalyticsEngineControlResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__DeleteAnalyticsEngineControlResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__DeleteAnalyticsEngineControl(struct soap *soap, struct _tad__DeleteAnalyticsEngineControl *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__DeleteAnalyticsEngineControl))
		soap_serialize__tad__DeleteAnalyticsEngineControl(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__DeleteAnalyticsEngineControl(struct soap *soap, const char *tag, int id, struct _tad__DeleteAnalyticsEngineControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__DeleteAnalyticsEngineControl);
	if (id < 0)
		return soap->error;
	return soap_out__tad__DeleteAnalyticsEngineControl(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineControl ** SOAP_FMAC4 soap_in_PointerTo_tad__DeleteAnalyticsEngineControl(struct soap *soap, const char *tag, struct _tad__DeleteAnalyticsEngineControl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__DeleteAnalyticsEngineControl **)soap_malloc(soap, sizeof(struct _tad__DeleteAnalyticsEngineControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__DeleteAnalyticsEngineControl(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__DeleteAnalyticsEngineControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__DeleteAnalyticsEngineControl, sizeof(struct _tad__DeleteAnalyticsEngineControl), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__DeleteAnalyticsEngineControl(struct soap *soap, struct _tad__DeleteAnalyticsEngineControl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__DeleteAnalyticsEngineControl);
	if (soap_out_PointerTo_tad__DeleteAnalyticsEngineControl(soap, tag?tag:"tad:DeleteAnalyticsEngineControl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__DeleteAnalyticsEngineControl ** SOAP_FMAC4 soap_get_PointerTo_tad__DeleteAnalyticsEngineControl(struct soap *soap, struct _tad__DeleteAnalyticsEngineControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__DeleteAnalyticsEngineControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetServiceCapabilitiesResponse(struct soap *soap, struct _tad__GetServiceCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetServiceCapabilitiesResponse))
		soap_serialize__tad__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tad__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tad__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tad__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tad__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetServiceCapabilitiesResponse, sizeof(struct _tad__GetServiceCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetServiceCapabilitiesResponse(struct soap *soap, struct _tad__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_tad__GetServiceCapabilitiesResponse(soap, tag?tag:"tad:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tad__GetServiceCapabilitiesResponse(struct soap *soap, struct _tad__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tad__GetServiceCapabilities(struct soap *soap, struct _tad__GetServiceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tad__GetServiceCapabilities))
		soap_serialize__tad__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tad__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _tad__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tad__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__tad__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tad__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tad__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tad__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tad__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _tad__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tad__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tad__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tad__GetServiceCapabilities, sizeof(struct _tad__GetServiceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tad__GetServiceCapabilities(struct soap *soap, struct _tad__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tad__GetServiceCapabilities);
	if (soap_out_PointerTo_tad__GetServiceCapabilities(soap, tag?tag:"tad:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tad__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tad__GetServiceCapabilities(struct soap *soap, struct _tad__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tad__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ModifyActionTriggersResponse(struct soap *soap, struct _ns1__ModifyActionTriggersResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ModifyActionTriggersResponse))
		soap_serialize__ns1__ModifyActionTriggersResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ModifyActionTriggersResponse(struct soap *soap, const char *tag, int id, struct _ns1__ModifyActionTriggersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ModifyActionTriggersResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ModifyActionTriggersResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ModifyActionTriggersResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__ModifyActionTriggersResponse(struct soap *soap, const char *tag, struct _ns1__ModifyActionTriggersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ModifyActionTriggersResponse **)soap_malloc(soap, sizeof(struct _ns1__ModifyActionTriggersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ModifyActionTriggersResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ModifyActionTriggersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ModifyActionTriggersResponse, sizeof(struct _ns1__ModifyActionTriggersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ModifyActionTriggersResponse(struct soap *soap, struct _ns1__ModifyActionTriggersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ModifyActionTriggersResponse);
	if (soap_out_PointerTo_ns1__ModifyActionTriggersResponse(soap, tag?tag:"ns1:ModifyActionTriggersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ModifyActionTriggersResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__ModifyActionTriggersResponse(struct soap *soap, struct _ns1__ModifyActionTriggersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ModifyActionTriggersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ModifyActionTriggers(struct soap *soap, struct _ns1__ModifyActionTriggers *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ModifyActionTriggers))
		soap_serialize__ns1__ModifyActionTriggers(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ModifyActionTriggers(struct soap *soap, const char *tag, int id, struct _ns1__ModifyActionTriggers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ModifyActionTriggers);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ModifyActionTriggers(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ModifyActionTriggers ** SOAP_FMAC4 soap_in_PointerTo_ns1__ModifyActionTriggers(struct soap *soap, const char *tag, struct _ns1__ModifyActionTriggers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ModifyActionTriggers **)soap_malloc(soap, sizeof(struct _ns1__ModifyActionTriggers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ModifyActionTriggers(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ModifyActionTriggers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ModifyActionTriggers, sizeof(struct _ns1__ModifyActionTriggers), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ModifyActionTriggers(struct soap *soap, struct _ns1__ModifyActionTriggers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ModifyActionTriggers);
	if (soap_out_PointerTo_ns1__ModifyActionTriggers(soap, tag?tag:"ns1:ModifyActionTriggers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ModifyActionTriggers ** SOAP_FMAC4 soap_get_PointerTo_ns1__ModifyActionTriggers(struct soap *soap, struct _ns1__ModifyActionTriggers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ModifyActionTriggers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeleteActionTriggersResponse(struct soap *soap, struct _ns1__DeleteActionTriggersResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeleteActionTriggersResponse))
		soap_serialize__ns1__DeleteActionTriggersResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeleteActionTriggersResponse(struct soap *soap, const char *tag, int id, struct _ns1__DeleteActionTriggersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeleteActionTriggersResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__DeleteActionTriggersResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__DeleteActionTriggersResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeleteActionTriggersResponse(struct soap *soap, const char *tag, struct _ns1__DeleteActionTriggersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__DeleteActionTriggersResponse **)soap_malloc(soap, sizeof(struct _ns1__DeleteActionTriggersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__DeleteActionTriggersResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__DeleteActionTriggersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteActionTriggersResponse, sizeof(struct _ns1__DeleteActionTriggersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeleteActionTriggersResponse(struct soap *soap, struct _ns1__DeleteActionTriggersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DeleteActionTriggersResponse);
	if (soap_out_PointerTo_ns1__DeleteActionTriggersResponse(soap, tag?tag:"ns1:DeleteActionTriggersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__DeleteActionTriggersResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeleteActionTriggersResponse(struct soap *soap, struct _ns1__DeleteActionTriggersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeleteActionTriggersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeleteActionTriggers(struct soap *soap, struct _ns1__DeleteActionTriggers *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeleteActionTriggers))
		soap_serialize__ns1__DeleteActionTriggers(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeleteActionTriggers(struct soap *soap, const char *tag, int id, struct _ns1__DeleteActionTriggers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeleteActionTriggers);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__DeleteActionTriggers(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__DeleteActionTriggers ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeleteActionTriggers(struct soap *soap, const char *tag, struct _ns1__DeleteActionTriggers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__DeleteActionTriggers **)soap_malloc(soap, sizeof(struct _ns1__DeleteActionTriggers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__DeleteActionTriggers(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__DeleteActionTriggers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteActionTriggers, sizeof(struct _ns1__DeleteActionTriggers), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeleteActionTriggers(struct soap *soap, struct _ns1__DeleteActionTriggers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DeleteActionTriggers);
	if (soap_out_PointerTo_ns1__DeleteActionTriggers(soap, tag?tag:"ns1:DeleteActionTriggers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__DeleteActionTriggers ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeleteActionTriggers(struct soap *soap, struct _ns1__DeleteActionTriggers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeleteActionTriggers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CreateActionTriggersResponse(struct soap *soap, struct _ns1__CreateActionTriggersResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CreateActionTriggersResponse))
		soap_serialize__ns1__CreateActionTriggersResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CreateActionTriggersResponse(struct soap *soap, const char *tag, int id, struct _ns1__CreateActionTriggersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CreateActionTriggersResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__CreateActionTriggersResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__CreateActionTriggersResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__CreateActionTriggersResponse(struct soap *soap, const char *tag, struct _ns1__CreateActionTriggersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__CreateActionTriggersResponse **)soap_malloc(soap, sizeof(struct _ns1__CreateActionTriggersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__CreateActionTriggersResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__CreateActionTriggersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CreateActionTriggersResponse, sizeof(struct _ns1__CreateActionTriggersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CreateActionTriggersResponse(struct soap *soap, struct _ns1__CreateActionTriggersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CreateActionTriggersResponse);
	if (soap_out_PointerTo_ns1__CreateActionTriggersResponse(soap, tag?tag:"ns1:CreateActionTriggersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__CreateActionTriggersResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__CreateActionTriggersResponse(struct soap *soap, struct _ns1__CreateActionTriggersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CreateActionTriggersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CreateActionTriggers(struct soap *soap, struct _ns1__CreateActionTriggers *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CreateActionTriggers))
		soap_serialize__ns1__CreateActionTriggers(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CreateActionTriggers(struct soap *soap, const char *tag, int id, struct _ns1__CreateActionTriggers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CreateActionTriggers);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__CreateActionTriggers(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__CreateActionTriggers ** SOAP_FMAC4 soap_in_PointerTo_ns1__CreateActionTriggers(struct soap *soap, const char *tag, struct _ns1__CreateActionTriggers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__CreateActionTriggers **)soap_malloc(soap, sizeof(struct _ns1__CreateActionTriggers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__CreateActionTriggers(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__CreateActionTriggers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CreateActionTriggers, sizeof(struct _ns1__CreateActionTriggers), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CreateActionTriggers(struct soap *soap, struct _ns1__CreateActionTriggers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CreateActionTriggers);
	if (soap_out_PointerTo_ns1__CreateActionTriggers(soap, tag?tag:"ns1:CreateActionTriggers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__CreateActionTriggers ** SOAP_FMAC4 soap_get_PointerTo_ns1__CreateActionTriggers(struct soap *soap, struct _ns1__CreateActionTriggers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CreateActionTriggers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetActionTriggersResponse(struct soap *soap, struct _ns1__GetActionTriggersResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetActionTriggersResponse))
		soap_serialize__ns1__GetActionTriggersResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetActionTriggersResponse(struct soap *soap, const char *tag, int id, struct _ns1__GetActionTriggersResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetActionTriggersResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetActionTriggersResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetActionTriggersResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetActionTriggersResponse(struct soap *soap, const char *tag, struct _ns1__GetActionTriggersResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetActionTriggersResponse **)soap_malloc(soap, sizeof(struct _ns1__GetActionTriggersResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetActionTriggersResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetActionTriggersResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetActionTriggersResponse, sizeof(struct _ns1__GetActionTriggersResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetActionTriggersResponse(struct soap *soap, struct _ns1__GetActionTriggersResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetActionTriggersResponse);
	if (soap_out_PointerTo_ns1__GetActionTriggersResponse(soap, tag?tag:"ns1:GetActionTriggersResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetActionTriggersResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetActionTriggersResponse(struct soap *soap, struct _ns1__GetActionTriggersResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetActionTriggersResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetActionTriggers(struct soap *soap, struct _ns1__GetActionTriggers *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetActionTriggers))
		soap_serialize__ns1__GetActionTriggers(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetActionTriggers(struct soap *soap, const char *tag, int id, struct _ns1__GetActionTriggers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetActionTriggers);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetActionTriggers(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetActionTriggers ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetActionTriggers(struct soap *soap, const char *tag, struct _ns1__GetActionTriggers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetActionTriggers **)soap_malloc(soap, sizeof(struct _ns1__GetActionTriggers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetActionTriggers(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetActionTriggers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetActionTriggers, sizeof(struct _ns1__GetActionTriggers), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetActionTriggers(struct soap *soap, struct _ns1__GetActionTriggers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetActionTriggers);
	if (soap_out_PointerTo_ns1__GetActionTriggers(soap, tag?tag:"ns1:GetActionTriggers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetActionTriggers ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetActionTriggers(struct soap *soap, struct _ns1__GetActionTriggers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetActionTriggers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetServiceCapabilitiesResponse(struct soap *soap, struct _ns1__GetServiceCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetServiceCapabilitiesResponse))
		soap_serialize__ns1__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _ns1__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _ns1__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _ns1__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetServiceCapabilitiesResponse, sizeof(struct _ns1__GetServiceCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetServiceCapabilitiesResponse(struct soap *soap, struct _ns1__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_ns1__GetServiceCapabilitiesResponse(soap, tag?tag:"ns1:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetServiceCapabilitiesResponse(struct soap *soap, struct _ns1__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetServiceCapabilities(struct soap *soap, struct _ns1__GetServiceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetServiceCapabilities))
		soap_serialize__ns1__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _ns1__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetServiceCapabilities(struct soap *soap, const char *tag, struct _ns1__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _ns1__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetServiceCapabilities, sizeof(struct _ns1__GetServiceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetServiceCapabilities(struct soap *soap, struct _ns1__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetServiceCapabilities);
	if (soap_out_PointerTo_ns1__GetServiceCapabilities(soap, tag?tag:"ns1:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetServiceCapabilities(struct soap *soap, struct _ns1__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ModifyActionsResponse(struct soap *soap, struct _ns1__ModifyActionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ModifyActionsResponse))
		soap_serialize__ns1__ModifyActionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ModifyActionsResponse(struct soap *soap, const char *tag, int id, struct _ns1__ModifyActionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ModifyActionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ModifyActionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ModifyActionsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__ModifyActionsResponse(struct soap *soap, const char *tag, struct _ns1__ModifyActionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ModifyActionsResponse **)soap_malloc(soap, sizeof(struct _ns1__ModifyActionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ModifyActionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ModifyActionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ModifyActionsResponse, sizeof(struct _ns1__ModifyActionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ModifyActionsResponse(struct soap *soap, struct _ns1__ModifyActionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ModifyActionsResponse);
	if (soap_out_PointerTo_ns1__ModifyActionsResponse(soap, tag?tag:"ns1:ModifyActionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ModifyActionsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__ModifyActionsResponse(struct soap *soap, struct _ns1__ModifyActionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ModifyActionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__ModifyActions(struct soap *soap, struct _ns1__ModifyActions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__ModifyActions))
		soap_serialize__ns1__ModifyActions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__ModifyActions(struct soap *soap, const char *tag, int id, struct _ns1__ModifyActions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__ModifyActions);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__ModifyActions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__ModifyActions ** SOAP_FMAC4 soap_in_PointerTo_ns1__ModifyActions(struct soap *soap, const char *tag, struct _ns1__ModifyActions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__ModifyActions **)soap_malloc(soap, sizeof(struct _ns1__ModifyActions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__ModifyActions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__ModifyActions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__ModifyActions, sizeof(struct _ns1__ModifyActions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__ModifyActions(struct soap *soap, struct _ns1__ModifyActions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__ModifyActions);
	if (soap_out_PointerTo_ns1__ModifyActions(soap, tag?tag:"ns1:ModifyActions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__ModifyActions ** SOAP_FMAC4 soap_get_PointerTo_ns1__ModifyActions(struct soap *soap, struct _ns1__ModifyActions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__ModifyActions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeleteActionsResponse(struct soap *soap, struct _ns1__DeleteActionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeleteActionsResponse))
		soap_serialize__ns1__DeleteActionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeleteActionsResponse(struct soap *soap, const char *tag, int id, struct _ns1__DeleteActionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeleteActionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__DeleteActionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__DeleteActionsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeleteActionsResponse(struct soap *soap, const char *tag, struct _ns1__DeleteActionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__DeleteActionsResponse **)soap_malloc(soap, sizeof(struct _ns1__DeleteActionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__DeleteActionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__DeleteActionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteActionsResponse, sizeof(struct _ns1__DeleteActionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeleteActionsResponse(struct soap *soap, struct _ns1__DeleteActionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DeleteActionsResponse);
	if (soap_out_PointerTo_ns1__DeleteActionsResponse(soap, tag?tag:"ns1:DeleteActionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__DeleteActionsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeleteActionsResponse(struct soap *soap, struct _ns1__DeleteActionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeleteActionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__DeleteActions(struct soap *soap, struct _ns1__DeleteActions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__DeleteActions))
		soap_serialize__ns1__DeleteActions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__DeleteActions(struct soap *soap, const char *tag, int id, struct _ns1__DeleteActions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__DeleteActions);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__DeleteActions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__DeleteActions ** SOAP_FMAC4 soap_in_PointerTo_ns1__DeleteActions(struct soap *soap, const char *tag, struct _ns1__DeleteActions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__DeleteActions **)soap_malloc(soap, sizeof(struct _ns1__DeleteActions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__DeleteActions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__DeleteActions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__DeleteActions, sizeof(struct _ns1__DeleteActions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__DeleteActions(struct soap *soap, struct _ns1__DeleteActions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__DeleteActions);
	if (soap_out_PointerTo_ns1__DeleteActions(soap, tag?tag:"ns1:DeleteActions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__DeleteActions ** SOAP_FMAC4 soap_get_PointerTo_ns1__DeleteActions(struct soap *soap, struct _ns1__DeleteActions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__DeleteActions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CreateActionsResponse(struct soap *soap, struct _ns1__CreateActionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CreateActionsResponse))
		soap_serialize__ns1__CreateActionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CreateActionsResponse(struct soap *soap, const char *tag, int id, struct _ns1__CreateActionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CreateActionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__CreateActionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__CreateActionsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__CreateActionsResponse(struct soap *soap, const char *tag, struct _ns1__CreateActionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__CreateActionsResponse **)soap_malloc(soap, sizeof(struct _ns1__CreateActionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__CreateActionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__CreateActionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CreateActionsResponse, sizeof(struct _ns1__CreateActionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CreateActionsResponse(struct soap *soap, struct _ns1__CreateActionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CreateActionsResponse);
	if (soap_out_PointerTo_ns1__CreateActionsResponse(soap, tag?tag:"ns1:CreateActionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__CreateActionsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__CreateActionsResponse(struct soap *soap, struct _ns1__CreateActionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CreateActionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__CreateActions(struct soap *soap, struct _ns1__CreateActions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__CreateActions))
		soap_serialize__ns1__CreateActions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__CreateActions(struct soap *soap, const char *tag, int id, struct _ns1__CreateActions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__CreateActions);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__CreateActions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__CreateActions ** SOAP_FMAC4 soap_in_PointerTo_ns1__CreateActions(struct soap *soap, const char *tag, struct _ns1__CreateActions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__CreateActions **)soap_malloc(soap, sizeof(struct _ns1__CreateActions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__CreateActions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__CreateActions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__CreateActions, sizeof(struct _ns1__CreateActions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__CreateActions(struct soap *soap, struct _ns1__CreateActions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__CreateActions);
	if (soap_out_PointerTo_ns1__CreateActions(soap, tag?tag:"ns1:CreateActions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__CreateActions ** SOAP_FMAC4 soap_get_PointerTo_ns1__CreateActions(struct soap *soap, struct _ns1__CreateActions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__CreateActions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetActionsResponse(struct soap *soap, struct _ns1__GetActionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetActionsResponse))
		soap_serialize__ns1__GetActionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetActionsResponse(struct soap *soap, const char *tag, int id, struct _ns1__GetActionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetActionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetActionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetActionsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetActionsResponse(struct soap *soap, const char *tag, struct _ns1__GetActionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetActionsResponse **)soap_malloc(soap, sizeof(struct _ns1__GetActionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetActionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetActionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetActionsResponse, sizeof(struct _ns1__GetActionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetActionsResponse(struct soap *soap, struct _ns1__GetActionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetActionsResponse);
	if (soap_out_PointerTo_ns1__GetActionsResponse(soap, tag?tag:"ns1:GetActionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetActionsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetActionsResponse(struct soap *soap, struct _ns1__GetActionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetActionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetActions(struct soap *soap, struct _ns1__GetActions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetActions))
		soap_serialize__ns1__GetActions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetActions(struct soap *soap, const char *tag, int id, struct _ns1__GetActions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetActions);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetActions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetActions ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetActions(struct soap *soap, const char *tag, struct _ns1__GetActions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetActions **)soap_malloc(soap, sizeof(struct _ns1__GetActions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetActions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetActions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetActions, sizeof(struct _ns1__GetActions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetActions(struct soap *soap, struct _ns1__GetActions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetActions);
	if (soap_out_PointerTo_ns1__GetActions(soap, tag?tag:"ns1:GetActions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetActions ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetActions(struct soap *soap, struct _ns1__GetActions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetActions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetSupportedActionsResponse(struct soap *soap, struct _ns1__GetSupportedActionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetSupportedActionsResponse))
		soap_serialize__ns1__GetSupportedActionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetSupportedActionsResponse(struct soap *soap, const char *tag, int id, struct _ns1__GetSupportedActionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetSupportedActionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetSupportedActionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetSupportedActionsResponse ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetSupportedActionsResponse(struct soap *soap, const char *tag, struct _ns1__GetSupportedActionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetSupportedActionsResponse **)soap_malloc(soap, sizeof(struct _ns1__GetSupportedActionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetSupportedActionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetSupportedActionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSupportedActionsResponse, sizeof(struct _ns1__GetSupportedActionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetSupportedActionsResponse(struct soap *soap, struct _ns1__GetSupportedActionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetSupportedActionsResponse);
	if (soap_out_PointerTo_ns1__GetSupportedActionsResponse(soap, tag?tag:"ns1:GetSupportedActionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetSupportedActionsResponse ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetSupportedActionsResponse(struct soap *soap, struct _ns1__GetSupportedActionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetSupportedActionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_ns1__GetSupportedActions(struct soap *soap, struct _ns1__GetSupportedActions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__ns1__GetSupportedActions))
		soap_serialize__ns1__GetSupportedActions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_ns1__GetSupportedActions(struct soap *soap, const char *tag, int id, struct _ns1__GetSupportedActions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__ns1__GetSupportedActions);
	if (id < 0)
		return soap->error;
	return soap_out__ns1__GetSupportedActions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _ns1__GetSupportedActions ** SOAP_FMAC4 soap_in_PointerTo_ns1__GetSupportedActions(struct soap *soap, const char *tag, struct _ns1__GetSupportedActions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _ns1__GetSupportedActions **)soap_malloc(soap, sizeof(struct _ns1__GetSupportedActions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__ns1__GetSupportedActions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _ns1__GetSupportedActions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__ns1__GetSupportedActions, sizeof(struct _ns1__GetSupportedActions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_ns1__GetSupportedActions(struct soap *soap, struct _ns1__GetSupportedActions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_ns1__GetSupportedActions);
	if (soap_out_PointerTo_ns1__GetSupportedActions(soap, tag?tag:"ns1:GetSupportedActions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _ns1__GetSupportedActions ** SOAP_FMAC4 soap_get_PointerTo_ns1__GetSupportedActions(struct soap *soap, struct _ns1__GetSupportedActions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_ns1__GetSupportedActions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnsupportedPolicyRequestFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType))
		soap_serialize_wsnt__UnsupportedPolicyRequestFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, struct wsnt__UnsupportedPolicyRequestFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__UnsupportedPolicyRequestFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, const char *tag, struct wsnt__UnsupportedPolicyRequestFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__UnsupportedPolicyRequestFaultType **)soap_malloc(soap, sizeof(struct wsnt__UnsupportedPolicyRequestFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__UnsupportedPolicyRequestFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__UnsupportedPolicyRequestFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnsupportedPolicyRequestFaultType, sizeof(struct wsnt__UnsupportedPolicyRequestFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnsupportedPolicyRequestFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__UnsupportedPolicyRequestFaultType);
	if (soap_out_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, tag?tag:"wsnt:UnsupportedPolicyRequestFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnsupportedPolicyRequestFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnsupportedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnsupportedPolicyRequestFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnrecognizedPolicyRequestFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType))
		soap_serialize_wsnt__UnrecognizedPolicyRequestFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, int id, struct wsnt__UnrecognizedPolicyRequestFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__UnrecognizedPolicyRequestFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, const char *tag, struct wsnt__UnrecognizedPolicyRequestFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__UnrecognizedPolicyRequestFaultType **)soap_malloc(soap, sizeof(struct wsnt__UnrecognizedPolicyRequestFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__UnrecognizedPolicyRequestFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__UnrecognizedPolicyRequestFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnrecognizedPolicyRequestFaultType, sizeof(struct wsnt__UnrecognizedPolicyRequestFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnrecognizedPolicyRequestFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__UnrecognizedPolicyRequestFaultType);
	if (soap_out_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, tag?tag:"wsnt:UnrecognizedPolicyRequestFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnrecognizedPolicyRequestFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnrecognizedPolicyRequestFaultType(struct soap *soap, struct wsnt__UnrecognizedPolicyRequestFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableTerminationTimeFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType))
		soap_serialize_wsnt__UnacceptableTerminationTimeFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, int id, struct wsnt__UnacceptableTerminationTimeFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__UnacceptableTerminationTimeFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, const char *tag, struct wsnt__UnacceptableTerminationTimeFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__UnacceptableTerminationTimeFaultType **)soap_malloc(soap, sizeof(struct wsnt__UnacceptableTerminationTimeFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__UnacceptableTerminationTimeFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__UnacceptableTerminationTimeFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnacceptableTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableTerminationTimeFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableTerminationTimeFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__UnacceptableTerminationTimeFaultType);
	if (soap_out_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, tag?tag:"wsnt:UnacceptableTerminationTimeFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnacceptableTerminationTimeFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnacceptableTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableTerminationTimeFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableInitialTerminationTimeFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType))
		soap_serialize_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, int id, struct wsnt__UnacceptableInitialTerminationTimeFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__UnacceptableInitialTerminationTimeFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, const char *tag, struct wsnt__UnacceptableInitialTerminationTimeFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__UnacceptableInitialTerminationTimeFaultType **)soap_malloc(soap, sizeof(struct wsnt__UnacceptableInitialTerminationTimeFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__UnacceptableInitialTerminationTimeFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnacceptableInitialTerminationTimeFaultType, sizeof(struct wsnt__UnacceptableInitialTerminationTimeFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableInitialTerminationTimeFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType);
	if (soap_out_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag?tag:"wsnt:UnacceptableInitialTerminationTimeFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnacceptableInitialTerminationTimeFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(struct soap *soap, struct wsnt__UnacceptableInitialTerminationTimeFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, struct wsnt__UnableToGetMessagesFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType))
		soap_serialize_wsnt__UnableToGetMessagesFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, int id, struct wsnt__UnableToGetMessagesFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__UnableToGetMessagesFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__UnableToGetMessagesFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToGetMessagesFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__UnableToGetMessagesFaultType **)soap_malloc(soap, sizeof(struct wsnt__UnableToGetMessagesFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__UnableToGetMessagesFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__UnableToGetMessagesFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToGetMessagesFaultType, sizeof(struct wsnt__UnableToGetMessagesFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, struct wsnt__UnableToGetMessagesFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__UnableToGetMessagesFaultType);
	if (soap_out_PointerTowsnt__UnableToGetMessagesFaultType(soap, tag?tag:"wsnt:UnableToGetMessagesFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToGetMessagesFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnableToGetMessagesFaultType(struct soap *soap, struct wsnt__UnableToGetMessagesFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnableToGetMessagesFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, struct wsnt__UnableToDestroySubscriptionFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType))
		soap_serialize_wsnt__UnableToDestroySubscriptionFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, int id, struct wsnt__UnableToDestroySubscriptionFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__UnableToDestroySubscriptionFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToDestroySubscriptionFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__UnableToDestroySubscriptionFaultType **)soap_malloc(soap, sizeof(struct wsnt__UnableToDestroySubscriptionFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__UnableToDestroySubscriptionFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__UnableToDestroySubscriptionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToDestroySubscriptionFaultType, sizeof(struct wsnt__UnableToDestroySubscriptionFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, struct wsnt__UnableToDestroySubscriptionFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__UnableToDestroySubscriptionFaultType);
	if (soap_out_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, tag?tag:"wsnt:UnableToDestroySubscriptionFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToDestroySubscriptionFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnableToDestroySubscriptionFaultType(struct soap *soap, struct wsnt__UnableToDestroySubscriptionFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, struct wsnt__UnableToDestroyPullPointFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType))
		soap_serialize_wsnt__UnableToDestroyPullPointFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, int id, struct wsnt__UnableToDestroyPullPointFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__UnableToDestroyPullPointFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__UnableToDestroyPullPointFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToDestroyPullPointFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__UnableToDestroyPullPointFaultType **)soap_malloc(soap, sizeof(struct wsnt__UnableToDestroyPullPointFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__UnableToDestroyPullPointFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__UnableToDestroyPullPointFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToDestroyPullPointFaultType, sizeof(struct wsnt__UnableToDestroyPullPointFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, struct wsnt__UnableToDestroyPullPointFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__UnableToDestroyPullPointFaultType);
	if (soap_out_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, tag?tag:"wsnt:UnableToDestroyPullPointFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToDestroyPullPointFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnableToDestroyPullPointFaultType(struct soap *soap, struct wsnt__UnableToDestroyPullPointFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, struct wsnt__UnableToCreatePullPointFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType))
		soap_serialize_wsnt__UnableToCreatePullPointFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, int id, struct wsnt__UnableToCreatePullPointFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__UnableToCreatePullPointFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__UnableToCreatePullPointFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, const char *tag, struct wsnt__UnableToCreatePullPointFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__UnableToCreatePullPointFaultType **)soap_malloc(soap, sizeof(struct wsnt__UnableToCreatePullPointFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__UnableToCreatePullPointFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__UnableToCreatePullPointFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__UnableToCreatePullPointFaultType, sizeof(struct wsnt__UnableToCreatePullPointFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, struct wsnt__UnableToCreatePullPointFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__UnableToCreatePullPointFaultType);
	if (soap_out_PointerTowsnt__UnableToCreatePullPointFaultType(soap, tag?tag:"wsnt:UnableToCreatePullPointFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__UnableToCreatePullPointFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__UnableToCreatePullPointFaultType(struct soap *soap, struct wsnt__UnableToCreatePullPointFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__UnableToCreatePullPointFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, struct wsnt__TopicNotSupportedFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType))
		soap_serialize_wsnt__TopicNotSupportedFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, int id, struct wsnt__TopicNotSupportedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__TopicNotSupportedFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__TopicNotSupportedFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__TopicNotSupportedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, const char *tag, struct wsnt__TopicNotSupportedFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__TopicNotSupportedFaultType **)soap_malloc(soap, sizeof(struct wsnt__TopicNotSupportedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__TopicNotSupportedFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__TopicNotSupportedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicNotSupportedFaultType, sizeof(struct wsnt__TopicNotSupportedFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, struct wsnt__TopicNotSupportedFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__TopicNotSupportedFaultType);
	if (soap_out_PointerTowsnt__TopicNotSupportedFaultType(soap, tag?tag:"wsnt:TopicNotSupportedFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicNotSupportedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__TopicNotSupportedFaultType(struct soap *soap, struct wsnt__TopicNotSupportedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__TopicNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct wsnt__TopicExpressionDialectUnknownFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType))
		soap_serialize_wsnt__TopicExpressionDialectUnknownFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, int id, struct wsnt__TopicExpressionDialectUnknownFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, struct wsnt__TopicExpressionDialectUnknownFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__TopicExpressionDialectUnknownFaultType **)soap_malloc(soap, sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__TopicExpressionDialectUnknownFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct wsnt__TopicExpressionDialectUnknownFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__TopicExpressionDialectUnknownFaultType);
	if (soap_out_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, tag?tag:"wsnt:TopicExpressionDialectUnknownFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct wsnt__TopicExpressionDialectUnknownFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, struct wsnt__SubscribeCreationFailedFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType))
		soap_serialize_wsnt__SubscribeCreationFailedFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, int id, struct wsnt__SubscribeCreationFailedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__SubscribeCreationFailedFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, struct wsnt__SubscribeCreationFailedFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__SubscribeCreationFailedFaultType **)soap_malloc(soap, sizeof(struct wsnt__SubscribeCreationFailedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__SubscribeCreationFailedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(struct wsnt__SubscribeCreationFailedFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, struct wsnt__SubscribeCreationFailedFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__SubscribeCreationFailedFaultType);
	if (soap_out_PointerTowsnt__SubscribeCreationFailedFaultType(soap, tag?tag:"wsnt:SubscribeCreationFailedFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__SubscribeCreationFailedFaultType(struct soap *soap, struct wsnt__SubscribeCreationFailedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__SubscribeCreationFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, struct wsnt__ResumeFailedFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__ResumeFailedFaultType))
		soap_serialize_wsnt__ResumeFailedFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, int id, struct wsnt__ResumeFailedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__ResumeFailedFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__ResumeFailedFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__ResumeFailedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, const char *tag, struct wsnt__ResumeFailedFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__ResumeFailedFaultType **)soap_malloc(soap, sizeof(struct wsnt__ResumeFailedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__ResumeFailedFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__ResumeFailedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__ResumeFailedFaultType, sizeof(struct wsnt__ResumeFailedFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, struct wsnt__ResumeFailedFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__ResumeFailedFaultType);
	if (soap_out_PointerTowsnt__ResumeFailedFaultType(soap, tag?tag:"wsnt:ResumeFailedFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__ResumeFailedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__ResumeFailedFaultType(struct soap *soap, struct wsnt__ResumeFailedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__ResumeFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsrfr__ResourceUnknownFaultType(struct soap *soap, struct wsrfr__ResourceUnknownFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsrfr__ResourceUnknownFaultType))
		soap_serialize_wsrfr__ResourceUnknownFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsrfr__ResourceUnknownFaultType(struct soap *soap, const char *tag, int id, struct wsrfr__ResourceUnknownFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsrfr__ResourceUnknownFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsrfr__ResourceUnknownFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsrfr__ResourceUnknownFaultType ** SOAP_FMAC4 soap_in_PointerTowsrfr__ResourceUnknownFaultType(struct soap *soap, const char *tag, struct wsrfr__ResourceUnknownFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsrfr__ResourceUnknownFaultType **)soap_malloc(soap, sizeof(struct wsrfr__ResourceUnknownFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsrfr__ResourceUnknownFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsrfr__ResourceUnknownFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsrfr__ResourceUnknownFaultType, sizeof(struct wsrfr__ResourceUnknownFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsrfr__ResourceUnknownFaultType(struct soap *soap, struct wsrfr__ResourceUnknownFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsrfr__ResourceUnknownFaultType);
	if (soap_out_PointerTowsrfr__ResourceUnknownFaultType(soap, tag?tag:"wsrfr:ResourceUnknownFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsrfr__ResourceUnknownFaultType ** SOAP_FMAC4 soap_get_PointerTowsrfr__ResourceUnknownFaultType(struct soap *soap, struct wsrfr__ResourceUnknownFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsrfr__ResourceUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, struct _tev__PullMessagesFaultResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__PullMessagesFaultResponse))
		soap_serialize__tev__PullMessagesFaultResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, int id, struct _tev__PullMessagesFaultResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__PullMessagesFaultResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tev__PullMessagesFaultResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__PullMessagesFaultResponse ** SOAP_FMAC4 soap_in_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, struct _tev__PullMessagesFaultResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__PullMessagesFaultResponse **)soap_malloc(soap, sizeof(struct _tev__PullMessagesFaultResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__PullMessagesFaultResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__PullMessagesFaultResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__PullMessagesFaultResponse, sizeof(struct _tev__PullMessagesFaultResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, struct _tev__PullMessagesFaultResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tev__PullMessagesFaultResponse);
	if (soap_out_PointerTo_tev__PullMessagesFaultResponse(soap, tag?tag:"tev:PullMessagesFaultResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__PullMessagesFaultResponse ** SOAP_FMAC4 soap_get_PointerTo_tev__PullMessagesFaultResponse(struct soap *soap, struct _tev__PullMessagesFaultResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__PullMessagesFaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__PauseFailedFaultType(struct soap *soap, struct wsnt__PauseFailedFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__PauseFailedFaultType))
		soap_serialize_wsnt__PauseFailedFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__PauseFailedFaultType(struct soap *soap, const char *tag, int id, struct wsnt__PauseFailedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__PauseFailedFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__PauseFailedFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__PauseFailedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__PauseFailedFaultType(struct soap *soap, const char *tag, struct wsnt__PauseFailedFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__PauseFailedFaultType **)soap_malloc(soap, sizeof(struct wsnt__PauseFailedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__PauseFailedFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__PauseFailedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__PauseFailedFaultType, sizeof(struct wsnt__PauseFailedFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__PauseFailedFaultType(struct soap *soap, struct wsnt__PauseFailedFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__PauseFailedFaultType);
	if (soap_out_PointerTowsnt__PauseFailedFaultType(soap, tag?tag:"wsnt:PauseFailedFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__PauseFailedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__PauseFailedFaultType(struct soap *soap, struct wsnt__PauseFailedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__PauseFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, struct wsnt__NotifyMessageNotSupportedFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType))
		soap_serialize_wsnt__NotifyMessageNotSupportedFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, int id, struct wsnt__NotifyMessageNotSupportedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__NotifyMessageNotSupportedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, const char *tag, struct wsnt__NotifyMessageNotSupportedFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__NotifyMessageNotSupportedFaultType **)soap_malloc(soap, sizeof(struct wsnt__NotifyMessageNotSupportedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__NotifyMessageNotSupportedFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__NotifyMessageNotSupportedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NotifyMessageNotSupportedFaultType, sizeof(struct wsnt__NotifyMessageNotSupportedFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, struct wsnt__NotifyMessageNotSupportedFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__NotifyMessageNotSupportedFaultType);
	if (soap_out_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, tag?tag:"wsnt:NotifyMessageNotSupportedFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NotifyMessageNotSupportedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__NotifyMessageNotSupportedFaultType(struct soap *soap, struct wsnt__NotifyMessageNotSupportedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, struct wsnt__NoCurrentMessageOnTopicFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType))
		soap_serialize_wsnt__NoCurrentMessageOnTopicFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, int id, struct wsnt__NoCurrentMessageOnTopicFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__NoCurrentMessageOnTopicFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, const char *tag, struct wsnt__NoCurrentMessageOnTopicFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__NoCurrentMessageOnTopicFaultType **)soap_malloc(soap, sizeof(struct wsnt__NoCurrentMessageOnTopicFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__NoCurrentMessageOnTopicFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__NoCurrentMessageOnTopicFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__NoCurrentMessageOnTopicFaultType, sizeof(struct wsnt__NoCurrentMessageOnTopicFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, struct wsnt__NoCurrentMessageOnTopicFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__NoCurrentMessageOnTopicFaultType);
	if (soap_out_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, tag?tag:"wsnt:NoCurrentMessageOnTopicFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__NoCurrentMessageOnTopicFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__NoCurrentMessageOnTopicFaultType(struct soap *soap, struct wsnt__NoCurrentMessageOnTopicFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, struct wsnt__MultipleTopicsSpecifiedFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType))
		soap_serialize_wsnt__MultipleTopicsSpecifiedFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, int id, struct wsnt__MultipleTopicsSpecifiedFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__MultipleTopicsSpecifiedFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, const char *tag, struct wsnt__MultipleTopicsSpecifiedFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__MultipleTopicsSpecifiedFaultType **)soap_malloc(soap, sizeof(struct wsnt__MultipleTopicsSpecifiedFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__MultipleTopicsSpecifiedFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__MultipleTopicsSpecifiedFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__MultipleTopicsSpecifiedFaultType, sizeof(struct wsnt__MultipleTopicsSpecifiedFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, struct wsnt__MultipleTopicsSpecifiedFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__MultipleTopicsSpecifiedFaultType);
	if (soap_out_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, tag?tag:"wsnt:MultipleTopicsSpecifiedFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__MultipleTopicsSpecifiedFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__MultipleTopicsSpecifiedFaultType(struct soap *soap, struct wsnt__MultipleTopicsSpecifiedFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, struct wsnt__InvalidTopicExpressionFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType))
		soap_serialize_wsnt__InvalidTopicExpressionFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, int id, struct wsnt__InvalidTopicExpressionFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__InvalidTopicExpressionFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__InvalidTopicExpressionFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidTopicExpressionFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__InvalidTopicExpressionFaultType **)soap_malloc(soap, sizeof(struct wsnt__InvalidTopicExpressionFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__InvalidTopicExpressionFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__InvalidTopicExpressionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(struct wsnt__InvalidTopicExpressionFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, struct wsnt__InvalidTopicExpressionFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__InvalidTopicExpressionFaultType);
	if (soap_out_PointerTowsnt__InvalidTopicExpressionFaultType(soap, tag?tag:"wsnt:InvalidTopicExpressionFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidTopicExpressionFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__InvalidTopicExpressionFaultType(struct soap *soap, struct wsnt__InvalidTopicExpressionFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__InvalidTopicExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, struct wsnt__InvalidProducerPropertiesExpressionFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType))
		soap_serialize_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, int id, struct wsnt__InvalidProducerPropertiesExpressionFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__InvalidProducerPropertiesExpressionFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidProducerPropertiesExpressionFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__InvalidProducerPropertiesExpressionFaultType **)soap_malloc(soap, sizeof(struct wsnt__InvalidProducerPropertiesExpressionFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__InvalidProducerPropertiesExpressionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidProducerPropertiesExpressionFaultType, sizeof(struct wsnt__InvalidProducerPropertiesExpressionFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, struct wsnt__InvalidProducerPropertiesExpressionFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType);
	if (soap_out_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag?tag:"wsnt:InvalidProducerPropertiesExpressionFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidProducerPropertiesExpressionFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(struct soap *soap, struct wsnt__InvalidProducerPropertiesExpressionFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, struct wsnt__InvalidMessageContentExpressionFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType))
		soap_serialize_wsnt__InvalidMessageContentExpressionFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, int id, struct wsnt__InvalidMessageContentExpressionFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__InvalidMessageContentExpressionFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidMessageContentExpressionFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__InvalidMessageContentExpressionFaultType **)soap_malloc(soap, sizeof(struct wsnt__InvalidMessageContentExpressionFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__InvalidMessageContentExpressionFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__InvalidMessageContentExpressionFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidMessageContentExpressionFaultType, sizeof(struct wsnt__InvalidMessageContentExpressionFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, struct wsnt__InvalidMessageContentExpressionFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__InvalidMessageContentExpressionFaultType);
	if (soap_out_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, tag?tag:"wsnt:InvalidMessageContentExpressionFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidMessageContentExpressionFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__InvalidMessageContentExpressionFaultType(struct soap *soap, struct wsnt__InvalidMessageContentExpressionFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, struct wsnt__InvalidFilterFaultType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wsnt__InvalidFilterFaultType))
		soap_serialize_wsnt__InvalidFilterFaultType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, int id, struct wsnt__InvalidFilterFaultType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wsnt__InvalidFilterFaultType);
	if (id < 0)
		return soap->error;
	return soap_out_wsnt__InvalidFilterFaultType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType ** SOAP_FMAC4 soap_in_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidFilterFaultType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wsnt__InvalidFilterFaultType **)soap_malloc(soap, sizeof(struct wsnt__InvalidFilterFaultType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wsnt__InvalidFilterFaultType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wsnt__InvalidFilterFaultType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(struct wsnt__InvalidFilterFaultType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, struct wsnt__InvalidFilterFaultType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowsnt__InvalidFilterFaultType);
	if (soap_out_PointerTowsnt__InvalidFilterFaultType(soap, tag?tag:"wsnt:InvalidFilterFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType ** SOAP_FMAC4 soap_get_PointerTowsnt__InvalidFilterFaultType(struct soap *soap, struct wsnt__InvalidFilterFaultType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowsnt__InvalidFilterFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause))
		soap_serialize__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsrfr__ResourceUnavailableFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnavailableFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfr__ResourceUnavailableFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsrfr__ResourceUnavailableFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfr__ResourceUnavailableFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnavailableFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnavailableFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause);
	if (soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(soap, tag?tag:"wsrfr:ResourceUnavailableFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_Description))
		soap_serialize__wsrfr__ResourceUnavailableFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsrfr__ResourceUnavailableFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfr__ResourceUnavailableFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnavailableFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfr__ResourceUnavailableFaultType_Description **)soap_malloc(soap, sizeof(struct _wsrfr__ResourceUnavailableFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfr__ResourceUnavailableFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnavailableFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_Description, sizeof(struct _wsrfr__ResourceUnavailableFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrfr__ResourceUnavailableFaultType_Description);
	if (soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_Description(soap, tag?tag:"wsrfr:ResourceUnavailableFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsrfr__ResourceUnavailableFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode))
		soap_serialize__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnavailableFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfr__ResourceUnavailableFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnavailableFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfr__ResourceUnavailableFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnavailableFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode);
	if (soap_out_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, tag?tag:"wsrfr:ResourceUnavailableFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnavailableFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnavailableFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfr__ResourceUnavailableFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause))
		soap_serialize__wsrfr__ResourceUnknownFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsrfr__ResourceUnknownFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfr__ResourceUnknownFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnknownFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfr__ResourceUnknownFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsrfr__ResourceUnknownFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfr__ResourceUnknownFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnknownFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_FaultCause, sizeof(struct _wsrfr__ResourceUnknownFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause);
	if (soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(soap, tag?tag:"wsrfr:ResourceUnknownFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_Description))
		soap_serialize__wsrfr__ResourceUnknownFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsrfr__ResourceUnknownFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfr__ResourceUnknownFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnknownFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfr__ResourceUnknownFaultType_Description **)soap_malloc(soap, sizeof(struct _wsrfr__ResourceUnknownFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfr__ResourceUnknownFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnknownFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_Description, sizeof(struct _wsrfr__ResourceUnknownFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrfr__ResourceUnknownFaultType_Description);
	if (soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_Description(soap, tag?tag:"wsrfr:ResourceUnknownFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsrfr__ResourceUnknownFaultType_Description(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode))
		soap_serialize__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsrfr__ResourceUnknownFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsrfr__ResourceUnknownFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsrfr__ResourceUnknownFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsrfr__ResourceUnknownFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsrfr__ResourceUnknownFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsrfr__ResourceUnknownFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsrfr__ResourceUnknownFaultType_ErrorCode, sizeof(struct _wsrfr__ResourceUnknownFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode);
	if (soap_out_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(soap, tag?tag:"wsrfr:ResourceUnknownFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsrfr__ResourceUnknownFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(struct soap *soap, struct _wsrfr__ResourceUnknownFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsrfr__ResourceUnknownFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wstop__TopicNamespaceType_Topic))
		soap_serialize__wstop__TopicNamespaceType_Topic(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, int id, struct _wstop__TopicNamespaceType_Topic *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wstop__TopicNamespaceType_Topic);
	if (id < 0)
		return soap->error;
	return soap_out__wstop__TopicNamespaceType_Topic(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic ** SOAP_FMAC4 soap_in_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, const char *tag, struct _wstop__TopicNamespaceType_Topic **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wstop__TopicNamespaceType_Topic **)soap_malloc(soap, sizeof(struct _wstop__TopicNamespaceType_Topic *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wstop__TopicNamespaceType_Topic(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wstop__TopicNamespaceType_Topic **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wstop__TopicNamespaceType_Topic, sizeof(struct _wstop__TopicNamespaceType_Topic), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wstop__TopicNamespaceType_Topic);
	if (soap_out_PointerTo_wstop__TopicNamespaceType_Topic(soap, tag?tag:"wstop:TopicNamespaceType-Topic", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wstop__TopicNamespaceType_Topic ** SOAP_FMAC4 soap_get_PointerTo_wstop__TopicNamespaceType_Topic(struct soap *soap, struct _wstop__TopicNamespaceType_Topic **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wstop__TopicNamespaceType_Topic(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__TopicType(struct soap *soap, struct wstop__TopicType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__TopicType))
		soap_serialize_wstop__TopicType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__TopicType(struct soap *soap, const char *tag, int id, struct wstop__TopicType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__TopicType);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__TopicType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wstop__TopicType ** SOAP_FMAC4 soap_in_PointerTowstop__TopicType(struct soap *soap, const char *tag, struct wstop__TopicType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wstop__TopicType **)soap_malloc(soap, sizeof(struct wstop__TopicType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__TopicType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wstop__TopicType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__TopicType, sizeof(struct wstop__TopicType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__TopicType(struct soap *soap, struct wstop__TopicType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowstop__TopicType);
	if (soap_out_PointerTowstop__TopicType(soap, tag?tag:"wstop:TopicType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__TopicType ** SOAP_FMAC4 soap_get_PointerTowstop__TopicType(struct soap *soap, struct wstop__TopicType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__TopicType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTowstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_wstop__QueryExpressionType))
		soap_serialize_wstop__QueryExpressionType(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, int id, struct wstop__QueryExpressionType *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_wstop__QueryExpressionType);
	if (id < 0)
		return soap->error;
	return soap_out_wstop__QueryExpressionType(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct wstop__QueryExpressionType ** SOAP_FMAC4 soap_in_PointerTowstop__QueryExpressionType(struct soap *soap, const char *tag, struct wstop__QueryExpressionType **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct wstop__QueryExpressionType **)soap_malloc(soap, sizeof(struct wstop__QueryExpressionType *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_wstop__QueryExpressionType(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct wstop__QueryExpressionType **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_wstop__QueryExpressionType, sizeof(struct wstop__QueryExpressionType), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTowstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTowstop__QueryExpressionType);
	if (soap_out_PointerTowstop__QueryExpressionType(soap, tag?tag:"wstop:QueryExpressionType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wstop__QueryExpressionType ** SOAP_FMAC4 soap_get_PointerTowstop__QueryExpressionType(struct soap *soap, struct wstop__QueryExpressionType **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTowstop__QueryExpressionType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause))
		soap_serialize__wsnt__ResumeFailedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__ResumeFailedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__ResumeFailedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__ResumeFailedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__ResumeFailedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeFailedFaultType_FaultCause, sizeof(struct _wsnt__ResumeFailedFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, tag?tag:"wsnt:ResumeFailedFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__ResumeFailedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__ResumeFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description))
		soap_serialize__wsnt__ResumeFailedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__ResumeFailedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__ResumeFailedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__ResumeFailedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__ResumeFailedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__ResumeFailedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeFailedFaultType_Description, sizeof(struct _wsnt__ResumeFailedFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_Description);
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_Description(soap, tag?tag:"wsnt:ResumeFailedFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__ResumeFailedFaultType_Description(struct soap *soap, struct _wsnt__ResumeFailedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__ResumeFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode))
		soap_serialize__wsnt__ResumeFailedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__ResumeFailedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__ResumeFailedFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__ResumeFailedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeFailedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeFailedFaultType_ErrorCode, sizeof(struct _wsnt__ResumeFailedFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, tag?tag:"wsnt:ResumeFailedFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__ResumeFailedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__ResumeFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause))
		soap_serialize__wsnt__PauseFailedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__PauseFailedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__PauseFailedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__PauseFailedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__PauseFailedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__PauseFailedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseFailedFaultType_FaultCause, sizeof(struct _wsnt__PauseFailedFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, tag?tag:"wsnt:PauseFailedFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__PauseFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__PauseFailedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__PauseFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__PauseFailedFaultType_Description))
		soap_serialize__wsnt__PauseFailedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__PauseFailedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__PauseFailedFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__PauseFailedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__PauseFailedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__PauseFailedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__PauseFailedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseFailedFaultType_Description, sizeof(struct _wsnt__PauseFailedFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_Description);
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_Description(soap, tag?tag:"wsnt:PauseFailedFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__PauseFailedFaultType_Description(struct soap *soap, struct _wsnt__PauseFailedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__PauseFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode))
		soap_serialize__wsnt__PauseFailedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__PauseFailedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__PauseFailedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__PauseFailedFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__PauseFailedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__PauseFailedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseFailedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseFailedFaultType_ErrorCode, sizeof(struct _wsnt__PauseFailedFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__PauseFailedFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, tag?tag:"wsnt:PauseFailedFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__PauseFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__PauseFailedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__PauseFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause))
		soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag?tag:"wsnt:UnableToDestroySubscriptionFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description))
		soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_Description, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description);
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag?tag:"wsnt:UnableToDestroySubscriptionFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode))
		soap_serialize__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroySubscriptionFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag?tag:"wsnt:UnableToDestroySubscriptionFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroySubscriptionFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroySubscriptionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause))
		soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag?tag:"wsnt:UnacceptableTerminationTimeFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description))
		soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description);
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag?tag:"wsnt:UnacceptableTerminationTimeFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode))
		soap_serialize__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag?tag:"wsnt:UnacceptableTerminationTimeFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableTerminationTimeFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableTerminationTimeFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause))
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag?tag:"wsnt:UnableToCreatePullPointFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description))
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToCreatePullPointFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_Description, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description);
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(soap, tag?tag:"wsnt:UnableToCreatePullPointFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode))
		soap_serialize__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToCreatePullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag?tag:"wsnt:UnableToCreatePullPointFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToCreatePullPointFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToCreatePullPointFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause))
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_FaultCause, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag?tag:"wsnt:UnableToDestroyPullPointFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description))
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroyPullPointFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroyPullPointFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_Description, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description);
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag?tag:"wsnt:UnableToDestroyPullPointFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode))
		soap_serialize__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToDestroyPullPointFaultType_ErrorCode, sizeof(struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag?tag:"wsnt:UnableToDestroyPullPointFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToDestroyPullPointFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToDestroyPullPointFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause))
		soap_serialize__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_FaultCause, sizeof(struct _wsnt__UnableToGetMessagesFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag?tag:"wsnt:UnableToGetMessagesFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description))
		soap_serialize__wsnt__UnableToGetMessagesFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToGetMessagesFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToGetMessagesFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToGetMessagesFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToGetMessagesFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_Description, sizeof(struct _wsnt__UnableToGetMessagesFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_Description);
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(soap, tag?tag:"wsnt:UnableToGetMessagesFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode))
		soap_serialize__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnableToGetMessagesFaultType_ErrorCode, sizeof(struct _wsnt__UnableToGetMessagesFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag?tag:"wsnt:UnableToGetMessagesFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnableToGetMessagesFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnableToGetMessagesFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnableToGetMessagesFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause))
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_FaultCause, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag?tag:"wsnt:NoCurrentMessageOnTopicFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description))
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_Description, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description);
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag?tag:"wsnt:NoCurrentMessageOnTopicFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode))
		soap_serialize__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode, sizeof(struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag?tag:"wsnt:NoCurrentMessageOnTopicFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(struct soap *soap, struct _wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NoCurrentMessageOnTopicFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause))
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag?tag:"wsnt:UnacceptableInitialTerminationTimeFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description))
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_Description, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description);
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag?tag:"wsnt:UnacceptableInitialTerminationTimeFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode))
		soap_serialize__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode, sizeof(struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag?tag:"wsnt:UnacceptableInitialTerminationTimeFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnacceptableInitialTerminationTimeFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause))
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag?tag:"wsnt:NotifyMessageNotSupportedFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description))
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_Description, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description);
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag?tag:"wsnt:NotifyMessageNotSupportedFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode))
		soap_serialize__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__NotifyMessageNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag?tag:"wsnt:NotifyMessageNotSupportedFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__NotifyMessageNotSupportedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__NotifyMessageNotSupportedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause))
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag?tag:"wsnt:UnsupportedPolicyRequestFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description))
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description);
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag?tag:"wsnt:UnsupportedPolicyRequestFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode))
		soap_serialize__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnsupportedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag?tag:"wsnt:UnsupportedPolicyRequestFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnsupportedPolicyRequestFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnsupportedPolicyRequestFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause))
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_FaultCause, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag?tag:"wsnt:UnrecognizedPolicyRequestFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description))
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_Description, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description);
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag?tag:"wsnt:UnrecognizedPolicyRequestFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode))
		soap_serialize__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode, sizeof(struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag?tag:"wsnt:UnrecognizedPolicyRequestFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(struct soap *soap, struct _wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__UnrecognizedPolicyRequestFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause))
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag?tag:"wsnt:InvalidMessageContentExpressionFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description))
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_Description, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description);
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag?tag:"wsnt:InvalidMessageContentExpressionFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidMessageContentExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag?tag:"wsnt:InvalidMessageContentExpressionFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidMessageContentExpressionFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidMessageContentExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause))
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag?tag:"wsnt:InvalidProducerPropertiesExpressionFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description))
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_Description, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description);
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag?tag:"wsnt:InvalidProducerPropertiesExpressionFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag?tag:"wsnt:InvalidProducerPropertiesExpressionFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidProducerPropertiesExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause))
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_FaultCause, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag?tag:"wsnt:MultipleTopicsSpecifiedFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description))
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_Description, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description);
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag?tag:"wsnt:MultipleTopicsSpecifiedFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode))
		soap_serialize__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode, sizeof(struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag?tag:"wsnt:MultipleTopicsSpecifiedFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(struct soap *soap, struct _wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__MultipleTopicsSpecifiedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause))
		soap_serialize__wsnt__TopicNotSupportedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__TopicNotSupportedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_FaultCause, sizeof(struct _wsnt__TopicNotSupportedFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag?tag:"wsnt:TopicNotSupportedFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description))
		soap_serialize__wsnt__TopicNotSupportedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__TopicNotSupportedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicNotSupportedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicNotSupportedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicNotSupportedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_Description, sizeof(struct _wsnt__TopicNotSupportedFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_Description);
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_Description(soap, tag?tag:"wsnt:TopicNotSupportedFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicNotSupportedFaultType_Description(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode))
		soap_serialize__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__TopicNotSupportedFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicNotSupportedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicNotSupportedFaultType_ErrorCode, sizeof(struct _wsnt__TopicNotSupportedFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag?tag:"wsnt:TopicNotSupportedFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicNotSupportedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicNotSupportedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicNotSupportedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause))
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_FaultCause, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag?tag:"wsnt:InvalidTopicExpressionFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description))
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidTopicExpressionFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description);
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(soap, tag?tag:"wsnt:InvalidTopicExpressionFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_ErrorCode, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag?tag:"wsnt:InvalidTopicExpressionFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidTopicExpressionFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause))
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag?tag:"wsnt:TopicExpressionDialectUnknownFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description))
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description);
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag?tag:"wsnt:TopicExpressionDialectUnknownFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode))
		soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag?tag:"wsnt:TopicExpressionDialectUnknownFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause))
		soap_serialize__wsnt__InvalidFilterFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidFilterFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidFilterFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidFilterFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidFilterFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, tag?tag:"wsnt:InvalidFilterFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description))
		soap_serialize__wsnt__InvalidFilterFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidFilterFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidFilterFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidFilterFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__InvalidFilterFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidFilterFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description, sizeof(struct _wsnt__InvalidFilterFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_Description);
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_Description(soap, tag?tag:"wsnt:InvalidFilterFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidFilterFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode))
		soap_serialize__wsnt__InvalidFilterFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__InvalidFilterFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__InvalidFilterFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, tag?tag:"wsnt:InvalidFilterFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause))
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause);
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag?tag:"wsnt:SubscribeCreationFailedFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description))
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeCreationFailedFaultType_Description *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_Description **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_Description **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_Description **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description);
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(soap, tag?tag:"wsnt:SubscribeCreationFailedFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode))
		soap_serialize__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **)soap_malloc(soap, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode);
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag?tag:"wsnt:SubscribeCreationFailedFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode ** SOAP_FMAC4 soap_get_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataInput(struct soap *soap, struct tt__MetadataInput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataInput))
		soap_serialize_tt__MetadataInput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataInput(struct soap *soap, const char *tag, int id, struct tt__MetadataInput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataInput);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataInput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataInput ** SOAP_FMAC4 soap_in_PointerTott__MetadataInput(struct soap *soap, const char *tag, struct tt__MetadataInput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataInput **)soap_malloc(soap, sizeof(struct tt__MetadataInput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataInput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataInput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataInput, sizeof(struct tt__MetadataInput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataInput(struct soap *soap, struct tt__MetadataInput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MetadataInput);
	if (soap_out_PointerTott__MetadataInput(soap, tag?tag:"tt:MetadataInput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataInput ** SOAP_FMAC4 soap_get_PointerTott__MetadataInput(struct soap *soap, struct tt__MetadataInput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SourceIdentification(struct soap *soap, struct tt__SourceIdentification *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SourceIdentification))
		soap_serialize_tt__SourceIdentification(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SourceIdentification(struct soap *soap, const char *tag, int id, struct tt__SourceIdentification *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SourceIdentification);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SourceIdentification(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SourceIdentification ** SOAP_FMAC4 soap_in_PointerTott__SourceIdentification(struct soap *soap, const char *tag, struct tt__SourceIdentification **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SourceIdentification **)soap_malloc(soap, sizeof(struct tt__SourceIdentification *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SourceIdentification(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SourceIdentification **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SourceIdentification, sizeof(struct tt__SourceIdentification), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SourceIdentification(struct soap *soap, struct tt__SourceIdentification *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SourceIdentification);
	if (soap_out_PointerTott__SourceIdentification(soap, tag?tag:"tt:SourceIdentification", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SourceIdentification ** SOAP_FMAC4 soap_get_PointerTott__SourceIdentification(struct soap *soap, struct tt__SourceIdentification **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SourceIdentification(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, struct tt__AnalyticsDeviceEngineConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration))
		soap_serialize_tt__AnalyticsDeviceEngineConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, int id, struct tt__AnalyticsDeviceEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsDeviceEngineConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, const char *tag, struct tt__AnalyticsDeviceEngineConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsDeviceEngineConfiguration **)soap_malloc(soap, sizeof(struct tt__AnalyticsDeviceEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsDeviceEngineConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsDeviceEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsDeviceEngineConfiguration, sizeof(struct tt__AnalyticsDeviceEngineConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, struct tt__AnalyticsDeviceEngineConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsDeviceEngineConfiguration);
	if (soap_out_PointerTott__AnalyticsDeviceEngineConfiguration(soap, tag?tag:"tt:AnalyticsDeviceEngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsDeviceEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsDeviceEngineConfiguration(struct soap *soap, struct tt__AnalyticsDeviceEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsDeviceEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ObjectExtension(struct soap *soap, struct tt__ObjectExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ObjectExtension))
		soap_serialize_tt__ObjectExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ObjectExtension(struct soap *soap, const char *tag, int id, struct tt__ObjectExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ObjectExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ObjectExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ObjectExtension ** SOAP_FMAC4 soap_in_PointerTott__ObjectExtension(struct soap *soap, const char *tag, struct tt__ObjectExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ObjectExtension **)soap_malloc(soap, sizeof(struct tt__ObjectExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ObjectExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ObjectExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ObjectExtension, sizeof(struct tt__ObjectExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ObjectExtension(struct soap *soap, struct tt__ObjectExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ObjectExtension);
	if (soap_out_PointerTott__ObjectExtension(soap, tag?tag:"tt:ObjectExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ObjectExtension ** SOAP_FMAC4 soap_get_PointerTott__ObjectExtension(struct soap *soap, struct tt__ObjectExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ObjectExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Behaviour(struct soap *soap, struct tt__Behaviour *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Behaviour))
		soap_serialize_tt__Behaviour(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Behaviour(struct soap *soap, const char *tag, int id, struct tt__Behaviour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Behaviour);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Behaviour(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Behaviour ** SOAP_FMAC4 soap_in_PointerTott__Behaviour(struct soap *soap, const char *tag, struct tt__Behaviour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Behaviour **)soap_malloc(soap, sizeof(struct tt__Behaviour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Behaviour(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Behaviour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Behaviour, sizeof(struct tt__Behaviour), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Behaviour(struct soap *soap, struct tt__Behaviour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Behaviour);
	if (soap_out_PointerTott__Behaviour(soap, tag?tag:"tt:Behaviour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Behaviour ** SOAP_FMAC4 soap_get_PointerTott__Behaviour(struct soap *soap, struct tt__Behaviour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Behaviour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Appearance(struct soap *soap, struct tt__Appearance *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Appearance))
		soap_serialize_tt__Appearance(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Appearance(struct soap *soap, const char *tag, int id, struct tt__Appearance *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Appearance);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Appearance(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Appearance ** SOAP_FMAC4 soap_in_PointerTott__Appearance(struct soap *soap, const char *tag, struct tt__Appearance **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Appearance **)soap_malloc(soap, sizeof(struct tt__Appearance *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Appearance(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Appearance **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Appearance, sizeof(struct tt__Appearance), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Appearance(struct soap *soap, struct tt__Appearance *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Appearance);
	if (soap_out_PointerTott__Appearance(soap, tag?tag:"tt:Appearance", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Appearance ** SOAP_FMAC4 soap_get_PointerTott__Appearance(struct soap *soap, struct tt__Appearance **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Appearance(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationExtension))
		soap_serialize_tt__PTZConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__PTZConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationExtension(struct soap *soap, const char *tag, struct tt__PTZConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__PTZConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationExtension, sizeof(struct tt__PTZConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZConfigurationExtension);
	if (soap_out_PointerTott__PTZConfigurationExtension(soap, tag?tag:"tt:PTZConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationExtension(struct soap *soap, struct tt__PTZConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ZoomLimits))
		soap_serialize_tt__ZoomLimits(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ZoomLimits(struct soap *soap, const char *tag, int id, struct tt__ZoomLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ZoomLimits);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ZoomLimits(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ZoomLimits ** SOAP_FMAC4 soap_in_PointerTott__ZoomLimits(struct soap *soap, const char *tag, struct tt__ZoomLimits **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ZoomLimits **)soap_malloc(soap, sizeof(struct tt__ZoomLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ZoomLimits(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ZoomLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ZoomLimits, sizeof(struct tt__ZoomLimits), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ZoomLimits(struct soap *soap, struct tt__ZoomLimits *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ZoomLimits);
	if (soap_out_PointerTott__ZoomLimits(soap, tag?tag:"tt:ZoomLimits", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ZoomLimits ** SOAP_FMAC4 soap_get_PointerTott__ZoomLimits(struct soap *soap, struct tt__ZoomLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ZoomLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PanTiltLimits))
		soap_serialize_tt__PanTiltLimits(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, int id, struct tt__PanTiltLimits *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PanTiltLimits);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PanTiltLimits(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PanTiltLimits ** SOAP_FMAC4 soap_in_PointerTott__PanTiltLimits(struct soap *soap, const char *tag, struct tt__PanTiltLimits **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PanTiltLimits **)soap_malloc(soap, sizeof(struct tt__PanTiltLimits *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PanTiltLimits(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PanTiltLimits **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PanTiltLimits, sizeof(struct tt__PanTiltLimits), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PanTiltLimits);
	if (soap_out_PointerTott__PanTiltLimits(soap, tag?tag:"tt:PanTiltLimits", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PanTiltLimits ** SOAP_FMAC4 soap_get_PointerTott__PanTiltLimits(struct soap *soap, struct tt__PanTiltLimits **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PanTiltLimits(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZNodeExtension(struct soap *soap, struct tt__PTZNodeExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZNodeExtension))
		soap_serialize_tt__PTZNodeExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZNodeExtension(struct soap *soap, const char *tag, int id, struct tt__PTZNodeExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZNodeExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZNodeExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZNodeExtension ** SOAP_FMAC4 soap_in_PointerTott__PTZNodeExtension(struct soap *soap, const char *tag, struct tt__PTZNodeExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZNodeExtension **)soap_malloc(soap, sizeof(struct tt__PTZNodeExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZNodeExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZNodeExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZNodeExtension, sizeof(struct tt__PTZNodeExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZNodeExtension(struct soap *soap, struct tt__PTZNodeExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZNodeExtension);
	if (soap_out_PointerTott__PTZNodeExtension(soap, tag?tag:"tt:PTZNodeExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZNodeExtension ** SOAP_FMAC4 soap_get_PointerTott__PTZNodeExtension(struct soap *soap, struct tt__PTZNodeExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZNodeExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceExtension))
		soap_serialize_tt__NetworkInterfaceExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceExtension(struct soap *soap, const char *tag, struct tt__NetworkInterfaceExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceExtension **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceExtension, sizeof(struct tt__NetworkInterfaceExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceExtension);
	if (soap_out_PointerTott__NetworkInterfaceExtension(soap, tag?tag:"tt:NetworkInterfaceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceExtension ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceExtension(struct soap *soap, struct tt__NetworkInterfaceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv6NetworkInterface))
		soap_serialize_tt__IPv6NetworkInterface(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, int id, struct tt__IPv6NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv6NetworkInterface);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv6NetworkInterface(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv6NetworkInterface(struct soap *soap, const char *tag, struct tt__IPv6NetworkInterface **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPv6NetworkInterface **)soap_malloc(soap, sizeof(struct tt__IPv6NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv6NetworkInterface(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPv6NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv6NetworkInterface, sizeof(struct tt__IPv6NetworkInterface), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv6NetworkInterface);
	if (soap_out_PointerTott__IPv6NetworkInterface(soap, tag?tag:"tt:IPv6NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv6NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv6NetworkInterface(struct soap *soap, struct tt__IPv6NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv6NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPv4NetworkInterface))
		soap_serialize_tt__IPv4NetworkInterface(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, int id, struct tt__IPv4NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPv4NetworkInterface);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPv4NetworkInterface(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__IPv4NetworkInterface(struct soap *soap, const char *tag, struct tt__IPv4NetworkInterface **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPv4NetworkInterface **)soap_malloc(soap, sizeof(struct tt__IPv4NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPv4NetworkInterface(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPv4NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPv4NetworkInterface, sizeof(struct tt__IPv4NetworkInterface), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPv4NetworkInterface);
	if (soap_out_PointerTott__IPv4NetworkInterface(soap, tag?tag:"tt:IPv4NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPv4NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__IPv4NetworkInterface(struct soap *soap, struct tt__IPv4NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPv4NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceLink))
		soap_serialize_tt__NetworkInterfaceLink(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceLink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceLink);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceLink(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceLink(struct soap *soap, const char *tag, struct tt__NetworkInterfaceLink **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceLink **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceLink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceLink(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceLink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceLink, sizeof(struct tt__NetworkInterfaceLink), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceLink);
	if (soap_out_PointerTott__NetworkInterfaceLink(soap, tag?tag:"tt:NetworkInterfaceLink", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceLink ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceLink(struct soap *soap, struct tt__NetworkInterfaceLink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceLink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceInfo))
		soap_serialize_tt__NetworkInterfaceInfo(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceInfo *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceInfo);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceInfo(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceInfo(struct soap *soap, const char *tag, struct tt__NetworkInterfaceInfo **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceInfo **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceInfo *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceInfo(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceInfo **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceInfo, sizeof(struct tt__NetworkInterfaceInfo), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceInfo);
	if (soap_out_PointerTott__NetworkInterfaceInfo(soap, tag?tag:"tt:NetworkInterfaceInfo", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceInfo ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceInfo(struct soap *soap, struct tt__NetworkInterfaceInfo **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceInfo(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoOutputExtension(struct soap *soap, struct tt__VideoOutputExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoOutputExtension))
		soap_serialize_tt__VideoOutputExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoOutputExtension(struct soap *soap, const char *tag, int id, struct tt__VideoOutputExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoOutputExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoOutputExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoOutputExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoOutputExtension(struct soap *soap, const char *tag, struct tt__VideoOutputExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoOutputExtension **)soap_malloc(soap, sizeof(struct tt__VideoOutputExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoOutputExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoOutputExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoOutputExtension, sizeof(struct tt__VideoOutputExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoOutputExtension(struct soap *soap, struct tt__VideoOutputExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoOutputExtension);
	if (soap_out_PointerTott__VideoOutputExtension(soap, tag?tag:"tt:VideoOutputExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoOutputExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoOutputExtension(struct soap *soap, struct tt__VideoOutputExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoOutputExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfigurationExtension(struct soap *soap, struct tt__MetadataConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfigurationExtension))
		soap_serialize_tt__MetadataConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__MetadataConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfigurationExtension(struct soap *soap, const char *tag, struct tt__MetadataConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__MetadataConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationExtension, sizeof(struct tt__MetadataConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfigurationExtension(struct soap *soap, struct tt__MetadataConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MetadataConfigurationExtension);
	if (soap_out_PointerTott__MetadataConfigurationExtension(soap, tag?tag:"tt:MetadataConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfigurationExtension(struct soap *soap, struct tt__MetadataConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventSubscription(struct soap *soap, struct tt__EventSubscription *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventSubscription))
		soap_serialize_tt__EventSubscription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventSubscription(struct soap *soap, const char *tag, int id, struct tt__EventSubscription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventSubscription);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EventSubscription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EventSubscription ** SOAP_FMAC4 soap_in_PointerTott__EventSubscription(struct soap *soap, const char *tag, struct tt__EventSubscription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EventSubscription **)soap_malloc(soap, sizeof(struct tt__EventSubscription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EventSubscription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EventSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventSubscription, sizeof(struct tt__EventSubscription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventSubscription(struct soap *soap, struct tt__EventSubscription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__EventSubscription);
	if (soap_out_PointerTott__EventSubscription(soap, tag?tag:"tt:EventSubscription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventSubscription ** SOAP_FMAC4 soap_get_PointerTott__EventSubscription(struct soap *soap, struct tt__EventSubscription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZFilter(struct soap *soap, struct tt__PTZFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZFilter))
		soap_serialize_tt__PTZFilter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZFilter(struct soap *soap, const char *tag, int id, struct tt__PTZFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZFilter);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZFilter ** SOAP_FMAC4 soap_in_PointerTott__PTZFilter(struct soap *soap, const char *tag, struct tt__PTZFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZFilter **)soap_malloc(soap, sizeof(struct tt__PTZFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZFilter, sizeof(struct tt__PTZFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZFilter(struct soap *soap, struct tt__PTZFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZFilter);
	if (soap_out_PointerTott__PTZFilter(soap, tag?tag:"tt:PTZFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZFilter ** SOAP_FMAC4 soap_get_PointerTott__PTZFilter(struct soap *soap, struct tt__PTZFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RuleEngineConfiguration(struct soap *soap, struct tt__RuleEngineConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RuleEngineConfiguration))
		soap_serialize_tt__RuleEngineConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RuleEngineConfiguration(struct soap *soap, const char *tag, int id, struct tt__RuleEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RuleEngineConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RuleEngineConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RuleEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__RuleEngineConfiguration(struct soap *soap, const char *tag, struct tt__RuleEngineConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RuleEngineConfiguration **)soap_malloc(soap, sizeof(struct tt__RuleEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RuleEngineConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RuleEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RuleEngineConfiguration, sizeof(struct tt__RuleEngineConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RuleEngineConfiguration(struct soap *soap, struct tt__RuleEngineConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RuleEngineConfiguration);
	if (soap_out_PointerTott__RuleEngineConfiguration(soap, tag?tag:"tt:RuleEngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RuleEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__RuleEngineConfiguration(struct soap *soap, struct tt__RuleEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RuleEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, struct tt__AnalyticsEngineConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AnalyticsEngineConfiguration))
		soap_serialize_tt__AnalyticsEngineConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, int id, struct tt__AnalyticsEngineConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AnalyticsEngineConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AnalyticsEngineConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_in_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, const char *tag, struct tt__AnalyticsEngineConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AnalyticsEngineConfiguration **)soap_malloc(soap, sizeof(struct tt__AnalyticsEngineConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AnalyticsEngineConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AnalyticsEngineConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AnalyticsEngineConfiguration, sizeof(struct tt__AnalyticsEngineConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, struct tt__AnalyticsEngineConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AnalyticsEngineConfiguration);
	if (soap_out_PointerTott__AnalyticsEngineConfiguration(soap, tag?tag:"tt:AnalyticsEngineConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AnalyticsEngineConfiguration ** SOAP_FMAC4 soap_get_PointerTott__AnalyticsEngineConfiguration(struct soap *soap, struct tt__AnalyticsEngineConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AnalyticsEngineConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MulticastConfiguration))
		soap_serialize_tt__MulticastConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, int id, struct tt__MulticastConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MulticastConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MulticastConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MulticastConfiguration ** SOAP_FMAC4 soap_in_PointerTott__MulticastConfiguration(struct soap *soap, const char *tag, struct tt__MulticastConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MulticastConfiguration **)soap_malloc(soap, sizeof(struct tt__MulticastConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MulticastConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MulticastConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MulticastConfiguration, sizeof(struct tt__MulticastConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MulticastConfiguration);
	if (soap_out_PointerTott__MulticastConfiguration(soap, tag?tag:"tt:MulticastConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MulticastConfiguration ** SOAP_FMAC4 soap_get_PointerTott__MulticastConfiguration(struct soap *soap, struct tt__MulticastConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MulticastConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__H264Configuration(struct soap *soap, struct tt__H264Configuration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__H264Configuration))
		soap_serialize_tt__H264Configuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__H264Configuration(struct soap *soap, const char *tag, int id, struct tt__H264Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__H264Configuration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__H264Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__H264Configuration ** SOAP_FMAC4 soap_in_PointerTott__H264Configuration(struct soap *soap, const char *tag, struct tt__H264Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__H264Configuration **)soap_malloc(soap, sizeof(struct tt__H264Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__H264Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__H264Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__H264Configuration, sizeof(struct tt__H264Configuration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__H264Configuration(struct soap *soap, struct tt__H264Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__H264Configuration);
	if (soap_out_PointerTott__H264Configuration(soap, tag?tag:"tt:H264Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__H264Configuration ** SOAP_FMAC4 soap_get_PointerTott__H264Configuration(struct soap *soap, struct tt__H264Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__H264Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Mpeg4Configuration))
		soap_serialize_tt__Mpeg4Configuration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, int id, struct tt__Mpeg4Configuration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Mpeg4Configuration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Mpeg4Configuration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Mpeg4Configuration ** SOAP_FMAC4 soap_in_PointerTott__Mpeg4Configuration(struct soap *soap, const char *tag, struct tt__Mpeg4Configuration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Mpeg4Configuration **)soap_malloc(soap, sizeof(struct tt__Mpeg4Configuration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Mpeg4Configuration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Mpeg4Configuration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Mpeg4Configuration, sizeof(struct tt__Mpeg4Configuration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Mpeg4Configuration);
	if (soap_out_PointerTott__Mpeg4Configuration(soap, tag?tag:"tt:Mpeg4Configuration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Mpeg4Configuration ** SOAP_FMAC4 soap_get_PointerTott__Mpeg4Configuration(struct soap *soap, struct tt__Mpeg4Configuration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Mpeg4Configuration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoRateControl(struct soap *soap, struct tt__VideoRateControl *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoRateControl))
		soap_serialize_tt__VideoRateControl(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoRateControl(struct soap *soap, const char *tag, int id, struct tt__VideoRateControl *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoRateControl);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoRateControl(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoRateControl ** SOAP_FMAC4 soap_in_PointerTott__VideoRateControl(struct soap *soap, const char *tag, struct tt__VideoRateControl **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoRateControl **)soap_malloc(soap, sizeof(struct tt__VideoRateControl *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoRateControl(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoRateControl **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoRateControl, sizeof(struct tt__VideoRateControl), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoRateControl(struct soap *soap, struct tt__VideoRateControl *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoRateControl);
	if (soap_out_PointerTott__VideoRateControl(soap, tag?tag:"tt:VideoRateControl", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoRateControl ** SOAP_FMAC4 soap_get_PointerTott__VideoRateControl(struct soap *soap, struct tt__VideoRateControl **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoRateControl(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, struct tt__VideoSourceConfigurationExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationExtension))
		soap_serialize_tt__VideoSourceConfigurationExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfigurationExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceConfigurationExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceConfigurationExtension **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfigurationExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceConfigurationExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationExtension, sizeof(struct tt__VideoSourceConfigurationExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, struct tt__VideoSourceConfigurationExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoSourceConfigurationExtension);
	if (soap_out_PointerTott__VideoSourceConfigurationExtension(soap, tag?tag:"tt:VideoSourceConfigurationExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationExtension(struct soap *soap, struct tt__VideoSourceConfigurationExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IntRectangle(struct soap *soap, struct tt__IntRectangle *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IntRectangle))
		soap_serialize_tt__IntRectangle(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IntRectangle(struct soap *soap, const char *tag, int id, struct tt__IntRectangle *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IntRectangle);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IntRectangle(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IntRectangle ** SOAP_FMAC4 soap_in_PointerTott__IntRectangle(struct soap *soap, const char *tag, struct tt__IntRectangle **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IntRectangle **)soap_malloc(soap, sizeof(struct tt__IntRectangle *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IntRectangle(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IntRectangle **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IntRectangle, sizeof(struct tt__IntRectangle), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IntRectangle(struct soap *soap, struct tt__IntRectangle *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IntRectangle);
	if (soap_out_PointerTott__IntRectangle(soap, tag?tag:"tt:IntRectangle", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IntRectangle ** SOAP_FMAC4 soap_get_PointerTott__IntRectangle(struct soap *soap, struct tt__IntRectangle **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IntRectangle(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceExtension(struct soap *soap, struct tt__VideoSourceExtension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceExtension))
		soap_serialize_tt__VideoSourceExtension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceExtension(struct soap *soap, const char *tag, int id, struct tt__VideoSourceExtension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceExtension);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceExtension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceExtension ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceExtension(struct soap *soap, const char *tag, struct tt__VideoSourceExtension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceExtension **)soap_malloc(soap, sizeof(struct tt__VideoSourceExtension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceExtension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceExtension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceExtension, sizeof(struct tt__VideoSourceExtension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceExtension(struct soap *soap, struct tt__VideoSourceExtension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoSourceExtension);
	if (soap_out_PointerTott__VideoSourceExtension(soap, tag?tag:"tt:VideoSourceExtension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceExtension ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceExtension(struct soap *soap, struct tt__VideoSourceExtension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceExtension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingSettings(struct soap *soap, struct tt__ImagingSettings *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingSettings))
		soap_serialize_tt__ImagingSettings(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingSettings(struct soap *soap, const char *tag, int id, struct tt__ImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingSettings);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingSettings ** SOAP_FMAC4 soap_in_PointerTott__ImagingSettings(struct soap *soap, const char *tag, struct tt__ImagingSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingSettings **)soap_malloc(soap, sizeof(struct tt__ImagingSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingSettings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingSettings, sizeof(struct tt__ImagingSettings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingSettings(struct soap *soap, struct tt__ImagingSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingSettings);
	if (soap_out_PointerTott__ImagingSettings(soap, tag?tag:"tt:ImagingSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingSettings ** SOAP_FMAC4 soap_get_PointerTott__ImagingSettings(struct soap *soap, struct tt__ImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindMetadataResultList(struct soap *soap, struct tt__FindMetadataResultList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindMetadataResultList))
		soap_serialize_tt__FindMetadataResultList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindMetadataResultList(struct soap *soap, const char *tag, int id, struct tt__FindMetadataResultList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindMetadataResultList);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FindMetadataResultList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FindMetadataResultList ** SOAP_FMAC4 soap_in_PointerTott__FindMetadataResultList(struct soap *soap, const char *tag, struct tt__FindMetadataResultList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FindMetadataResultList **)soap_malloc(soap, sizeof(struct tt__FindMetadataResultList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FindMetadataResultList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FindMetadataResultList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindMetadataResultList, sizeof(struct tt__FindMetadataResultList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindMetadataResultList(struct soap *soap, struct tt__FindMetadataResultList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FindMetadataResultList);
	if (soap_out_PointerTott__FindMetadataResultList(soap, tag?tag:"tt:FindMetadataResultList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindMetadataResultList ** SOAP_FMAC4 soap_get_PointerTott__FindMetadataResultList(struct soap *soap, struct tt__FindMetadataResultList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindMetadataResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataFilter(struct soap *soap, struct tt__MetadataFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataFilter))
		soap_serialize_tt__MetadataFilter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataFilter(struct soap *soap, const char *tag, int id, struct tt__MetadataFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataFilter);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataFilter ** SOAP_FMAC4 soap_in_PointerTott__MetadataFilter(struct soap *soap, const char *tag, struct tt__MetadataFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataFilter **)soap_malloc(soap, sizeof(struct tt__MetadataFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataFilter, sizeof(struct tt__MetadataFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataFilter(struct soap *soap, struct tt__MetadataFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MetadataFilter);
	if (soap_out_PointerTott__MetadataFilter(soap, tag?tag:"tt:MetadataFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataFilter ** SOAP_FMAC4 soap_get_PointerTott__MetadataFilter(struct soap *soap, struct tt__MetadataFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindPTZPositionResultList(struct soap *soap, struct tt__FindPTZPositionResultList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindPTZPositionResultList))
		soap_serialize_tt__FindPTZPositionResultList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindPTZPositionResultList(struct soap *soap, const char *tag, int id, struct tt__FindPTZPositionResultList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindPTZPositionResultList);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FindPTZPositionResultList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FindPTZPositionResultList ** SOAP_FMAC4 soap_in_PointerTott__FindPTZPositionResultList(struct soap *soap, const char *tag, struct tt__FindPTZPositionResultList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FindPTZPositionResultList **)soap_malloc(soap, sizeof(struct tt__FindPTZPositionResultList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FindPTZPositionResultList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FindPTZPositionResultList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindPTZPositionResultList, sizeof(struct tt__FindPTZPositionResultList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindPTZPositionResultList(struct soap *soap, struct tt__FindPTZPositionResultList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FindPTZPositionResultList);
	if (soap_out_PointerTott__FindPTZPositionResultList(soap, tag?tag:"tt:FindPTZPositionResultList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindPTZPositionResultList ** SOAP_FMAC4 soap_get_PointerTott__FindPTZPositionResultList(struct soap *soap, struct tt__FindPTZPositionResultList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindPTZPositionResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPositionFilter(struct soap *soap, struct tt__PTZPositionFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPositionFilter))
		soap_serialize_tt__PTZPositionFilter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPositionFilter(struct soap *soap, const char *tag, int id, struct tt__PTZPositionFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPositionFilter);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPositionFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPositionFilter ** SOAP_FMAC4 soap_in_PointerTott__PTZPositionFilter(struct soap *soap, const char *tag, struct tt__PTZPositionFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPositionFilter **)soap_malloc(soap, sizeof(struct tt__PTZPositionFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPositionFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPositionFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPositionFilter, sizeof(struct tt__PTZPositionFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPositionFilter(struct soap *soap, struct tt__PTZPositionFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPositionFilter);
	if (soap_out_PointerTott__PTZPositionFilter(soap, tag?tag:"tt:PTZPositionFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPositionFilter ** SOAP_FMAC4 soap_get_PointerTott__PTZPositionFilter(struct soap *soap, struct tt__PTZPositionFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPositionFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindEventResultList(struct soap *soap, struct tt__FindEventResultList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindEventResultList))
		soap_serialize_tt__FindEventResultList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindEventResultList(struct soap *soap, const char *tag, int id, struct tt__FindEventResultList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindEventResultList);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FindEventResultList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FindEventResultList ** SOAP_FMAC4 soap_in_PointerTott__FindEventResultList(struct soap *soap, const char *tag, struct tt__FindEventResultList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FindEventResultList **)soap_malloc(soap, sizeof(struct tt__FindEventResultList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FindEventResultList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FindEventResultList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindEventResultList, sizeof(struct tt__FindEventResultList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindEventResultList(struct soap *soap, struct tt__FindEventResultList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FindEventResultList);
	if (soap_out_PointerTott__FindEventResultList(soap, tag?tag:"tt:FindEventResultList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindEventResultList ** SOAP_FMAC4 soap_get_PointerTott__FindEventResultList(struct soap *soap, struct tt__FindEventResultList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindEventResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__EventFilter(struct soap *soap, struct tt__EventFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__EventFilter))
		soap_serialize_tt__EventFilter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__EventFilter(struct soap *soap, const char *tag, int id, struct tt__EventFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__EventFilter);
	if (id < 0)
		return soap->error;
	return soap_out_tt__EventFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__EventFilter ** SOAP_FMAC4 soap_in_PointerTott__EventFilter(struct soap *soap, const char *tag, struct tt__EventFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__EventFilter **)soap_malloc(soap, sizeof(struct tt__EventFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__EventFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__EventFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__EventFilter, sizeof(struct tt__EventFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__EventFilter(struct soap *soap, struct tt__EventFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__EventFilter);
	if (soap_out_PointerTott__EventFilter(soap, tag?tag:"tt:EventFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventFilter ** SOAP_FMAC4 soap_get_PointerTott__EventFilter(struct soap *soap, struct tt__EventFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__EventFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FindRecordingResultList(struct soap *soap, struct tt__FindRecordingResultList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FindRecordingResultList))
		soap_serialize_tt__FindRecordingResultList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FindRecordingResultList(struct soap *soap, const char *tag, int id, struct tt__FindRecordingResultList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FindRecordingResultList);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FindRecordingResultList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FindRecordingResultList ** SOAP_FMAC4 soap_in_PointerTott__FindRecordingResultList(struct soap *soap, const char *tag, struct tt__FindRecordingResultList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FindRecordingResultList **)soap_malloc(soap, sizeof(struct tt__FindRecordingResultList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FindRecordingResultList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FindRecordingResultList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FindRecordingResultList, sizeof(struct tt__FindRecordingResultList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FindRecordingResultList(struct soap *soap, struct tt__FindRecordingResultList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FindRecordingResultList);
	if (soap_out_PointerTott__FindRecordingResultList(soap, tag?tag:"tt:FindRecordingResultList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FindRecordingResultList ** SOAP_FMAC4 soap_get_PointerTott__FindRecordingResultList(struct soap *soap, struct tt__FindRecordingResultList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FindRecordingResultList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SearchScope(struct soap *soap, struct tt__SearchScope *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SearchScope))
		soap_serialize_tt__SearchScope(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SearchScope(struct soap *soap, const char *tag, int id, struct tt__SearchScope *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SearchScope);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SearchScope(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SearchScope ** SOAP_FMAC4 soap_in_PointerTott__SearchScope(struct soap *soap, const char *tag, struct tt__SearchScope **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SearchScope **)soap_malloc(soap, sizeof(struct tt__SearchScope *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SearchScope(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SearchScope **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SearchScope, sizeof(struct tt__SearchScope), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SearchScope(struct soap *soap, struct tt__SearchScope *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SearchScope);
	if (soap_out_PointerTott__SearchScope(soap, tag?tag:"tt:SearchScope", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SearchScope ** SOAP_FMAC4 soap_get_PointerTott__SearchScope(struct soap *soap, struct tt__SearchScope **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SearchScope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaAttributes(struct soap *soap, struct tt__MediaAttributes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaAttributes))
		soap_serialize_tt__MediaAttributes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaAttributes(struct soap *soap, const char *tag, int id, struct tt__MediaAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaAttributes);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MediaAttributes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MediaAttributes ** SOAP_FMAC4 soap_in_PointerTott__MediaAttributes(struct soap *soap, const char *tag, struct tt__MediaAttributes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MediaAttributes **)soap_malloc(soap, sizeof(struct tt__MediaAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MediaAttributes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MediaAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaAttributes, sizeof(struct tt__MediaAttributes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaAttributes(struct soap *soap, struct tt__MediaAttributes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MediaAttributes);
	if (soap_out_PointerTott__MediaAttributes(soap, tag?tag:"tt:MediaAttributes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaAttributes ** SOAP_FMAC4 soap_get_PointerTott__MediaAttributes(struct soap *soap, struct tt__MediaAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingSummary(struct soap *soap, struct tt__RecordingSummary *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingSummary))
		soap_serialize_tt__RecordingSummary(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingSummary(struct soap *soap, const char *tag, int id, struct tt__RecordingSummary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingSummary);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingSummary(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingSummary ** SOAP_FMAC4 soap_in_PointerTott__RecordingSummary(struct soap *soap, const char *tag, struct tt__RecordingSummary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingSummary **)soap_malloc(soap, sizeof(struct tt__RecordingSummary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingSummary(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingSummary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingSummary, sizeof(struct tt__RecordingSummary), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingSummary(struct soap *soap, struct tt__RecordingSummary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingSummary);
	if (soap_out_PointerTott__RecordingSummary(soap, tag?tag:"tt:RecordingSummary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingSummary ** SOAP_FMAC4 soap_get_PointerTott__RecordingSummary(struct soap *soap, struct tt__RecordingSummary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotse__Capabilities(struct soap *soap, struct tse__Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tse__Capabilities))
		soap_serialize_tse__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotse__Capabilities(struct soap *soap, const char *tag, int id, struct tse__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tse__Capabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tse__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tse__Capabilities ** SOAP_FMAC4 soap_in_PointerTotse__Capabilities(struct soap *soap, const char *tag, struct tse__Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tse__Capabilities **)soap_malloc(soap, sizeof(struct tse__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tse__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tse__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tse__Capabilities, sizeof(struct tse__Capabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotse__Capabilities(struct soap *soap, struct tse__Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotse__Capabilities);
	if (soap_out_PointerTotse__Capabilities(soap, tag?tag:"tse:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tse__Capabilities ** SOAP_FMAC4 soap_get_PointerTotse__Capabilities(struct soap *soap, struct tse__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotse__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReplayConfiguration(struct soap *soap, struct tt__ReplayConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReplayConfiguration))
		soap_serialize_tt__ReplayConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReplayConfiguration(struct soap *soap, const char *tag, int id, struct tt__ReplayConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReplayConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReplayConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ReplayConfiguration ** SOAP_FMAC4 soap_in_PointerTott__ReplayConfiguration(struct soap *soap, const char *tag, struct tt__ReplayConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ReplayConfiguration **)soap_malloc(soap, sizeof(struct tt__ReplayConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReplayConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ReplayConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReplayConfiguration, sizeof(struct tt__ReplayConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReplayConfiguration(struct soap *soap, struct tt__ReplayConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ReplayConfiguration);
	if (soap_out_PointerTott__ReplayConfiguration(soap, tag?tag:"tt:ReplayConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReplayConfiguration ** SOAP_FMAC4 soap_get_PointerTott__ReplayConfiguration(struct soap *soap, struct tt__ReplayConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReplayConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrp__Capabilities(struct soap *soap, struct trp__Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trp__Capabilities))
		soap_serialize_trp__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrp__Capabilities(struct soap *soap, const char *tag, int id, struct trp__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trp__Capabilities);
	if (id < 0)
		return soap->error;
	return soap_out_trp__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trp__Capabilities ** SOAP_FMAC4 soap_in_PointerTotrp__Capabilities(struct soap *soap, const char *tag, struct trp__Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trp__Capabilities **)soap_malloc(soap, sizeof(struct trp__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trp__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trp__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trp__Capabilities, sizeof(struct trp__Capabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrp__Capabilities(struct soap *soap, struct trp__Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrp__Capabilities);
	if (soap_out_PointerTotrp__Capabilities(soap, tag?tag:"trp:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trp__Capabilities ** SOAP_FMAC4 soap_get_PointerTotrp__Capabilities(struct soap *soap, struct trp__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrp__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrc__RecordingOptions(struct soap *soap, struct trc__RecordingOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trc__RecordingOptions))
		soap_serialize_trc__RecordingOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrc__RecordingOptions(struct soap *soap, const char *tag, int id, struct trc__RecordingOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trc__RecordingOptions);
	if (id < 0)
		return soap->error;
	return soap_out_trc__RecordingOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trc__RecordingOptions ** SOAP_FMAC4 soap_in_PointerTotrc__RecordingOptions(struct soap *soap, const char *tag, struct trc__RecordingOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trc__RecordingOptions **)soap_malloc(soap, sizeof(struct trc__RecordingOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trc__RecordingOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trc__RecordingOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trc__RecordingOptions, sizeof(struct trc__RecordingOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrc__RecordingOptions(struct soap *soap, struct trc__RecordingOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrc__RecordingOptions);
	if (soap_out_PointerTotrc__RecordingOptions(soap, tag?tag:"trc:RecordingOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__RecordingOptions ** SOAP_FMAC4 soap_get_PointerTotrc__RecordingOptions(struct soap *soap, struct trc__RecordingOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrc__RecordingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RecordingJobStateInformation(struct soap *soap, struct tt__RecordingJobStateInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RecordingJobStateInformation))
		soap_serialize_tt__RecordingJobStateInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RecordingJobStateInformation(struct soap *soap, const char *tag, int id, struct tt__RecordingJobStateInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RecordingJobStateInformation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RecordingJobStateInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformation ** SOAP_FMAC4 soap_in_PointerTott__RecordingJobStateInformation(struct soap *soap, const char *tag, struct tt__RecordingJobStateInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RecordingJobStateInformation **)soap_malloc(soap, sizeof(struct tt__RecordingJobStateInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RecordingJobStateInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RecordingJobStateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RecordingJobStateInformation, sizeof(struct tt__RecordingJobStateInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RecordingJobStateInformation(struct soap *soap, struct tt__RecordingJobStateInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RecordingJobStateInformation);
	if (soap_out_PointerTott__RecordingJobStateInformation(soap, tag?tag:"tt:RecordingJobStateInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RecordingJobStateInformation ** SOAP_FMAC4 soap_get_PointerTott__RecordingJobStateInformation(struct soap *soap, struct tt__RecordingJobStateInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RecordingJobStateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GetRecordingJobsResponseItem(struct soap *soap, struct tt__GetRecordingJobsResponseItem *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GetRecordingJobsResponseItem))
		soap_serialize_tt__GetRecordingJobsResponseItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GetRecordingJobsResponseItem(struct soap *soap, const char *tag, int id, struct tt__GetRecordingJobsResponseItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GetRecordingJobsResponseItem);
	if (id < 0)
		return soap->error;
	return soap_out_tt__GetRecordingJobsResponseItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__GetRecordingJobsResponseItem ** SOAP_FMAC4 soap_in_PointerTott__GetRecordingJobsResponseItem(struct soap *soap, const char *tag, struct tt__GetRecordingJobsResponseItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__GetRecordingJobsResponseItem **)soap_malloc(soap, sizeof(struct tt__GetRecordingJobsResponseItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__GetRecordingJobsResponseItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__GetRecordingJobsResponseItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GetRecordingJobsResponseItem, sizeof(struct tt__GetRecordingJobsResponseItem), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GetRecordingJobsResponseItem(struct soap *soap, struct tt__GetRecordingJobsResponseItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__GetRecordingJobsResponseItem);
	if (soap_out_PointerTott__GetRecordingJobsResponseItem(soap, tag?tag:"tt:GetRecordingJobsResponseItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetRecordingJobsResponseItem ** SOAP_FMAC4 soap_get_PointerTott__GetRecordingJobsResponseItem(struct soap *soap, struct tt__GetRecordingJobsResponseItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GetRecordingJobsResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__GetRecordingsResponseItem(struct soap *soap, struct tt__GetRecordingsResponseItem *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__GetRecordingsResponseItem))
		soap_serialize_tt__GetRecordingsResponseItem(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__GetRecordingsResponseItem(struct soap *soap, const char *tag, int id, struct tt__GetRecordingsResponseItem *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__GetRecordingsResponseItem);
	if (id < 0)
		return soap->error;
	return soap_out_tt__GetRecordingsResponseItem(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__GetRecordingsResponseItem ** SOAP_FMAC4 soap_in_PointerTott__GetRecordingsResponseItem(struct soap *soap, const char *tag, struct tt__GetRecordingsResponseItem **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__GetRecordingsResponseItem **)soap_malloc(soap, sizeof(struct tt__GetRecordingsResponseItem *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__GetRecordingsResponseItem(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__GetRecordingsResponseItem **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__GetRecordingsResponseItem, sizeof(struct tt__GetRecordingsResponseItem), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__GetRecordingsResponseItem(struct soap *soap, struct tt__GetRecordingsResponseItem *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__GetRecordingsResponseItem);
	if (soap_out_PointerTott__GetRecordingsResponseItem(soap, tag?tag:"tt:GetRecordingsResponseItem", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__GetRecordingsResponseItem ** SOAP_FMAC4 soap_get_PointerTott__GetRecordingsResponseItem(struct soap *soap, struct tt__GetRecordingsResponseItem **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__GetRecordingsResponseItem(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrc__Capabilities(struct soap *soap, struct trc__Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trc__Capabilities))
		soap_serialize_trc__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrc__Capabilities(struct soap *soap, const char *tag, int id, struct trc__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trc__Capabilities);
	if (id < 0)
		return soap->error;
	return soap_out_trc__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trc__Capabilities ** SOAP_FMAC4 soap_in_PointerTotrc__Capabilities(struct soap *soap, const char *tag, struct trc__Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trc__Capabilities **)soap_malloc(soap, sizeof(struct trc__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trc__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trc__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trc__Capabilities, sizeof(struct trc__Capabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrc__Capabilities(struct soap *soap, struct trc__Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrc__Capabilities);
	if (soap_out_PointerTotrc__Capabilities(soap, tag?tag:"trc:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__Capabilities ** SOAP_FMAC4 soap_get_PointerTotrc__Capabilities(struct soap *soap, struct trc__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrc__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrc__TrackOptions(struct soap *soap, struct trc__TrackOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trc__TrackOptions))
		soap_serialize_trc__TrackOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrc__TrackOptions(struct soap *soap, const char *tag, int id, struct trc__TrackOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trc__TrackOptions);
	if (id < 0)
		return soap->error;
	return soap_out_trc__TrackOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trc__TrackOptions ** SOAP_FMAC4 soap_in_PointerTotrc__TrackOptions(struct soap *soap, const char *tag, struct trc__TrackOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trc__TrackOptions **)soap_malloc(soap, sizeof(struct trc__TrackOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trc__TrackOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trc__TrackOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trc__TrackOptions, sizeof(struct trc__TrackOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrc__TrackOptions(struct soap *soap, struct trc__TrackOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrc__TrackOptions);
	if (soap_out_PointerTotrc__TrackOptions(soap, tag?tag:"trc:TrackOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__TrackOptions ** SOAP_FMAC4 soap_get_PointerTotrc__TrackOptions(struct soap *soap, struct trc__TrackOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrc__TrackOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrc__JobOptions(struct soap *soap, struct trc__JobOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trc__JobOptions))
		soap_serialize_trc__JobOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrc__JobOptions(struct soap *soap, const char *tag, int id, struct trc__JobOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trc__JobOptions);
	if (id < 0)
		return soap->error;
	return soap_out_trc__JobOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trc__JobOptions ** SOAP_FMAC4 soap_in_PointerTotrc__JobOptions(struct soap *soap, const char *tag, struct trc__JobOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trc__JobOptions **)soap_malloc(soap, sizeof(struct trc__JobOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trc__JobOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trc__JobOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trc__JobOptions, sizeof(struct trc__JobOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrc__JobOptions(struct soap *soap, struct trc__JobOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrc__JobOptions);
	if (soap_out_PointerTotrc__JobOptions(soap, tag?tag:"trc:JobOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__JobOptions ** SOAP_FMAC4 soap_get_PointerTotrc__JobOptions(struct soap *soap, struct trc__JobOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrc__JobOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ReceiverStateInformation(struct soap *soap, struct tt__ReceiverStateInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ReceiverStateInformation))
		soap_serialize_tt__ReceiverStateInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ReceiverStateInformation(struct soap *soap, const char *tag, int id, struct tt__ReceiverStateInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ReceiverStateInformation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ReceiverStateInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ReceiverStateInformation ** SOAP_FMAC4 soap_in_PointerTott__ReceiverStateInformation(struct soap *soap, const char *tag, struct tt__ReceiverStateInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ReceiverStateInformation **)soap_malloc(soap, sizeof(struct tt__ReceiverStateInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ReceiverStateInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ReceiverStateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ReceiverStateInformation, sizeof(struct tt__ReceiverStateInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ReceiverStateInformation(struct soap *soap, struct tt__ReceiverStateInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ReceiverStateInformation);
	if (soap_out_PointerTott__ReceiverStateInformation(soap, tag?tag:"tt:ReceiverStateInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ReceiverStateInformation ** SOAP_FMAC4 soap_get_PointerTott__ReceiverStateInformation(struct soap *soap, struct tt__ReceiverStateInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ReceiverStateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Receiver(struct soap *soap, struct tt__Receiver *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Receiver))
		soap_serialize_tt__Receiver(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Receiver(struct soap *soap, const char *tag, int id, struct tt__Receiver *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Receiver);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Receiver(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Receiver ** SOAP_FMAC4 soap_in_PointerTott__Receiver(struct soap *soap, const char *tag, struct tt__Receiver **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Receiver **)soap_malloc(soap, sizeof(struct tt__Receiver *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Receiver(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Receiver **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Receiver, sizeof(struct tt__Receiver), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Receiver(struct soap *soap, struct tt__Receiver *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Receiver);
	if (soap_out_PointerTott__Receiver(soap, tag?tag:"tt:Receiver", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Receiver ** SOAP_FMAC4 soap_get_PointerTott__Receiver(struct soap *soap, struct tt__Receiver **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Receiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrv__Capabilities(struct soap *soap, struct trv__Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trv__Capabilities))
		soap_serialize_trv__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrv__Capabilities(struct soap *soap, const char *tag, int id, struct trv__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trv__Capabilities);
	if (id < 0)
		return soap->error;
	return soap_out_trv__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trv__Capabilities ** SOAP_FMAC4 soap_in_PointerTotrv__Capabilities(struct soap *soap, const char *tag, struct trv__Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trv__Capabilities **)soap_malloc(soap, sizeof(struct trv__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trv__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trv__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trv__Capabilities, sizeof(struct trv__Capabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrv__Capabilities(struct soap *soap, struct trv__Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrv__Capabilities);
	if (soap_out_PointerTotrv__Capabilities(soap, tag?tag:"trv:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trv__Capabilities ** SOAP_FMAC4 soap_get_PointerTotrv__Capabilities(struct soap *soap, struct trv__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrv__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPresetTourOptions(struct soap *soap, struct tt__PTZPresetTourOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPresetTourOptions))
		soap_serialize_tt__PTZPresetTourOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPresetTourOptions(struct soap *soap, const char *tag, int id, struct tt__PTZPresetTourOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPresetTourOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPresetTourOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPresetTourOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZPresetTourOptions(struct soap *soap, const char *tag, struct tt__PTZPresetTourOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPresetTourOptions **)soap_malloc(soap, sizeof(struct tt__PTZPresetTourOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPresetTourOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPresetTourOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPresetTourOptions, sizeof(struct tt__PTZPresetTourOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPresetTourOptions(struct soap *soap, struct tt__PTZPresetTourOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPresetTourOptions);
	if (soap_out_PointerTott__PTZPresetTourOptions(soap, tag?tag:"tt:PTZPresetTourOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPresetTourOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZPresetTourOptions(struct soap *soap, struct tt__PTZPresetTourOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPresetTourOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PresetTour(struct soap *soap, struct tt__PresetTour *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PresetTour))
		soap_serialize_tt__PresetTour(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PresetTour(struct soap *soap, const char *tag, int id, struct tt__PresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PresetTour);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PresetTour(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PresetTour ** SOAP_FMAC4 soap_in_PointerTott__PresetTour(struct soap *soap, const char *tag, struct tt__PresetTour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PresetTour **)soap_malloc(soap, sizeof(struct tt__PresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PresetTour(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PresetTour, sizeof(struct tt__PresetTour), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PresetTour(struct soap *soap, struct tt__PresetTour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PresetTour);
	if (soap_out_PointerTott__PresetTour(soap, tag?tag:"tt:PresetTour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PresetTour ** SOAP_FMAC4 soap_get_PointerTott__PresetTour(struct soap *soap, struct tt__PresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZPreset(struct soap *soap, struct tt__PTZPreset *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZPreset))
		soap_serialize_tt__PTZPreset(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZPreset(struct soap *soap, const char *tag, int id, struct tt__PTZPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZPreset);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZPreset(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZPreset ** SOAP_FMAC4 soap_in_PointerTott__PTZPreset(struct soap *soap, const char *tag, struct tt__PTZPreset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZPreset **)soap_malloc(soap, sizeof(struct tt__PTZPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZPreset(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZPreset, sizeof(struct tt__PTZPreset), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZPreset(struct soap *soap, struct tt__PTZPreset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZPreset);
	if (soap_out_PointerTott__PTZPreset(soap, tag?tag:"tt:PTZPreset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZPreset ** SOAP_FMAC4 soap_get_PointerTott__PTZPreset(struct soap *soap, struct tt__PTZPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZConfigurationOptions(struct soap *soap, struct tt__PTZConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZConfigurationOptions))
		soap_serialize_tt__PTZConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__PTZConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__PTZConfigurationOptions(struct soap *soap, const char *tag, struct tt__PTZConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__PTZConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZConfigurationOptions, sizeof(struct tt__PTZConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZConfigurationOptions(struct soap *soap, struct tt__PTZConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZConfigurationOptions);
	if (soap_out_PointerTott__PTZConfigurationOptions(soap, tag?tag:"tt:PTZConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__PTZConfigurationOptions(struct soap *soap, struct tt__PTZConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, struct __tptz__SetConfigurationResponse_sequence *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE___tptz__SetConfigurationResponse_sequence))
		soap_serialize___tptz__SetConfigurationResponse_sequence(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, const char *tag, int id, struct __tptz__SetConfigurationResponse_sequence *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___tptz__SetConfigurationResponse_sequence);
	if (id < 0)
		return soap->error;
	return soap_out___tptz__SetConfigurationResponse_sequence(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct __tptz__SetConfigurationResponse_sequence ** SOAP_FMAC4 soap_in_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, const char *tag, struct __tptz__SetConfigurationResponse_sequence **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct __tptz__SetConfigurationResponse_sequence **)soap_malloc(soap, sizeof(struct __tptz__SetConfigurationResponse_sequence *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in___tptz__SetConfigurationResponse_sequence(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct __tptz__SetConfigurationResponse_sequence **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___tptz__SetConfigurationResponse_sequence, sizeof(struct __tptz__SetConfigurationResponse_sequence), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, struct __tptz__SetConfigurationResponse_sequence *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__tptz__SetConfigurationResponse_sequence);
	if (soap_out_PointerTo__tptz__SetConfigurationResponse_sequence(soap, tag?tag:"-tptz:SetConfigurationResponse-sequence", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct __tptz__SetConfigurationResponse_sequence ** SOAP_FMAC4 soap_get_PointerTo__tptz__SetConfigurationResponse_sequence(struct soap *soap, struct __tptz__SetConfigurationResponse_sequence **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__tptz__SetConfigurationResponse_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PTZNode(struct soap *soap, struct tt__PTZNode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PTZNode))
		soap_serialize_tt__PTZNode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PTZNode(struct soap *soap, const char *tag, int id, struct tt__PTZNode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PTZNode);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PTZNode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PTZNode ** SOAP_FMAC4 soap_in_PointerTott__PTZNode(struct soap *soap, const char *tag, struct tt__PTZNode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PTZNode **)soap_malloc(soap, sizeof(struct tt__PTZNode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PTZNode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PTZNode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PTZNode, sizeof(struct tt__PTZNode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PTZNode(struct soap *soap, struct tt__PTZNode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PTZNode);
	if (soap_out_PointerTott__PTZNode(soap, tag?tag:"tt:PTZNode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZNode ** SOAP_FMAC4 soap_get_PointerTott__PTZNode(struct soap *soap, struct tt__PTZNode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PTZNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotptz__Capabilities(struct soap *soap, struct tptz__Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tptz__Capabilities))
		soap_serialize_tptz__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotptz__Capabilities(struct soap *soap, const char *tag, int id, struct tptz__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tptz__Capabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tptz__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tptz__Capabilities ** SOAP_FMAC4 soap_in_PointerTotptz__Capabilities(struct soap *soap, const char *tag, struct tptz__Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tptz__Capabilities **)soap_malloc(soap, sizeof(struct tptz__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tptz__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tptz__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tptz__Capabilities, sizeof(struct tptz__Capabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotptz__Capabilities(struct soap *soap, struct tptz__Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotptz__Capabilities);
	if (soap_out_PointerTotptz__Capabilities(soap, tag?tag:"tptz:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tptz__Capabilities ** SOAP_FMAC4 soap_get_PointerTotptz__Capabilities(struct soap *soap, struct tptz__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotptz__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingStatus20(struct soap *soap, struct tt__ImagingStatus20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingStatus20))
		soap_serialize_tt__ImagingStatus20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingStatus20(struct soap *soap, const char *tag, int id, struct tt__ImagingStatus20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingStatus20);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingStatus20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingStatus20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingStatus20(struct soap *soap, const char *tag, struct tt__ImagingStatus20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingStatus20 **)soap_malloc(soap, sizeof(struct tt__ImagingStatus20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingStatus20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingStatus20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingStatus20, sizeof(struct tt__ImagingStatus20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingStatus20(struct soap *soap, struct tt__ImagingStatus20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingStatus20);
	if (soap_out_PointerTott__ImagingStatus20(soap, tag?tag:"tt:ImagingStatus20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingStatus20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingStatus20(struct soap *soap, struct tt__ImagingStatus20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingStatus20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MoveOptions20(struct soap *soap, struct tt__MoveOptions20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MoveOptions20))
		soap_serialize_tt__MoveOptions20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MoveOptions20(struct soap *soap, const char *tag, int id, struct tt__MoveOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MoveOptions20);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MoveOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MoveOptions20 ** SOAP_FMAC4 soap_in_PointerTott__MoveOptions20(struct soap *soap, const char *tag, struct tt__MoveOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MoveOptions20 **)soap_malloc(soap, sizeof(struct tt__MoveOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MoveOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MoveOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MoveOptions20, sizeof(struct tt__MoveOptions20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MoveOptions20(struct soap *soap, struct tt__MoveOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MoveOptions20);
	if (soap_out_PointerTott__MoveOptions20(soap, tag?tag:"tt:MoveOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MoveOptions20 ** SOAP_FMAC4 soap_get_PointerTott__MoveOptions20(struct soap *soap, struct tt__MoveOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MoveOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__FocusMove(struct soap *soap, struct tt__FocusMove *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__FocusMove))
		soap_serialize_tt__FocusMove(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__FocusMove(struct soap *soap, const char *tag, int id, struct tt__FocusMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__FocusMove);
	if (id < 0)
		return soap->error;
	return soap_out_tt__FocusMove(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__FocusMove ** SOAP_FMAC4 soap_in_PointerTott__FocusMove(struct soap *soap, const char *tag, struct tt__FocusMove **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__FocusMove **)soap_malloc(soap, sizeof(struct tt__FocusMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__FocusMove(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__FocusMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__FocusMove, sizeof(struct tt__FocusMove), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__FocusMove(struct soap *soap, struct tt__FocusMove *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__FocusMove);
	if (soap_out_PointerTott__FocusMove(soap, tag?tag:"tt:FocusMove", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__FocusMove ** SOAP_FMAC4 soap_get_PointerTott__FocusMove(struct soap *soap, struct tt__FocusMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__FocusMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__ImagingOptions20(struct soap *soap, struct tt__ImagingOptions20 *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__ImagingOptions20))
		soap_serialize_tt__ImagingOptions20(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__ImagingOptions20(struct soap *soap, const char *tag, int id, struct tt__ImagingOptions20 *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__ImagingOptions20);
	if (id < 0)
		return soap->error;
	return soap_out_tt__ImagingOptions20(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__ImagingOptions20 ** SOAP_FMAC4 soap_in_PointerTott__ImagingOptions20(struct soap *soap, const char *tag, struct tt__ImagingOptions20 **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__ImagingOptions20 **)soap_malloc(soap, sizeof(struct tt__ImagingOptions20 *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__ImagingOptions20(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__ImagingOptions20 **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__ImagingOptions20, sizeof(struct tt__ImagingOptions20), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__ImagingOptions20(struct soap *soap, struct tt__ImagingOptions20 *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__ImagingOptions20);
	if (soap_out_PointerTott__ImagingOptions20(soap, tag?tag:"tt:ImagingOptions20", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__ImagingOptions20 ** SOAP_FMAC4 soap_get_PointerTott__ImagingOptions20(struct soap *soap, struct tt__ImagingOptions20 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__ImagingOptions20(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotimg__Capabilities(struct soap *soap, struct timg__Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_timg__Capabilities))
		soap_serialize_timg__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotimg__Capabilities(struct soap *soap, const char *tag, int id, struct timg__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_timg__Capabilities);
	if (id < 0)
		return soap->error;
	return soap_out_timg__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct timg__Capabilities ** SOAP_FMAC4 soap_in_PointerTotimg__Capabilities(struct soap *soap, const char *tag, struct timg__Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct timg__Capabilities **)soap_malloc(soap, sizeof(struct timg__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_timg__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct timg__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_timg__Capabilities, sizeof(struct timg__Capabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotimg__Capabilities(struct soap *soap, struct timg__Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotimg__Capabilities);
	if (soap_out_PointerTotimg__Capabilities(soap, tag?tag:"timg:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct timg__Capabilities ** SOAP_FMAC4 soap_get_PointerTotimg__Capabilities(struct soap *soap, struct timg__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotimg__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy))
		soap_serialize__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy);
	if (id < 0)
		return soap->error;
	return soap_out__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_in_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, struct _tev__CreatePullPointSubscription_SubscriptionPolicy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy **)soap_malloc(soap, sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy);
	if (soap_out_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag?tag:"tev:CreatePullPointSubscription-SubscriptionPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription_SubscriptionPolicy ** SOAP_FMAC4 soap_get_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, struct _tev__CreatePullPointSubscription_SubscriptionPolicy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotev__Capabilities(struct soap *soap, struct tev__Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tev__Capabilities))
		soap_serialize_tev__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotev__Capabilities(struct soap *soap, const char *tag, int id, struct tev__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tev__Capabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tev__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tev__Capabilities ** SOAP_FMAC4 soap_in_PointerTotev__Capabilities(struct soap *soap, const char *tag, struct tev__Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tev__Capabilities **)soap_malloc(soap, sizeof(struct tev__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tev__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tev__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tev__Capabilities, sizeof(struct tev__Capabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotev__Capabilities(struct soap *soap, struct tev__Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotev__Capabilities);
	if (soap_out_PointerTotev__Capabilities(soap, tag?tag:"tev:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tev__Capabilities ** SOAP_FMAC4 soap_get_PointerTotev__Capabilities(struct soap *soap, struct tev__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotev__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__PaneConfiguration(struct soap *soap, struct tt__PaneConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__PaneConfiguration))
		soap_serialize_tt__PaneConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__PaneConfiguration(struct soap *soap, const char *tag, int id, struct tt__PaneConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__PaneConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__PaneConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__PaneConfiguration ** SOAP_FMAC4 soap_in_PointerTott__PaneConfiguration(struct soap *soap, const char *tag, struct tt__PaneConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__PaneConfiguration **)soap_malloc(soap, sizeof(struct tt__PaneConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__PaneConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__PaneConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__PaneConfiguration, sizeof(struct tt__PaneConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__PaneConfiguration(struct soap *soap, struct tt__PaneConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__PaneConfiguration);
	if (soap_out_PointerTott__PaneConfiguration(soap, tag?tag:"tt:PaneConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PaneConfiguration ** SOAP_FMAC4 soap_get_PointerTott__PaneConfiguration(struct soap *soap, struct tt__PaneConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__PaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CodingCapabilities(struct soap *soap, struct tt__CodingCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CodingCapabilities))
		soap_serialize_tt__CodingCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CodingCapabilities(struct soap *soap, const char *tag, int id, struct tt__CodingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CodingCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CodingCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CodingCapabilities ** SOAP_FMAC4 soap_in_PointerTott__CodingCapabilities(struct soap *soap, const char *tag, struct tt__CodingCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CodingCapabilities **)soap_malloc(soap, sizeof(struct tt__CodingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CodingCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CodingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CodingCapabilities, sizeof(struct tt__CodingCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CodingCapabilities(struct soap *soap, struct tt__CodingCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__CodingCapabilities);
	if (soap_out_PointerTott__CodingCapabilities(soap, tag?tag:"tt:CodingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CodingCapabilities ** SOAP_FMAC4 soap_get_PointerTott__CodingCapabilities(struct soap *soap, struct tt__CodingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CodingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__LayoutOptions(struct soap *soap, struct tt__LayoutOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__LayoutOptions))
		soap_serialize_tt__LayoutOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__LayoutOptions(struct soap *soap, const char *tag, int id, struct tt__LayoutOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__LayoutOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__LayoutOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__LayoutOptions ** SOAP_FMAC4 soap_in_PointerTott__LayoutOptions(struct soap *soap, const char *tag, struct tt__LayoutOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__LayoutOptions **)soap_malloc(soap, sizeof(struct tt__LayoutOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__LayoutOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__LayoutOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__LayoutOptions, sizeof(struct tt__LayoutOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__LayoutOptions(struct soap *soap, struct tt__LayoutOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__LayoutOptions);
	if (soap_out_PointerTott__LayoutOptions(soap, tag?tag:"tt:LayoutOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__LayoutOptions ** SOAP_FMAC4 soap_get_PointerTott__LayoutOptions(struct soap *soap, struct tt__LayoutOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__LayoutOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Layout(struct soap *soap, struct tt__Layout *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Layout))
		soap_serialize_tt__Layout(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Layout(struct soap *soap, const char *tag, int id, struct tt__Layout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Layout);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Layout(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Layout ** SOAP_FMAC4 soap_in_PointerTott__Layout(struct soap *soap, const char *tag, struct tt__Layout **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Layout **)soap_malloc(soap, sizeof(struct tt__Layout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Layout(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Layout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Layout, sizeof(struct tt__Layout), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Layout(struct soap *soap, struct tt__Layout *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Layout);
	if (soap_out_PointerTott__Layout(soap, tag?tag:"tt:Layout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Layout ** SOAP_FMAC4 soap_get_PointerTott__Layout(struct soap *soap, struct tt__Layout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Layout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotls__Capabilities(struct soap *soap, struct tls__Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tls__Capabilities))
		soap_serialize_tls__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotls__Capabilities(struct soap *soap, const char *tag, int id, struct tls__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tls__Capabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tls__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tls__Capabilities ** SOAP_FMAC4 soap_in_PointerTotls__Capabilities(struct soap *soap, const char *tag, struct tls__Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tls__Capabilities **)soap_malloc(soap, sizeof(struct tls__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tls__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tls__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tls__Capabilities, sizeof(struct tls__Capabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotls__Capabilities(struct soap *soap, struct tls__Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotls__Capabilities);
	if (soap_out_PointerTotls__Capabilities(soap, tag?tag:"tls:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tls__Capabilities ** SOAP_FMAC4 soap_get_PointerTotls__Capabilities(struct soap *soap, struct tls__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotls__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension))
		soap_serialize__tds__GetSystemUrisResponse_Extension(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, int id, struct _tds__GetSystemUrisResponse_Extension *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__GetSystemUrisResponse_Extension);
	if (id < 0)
		return soap->error;
	return soap_out__tds__GetSystemUrisResponse_Extension(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse_Extension ** SOAP_FMAC4 soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, struct _tds__GetSystemUrisResponse_Extension **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__GetSystemUrisResponse_Extension **)soap_malloc(soap, sizeof(struct _tds__GetSystemUrisResponse_Extension *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__GetSystemUrisResponse_Extension(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUrisResponse_Extension **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, sizeof(struct _tds__GetSystemUrisResponse_Extension), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__GetSystemUrisResponse_Extension);
	if (soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(soap, tag?tag:"tds:GetSystemUrisResponse-Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse_Extension ** SOAP_FMAC4 soap_get_PointerTo_tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemLogUriList(struct soap *soap, struct tt__SystemLogUriList *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemLogUriList))
		soap_serialize_tt__SystemLogUriList(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemLogUriList(struct soap *soap, const char *tag, int id, struct tt__SystemLogUriList *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemLogUriList);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemLogUriList(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemLogUriList ** SOAP_FMAC4 soap_in_PointerTott__SystemLogUriList(struct soap *soap, const char *tag, struct tt__SystemLogUriList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemLogUriList **)soap_malloc(soap, sizeof(struct tt__SystemLogUriList *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemLogUriList(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemLogUriList **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemLogUriList, sizeof(struct tt__SystemLogUriList), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemLogUriList(struct soap *soap, struct tt__SystemLogUriList *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SystemLogUriList);
	if (soap_out_PointerTott__SystemLogUriList(soap, tag?tag:"tt:SystemLogUriList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemLogUriList ** SOAP_FMAC4 soap_get_PointerTott__SystemLogUriList(struct soap *soap, struct tt__SystemLogUriList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemLogUriList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11AvailableNetworks(struct soap *soap, struct tt__Dot11AvailableNetworks *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11AvailableNetworks))
		soap_serialize_tt__Dot11AvailableNetworks(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, int id, struct tt__Dot11AvailableNetworks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11AvailableNetworks);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11AvailableNetworks(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworks ** SOAP_FMAC4 soap_in_PointerTott__Dot11AvailableNetworks(struct soap *soap, const char *tag, struct tt__Dot11AvailableNetworks **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11AvailableNetworks **)soap_malloc(soap, sizeof(struct tt__Dot11AvailableNetworks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11AvailableNetworks(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11AvailableNetworks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11AvailableNetworks, sizeof(struct tt__Dot11AvailableNetworks), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11AvailableNetworks(struct soap *soap, struct tt__Dot11AvailableNetworks *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11AvailableNetworks);
	if (soap_out_PointerTott__Dot11AvailableNetworks(soap, tag?tag:"tt:Dot11AvailableNetworks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11AvailableNetworks ** SOAP_FMAC4 soap_get_PointerTott__Dot11AvailableNetworks(struct soap *soap, struct tt__Dot11AvailableNetworks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11AvailableNetworks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Status(struct soap *soap, struct tt__Dot11Status *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Status))
		soap_serialize_tt__Dot11Status(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Status(struct soap *soap, const char *tag, int id, struct tt__Dot11Status *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Status);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11Status(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11Status ** SOAP_FMAC4 soap_in_PointerTott__Dot11Status(struct soap *soap, const char *tag, struct tt__Dot11Status **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11Status **)soap_malloc(soap, sizeof(struct tt__Dot11Status *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11Status(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11Status **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Status, sizeof(struct tt__Dot11Status), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Status(struct soap *soap, struct tt__Dot11Status *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11Status);
	if (soap_out_PointerTott__Dot11Status(soap, tag?tag:"tt:Dot11Status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Status ** SOAP_FMAC4 soap_get_PointerTott__Dot11Status(struct soap *soap, struct tt__Dot11Status **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot11Capabilities(struct soap *soap, struct tt__Dot11Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot11Capabilities))
		soap_serialize_tt__Dot11Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot11Capabilities(struct soap *soap, const char *tag, int id, struct tt__Dot11Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot11Capabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot11Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot11Capabilities ** SOAP_FMAC4 soap_in_PointerTott__Dot11Capabilities(struct soap *soap, const char *tag, struct tt__Dot11Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot11Capabilities **)soap_malloc(soap, sizeof(struct tt__Dot11Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot11Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot11Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot11Capabilities, sizeof(struct tt__Dot11Capabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot11Capabilities(struct soap *soap, struct tt__Dot11Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot11Capabilities);
	if (soap_out_PointerTott__Dot11Capabilities(soap, tag?tag:"tt:Dot11Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot11Capabilities ** SOAP_FMAC4 soap_get_PointerTott__Dot11Capabilities(struct soap *soap, struct tt__Dot11Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelayOutputSettings))
		soap_serialize_tt__RelayOutputSettings(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelayOutputSettings(struct soap *soap, const char *tag, int id, struct tt__RelayOutputSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelayOutputSettings);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RelayOutputSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RelayOutputSettings ** SOAP_FMAC4 soap_in_PointerTott__RelayOutputSettings(struct soap *soap, const char *tag, struct tt__RelayOutputSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RelayOutputSettings **)soap_malloc(soap, sizeof(struct tt__RelayOutputSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RelayOutputSettings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RelayOutputSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelayOutputSettings, sizeof(struct tt__RelayOutputSettings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RelayOutputSettings);
	if (soap_out_PointerTott__RelayOutputSettings(soap, tag?tag:"tt:RelayOutputSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelayOutputSettings ** SOAP_FMAC4 soap_get_PointerTott__RelayOutputSettings(struct soap *soap, struct tt__RelayOutputSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Dot1XConfiguration(struct soap *soap, struct tt__Dot1XConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Dot1XConfiguration))
		soap_serialize_tt__Dot1XConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Dot1XConfiguration(struct soap *soap, const char *tag, int id, struct tt__Dot1XConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Dot1XConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Dot1XConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Dot1XConfiguration ** SOAP_FMAC4 soap_in_PointerTott__Dot1XConfiguration(struct soap *soap, const char *tag, struct tt__Dot1XConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Dot1XConfiguration **)soap_malloc(soap, sizeof(struct tt__Dot1XConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Dot1XConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Dot1XConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Dot1XConfiguration, sizeof(struct tt__Dot1XConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Dot1XConfiguration(struct soap *soap, struct tt__Dot1XConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Dot1XConfiguration);
	if (soap_out_PointerTott__Dot1XConfiguration(soap, tag?tag:"tt:Dot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Dot1XConfiguration ** SOAP_FMAC4 soap_get_PointerTott__Dot1XConfiguration(struct soap *soap, struct tt__Dot1XConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Dot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateInformation(struct soap *soap, struct tt__CertificateInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateInformation))
		soap_serialize_tt__CertificateInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateInformation(struct soap *soap, const char *tag, int id, struct tt__CertificateInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateInformation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CertificateInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CertificateInformation ** SOAP_FMAC4 soap_in_PointerTott__CertificateInformation(struct soap *soap, const char *tag, struct tt__CertificateInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CertificateInformation **)soap_malloc(soap, sizeof(struct tt__CertificateInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CertificateInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateInformation, sizeof(struct tt__CertificateInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateInformation(struct soap *soap, struct tt__CertificateInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__CertificateInformation);
	if (soap_out_PointerTott__CertificateInformation(soap, tag?tag:"tt:CertificateInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateInformation ** SOAP_FMAC4 soap_get_PointerTott__CertificateInformation(struct soap *soap, struct tt__CertificateInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateWithPrivateKey(struct soap *soap, struct tt__CertificateWithPrivateKey *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateWithPrivateKey))
		soap_serialize_tt__CertificateWithPrivateKey(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateWithPrivateKey(struct soap *soap, const char *tag, int id, struct tt__CertificateWithPrivateKey *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateWithPrivateKey);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CertificateWithPrivateKey(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CertificateWithPrivateKey ** SOAP_FMAC4 soap_in_PointerTott__CertificateWithPrivateKey(struct soap *soap, const char *tag, struct tt__CertificateWithPrivateKey **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CertificateWithPrivateKey **)soap_malloc(soap, sizeof(struct tt__CertificateWithPrivateKey *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CertificateWithPrivateKey(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateWithPrivateKey **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateWithPrivateKey, sizeof(struct tt__CertificateWithPrivateKey), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateWithPrivateKey(struct soap *soap, struct tt__CertificateWithPrivateKey *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__CertificateWithPrivateKey);
	if (soap_out_PointerTott__CertificateWithPrivateKey(soap, tag?tag:"tt:CertificateWithPrivateKey", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateWithPrivateKey ** SOAP_FMAC4 soap_get_PointerTott__CertificateWithPrivateKey(struct soap *soap, struct tt__CertificateWithPrivateKey **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CertificateStatus(struct soap *soap, struct tt__CertificateStatus *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__CertificateStatus))
		soap_serialize_tt__CertificateStatus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CertificateStatus(struct soap *soap, const char *tag, int id, struct tt__CertificateStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CertificateStatus);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CertificateStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__CertificateStatus ** SOAP_FMAC4 soap_in_PointerTott__CertificateStatus(struct soap *soap, const char *tag, struct tt__CertificateStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__CertificateStatus **)soap_malloc(soap, sizeof(struct tt__CertificateStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CertificateStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__CertificateStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CertificateStatus, sizeof(struct tt__CertificateStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CertificateStatus(struct soap *soap, struct tt__CertificateStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__CertificateStatus);
	if (soap_out_PointerTott__CertificateStatus(soap, tag?tag:"tt:CertificateStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__CertificateStatus ** SOAP_FMAC4 soap_get_PointerTott__CertificateStatus(struct soap *soap, struct tt__CertificateStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CertificateStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Certificate(struct soap *soap, struct tt__Certificate *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Certificate))
		soap_serialize_tt__Certificate(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Certificate(struct soap *soap, const char *tag, int id, struct tt__Certificate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Certificate);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Certificate(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Certificate ** SOAP_FMAC4 soap_in_PointerTott__Certificate(struct soap *soap, const char *tag, struct tt__Certificate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Certificate **)soap_malloc(soap, sizeof(struct tt__Certificate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Certificate(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Certificate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Certificate, sizeof(struct tt__Certificate), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Certificate(struct soap *soap, struct tt__Certificate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Certificate);
	if (soap_out_PointerTott__Certificate(soap, tag?tag:"tt:Certificate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Certificate ** SOAP_FMAC4 soap_get_PointerTott__Certificate(struct soap *soap, struct tt__Certificate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Certificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__IPAddressFilter))
		soap_serialize_tt__IPAddressFilter(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__IPAddressFilter(struct soap *soap, const char *tag, int id, struct tt__IPAddressFilter *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__IPAddressFilter);
	if (id < 0)
		return soap->error;
	return soap_out_tt__IPAddressFilter(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__IPAddressFilter ** SOAP_FMAC4 soap_in_PointerTott__IPAddressFilter(struct soap *soap, const char *tag, struct tt__IPAddressFilter **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__IPAddressFilter **)soap_malloc(soap, sizeof(struct tt__IPAddressFilter *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__IPAddressFilter(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__IPAddressFilter **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__IPAddressFilter, sizeof(struct tt__IPAddressFilter), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__IPAddressFilter);
	if (soap_out_PointerTott__IPAddressFilter(soap, tag?tag:"tt:IPAddressFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__IPAddressFilter ** SOAP_FMAC4 soap_get_PointerTott__IPAddressFilter(struct soap *soap, struct tt__IPAddressFilter **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__IPAddressFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkGateway(struct soap *soap, struct tt__NetworkGateway *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkGateway))
		soap_serialize_tt__NetworkGateway(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkGateway(struct soap *soap, const char *tag, int id, struct tt__NetworkGateway *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkGateway);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkGateway(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkGateway ** SOAP_FMAC4 soap_in_PointerTott__NetworkGateway(struct soap *soap, const char *tag, struct tt__NetworkGateway **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkGateway **)soap_malloc(soap, sizeof(struct tt__NetworkGateway *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkGateway(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkGateway **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkGateway, sizeof(struct tt__NetworkGateway), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkGateway(struct soap *soap, struct tt__NetworkGateway *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkGateway);
	if (soap_out_PointerTott__NetworkGateway(soap, tag?tag:"tt:NetworkGateway", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkGateway ** SOAP_FMAC4 soap_get_PointerTott__NetworkGateway(struct soap *soap, struct tt__NetworkGateway **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkGateway(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkProtocol(struct soap *soap, struct tt__NetworkProtocol *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkProtocol))
		soap_serialize_tt__NetworkProtocol(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkProtocol(struct soap *soap, const char *tag, int id, struct tt__NetworkProtocol *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkProtocol);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkProtocol(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkProtocol ** SOAP_FMAC4 soap_in_PointerTott__NetworkProtocol(struct soap *soap, const char *tag, struct tt__NetworkProtocol **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkProtocol **)soap_malloc(soap, sizeof(struct tt__NetworkProtocol *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkProtocol(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkProtocol **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkProtocol, sizeof(struct tt__NetworkProtocol), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkProtocol(struct soap *soap, struct tt__NetworkProtocol *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkProtocol);
	if (soap_out_PointerTott__NetworkProtocol(soap, tag?tag:"tt:NetworkProtocol", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkProtocol ** SOAP_FMAC4 soap_get_PointerTott__NetworkProtocol(struct soap *soap, struct tt__NetworkProtocol **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkProtocol(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration))
		soap_serialize_tt__NetworkInterfaceSetConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, int id, struct tt__NetworkInterfaceSetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterfaceSetConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, const char *tag, struct tt__NetworkInterfaceSetConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterfaceSetConfiguration **)soap_malloc(soap, sizeof(struct tt__NetworkInterfaceSetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterfaceSetConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterfaceSetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterfaceSetConfiguration, sizeof(struct tt__NetworkInterfaceSetConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterfaceSetConfiguration);
	if (soap_out_PointerTott__NetworkInterfaceSetConfiguration(soap, tag?tag:"tt:NetworkInterfaceSetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterfaceSetConfiguration ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterfaceSetConfiguration(struct soap *soap, struct tt__NetworkInterfaceSetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterfaceSetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NetworkInterface(struct soap *soap, struct tt__NetworkInterface *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NetworkInterface))
		soap_serialize_tt__NetworkInterface(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NetworkInterface(struct soap *soap, const char *tag, int id, struct tt__NetworkInterface *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NetworkInterface);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NetworkInterface(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NetworkInterface ** SOAP_FMAC4 soap_in_PointerTott__NetworkInterface(struct soap *soap, const char *tag, struct tt__NetworkInterface **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NetworkInterface **)soap_malloc(soap, sizeof(struct tt__NetworkInterface *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NetworkInterface(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NetworkInterface **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NetworkInterface, sizeof(struct tt__NetworkInterface), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NetworkInterface(struct soap *soap, struct tt__NetworkInterface *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NetworkInterface);
	if (soap_out_PointerTott__NetworkInterface(soap, tag?tag:"tt:NetworkInterface", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NetworkInterface ** SOAP_FMAC4 soap_get_PointerTott__NetworkInterface(struct soap *soap, struct tt__NetworkInterface **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NetworkInterface(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DynamicDNSInformation))
		soap_serialize_tt__DynamicDNSInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DynamicDNSInformation(struct soap *soap, const char *tag, int id, struct tt__DynamicDNSInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DynamicDNSInformation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DynamicDNSInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DynamicDNSInformation ** SOAP_FMAC4 soap_in_PointerTott__DynamicDNSInformation(struct soap *soap, const char *tag, struct tt__DynamicDNSInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DynamicDNSInformation **)soap_malloc(soap, sizeof(struct tt__DynamicDNSInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DynamicDNSInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DynamicDNSInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DynamicDNSInformation, sizeof(struct tt__DynamicDNSInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DynamicDNSInformation);
	if (soap_out_PointerTott__DynamicDNSInformation(soap, tag?tag:"tt:DynamicDNSInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DynamicDNSInformation ** SOAP_FMAC4 soap_get_PointerTott__DynamicDNSInformation(struct soap *soap, struct tt__DynamicDNSInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DynamicDNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__NTPInformation(struct soap *soap, struct tt__NTPInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__NTPInformation))
		soap_serialize_tt__NTPInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__NTPInformation(struct soap *soap, const char *tag, int id, struct tt__NTPInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__NTPInformation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__NTPInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__NTPInformation ** SOAP_FMAC4 soap_in_PointerTott__NTPInformation(struct soap *soap, const char *tag, struct tt__NTPInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__NTPInformation **)soap_malloc(soap, sizeof(struct tt__NTPInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__NTPInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__NTPInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__NTPInformation, sizeof(struct tt__NTPInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__NTPInformation(struct soap *soap, struct tt__NTPInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__NTPInformation);
	if (soap_out_PointerTott__NTPInformation(soap, tag?tag:"tt:NTPInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__NTPInformation ** SOAP_FMAC4 soap_get_PointerTott__NTPInformation(struct soap *soap, struct tt__NTPInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__NTPInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DNSInformation(struct soap *soap, struct tt__DNSInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DNSInformation))
		soap_serialize_tt__DNSInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DNSInformation(struct soap *soap, const char *tag, int id, struct tt__DNSInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DNSInformation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DNSInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DNSInformation ** SOAP_FMAC4 soap_in_PointerTott__DNSInformation(struct soap *soap, const char *tag, struct tt__DNSInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DNSInformation **)soap_malloc(soap, sizeof(struct tt__DNSInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DNSInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DNSInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DNSInformation, sizeof(struct tt__DNSInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DNSInformation(struct soap *soap, struct tt__DNSInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DNSInformation);
	if (soap_out_PointerTott__DNSInformation(soap, tag?tag:"tt:DNSInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DNSInformation ** SOAP_FMAC4 soap_get_PointerTott__DNSInformation(struct soap *soap, struct tt__DNSInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DNSInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__HostnameInformation(struct soap *soap, struct tt__HostnameInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__HostnameInformation))
		soap_serialize_tt__HostnameInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__HostnameInformation(struct soap *soap, const char *tag, int id, struct tt__HostnameInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__HostnameInformation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__HostnameInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__HostnameInformation ** SOAP_FMAC4 soap_in_PointerTott__HostnameInformation(struct soap *soap, const char *tag, struct tt__HostnameInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__HostnameInformation **)soap_malloc(soap, sizeof(struct tt__HostnameInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__HostnameInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__HostnameInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__HostnameInformation, sizeof(struct tt__HostnameInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__HostnameInformation(struct soap *soap, struct tt__HostnameInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__HostnameInformation);
	if (soap_out_PointerTott__HostnameInformation(soap, tag?tag:"tt:HostnameInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__HostnameInformation ** SOAP_FMAC4 soap_get_PointerTott__HostnameInformation(struct soap *soap, struct tt__HostnameInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__HostnameInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Capabilities(struct soap *soap, struct tt__Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Capabilities))
		soap_serialize_tt__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Capabilities(struct soap *soap, const char *tag, int id, struct tt__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Capabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Capabilities ** SOAP_FMAC4 soap_in_PointerTott__Capabilities(struct soap *soap, const char *tag, struct tt__Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Capabilities **)soap_malloc(soap, sizeof(struct tt__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Capabilities, sizeof(struct tt__Capabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Capabilities(struct soap *soap, struct tt__Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Capabilities);
	if (soap_out_PointerTott__Capabilities(soap, tag?tag:"tt:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Capabilities ** SOAP_FMAC4 soap_get_PointerTott__Capabilities(struct soap *soap, struct tt__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory *const*a)
{
#ifndef WITH_NOIDREF
	soap_reference(soap, *a, SOAP_TYPE_tt__CapabilityCategory);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__CapabilityCategory(struct soap *soap, const char *tag, int id, enum tt__CapabilityCategory *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__CapabilityCategory);
	if (id < 0)
		return soap->error;
	return soap_out_tt__CapabilityCategory(soap, tag, id, *a, type);
}

SOAP_FMAC3 enum tt__CapabilityCategory ** SOAP_FMAC4 soap_in_PointerTott__CapabilityCategory(struct soap *soap, const char *tag, enum tt__CapabilityCategory **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (enum tt__CapabilityCategory **)soap_malloc(soap, sizeof(enum tt__CapabilityCategory *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__CapabilityCategory(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (enum tt__CapabilityCategory **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__CapabilityCategory, sizeof(enum tt__CapabilityCategory), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__CapabilityCategory);
	if (soap_out_PointerTott__CapabilityCategory(soap, tag?tag:"tt:CapabilityCategory", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 enum tt__CapabilityCategory ** SOAP_FMAC4 soap_get_PointerTott__CapabilityCategory(struct soap *soap, enum tt__CapabilityCategory **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__CapabilityCategory(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__User(struct soap *soap, struct tt__User *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__User))
		soap_serialize_tt__User(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__User(struct soap *soap, const char *tag, int id, struct tt__User *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__User);
	if (id < 0)
		return soap->error;
	return soap_out_tt__User(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__User ** SOAP_FMAC4 soap_in_PointerTott__User(struct soap *soap, const char *tag, struct tt__User **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__User **)soap_malloc(soap, sizeof(struct tt__User *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__User(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__User **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__User, sizeof(struct tt__User), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__User(struct soap *soap, struct tt__User *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__User);
	if (soap_out_PointerTott__User(soap, tag?tag:"tt:User", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__User ** SOAP_FMAC4 soap_get_PointerTott__User(struct soap *soap, struct tt__User **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__User(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RemoteUser(struct soap *soap, struct tt__RemoteUser *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RemoteUser))
		soap_serialize_tt__RemoteUser(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RemoteUser(struct soap *soap, const char *tag, int id, struct tt__RemoteUser *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RemoteUser);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RemoteUser(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RemoteUser ** SOAP_FMAC4 soap_in_PointerTott__RemoteUser(struct soap *soap, const char *tag, struct tt__RemoteUser **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RemoteUser **)soap_malloc(soap, sizeof(struct tt__RemoteUser *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RemoteUser(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RemoteUser **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RemoteUser, sizeof(struct tt__RemoteUser), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RemoteUser(struct soap *soap, struct tt__RemoteUser *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RemoteUser);
	if (soap_out_PointerTott__RemoteUser(soap, tag?tag:"tt:RemoteUser", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RemoteUser ** SOAP_FMAC4 soap_get_PointerTott__RemoteUser(struct soap *soap, struct tt__RemoteUser **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RemoteUser(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Scope(struct soap *soap, struct tt__Scope *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Scope))
		soap_serialize_tt__Scope(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Scope(struct soap *soap, const char *tag, int id, struct tt__Scope *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Scope);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Scope(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Scope ** SOAP_FMAC4 soap_in_PointerTott__Scope(struct soap *soap, const char *tag, struct tt__Scope **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Scope **)soap_malloc(soap, sizeof(struct tt__Scope *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Scope(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Scope **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Scope, sizeof(struct tt__Scope), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Scope(struct soap *soap, struct tt__Scope *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Scope);
	if (soap_out_PointerTott__Scope(soap, tag?tag:"tt:Scope", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Scope ** SOAP_FMAC4 soap_get_PointerTott__Scope(struct soap *soap, struct tt__Scope **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Scope(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemLog(struct soap *soap, struct tt__SystemLog *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemLog))
		soap_serialize_tt__SystemLog(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemLog(struct soap *soap, const char *tag, int id, struct tt__SystemLog *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemLog);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemLog(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemLog ** SOAP_FMAC4 soap_in_PointerTott__SystemLog(struct soap *soap, const char *tag, struct tt__SystemLog **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemLog **)soap_malloc(soap, sizeof(struct tt__SystemLog *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemLog(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemLog **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemLog, sizeof(struct tt__SystemLog), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemLog(struct soap *soap, struct tt__SystemLog *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SystemLog);
	if (soap_out_PointerTott__SystemLog(soap, tag?tag:"tt:SystemLog", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemLog ** SOAP_FMAC4 soap_get_PointerTott__SystemLog(struct soap *soap, struct tt__SystemLog **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemLog(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SupportInformation(struct soap *soap, struct tt__SupportInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SupportInformation))
		soap_serialize_tt__SupportInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SupportInformation(struct soap *soap, const char *tag, int id, struct tt__SupportInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SupportInformation);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SupportInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SupportInformation ** SOAP_FMAC4 soap_in_PointerTott__SupportInformation(struct soap *soap, const char *tag, struct tt__SupportInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SupportInformation **)soap_malloc(soap, sizeof(struct tt__SupportInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SupportInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SupportInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SupportInformation, sizeof(struct tt__SupportInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SupportInformation(struct soap *soap, struct tt__SupportInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SupportInformation);
	if (soap_out_PointerTott__SupportInformation(soap, tag?tag:"tt:SupportInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SupportInformation ** SOAP_FMAC4 soap_get_PointerTott__SupportInformation(struct soap *soap, struct tt__SupportInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SupportInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__BackupFile(struct soap *soap, struct tt__BackupFile *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__BackupFile))
		soap_serialize_tt__BackupFile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__BackupFile(struct soap *soap, const char *tag, int id, struct tt__BackupFile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__BackupFile);
	if (id < 0)
		return soap->error;
	return soap_out_tt__BackupFile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__BackupFile ** SOAP_FMAC4 soap_in_PointerTott__BackupFile(struct soap *soap, const char *tag, struct tt__BackupFile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__BackupFile **)soap_malloc(soap, sizeof(struct tt__BackupFile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__BackupFile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__BackupFile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__BackupFile, sizeof(struct tt__BackupFile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__BackupFile(struct soap *soap, struct tt__BackupFile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__BackupFile);
	if (soap_out_PointerTott__BackupFile(soap, tag?tag:"tt:BackupFile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__BackupFile ** SOAP_FMAC4 soap_get_PointerTott__BackupFile(struct soap *soap, struct tt__BackupFile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__BackupFile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__SystemDateTime(struct soap *soap, struct tt__SystemDateTime *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__SystemDateTime))
		soap_serialize_tt__SystemDateTime(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__SystemDateTime(struct soap *soap, const char *tag, int id, struct tt__SystemDateTime *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__SystemDateTime);
	if (id < 0)
		return soap->error;
	return soap_out_tt__SystemDateTime(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__SystemDateTime ** SOAP_FMAC4 soap_in_PointerTott__SystemDateTime(struct soap *soap, const char *tag, struct tt__SystemDateTime **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__SystemDateTime **)soap_malloc(soap, sizeof(struct tt__SystemDateTime *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__SystemDateTime(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__SystemDateTime **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__SystemDateTime, sizeof(struct tt__SystemDateTime), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__SystemDateTime(struct soap *soap, struct tt__SystemDateTime *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__SystemDateTime);
	if (soap_out_PointerTott__SystemDateTime(soap, tag?tag:"tt:SystemDateTime", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__SystemDateTime ** SOAP_FMAC4 soap_get_PointerTott__SystemDateTime(struct soap *soap, struct tt__SystemDateTime **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__SystemDateTime(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__DeviceServiceCapabilities))
		soap_serialize_tds__DeviceServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__DeviceServiceCapabilities(struct soap *soap, const char *tag, int id, struct tds__DeviceServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__DeviceServiceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tds__DeviceServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__DeviceServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__DeviceServiceCapabilities(struct soap *soap, const char *tag, struct tds__DeviceServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__DeviceServiceCapabilities **)soap_malloc(soap, sizeof(struct tds__DeviceServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__DeviceServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__DeviceServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__DeviceServiceCapabilities, sizeof(struct tds__DeviceServiceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotds__DeviceServiceCapabilities);
	if (soap_out_PointerTotds__DeviceServiceCapabilities(soap, tag?tag:"tds:DeviceServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__DeviceServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__DeviceServiceCapabilities(struct soap *soap, struct tds__DeviceServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__DeviceServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__Service(struct soap *soap, struct tds__Service *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__Service))
		soap_serialize_tds__Service(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__Service(struct soap *soap, const char *tag, int id, struct tds__Service *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__Service);
	if (id < 0)
		return soap->error;
	return soap_out_tds__Service(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__Service ** SOAP_FMAC4 soap_in_PointerTotds__Service(struct soap *soap, const char *tag, struct tds__Service **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__Service **)soap_malloc(soap, sizeof(struct tds__Service *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__Service(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__Service **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__Service, sizeof(struct tds__Service), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__Service(struct soap *soap, struct tds__Service *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotds__Service);
	if (soap_out_PointerTotds__Service(soap, tag?tag:"tds:Service", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__Service ** SOAP_FMAC4 soap_get_PointerTotds__Service(struct soap *soap, struct tds__Service **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__Service(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__MiscCapabilities(struct soap *soap, struct tds__MiscCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__MiscCapabilities))
		soap_serialize_tds__MiscCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__MiscCapabilities(struct soap *soap, const char *tag, int id, struct tds__MiscCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__MiscCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tds__MiscCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__MiscCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__MiscCapabilities(struct soap *soap, const char *tag, struct tds__MiscCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__MiscCapabilities **)soap_malloc(soap, sizeof(struct tds__MiscCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__MiscCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__MiscCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__MiscCapabilities, sizeof(struct tds__MiscCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__MiscCapabilities(struct soap *soap, struct tds__MiscCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotds__MiscCapabilities);
	if (soap_out_PointerTotds__MiscCapabilities(soap, tag?tag:"tds:MiscCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__MiscCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__MiscCapabilities(struct soap *soap, struct tds__MiscCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__MiscCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__SystemCapabilities(struct soap *soap, struct tds__SystemCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__SystemCapabilities))
		soap_serialize_tds__SystemCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__SystemCapabilities(struct soap *soap, const char *tag, int id, struct tds__SystemCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__SystemCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tds__SystemCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__SystemCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__SystemCapabilities(struct soap *soap, const char *tag, struct tds__SystemCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__SystemCapabilities **)soap_malloc(soap, sizeof(struct tds__SystemCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__SystemCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__SystemCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__SystemCapabilities, sizeof(struct tds__SystemCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__SystemCapabilities(struct soap *soap, struct tds__SystemCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotds__SystemCapabilities);
	if (soap_out_PointerTotds__SystemCapabilities(soap, tag?tag:"tds:SystemCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__SystemCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__SystemCapabilities(struct soap *soap, struct tds__SystemCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__SystemCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__SecurityCapabilities(struct soap *soap, struct tds__SecurityCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__SecurityCapabilities))
		soap_serialize_tds__SecurityCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__SecurityCapabilities(struct soap *soap, const char *tag, int id, struct tds__SecurityCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__SecurityCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tds__SecurityCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__SecurityCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__SecurityCapabilities(struct soap *soap, const char *tag, struct tds__SecurityCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__SecurityCapabilities **)soap_malloc(soap, sizeof(struct tds__SecurityCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__SecurityCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__SecurityCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__SecurityCapabilities, sizeof(struct tds__SecurityCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__SecurityCapabilities(struct soap *soap, struct tds__SecurityCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotds__SecurityCapabilities);
	if (soap_out_PointerTotds__SecurityCapabilities(soap, tag?tag:"tds:SecurityCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__SecurityCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__SecurityCapabilities(struct soap *soap, struct tds__SecurityCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__SecurityCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotds__NetworkCapabilities(struct soap *soap, struct tds__NetworkCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tds__NetworkCapabilities))
		soap_serialize_tds__NetworkCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotds__NetworkCapabilities(struct soap *soap, const char *tag, int id, struct tds__NetworkCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tds__NetworkCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_tds__NetworkCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tds__NetworkCapabilities ** SOAP_FMAC4 soap_in_PointerTotds__NetworkCapabilities(struct soap *soap, const char *tag, struct tds__NetworkCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tds__NetworkCapabilities **)soap_malloc(soap, sizeof(struct tds__NetworkCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tds__NetworkCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tds__NetworkCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tds__NetworkCapabilities, sizeof(struct tds__NetworkCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotds__NetworkCapabilities(struct soap *soap, struct tds__NetworkCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotds__NetworkCapabilities);
	if (soap_out_PointerTotds__NetworkCapabilities(soap, tag?tag:"tds:NetworkCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tds__NetworkCapabilities ** SOAP_FMAC4 soap_get_PointerTotds__NetworkCapabilities(struct soap *soap, struct tds__NetworkCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotds__NetworkCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tds__Service_Capabilities))
		soap_serialize__tds__Service_Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tds__Service_Capabilities(struct soap *soap, const char *tag, int id, struct _tds__Service_Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tds__Service_Capabilities);
	if (id < 0)
		return soap->error;
	return soap_out__tds__Service_Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tds__Service_Capabilities ** SOAP_FMAC4 soap_in_PointerTo_tds__Service_Capabilities(struct soap *soap, const char *tag, struct _tds__Service_Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tds__Service_Capabilities **)soap_malloc(soap, sizeof(struct _tds__Service_Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tds__Service_Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tds__Service_Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tds__Service_Capabilities, sizeof(struct _tds__Service_Capabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tds__Service_Capabilities);
	if (soap_out_PointerTo_tds__Service_Capabilities(soap, tag?tag:"tds:Service-Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__Service_Capabilities ** SOAP_FMAC4 soap_get_PointerTo_tds__Service_Capabilities(struct soap *soap, struct _tds__Service_Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tds__Service_Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MediaUri(struct soap *soap, struct tt__MediaUri *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MediaUri))
		soap_serialize_tt__MediaUri(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MediaUri(struct soap *soap, const char *tag, int id, struct tt__MediaUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MediaUri);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MediaUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MediaUri ** SOAP_FMAC4 soap_in_PointerTott__MediaUri(struct soap *soap, const char *tag, struct tt__MediaUri **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MediaUri **)soap_malloc(soap, sizeof(struct tt__MediaUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MediaUri(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MediaUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MediaUri, sizeof(struct tt__MediaUri), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MediaUri(struct soap *soap, struct tt__MediaUri *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MediaUri);
	if (soap_out_PointerTott__MediaUri(soap, tag?tag:"tt:MediaUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MediaUri ** SOAP_FMAC4 soap_get_PointerTott__MediaUri(struct soap *soap, struct tt__MediaUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MediaUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__MetadataConfigurationOptions(struct soap *soap, struct tt__MetadataConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__MetadataConfigurationOptions))
		soap_serialize_tt__MetadataConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__MetadataConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__MetadataConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__MetadataConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__MetadataConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__MetadataConfigurationOptions(struct soap *soap, const char *tag, struct tt__MetadataConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__MetadataConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__MetadataConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__MetadataConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__MetadataConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__MetadataConfigurationOptions, sizeof(struct tt__MetadataConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__MetadataConfigurationOptions(struct soap *soap, struct tt__MetadataConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__MetadataConfigurationOptions);
	if (soap_out_PointerTott__MetadataConfigurationOptions(soap, tag?tag:"tt:MetadataConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__MetadataConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__MetadataConfigurationOptions(struct soap *soap, struct tt__MetadataConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__MetadataConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions))
		soap_serialize_tt__VideoEncoderConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__VideoEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoEncoderConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoEncoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoEncoderConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoEncoderConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__VideoEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoEncoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoEncoderConfigurationOptions, sizeof(struct tt__VideoEncoderConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoEncoderConfigurationOptions);
	if (soap_out_PointerTott__VideoEncoderConfigurationOptions(soap, tag?tag:"tt:VideoEncoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__VideoEncoderConfigurationOptions(struct soap *soap, struct tt__VideoEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__Profile(struct soap *soap, struct tt__Profile *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__Profile))
		soap_serialize_tt__Profile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__Profile(struct soap *soap, const char *tag, int id, struct tt__Profile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__Profile);
	if (id < 0)
		return soap->error;
	return soap_out_tt__Profile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__Profile ** SOAP_FMAC4 soap_in_PointerTott__Profile(struct soap *soap, const char *tag, struct tt__Profile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__Profile **)soap_malloc(soap, sizeof(struct tt__Profile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__Profile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__Profile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__Profile, sizeof(struct tt__Profile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__Profile(struct soap *soap, struct tt__Profile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__Profile);
	if (soap_out_PointerTott__Profile(soap, tag?tag:"tt:Profile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__Profile ** SOAP_FMAC4 soap_get_PointerTott__Profile(struct soap *soap, struct tt__Profile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__Profile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioOutput(struct soap *soap, struct tt__AudioOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioOutput))
		soap_serialize_tt__AudioOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioOutput(struct soap *soap, const char *tag, int id, struct tt__AudioOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioOutput);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioOutput ** SOAP_FMAC4 soap_in_PointerTott__AudioOutput(struct soap *soap, const char *tag, struct tt__AudioOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioOutput **)soap_malloc(soap, sizeof(struct tt__AudioOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioOutput, sizeof(struct tt__AudioOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioOutput(struct soap *soap, struct tt__AudioOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioOutput);
	if (soap_out_PointerTott__AudioOutput(soap, tag?tag:"tt:AudioOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutput ** SOAP_FMAC4 soap_get_PointerTott__AudioOutput(struct soap *soap, struct tt__AudioOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSource(struct soap *soap, struct tt__AudioSource *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSource))
		soap_serialize_tt__AudioSource(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSource(struct soap *soap, const char *tag, int id, struct tt__AudioSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSource);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioSource(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioSource ** SOAP_FMAC4 soap_in_PointerTott__AudioSource(struct soap *soap, const char *tag, struct tt__AudioSource **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioSource **)soap_malloc(soap, sizeof(struct tt__AudioSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioSource(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSource, sizeof(struct tt__AudioSource), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSource(struct soap *soap, struct tt__AudioSource *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioSource);
	if (soap_out_PointerTott__AudioSource(soap, tag?tag:"tt:AudioSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSource ** SOAP_FMAC4 soap_get_PointerTott__AudioSource(struct soap *soap, struct tt__AudioSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSource(struct soap *soap, struct tt__VideoSource *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSource))
		soap_serialize_tt__VideoSource(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSource(struct soap *soap, const char *tag, int id, struct tt__VideoSource *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSource);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSource(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSource ** SOAP_FMAC4 soap_in_PointerTott__VideoSource(struct soap *soap, const char *tag, struct tt__VideoSource **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSource **)soap_malloc(soap, sizeof(struct tt__VideoSource *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSource(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSource **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSource, sizeof(struct tt__VideoSource), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSource(struct soap *soap, struct tt__VideoSource *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoSource);
	if (soap_out_PointerTott__VideoSource(soap, tag?tag:"tt:VideoSource", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSource ** SOAP_FMAC4 soap_get_PointerTott__VideoSource(struct soap *soap, struct tt__VideoSource **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSource(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__Capabilities(struct soap *soap, struct trt__Capabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__Capabilities))
		soap_serialize_trt__Capabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__Capabilities(struct soap *soap, const char *tag, int id, struct trt__Capabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__Capabilities);
	if (id < 0)
		return soap->error;
	return soap_out_trt__Capabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trt__Capabilities ** SOAP_FMAC4 soap_in_PointerTotrt__Capabilities(struct soap *soap, const char *tag, struct trt__Capabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trt__Capabilities **)soap_malloc(soap, sizeof(struct trt__Capabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trt__Capabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trt__Capabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__Capabilities, sizeof(struct trt__Capabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__Capabilities(struct soap *soap, struct trt__Capabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrt__Capabilities);
	if (soap_out_PointerTotrt__Capabilities(soap, tag?tag:"trt:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__Capabilities ** SOAP_FMAC4 soap_get_PointerTotrt__Capabilities(struct soap *soap, struct trt__Capabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__StreamingCapabilities(struct soap *soap, struct trt__StreamingCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__StreamingCapabilities))
		soap_serialize_trt__StreamingCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__StreamingCapabilities(struct soap *soap, const char *tag, int id, struct trt__StreamingCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__StreamingCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_trt__StreamingCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trt__StreamingCapabilities ** SOAP_FMAC4 soap_in_PointerTotrt__StreamingCapabilities(struct soap *soap, const char *tag, struct trt__StreamingCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trt__StreamingCapabilities **)soap_malloc(soap, sizeof(struct trt__StreamingCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trt__StreamingCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trt__StreamingCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__StreamingCapabilities, sizeof(struct trt__StreamingCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__StreamingCapabilities(struct soap *soap, struct trt__StreamingCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrt__StreamingCapabilities);
	if (soap_out_PointerTotrt__StreamingCapabilities(soap, tag?tag:"trt:StreamingCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__StreamingCapabilities ** SOAP_FMAC4 soap_get_PointerTotrt__StreamingCapabilities(struct soap *soap, struct trt__StreamingCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__StreamingCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotrt__ProfileCapabilities(struct soap *soap, struct trt__ProfileCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_trt__ProfileCapabilities))
		soap_serialize_trt__ProfileCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotrt__ProfileCapabilities(struct soap *soap, const char *tag, int id, struct trt__ProfileCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_trt__ProfileCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out_trt__ProfileCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct trt__ProfileCapabilities ** SOAP_FMAC4 soap_in_PointerTotrt__ProfileCapabilities(struct soap *soap, const char *tag, struct trt__ProfileCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct trt__ProfileCapabilities **)soap_malloc(soap, sizeof(struct trt__ProfileCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_trt__ProfileCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct trt__ProfileCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_trt__ProfileCapabilities, sizeof(struct trt__ProfileCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotrt__ProfileCapabilities(struct soap *soap, struct trt__ProfileCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotrt__ProfileCapabilities);
	if (soap_out_PointerTotrt__ProfileCapabilities(soap, tag?tag:"trt:ProfileCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trt__ProfileCapabilities ** SOAP_FMAC4 soap_get_PointerTotrt__ProfileCapabilities(struct soap *soap, struct trt__ProfileCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotrt__ProfileCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotmd__SerialData(struct soap *soap, struct tmd__SerialData *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tmd__SerialData))
		soap_serialize_tmd__SerialData(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotmd__SerialData(struct soap *soap, const char *tag, int id, struct tmd__SerialData *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tmd__SerialData);
	if (id < 0)
		return soap->error;
	return soap_out_tmd__SerialData(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tmd__SerialData ** SOAP_FMAC4 soap_in_PointerTotmd__SerialData(struct soap *soap, const char *tag, struct tmd__SerialData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tmd__SerialData **)soap_malloc(soap, sizeof(struct tmd__SerialData *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tmd__SerialData(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tmd__SerialData **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__SerialData, sizeof(struct tmd__SerialData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotmd__SerialData(struct soap *soap, struct tmd__SerialData *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotmd__SerialData);
	if (soap_out_PointerTotmd__SerialData(soap, tag?tag:"tmd:SerialData", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__SerialData ** SOAP_FMAC4 soap_get_PointerTotmd__SerialData(struct soap *soap, struct tmd__SerialData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotmd__SerialData(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotmd__SerialPortConfigurationOptions(struct soap *soap, struct tmd__SerialPortConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tmd__SerialPortConfigurationOptions))
		soap_serialize_tmd__SerialPortConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotmd__SerialPortConfigurationOptions(struct soap *soap, const char *tag, int id, struct tmd__SerialPortConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tmd__SerialPortConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tmd__SerialPortConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tmd__SerialPortConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTotmd__SerialPortConfigurationOptions(struct soap *soap, const char *tag, struct tmd__SerialPortConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tmd__SerialPortConfigurationOptions **)soap_malloc(soap, sizeof(struct tmd__SerialPortConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tmd__SerialPortConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tmd__SerialPortConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__SerialPortConfigurationOptions, sizeof(struct tmd__SerialPortConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotmd__SerialPortConfigurationOptions(struct soap *soap, struct tmd__SerialPortConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotmd__SerialPortConfigurationOptions);
	if (soap_out_PointerTotmd__SerialPortConfigurationOptions(soap, tag?tag:"tmd:SerialPortConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__SerialPortConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTotmd__SerialPortConfigurationOptions(struct soap *soap, struct tmd__SerialPortConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotmd__SerialPortConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotmd__SerialPortConfiguration(struct soap *soap, struct tmd__SerialPortConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tmd__SerialPortConfiguration))
		soap_serialize_tmd__SerialPortConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotmd__SerialPortConfiguration(struct soap *soap, const char *tag, int id, struct tmd__SerialPortConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tmd__SerialPortConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tmd__SerialPortConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tmd__SerialPortConfiguration ** SOAP_FMAC4 soap_in_PointerTotmd__SerialPortConfiguration(struct soap *soap, const char *tag, struct tmd__SerialPortConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tmd__SerialPortConfiguration **)soap_malloc(soap, sizeof(struct tmd__SerialPortConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tmd__SerialPortConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tmd__SerialPortConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__SerialPortConfiguration, sizeof(struct tmd__SerialPortConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotmd__SerialPortConfiguration(struct soap *soap, struct tmd__SerialPortConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotmd__SerialPortConfiguration);
	if (soap_out_PointerTotmd__SerialPortConfiguration(soap, tag?tag:"tmd:SerialPortConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__SerialPortConfiguration ** SOAP_FMAC4 soap_get_PointerTotmd__SerialPortConfiguration(struct soap *soap, struct tmd__SerialPortConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotmd__SerialPortConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTotmd__SerialPort(struct soap *soap, struct tmd__SerialPort *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tmd__SerialPort))
		soap_serialize_tmd__SerialPort(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTotmd__SerialPort(struct soap *soap, const char *tag, int id, struct tmd__SerialPort *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tmd__SerialPort);
	if (id < 0)
		return soap->error;
	return soap_out_tmd__SerialPort(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tmd__SerialPort ** SOAP_FMAC4 soap_in_PointerTotmd__SerialPort(struct soap *soap, const char *tag, struct tmd__SerialPort **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tmd__SerialPort **)soap_malloc(soap, sizeof(struct tmd__SerialPort *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tmd__SerialPort(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tmd__SerialPort **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tmd__SerialPort, sizeof(struct tmd__SerialPort), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTotmd__SerialPort(struct soap *soap, struct tmd__SerialPort *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTotmd__SerialPort);
	if (soap_out_PointerTotmd__SerialPort(soap, tag?tag:"tmd:SerialPort", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tmd__SerialPort ** SOAP_FMAC4 soap_get_PointerTotmd__SerialPort(struct soap *soap, struct tmd__SerialPort **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotmd__SerialPort(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__DigitalInput(struct soap *soap, struct tt__DigitalInput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__DigitalInput))
		soap_serialize_tt__DigitalInput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__DigitalInput(struct soap *soap, const char *tag, int id, struct tt__DigitalInput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__DigitalInput);
	if (id < 0)
		return soap->error;
	return soap_out_tt__DigitalInput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__DigitalInput ** SOAP_FMAC4 soap_in_PointerTott__DigitalInput(struct soap *soap, const char *tag, struct tt__DigitalInput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__DigitalInput **)soap_malloc(soap, sizeof(struct tt__DigitalInput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__DigitalInput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__DigitalInput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__DigitalInput, sizeof(struct tt__DigitalInput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__DigitalInput(struct soap *soap, struct tt__DigitalInput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__DigitalInput);
	if (soap_out_PointerTott__DigitalInput(soap, tag?tag:"tt:DigitalInput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__DigitalInput ** SOAP_FMAC4 soap_get_PointerTott__DigitalInput(struct soap *soap, struct tt__DigitalInput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__DigitalInput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__RelayOutput(struct soap *soap, struct tt__RelayOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__RelayOutput))
		soap_serialize_tt__RelayOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__RelayOutput(struct soap *soap, const char *tag, int id, struct tt__RelayOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__RelayOutput);
	if (id < 0)
		return soap->error;
	return soap_out_tt__RelayOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__RelayOutput ** SOAP_FMAC4 soap_in_PointerTott__RelayOutput(struct soap *soap, const char *tag, struct tt__RelayOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__RelayOutput **)soap_malloc(soap, sizeof(struct tt__RelayOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__RelayOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__RelayOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__RelayOutput, sizeof(struct tt__RelayOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__RelayOutput(struct soap *soap, struct tt__RelayOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__RelayOutput);
	if (soap_out_PointerTott__RelayOutput(soap, tag?tag:"tt:RelayOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__RelayOutput ** SOAP_FMAC4 soap_get_PointerTott__RelayOutput(struct soap *soap, struct tt__RelayOutput **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__RelayOutput(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, struct tt__AudioOutputConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioOutputConfigurationOptions))
		soap_serialize_tt__AudioOutputConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__AudioOutputConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioOutputConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioOutputConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioOutputConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioOutputConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioOutputConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__AudioOutputConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioOutputConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioOutputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioOutputConfigurationOptions, sizeof(struct tt__AudioOutputConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, struct tt__AudioOutputConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioOutputConfigurationOptions);
	if (soap_out_PointerTott__AudioOutputConfigurationOptions(soap, tag?tag:"tt:AudioOutputConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioOutputConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioOutputConfigurationOptions(struct soap *soap, struct tt__AudioOutputConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, struct tt__AudioSourceConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__AudioSourceConfigurationOptions))
		soap_serialize_tt__AudioSourceConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__AudioSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__AudioSourceConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__AudioSourceConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__AudioSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, const char *tag, struct tt__AudioSourceConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__AudioSourceConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__AudioSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__AudioSourceConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__AudioSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__AudioSourceConfigurationOptions, sizeof(struct tt__AudioSourceConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, struct tt__AudioSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__AudioSourceConfigurationOptions);
	if (soap_out_PointerTott__AudioSourceConfigurationOptions(soap, tag?tag:"tt:AudioSourceConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__AudioSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__AudioSourceConfigurationOptions(struct soap *soap, struct tt__AudioSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__AudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoOutputConfigurationOptions(struct soap *soap, struct tt__VideoOutputConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoOutputConfigurationOptions))
		soap_serialize_tt__VideoOutputConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoOutputConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__VideoOutputConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoOutputConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoOutputConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoOutputConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__VideoOutputConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoOutputConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoOutputConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__VideoOutputConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoOutputConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoOutputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoOutputConfigurationOptions, sizeof(struct tt__VideoOutputConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoOutputConfigurationOptions(struct soap *soap, struct tt__VideoOutputConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoOutputConfigurationOptions);
	if (soap_out_PointerTott__VideoOutputConfigurationOptions(soap, tag?tag:"tt:VideoOutputConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoOutputConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__VideoOutputConfigurationOptions(struct soap *soap, struct tt__VideoOutputConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, struct tt__VideoSourceConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoSourceConfigurationOptions))
		soap_serialize_tt__VideoSourceConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, struct tt__VideoSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoSourceConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoSourceConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, const char *tag, struct tt__VideoSourceConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoSourceConfigurationOptions **)soap_malloc(soap, sizeof(struct tt__VideoSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoSourceConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoSourceConfigurationOptions, sizeof(struct tt__VideoSourceConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, struct tt__VideoSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoSourceConfigurationOptions);
	if (soap_out_PointerTott__VideoSourceConfigurationOptions(soap, tag?tag:"tt:VideoSourceConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTott__VideoSourceConfigurationOptions(struct soap *soap, struct tt__VideoSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoOutputConfiguration(struct soap *soap, struct tt__VideoOutputConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoOutputConfiguration))
		soap_serialize_tt__VideoOutputConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoOutputConfiguration(struct soap *soap, const char *tag, int id, struct tt__VideoOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoOutputConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoOutputConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTott__VideoOutputConfiguration(struct soap *soap, const char *tag, struct tt__VideoOutputConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoOutputConfiguration **)soap_malloc(soap, sizeof(struct tt__VideoOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoOutputConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoOutputConfiguration, sizeof(struct tt__VideoOutputConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoOutputConfiguration(struct soap *soap, struct tt__VideoOutputConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoOutputConfiguration);
	if (soap_out_PointerTott__VideoOutputConfiguration(soap, tag?tag:"tt:VideoOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__VideoOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTott__VideoOutputConfiguration(struct soap *soap, struct tt__VideoOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTott__VideoOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTott__VideoOutput(struct soap *soap, struct tt__VideoOutput *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_tt__VideoOutput))
		soap_serialize_tt__VideoOutput(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTott__VideoOutput(struct soap *soap, const char *tag, int id, struct tt__VideoOutput *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_tt__VideoOutput);
	if (id < 0)
		return soap->error;
	return soap_out_tt__VideoOutput(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct tt__VideoOutput ** SOAP_FMAC4 soap_in_PointerTott__VideoOutput(struct soap *soap, const char *tag, struct tt__VideoOutput **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct tt__VideoOutput **)soap_malloc(soap, sizeof(struct tt__VideoOutput *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_tt__VideoOutput(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct tt__VideoOutput **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_tt__VideoOutput, sizeof(struct tt__VideoOutput), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTott__VideoOutput(struct soap *soap, struct tt__VideoOutput *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTott__VideoOutput);
	if (soap_out_PointerTott__VideoOutput(soap, tag?tag:"tt:VideoOutput", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

#ifdef __cplusplus
}
#endif
