#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif


SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsdd__HelloType(struct soap *soap, const struct wsdd__HelloType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsdd__HelloType);
	if (soap_out_wsdd__HelloType(soap, tag?tag:"wsdd:HelloType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsdd__HelloType * SOAP_FMAC4 soap_get_wsdd__HelloType(struct soap *soap, struct wsdd__HelloType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsdd__HelloType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag?tag:"SOAP-ENV:Fault", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag?tag:"SOAP-ENV:Reason", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag?tag:"SOAP-ENV:Code", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->wsnt__InvalidFilterFault = NULL;
	a->wsnt__InvalidMessageContentExpressionFault = NULL;
	a->wsnt__InvalidProducerPropertiesExpressionFault = NULL;
	a->wsnt__InvalidTopicExpressionFault = NULL;
	a->wsnt__MultipleTopicsSpecifiedFault = NULL;
	a->wsnt__NoCurrentMessageOnTopicFault = NULL;
	a->wsnt__NotifyMessageNotSupportedFault = NULL;
	a->wsnt__PauseFailedFault = NULL;
	a->tev__PullMessagesFaultResponse = NULL;
	a->wsrfr__ResourceUnknownFault = NULL;
	a->wsnt__ResumeFailedFault = NULL;
	a->wsnt__SubscribeCreationFailedFault = NULL;
	a->wsnt__TopicExpressionDialectUnknownFault = NULL;
	a->wsnt__TopicNotSupportedFault = NULL;
	a->wsnt__UnableToCreatePullPointFault = NULL;
	a->wsnt__UnableToDestroyPullPointFault = NULL;
	a->wsnt__UnableToDestroySubscriptionFault = NULL;
	a->wsnt__UnableToGetMessagesFault = NULL;
	a->wsnt__UnacceptableInitialTerminationTimeFault = NULL;
	a->wsnt__UnacceptableTerminationTimeFault = NULL;
	a->wsnt__UnrecognizedPolicyRequestFault = NULL;
	a->wsnt__UnsupportedPolicyRequestFault = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsnt__InvalidFilterFaultType(soap, &a->wsnt__InvalidFilterFault);
	soap_serialize_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, &a->wsnt__InvalidMessageContentExpressionFault);
	soap_serialize_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, &a->wsnt__InvalidProducerPropertiesExpressionFault);
	soap_serialize_PointerTowsnt__InvalidTopicExpressionFaultType(soap, &a->wsnt__InvalidTopicExpressionFault);
	soap_serialize_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, &a->wsnt__MultipleTopicsSpecifiedFault);
	soap_serialize_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, &a->wsnt__NoCurrentMessageOnTopicFault);
	soap_serialize_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, &a->wsnt__NotifyMessageNotSupportedFault);
	soap_serialize_PointerTowsnt__PauseFailedFaultType(soap, &a->wsnt__PauseFailedFault);
	soap_serialize_PointerTo_tev__PullMessagesFaultResponse(soap, &a->tev__PullMessagesFaultResponse);
	soap_serialize_PointerTowsrfr__ResourceUnknownFaultType(soap, &a->wsrfr__ResourceUnknownFault);
	soap_serialize_PointerTowsnt__ResumeFailedFaultType(soap, &a->wsnt__ResumeFailedFault);
	soap_serialize_PointerTowsnt__SubscribeCreationFailedFaultType(soap, &a->wsnt__SubscribeCreationFailedFault);
	soap_serialize_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, &a->wsnt__TopicExpressionDialectUnknownFault);
	soap_serialize_PointerTowsnt__TopicNotSupportedFaultType(soap, &a->wsnt__TopicNotSupportedFault);
	soap_serialize_PointerTowsnt__UnableToCreatePullPointFaultType(soap, &a->wsnt__UnableToCreatePullPointFault);
	soap_serialize_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, &a->wsnt__UnableToDestroyPullPointFault);
	soap_serialize_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, &a->wsnt__UnableToDestroySubscriptionFault);
	soap_serialize_PointerTowsnt__UnableToGetMessagesFaultType(soap, &a->wsnt__UnableToGetMessagesFault);
	soap_serialize_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, &a->wsnt__UnacceptableInitialTerminationTimeFault);
	soap_serialize_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, &a->wsnt__UnacceptableTerminationTimeFault);
	soap_serialize_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, &a->wsnt__UnrecognizedPolicyRequestFault);
	soap_serialize_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, &a->wsnt__UnsupportedPolicyRequestFault);
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	if (soap_out_PointerTowsnt__InvalidFilterFaultType(soap, "wsnt:InvalidFilterFault", -1, &a->wsnt__InvalidFilterFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, "wsnt:InvalidMessageContentExpressionFault", -1, &a->wsnt__InvalidMessageContentExpressionFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, "wsnt:InvalidProducerPropertiesExpressionFault", -1, &a->wsnt__InvalidProducerPropertiesExpressionFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__InvalidTopicExpressionFaultType(soap, "wsnt:InvalidTopicExpressionFault", -1, &a->wsnt__InvalidTopicExpressionFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, "wsnt:MultipleTopicsSpecifiedFault", -1, &a->wsnt__MultipleTopicsSpecifiedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, "wsnt:NoCurrentMessageOnTopicFault", -1, &a->wsnt__NoCurrentMessageOnTopicFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, "wsnt:NotifyMessageNotSupportedFault", -1, &a->wsnt__NotifyMessageNotSupportedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__PauseFailedFaultType(soap, "wsnt:PauseFailedFault", -1, &a->wsnt__PauseFailedFault, ""))
		return soap->error;
	if (soap_out_PointerTo_tev__PullMessagesFaultResponse(soap, "tev:PullMessagesFaultResponse", -1, &a->tev__PullMessagesFaultResponse, ""))
		return soap->error;
	if (soap_out_PointerTowsrfr__ResourceUnknownFaultType(soap, "wsrfr:ResourceUnknownFault", -1, &a->wsrfr__ResourceUnknownFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__ResumeFailedFaultType(soap, "wsnt:ResumeFailedFault", -1, &a->wsnt__ResumeFailedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__SubscribeCreationFailedFaultType(soap, "wsnt:SubscribeCreationFailedFault", -1, &a->wsnt__SubscribeCreationFailedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, "wsnt:TopicExpressionDialectUnknownFault", -1, &a->wsnt__TopicExpressionDialectUnknownFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__TopicNotSupportedFaultType(soap, "wsnt:TopicNotSupportedFault", -1, &a->wsnt__TopicNotSupportedFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnableToCreatePullPointFaultType(soap, "wsnt:UnableToCreatePullPointFault", -1, &a->wsnt__UnableToCreatePullPointFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, "wsnt:UnableToDestroyPullPointFault", -1, &a->wsnt__UnableToDestroyPullPointFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, "wsnt:UnableToDestroySubscriptionFault", -1, &a->wsnt__UnableToDestroySubscriptionFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnableToGetMessagesFaultType(soap, "wsnt:UnableToGetMessagesFault", -1, &a->wsnt__UnableToGetMessagesFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, "wsnt:UnacceptableInitialTerminationTimeFault", -1, &a->wsnt__UnacceptableInitialTerminationTimeFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, "wsnt:UnacceptableTerminationTimeFault", -1, &a->wsnt__UnacceptableTerminationTimeFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, "wsnt:UnrecognizedPolicyRequestFault", -1, &a->wsnt__UnrecognizedPolicyRequestFault, ""))
		return soap->error;
	if (soap_out_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, "wsnt:UnsupportedPolicyRequestFault", -1, &a->wsnt__UnsupportedPolicyRequestFault, ""))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_wsnt__InvalidFilterFault = 1;
	size_t soap_flag_wsnt__InvalidMessageContentExpressionFault = 1;
	size_t soap_flag_wsnt__InvalidProducerPropertiesExpressionFault = 1;
	size_t soap_flag_wsnt__InvalidTopicExpressionFault = 1;
	size_t soap_flag_wsnt__MultipleTopicsSpecifiedFault = 1;
	size_t soap_flag_wsnt__NoCurrentMessageOnTopicFault = 1;
	size_t soap_flag_wsnt__NotifyMessageNotSupportedFault = 1;
	size_t soap_flag_wsnt__PauseFailedFault = 1;
	size_t soap_flag_tev__PullMessagesFaultResponse = 1;
	size_t soap_flag_wsrfr__ResourceUnknownFault = 1;
	size_t soap_flag_wsnt__ResumeFailedFault = 1;
	size_t soap_flag_wsnt__SubscribeCreationFailedFault = 1;
	size_t soap_flag_wsnt__TopicExpressionDialectUnknownFault = 1;
	size_t soap_flag_wsnt__TopicNotSupportedFault = 1;
	size_t soap_flag_wsnt__UnableToCreatePullPointFault = 1;
	size_t soap_flag_wsnt__UnableToDestroyPullPointFault = 1;
	size_t soap_flag_wsnt__UnableToDestroySubscriptionFault = 1;
	size_t soap_flag_wsnt__UnableToGetMessagesFault = 1;
	size_t soap_flag_wsnt__UnacceptableInitialTerminationTimeFault = 1;
	size_t soap_flag_wsnt__UnacceptableTerminationTimeFault = 1;
	size_t soap_flag_wsnt__UnrecognizedPolicyRequestFault = 1;
	size_t soap_flag_wsnt__UnsupportedPolicyRequestFault = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsnt__InvalidFilterFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__InvalidFilterFaultType(soap, "wsnt:InvalidFilterFault", &a->wsnt__InvalidFilterFault, "wsnt:InvalidFilterFaultType"))
				{	soap_flag_wsnt__InvalidFilterFault--;
					continue;
				}
			if (soap_flag_wsnt__InvalidMessageContentExpressionFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__InvalidMessageContentExpressionFaultType(soap, "wsnt:InvalidMessageContentExpressionFault", &a->wsnt__InvalidMessageContentExpressionFault, "wsnt:InvalidMessageContentExpressionFaultType"))
				{	soap_flag_wsnt__InvalidMessageContentExpressionFault--;
					continue;
				}
			if (soap_flag_wsnt__InvalidProducerPropertiesExpressionFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__InvalidProducerPropertiesExpressionFaultType(soap, "wsnt:InvalidProducerPropertiesExpressionFault", &a->wsnt__InvalidProducerPropertiesExpressionFault, "wsnt:InvalidProducerPropertiesExpressionFaultType"))
				{	soap_flag_wsnt__InvalidProducerPropertiesExpressionFault--;
					continue;
				}
			if (soap_flag_wsnt__InvalidTopicExpressionFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__InvalidTopicExpressionFaultType(soap, "wsnt:InvalidTopicExpressionFault", &a->wsnt__InvalidTopicExpressionFault, "wsnt:InvalidTopicExpressionFaultType"))
				{	soap_flag_wsnt__InvalidTopicExpressionFault--;
					continue;
				}
			if (soap_flag_wsnt__MultipleTopicsSpecifiedFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__MultipleTopicsSpecifiedFaultType(soap, "wsnt:MultipleTopicsSpecifiedFault", &a->wsnt__MultipleTopicsSpecifiedFault, "wsnt:MultipleTopicsSpecifiedFaultType"))
				{	soap_flag_wsnt__MultipleTopicsSpecifiedFault--;
					continue;
				}
			if (soap_flag_wsnt__NoCurrentMessageOnTopicFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__NoCurrentMessageOnTopicFaultType(soap, "wsnt:NoCurrentMessageOnTopicFault", &a->wsnt__NoCurrentMessageOnTopicFault, "wsnt:NoCurrentMessageOnTopicFaultType"))
				{	soap_flag_wsnt__NoCurrentMessageOnTopicFault--;
					continue;
				}
			if (soap_flag_wsnt__NotifyMessageNotSupportedFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__NotifyMessageNotSupportedFaultType(soap, "wsnt:NotifyMessageNotSupportedFault", &a->wsnt__NotifyMessageNotSupportedFault, "wsnt:NotifyMessageNotSupportedFaultType"))
				{	soap_flag_wsnt__NotifyMessageNotSupportedFault--;
					continue;
				}
			if (soap_flag_wsnt__PauseFailedFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__PauseFailedFaultType(soap, "wsnt:PauseFailedFault", &a->wsnt__PauseFailedFault, "wsnt:PauseFailedFaultType"))
				{	soap_flag_wsnt__PauseFailedFault--;
					continue;
				}
			if (soap_flag_tev__PullMessagesFaultResponse && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tev__PullMessagesFaultResponse(soap, "tev:PullMessagesFaultResponse", &a->tev__PullMessagesFaultResponse, ""))
				{	soap_flag_tev__PullMessagesFaultResponse--;
					continue;
				}
			if (soap_flag_wsrfr__ResourceUnknownFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsrfr__ResourceUnknownFaultType(soap, "wsrfr:ResourceUnknownFault", &a->wsrfr__ResourceUnknownFault, "wsrfr:ResourceUnknownFaultType"))
				{	soap_flag_wsrfr__ResourceUnknownFault--;
					continue;
				}
			if (soap_flag_wsnt__ResumeFailedFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__ResumeFailedFaultType(soap, "wsnt:ResumeFailedFault", &a->wsnt__ResumeFailedFault, "wsnt:ResumeFailedFaultType"))
				{	soap_flag_wsnt__ResumeFailedFault--;
					continue;
				}
			if (soap_flag_wsnt__SubscribeCreationFailedFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__SubscribeCreationFailedFaultType(soap, "wsnt:SubscribeCreationFailedFault", &a->wsnt__SubscribeCreationFailedFault, "wsnt:SubscribeCreationFailedFaultType"))
				{	soap_flag_wsnt__SubscribeCreationFailedFault--;
					continue;
				}
			if (soap_flag_wsnt__TopicExpressionDialectUnknownFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__TopicExpressionDialectUnknownFaultType(soap, "wsnt:TopicExpressionDialectUnknownFault", &a->wsnt__TopicExpressionDialectUnknownFault, "wsnt:TopicExpressionDialectUnknownFaultType"))
				{	soap_flag_wsnt__TopicExpressionDialectUnknownFault--;
					continue;
				}
			if (soap_flag_wsnt__TopicNotSupportedFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__TopicNotSupportedFaultType(soap, "wsnt:TopicNotSupportedFault", &a->wsnt__TopicNotSupportedFault, "wsnt:TopicNotSupportedFaultType"))
				{	soap_flag_wsnt__TopicNotSupportedFault--;
					continue;
				}
			if (soap_flag_wsnt__UnableToCreatePullPointFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__UnableToCreatePullPointFaultType(soap, "wsnt:UnableToCreatePullPointFault", &a->wsnt__UnableToCreatePullPointFault, "wsnt:UnableToCreatePullPointFaultType"))
				{	soap_flag_wsnt__UnableToCreatePullPointFault--;
					continue;
				}
			if (soap_flag_wsnt__UnableToDestroyPullPointFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__UnableToDestroyPullPointFaultType(soap, "wsnt:UnableToDestroyPullPointFault", &a->wsnt__UnableToDestroyPullPointFault, "wsnt:UnableToDestroyPullPointFaultType"))
				{	soap_flag_wsnt__UnableToDestroyPullPointFault--;
					continue;
				}
			if (soap_flag_wsnt__UnableToDestroySubscriptionFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__UnableToDestroySubscriptionFaultType(soap, "wsnt:UnableToDestroySubscriptionFault", &a->wsnt__UnableToDestroySubscriptionFault, "wsnt:UnableToDestroySubscriptionFaultType"))
				{	soap_flag_wsnt__UnableToDestroySubscriptionFault--;
					continue;
				}
			if (soap_flag_wsnt__UnableToGetMessagesFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__UnableToGetMessagesFaultType(soap, "wsnt:UnableToGetMessagesFault", &a->wsnt__UnableToGetMessagesFault, "wsnt:UnableToGetMessagesFaultType"))
				{	soap_flag_wsnt__UnableToGetMessagesFault--;
					continue;
				}
			if (soap_flag_wsnt__UnacceptableInitialTerminationTimeFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__UnacceptableInitialTerminationTimeFaultType(soap, "wsnt:UnacceptableInitialTerminationTimeFault", &a->wsnt__UnacceptableInitialTerminationTimeFault, "wsnt:UnacceptableInitialTerminationTimeFaultType"))
				{	soap_flag_wsnt__UnacceptableInitialTerminationTimeFault--;
					continue;
				}
			if (soap_flag_wsnt__UnacceptableTerminationTimeFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__UnacceptableTerminationTimeFaultType(soap, "wsnt:UnacceptableTerminationTimeFault", &a->wsnt__UnacceptableTerminationTimeFault, "wsnt:UnacceptableTerminationTimeFaultType"))
				{	soap_flag_wsnt__UnacceptableTerminationTimeFault--;
					continue;
				}
			if (soap_flag_wsnt__UnrecognizedPolicyRequestFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__UnrecognizedPolicyRequestFaultType(soap, "wsnt:UnrecognizedPolicyRequestFault", &a->wsnt__UnrecognizedPolicyRequestFault, "wsnt:UnrecognizedPolicyRequestFaultType"))
				{	soap_flag_wsnt__UnrecognizedPolicyRequestFault--;
					continue;
				}
			if (soap_flag_wsnt__UnsupportedPolicyRequestFault && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__UnsupportedPolicyRequestFaultType(soap, "wsnt:UnsupportedPolicyRequestFault", &a->wsnt__UnsupportedPolicyRequestFault, "wsnt:UnsupportedPolicyRequestFaultType"))
				{	soap_flag_wsnt__UnsupportedPolicyRequestFault--;
					continue;
				}
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fault > 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag?tag:"SOAP-ENV:Detail", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__Relationship(struct soap *soap, struct wsa__Relationship *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__QName(soap, &a->RelationshipType);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__Relationship(struct soap *soap, const char *tag, int id, const struct wsa__Relationship *a, const char *type)
{
	if (a->RelationshipType)
		soap_set_attr(soap, "RelationshipType", soap_QName2s(soap, a->RelationshipType), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_in_wsa__Relationship(struct soap *soap, const char *tag, struct wsa__Relationship *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__Relationship *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__Relationship, sizeof(struct wsa__Relationship), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__Relationship(soap, a);
	if (soap_s2QName(soap, soap_attr_value(soap, "RelationshipType", 0), &a->RelationshipType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, "wsa:Relationship"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__Relationship(struct soap *soap, const struct wsa__Relationship *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__Relationship);
	if (soap_out_wsa__Relationship(soap, tag?tag:"wsa:Relationship", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__Relationship * SOAP_FMAC4 soap_get_wsa__Relationship(struct soap *soap, struct wsa__Relationship *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__Relationship(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->__item);
	soap_default_string(soap, &a->PortName);
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ServiceNameType(struct soap *soap, const char *tag, int id, const struct wsa__ServiceNameType *a, const char *type)
{
	const char *soap_tmp___item = soap_QName2s(soap, a->__item);
	if (a->PortName)
		soap_set_attr(soap, "PortName", a->PortName, 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	return soap_out__QName(soap, tag, id, (char*const*)&soap_tmp___item, "");
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_in_wsa__ServiceNameType(struct soap *soap, const char *tag, struct wsa__ServiceNameType *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct wsa__ServiceNameType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ServiceNameType, sizeof(struct wsa__ServiceNameType), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default_wsa__ServiceNameType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PortName", 0), &a->PortName, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (!soap_in__QName(soap, tag, &a->__item, "wsa:ServiceNameType"))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ServiceNameType(struct soap *soap, const struct wsa__ServiceNameType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__ServiceNameType);
	if (soap_out_wsa__ServiceNameType(soap, tag?tag:"wsa:ServiceNameType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ServiceNameType * SOAP_FMAC4 soap_get_wsa__ServiceNameType(struct soap *soap, struct wsa__ServiceNameType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ServiceNameType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferenceParametersType(struct soap *soap, const char *tag, int id, const struct wsa__ReferenceParametersType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferenceParametersType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_in_wsa__ReferenceParametersType(struct soap *soap, const char *tag, struct wsa__ReferenceParametersType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ReferenceParametersType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferenceParametersType, sizeof(struct wsa__ReferenceParametersType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferenceParametersType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferenceParametersType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferenceParametersType, 0, sizeof(struct wsa__ReferenceParametersType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferenceParametersType(struct soap *soap, const struct wsa__ReferenceParametersType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__ReferenceParametersType);
	if (soap_out_wsa__ReferenceParametersType(soap, tag?tag:"wsa:ReferenceParametersType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferenceParametersType * SOAP_FMAC4 soap_get_wsa__ReferenceParametersType(struct soap *soap, struct wsa__ReferenceParametersType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferenceParametersType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, int id, const struct wsa__ReferencePropertiesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__ReferencePropertiesType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_in_wsa__ReferencePropertiesType(struct soap *soap, const char *tag, struct wsa__ReferencePropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__ReferencePropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__ReferencePropertiesType, sizeof(struct wsa__ReferencePropertiesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__ReferencePropertiesType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__ReferencePropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__ReferencePropertiesType, 0, sizeof(struct wsa__ReferencePropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__ReferencePropertiesType(struct soap *soap, const struct wsa__ReferencePropertiesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__ReferencePropertiesType);
	if (soap_out_wsa__ReferencePropertiesType(soap, tag?tag:"wsa:ReferencePropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__ReferencePropertiesType * SOAP_FMAC4 soap_get_wsa__ReferencePropertiesType(struct soap *soap, struct wsa__ReferencePropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__ReferencePropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Address);
	a->ReferenceProperties = NULL;
	a->ReferenceParameters = NULL;
	a->PortType = NULL;
	a->ServiceName = NULL;
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Address);
	soap_serialize_PointerTowsa__ReferencePropertiesType(soap, &a->ReferenceProperties);
	soap_serialize_PointerTowsa__ReferenceParametersType(soap, &a->ReferenceParameters);
	soap_serialize_PointerTo_QName(soap, &a->PortType);
	soap_serialize_PointerTowsa__ServiceNameType(soap, &a->ServiceName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsa__EndpointReferenceType(struct soap *soap, const char *tag, int id, const struct wsa__EndpointReferenceType *a, const char *type)
{
	const char *soap_tmp_PortType = a->PortType ? soap_QName2s(soap, *a->PortType) : NULL;
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsa__EndpointReferenceType), type))
		return soap->error;
	if (a->Address)
	{	if (soap_out_string(soap, "wsa:Address", -1, &a->Address, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wsa:Address"))
		return soap->error;
	if (soap_out_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", -1, &a->ReferenceProperties, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", -1, &a->ReferenceParameters, ""))
		return soap->error;
	if (soap_out__QName(soap, "wsa:PortType", -1, (char*const*)&soap_tmp_PortType, ""))
		return soap->error;
	if (soap_out_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", -1, &a->ServiceName, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			soap_outliteral(soap, "-any", a->__any + i, NULL);
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_in_wsa__EndpointReferenceType(struct soap *soap, const char *tag, struct wsa__EndpointReferenceType *a, const char *type)
{
	size_t soap_flag_Address = 1;
	size_t soap_flag_ReferenceProperties = 1;
	size_t soap_flag_ReferenceParameters = 1;
	size_t soap_flag_PortType = 1;
	size_t soap_flag_ServiceName = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsa__EndpointReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsa__EndpointReferenceType, sizeof(struct wsa__EndpointReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsa__EndpointReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Address && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsa:Address", &a->Address, "xsd:string"))
				{	soap_flag_Address--;
					continue;
				}
			if (soap_flag_ReferenceProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferencePropertiesType(soap, "wsa:ReferenceProperties", &a->ReferenceProperties, "wsa:ReferencePropertiesType"))
				{	soap_flag_ReferenceProperties--;
					continue;
				}
			if (soap_flag_ReferenceParameters && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ReferenceParametersType(soap, "wsa:ReferenceParameters", &a->ReferenceParameters, "wsa:ReferenceParametersType"))
				{	soap_flag_ReferenceParameters--;
					continue;
				}
			if (soap_flag_PortType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_QName(soap, "wsa:PortType", &a->PortType, ""))
				{	soap_flag_PortType--;
					continue;
				}
			if (soap_flag_ServiceName && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa__ServiceNameType(soap, "wsa:ServiceName", &a->ServiceName, "wsa:ServiceNameType"))
				{	soap_flag_ServiceName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char **)soap_push_block(soap, soap_blist___any, sizeof(char *));
					if (a->__any == NULL)
						return NULL;
					*a->__any = NULL;
				}
				if (soap_inliteral(soap, "-any", a->__any))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char **)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsa__EndpointReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsa__EndpointReferenceType, 0, sizeof(struct wsa__EndpointReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Address > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsa__EndpointReferenceType(struct soap *soap, const struct wsa__EndpointReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsa__EndpointReferenceType);
	if (soap_out_wsa__EndpointReferenceType(soap, tag?tag:"wsa:EndpointReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsa__EndpointReferenceType * SOAP_FMAC4 soap_get_wsa__EndpointReferenceType(struct soap *soap, struct wsa__EndpointReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsa__EndpointReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsse__Security = NULL;
	soap_default__wsa__MessageID(soap, &a->wsa__MessageID);
	a->wsa__RelatesTo = NULL;
	a->wsa__From = NULL;
	a->wsa__ReplyTo = NULL;
	a->wsa__FaultTo = NULL;
	soap_default__wsa__To(soap, &a->wsa__To);
	soap_default__wsa__Action(soap, &a->wsa__Action);
	a->wsdd__AppSequence = NULL;
	soap_default__wsa5__MessageID(soap, &a->wsa5__MessageID);
	a->wsa5__RelatesTo = NULL;
	a->wsa5__From = NULL;
	a->wsa5__ReplyTo = NULL;
	a->wsa5__FaultTo = NULL;
	soap_default__wsa5__To(soap, &a->wsa5__To);
	soap_default__wsa5__Action(soap, &a->wsa5__Action);
	a->chan__ChannelInstance = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__Security(soap, &a->wsse__Security);
	soap_serialize__wsa__MessageID(soap, &a->wsa__MessageID);
	soap_serialize_PointerTo_wsa__RelatesTo(soap, &a->wsa__RelatesTo);
	soap_serialize_PointerTo_wsa__From(soap, &a->wsa__From);
	soap_serialize_PointerTo_wsa__ReplyTo(soap, &a->wsa__ReplyTo);
	soap_serialize_PointerTo_wsa__FaultTo(soap, &a->wsa__FaultTo);
	soap_serialize__wsa__To(soap, &a->wsa__To);
	soap_serialize__wsa__Action(soap, &a->wsa__Action);
	soap_serialize_PointerTowsdd__AppSequenceType(soap, &a->wsdd__AppSequence);
	soap_serialize__wsa5__MessageID(soap, &a->wsa5__MessageID);
	soap_serialize_PointerTo_wsa5__RelatesTo(soap, &a->wsa5__RelatesTo);
	soap_serialize_PointerTo_wsa5__From(soap, &a->wsa5__From);
	soap_serialize_PointerTo_wsa5__ReplyTo(soap, &a->wsa5__ReplyTo);
	soap_serialize_PointerTo_wsa5__FaultTo(soap, &a->wsa5__FaultTo);
	soap_serialize__wsa5__To(soap, &a->wsa5__To);
	soap_serialize__wsa5__Action(soap, &a->wsa5__Action);
	soap_serialize_PointerTochan__ChannelInstanceType(soap, &a->chan__ChannelInstance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsse__Security(soap, "wsse:Security", -1, &a->wsse__Security, ""))
		return soap->error;
	if (soap_out__wsa__MessageID(soap, "wsa:MessageID", -1, &a->wsa__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", -1, &a->wsa__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa__From(soap, "wsa:From", -1, &a->wsa__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", -1, &a->wsa__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", -1, &a->wsa__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__To(soap, "wsa:To", -1, &a->wsa__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa__Action(soap, "wsa:Action", -1, &a->wsa__Action, ""))
		return soap->error;
	if (soap_out_PointerTowsdd__AppSequenceType(soap, "wsdd:AppSequence", -1, &a->wsdd__AppSequence, ""))
		return soap->error;
	if (soap_out__wsa5__MessageID(soap, "wsa5:MessageID", -1, &a->wsa5__MessageID, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", -1, &a->wsa5__RelatesTo, ""))
		return soap->error;
	if (soap_out_PointerTo_wsa5__From(soap, "wsa5:From", -1, &a->wsa5__From, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", -1, &a->wsa5__ReplyTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", -1, &a->wsa5__FaultTo, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__To(soap, "wsa5:To", -1, &a->wsa5__To, ""))
		return soap->error;
	soap->mustUnderstand = 1;
	if (soap_out__wsa5__Action(soap, "wsa5:Action", -1, &a->wsa5__Action, ""))
		return soap->error;
	if (soap_out_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", -1, &a->chan__ChannelInstance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	size_t soap_flag_wsse__Security = 1;
	size_t soap_flag_wsa__MessageID = 1;
	size_t soap_flag_wsa__RelatesTo = 1;
	size_t soap_flag_wsa__From = 1;
	size_t soap_flag_wsa__ReplyTo = 1;
	size_t soap_flag_wsa__FaultTo = 1;
	size_t soap_flag_wsa__To = 1;
	size_t soap_flag_wsa__Action = 1;
	size_t soap_flag_wsdd__AppSequence = 1;
	size_t soap_flag_wsa5__MessageID = 1;
	size_t soap_flag_wsa5__RelatesTo = 1;
	size_t soap_flag_wsa5__From = 1;
	size_t soap_flag_wsa5__ReplyTo = 1;
	size_t soap_flag_wsa5__FaultTo = 1;
	size_t soap_flag_wsa5__To = 1;
	size_t soap_flag_wsa5__Action = 1;
	size_t soap_flag_chan__ChannelInstance = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__Security && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Security(soap, "wsse:Security", &a->wsse__Security, ""))
				{	soap_flag_wsse__Security--;
					continue;
				}
			if (soap_flag_wsa__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa__MessageID(soap, "wsa:MessageID", &a->wsa__MessageID, ""))
				{	soap_flag_wsa__MessageID--;
					continue;
				}
			if (soap_flag_wsa__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__RelatesTo(soap, "wsa:RelatesTo", &a->wsa__RelatesTo, ""))
				{	soap_flag_wsa__RelatesTo--;
					continue;
				}
			if (soap_flag_wsa__From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__From(soap, "wsa:From", &a->wsa__From, ""))
				{	soap_flag_wsa__From--;
					continue;
				}
			if (soap_flag_wsa__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__ReplyTo(soap, "wsa:ReplyTo", &a->wsa__ReplyTo, ""))
				{	soap_flag_wsa__ReplyTo--;
					continue;
				}
			if (soap_flag_wsa__FaultTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa__FaultTo(soap, "wsa:FaultTo", &a->wsa__FaultTo, ""))
				{	soap_flag_wsa__FaultTo--;
					continue;
				}
			if (soap_flag_wsa__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa__To(soap, "wsa:To", &a->wsa__To, ""))
				{	soap_flag_wsa__To--;
					continue;
				}
			if (soap_flag_wsa__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa__Action(soap, "wsa:Action", &a->wsa__Action, ""))
				{	soap_flag_wsa__Action--;
					continue;
				}
			if (soap_flag_wsdd__AppSequence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsdd__AppSequenceType(soap, "wsdd:AppSequence", &a->wsdd__AppSequence, "wsdd:AppSequenceType"))
				{	soap_flag_wsdd__AppSequence--;
					continue;
				}
			if (soap_flag_wsa5__MessageID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__MessageID(soap, "wsa5:MessageID", &a->wsa5__MessageID, ""))
				{	soap_flag_wsa5__MessageID--;
					continue;
				}
			if (soap_flag_wsa5__RelatesTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__RelatesTo(soap, "wsa5:RelatesTo", &a->wsa5__RelatesTo, ""))
				{	soap_flag_wsa5__RelatesTo--;
					continue;
				}
			if (soap_flag_wsa5__From && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__From(soap, "wsa5:From", &a->wsa5__From, ""))
				{	soap_flag_wsa5__From--;
					continue;
				}
			if (soap_flag_wsa5__ReplyTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__ReplyTo(soap, "wsa5:ReplyTo", &a->wsa5__ReplyTo, ""))
				{	soap_flag_wsa5__ReplyTo--;
					continue;
				}
			if (soap_flag_wsa5__FaultTo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsa5__FaultTo(soap, "wsa5:FaultTo", &a->wsa5__FaultTo, ""))
				{	soap_flag_wsa5__FaultTo--;
					continue;
				}
			if (soap_flag_wsa5__To && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__To(soap, "wsa5:To", &a->wsa5__To, ""))
				{	soap_flag_wsa5__To--;
					continue;
				}
			if (soap_flag_wsa5__Action && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__wsa5__Action(soap, "wsa5:Action", &a->wsa5__Action, ""))
				{	soap_flag_wsa5__Action--;
					continue;
				}
			if (soap_flag_chan__ChannelInstance && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTochan__ChannelInstanceType(soap, "chan:ChannelInstance", &a->chan__ChannelInstance, "chan:ChannelInstanceType"))
				{	soap_flag_chan__ChannelInstance--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag?tag:"SOAP-ENV:Header", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Security(struct soap *soap, struct _wsse__Security *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsu__Timestamp = NULL;
	a->UsernameToken = NULL;
	a->BinarySecurityToken = NULL;
	a->xenc__EncryptedKey = NULL;
	a->xenc__ReferenceList = NULL;
	a->wsc__SecurityContextToken = NULL;
	a->ds__Signature = NULL;
	soap_default_string(soap, &a->SOAP_ENV__actor);
	soap_default_string(soap, &a->SOAP_ENV__role);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Security(struct soap *soap, const struct _wsse__Security *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsu__Timestamp(soap, &a->wsu__Timestamp);
	soap_serialize_PointerTo_wsse__UsernameToken(soap, &a->UsernameToken);
	soap_serialize_PointerTo_wsse__BinarySecurityToken(soap, &a->BinarySecurityToken);
	soap_serialize_PointerToxenc__EncryptedKeyType(soap, &a->xenc__EncryptedKey);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->xenc__ReferenceList);
	soap_serialize_PointerTowsc__SecurityContextTokenType(soap, &a->wsc__SecurityContextToken);
	soap_serialize_PointerTods__SignatureType(soap, &a->ds__Signature);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Security(struct soap *soap, const char *tag, int id, const struct _wsse__Security *a, const char *type)
{
	if (a->SOAP_ENV__actor)
		soap_set_attr(soap, "SOAP-ENV:actor", a->SOAP_ENV__actor, 1);
	if (a->SOAP_ENV__role)
		soap_set_attr(soap, "SOAP-ENV:role", a->SOAP_ENV__role, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Security), type))
		return soap->error;
	if (soap_out_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", -1, &a->wsu__Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", -1, &a->UsernameToken, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", -1, &a->BinarySecurityToken, ""))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", -1, &a->xenc__EncryptedKey, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->xenc__ReferenceList, ""))
		return soap->error;
	if (soap_out_PointerTowsc__SecurityContextTokenType(soap, "wsc:SecurityContextToken", -1, &a->wsc__SecurityContextToken, ""))
		return soap->error;
	if (soap_out_PointerTods__SignatureType(soap, "ds:Signature", -1, &a->ds__Signature, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_in__wsse__Security(struct soap *soap, const char *tag, struct _wsse__Security *a, const char *type)
{
	size_t soap_flag_wsu__Timestamp = 1;
	size_t soap_flag_UsernameToken = 1;
	size_t soap_flag_BinarySecurityToken = 1;
	size_t soap_flag_xenc__EncryptedKey = 1;
	size_t soap_flag_xenc__ReferenceList = 1;
	size_t soap_flag_wsc__SecurityContextToken = 1;
	size_t soap_flag_ds__Signature = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Security *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Security, sizeof(struct _wsse__Security), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Security(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:actor", 0), &a->SOAP_ENV__actor, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SOAP-ENV:role", 0), &a->SOAP_ENV__role, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsu__Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsu__Timestamp(soap, "wsu:Timestamp", &a->wsu__Timestamp, ""))
				{	soap_flag_wsu__Timestamp--;
					continue;
				}
			if (soap_flag_UsernameToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__UsernameToken(soap, "wsse:UsernameToken", &a->UsernameToken, ""))
				{	soap_flag_UsernameToken--;
					continue;
				}
			if (soap_flag_BinarySecurityToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__BinarySecurityToken(soap, "wsse:BinarySecurityToken", &a->BinarySecurityToken, ""))
				{	soap_flag_BinarySecurityToken--;
					continue;
				}
			if (soap_flag_xenc__EncryptedKey && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptedKeyType(soap, "xenc:EncryptedKey", &a->xenc__EncryptedKey, "xenc:EncryptedKeyType"))
				{	soap_flag_xenc__EncryptedKey--;
					continue;
				}
			if (soap_flag_xenc__ReferenceList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->xenc__ReferenceList, ""))
				{	soap_flag_xenc__ReferenceList--;
					continue;
				}
			if (soap_flag_wsc__SecurityContextToken && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsc__SecurityContextTokenType(soap, "wsc:SecurityContextToken", &a->wsc__SecurityContextToken, "wsc:SecurityContextTokenType"))
				{	soap_flag_wsc__SecurityContextToken--;
					continue;
				}
			if (soap_flag_ds__Signature && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureType(soap, "ds:Signature", &a->ds__Signature, "ds:SignatureType"))
				{	soap_flag_ds__Signature--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Security *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Security, 0, sizeof(struct _wsse__Security), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Security(struct soap *soap, const struct _wsse__Security *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Security);
	if (soap_out__wsse__Security(soap, tag?tag:"wsse:Security", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Security * SOAP_FMAC4 soap_get__wsse__Security(struct soap *soap, struct _wsse__Security *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Security(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__union_DerivedKeyTokenType = 0;
	a->Length = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const struct __wsc__DerivedKeyTokenType_sequence *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__wsc__union_DerivedKeyTokenType(soap, a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType);
	soap_serialize_PointerTounsignedLONG64(soap, &a->Length);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, int id, const struct __wsc__DerivedKeyTokenType_sequence *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out__wsc__union_DerivedKeyTokenType(soap, a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType))
		return soap->error;
	if (soap_out_PointerTounsignedLONG64(soap, "wsc:Length", -1, &a->Length, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC4 soap_in___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const char *tag, struct __wsc__DerivedKeyTokenType_sequence *a, const char *type)
{
	size_t soap_flag_union_DerivedKeyTokenType = 1;
	size_t soap_flag_Length = 1;
	short soap_flag;
	a = (struct __wsc__DerivedKeyTokenType_sequence *)soap_id_enter(soap, "", a, SOAP_TYPE___wsc__DerivedKeyTokenType_sequence, sizeof(struct __wsc__DerivedKeyTokenType_sequence), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___wsc__DerivedKeyTokenType_sequence(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_union_DerivedKeyTokenType && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__wsc__union_DerivedKeyTokenType(soap, &a->__union_DerivedKeyTokenType, &a->union_DerivedKeyTokenType))
				{	soap_flag_union_DerivedKeyTokenType = 0;
					continue;
				}
			if (soap_flag_Length && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTounsignedLONG64(soap, "wsc:Length", &a->Length, "xsd:unsignedLong"))
				{	soap_flag_Length--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_union_DerivedKeyTokenType))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___wsc__DerivedKeyTokenType_sequence(struct soap *soap, const struct __wsc__DerivedKeyTokenType_sequence *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___wsc__DerivedKeyTokenType_sequence(soap, tag?tag:"-wsc:DerivedKeyTokenType-sequence", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC4 soap_get___wsc__DerivedKeyTokenType_sequence(struct soap *soap, struct __wsc__DerivedKeyTokenType_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___wsc__DerivedKeyTokenType_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__PropertiesType(struct soap *soap, const struct wsc__PropertiesType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__PropertiesType(struct soap *soap, const char *tag, int id, const struct wsc__PropertiesType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__PropertiesType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__PropertiesType * SOAP_FMAC4 soap_in_wsc__PropertiesType(struct soap *soap, const char *tag, struct wsc__PropertiesType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsc__PropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__PropertiesType, sizeof(struct wsc__PropertiesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__PropertiesType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__PropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__PropertiesType, 0, sizeof(struct wsc__PropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__PropertiesType(struct soap *soap, const struct wsc__PropertiesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsc__PropertiesType);
	if (soap_out_wsc__PropertiesType(soap, tag?tag:"wsc:PropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__PropertiesType * SOAP_FMAC4 soap_get_wsc__PropertiesType(struct soap *soap, struct wsc__PropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__PropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__DerivedKeyTokenType(struct soap *soap, struct wsc__DerivedKeyTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->wsse__SecurityTokenReference = NULL;
	a->Properties = NULL;
	a->__size_DerivedKeyTokenType_sequence = 0;
	a->__DerivedKeyTokenType_sequence = NULL;
	soap_default_string(soap, &a->Label);
	soap_default_string(soap, &a->Nonce);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__DerivedKeyTokenType(struct soap *soap, const struct wsc__DerivedKeyTokenType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
	soap_serialize_PointerTowsc__PropertiesType(soap, &a->Properties);
	if (a->__DerivedKeyTokenType_sequence)
	{	int i;
		for (i = 0; i < a->__size_DerivedKeyTokenType_sequence; i++)
		{
			soap_serialize___wsc__DerivedKeyTokenType_sequence(soap, a->__DerivedKeyTokenType_sequence + i);
		}
	}
	soap_serialize_string(soap, &a->Label);
	soap_serialize_string(soap, &a->Nonce);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__DerivedKeyTokenType(struct soap *soap, const char *tag, int id, const struct wsc__DerivedKeyTokenType *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__DerivedKeyTokenType), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	if (soap_out_PointerTowsc__PropertiesType(soap, "wsc:Properties", -1, &a->Properties, ""))
		return soap->error;
	if (a->__DerivedKeyTokenType_sequence)
	{	int i;
		for (i = 0; i < a->__size_DerivedKeyTokenType_sequence; i++)
			if (soap_out___wsc__DerivedKeyTokenType_sequence(soap, "-DerivedKeyTokenType-sequence", -1, a->__DerivedKeyTokenType_sequence + i, ""))
				return soap->error;
	}
	if (soap_out_string(soap, "wsc:Label", -1, &a->Label, ""))
		return soap->error;
	if (soap_out_string(soap, "wsc:Nonce", -1, &a->Nonce, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__DerivedKeyTokenType * SOAP_FMAC4 soap_in_wsc__DerivedKeyTokenType(struct soap *soap, const char *tag, struct wsc__DerivedKeyTokenType *a, const char *type)
{
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	size_t soap_flag_Properties = 1;
	struct soap_blist *soap_blist___DerivedKeyTokenType_sequence = NULL;
	size_t soap_flag_Label = 1;
	size_t soap_flag_Nonce = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsc__DerivedKeyTokenType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__DerivedKeyTokenType, sizeof(struct wsc__DerivedKeyTokenType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__DerivedKeyTokenType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 0), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsc__PropertiesType(soap, "wsc:Properties", &a->Properties, "wsc:PropertiesType"))
				{	soap_flag_Properties--;
					continue;
				}
			if (soap_flag_Label && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsc:Label", &a->Label, "xsd:string"))
				{	soap_flag_Label--;
					continue;
				}
			if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsc:Nonce", &a->Nonce, "xsd:string"))
				{	soap_flag_Nonce--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__DerivedKeyTokenType_sequence == NULL)
				{	if (soap_blist___DerivedKeyTokenType_sequence == NULL)
						soap_blist___DerivedKeyTokenType_sequence = soap_new_block(soap);
					a->__DerivedKeyTokenType_sequence = (struct __wsc__DerivedKeyTokenType_sequence *)soap_push_block(soap, soap_blist___DerivedKeyTokenType_sequence, sizeof(struct __wsc__DerivedKeyTokenType_sequence));
					if (a->__DerivedKeyTokenType_sequence == NULL)
						return NULL;
					soap_default___wsc__DerivedKeyTokenType_sequence(soap, a->__DerivedKeyTokenType_sequence);
				}
				if (soap_in___wsc__DerivedKeyTokenType_sequence(soap, "-DerivedKeyTokenType-sequence", a->__DerivedKeyTokenType_sequence, "-wsc:DerivedKeyTokenType-sequence"))
				{	a->__size_DerivedKeyTokenType_sequence++;
					a->__DerivedKeyTokenType_sequence = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__DerivedKeyTokenType_sequence)
			soap_pop_block(soap, soap_blist___DerivedKeyTokenType_sequence);
		if (a->__size_DerivedKeyTokenType_sequence)
			a->__DerivedKeyTokenType_sequence = (struct __wsc__DerivedKeyTokenType_sequence *)soap_save_block(soap, soap_blist___DerivedKeyTokenType_sequence, NULL, 1);
		else
		{	a->__DerivedKeyTokenType_sequence = NULL;
			if (soap_blist___DerivedKeyTokenType_sequence)
				soap_end_block(soap, soap_blist___DerivedKeyTokenType_sequence);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__DerivedKeyTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__DerivedKeyTokenType, 0, sizeof(struct wsc__DerivedKeyTokenType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__DerivedKeyTokenType(struct soap *soap, const struct wsc__DerivedKeyTokenType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsc__DerivedKeyTokenType);
	if (soap_out_wsc__DerivedKeyTokenType(soap, tag?tag:"wsc:DerivedKeyTokenType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__DerivedKeyTokenType * SOAP_FMAC4 soap_get_wsc__DerivedKeyTokenType(struct soap *soap, struct wsc__DerivedKeyTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__DerivedKeyTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Identifier);
	soap_default_string(soap, &a->Instance);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsc__SecurityContextTokenType(struct soap *soap, const struct wsc__SecurityContextTokenType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Identifier);
	soap_serialize_string(soap, &a->Instance);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsc__SecurityContextTokenType(struct soap *soap, const char *tag, int id, const struct wsc__SecurityContextTokenType *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsc__SecurityContextTokenType), type))
		return soap->error;
	if (soap_out_string(soap, "wsc:Identifier", -1, &a->Identifier, ""))
		return soap->error;
	if (soap_out_string(soap, "wsc:Instance", -1, &a->Instance, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType * SOAP_FMAC4 soap_in_wsc__SecurityContextTokenType(struct soap *soap, const char *tag, struct wsc__SecurityContextTokenType *a, const char *type)
{
	size_t soap_flag_Identifier = 1;
	size_t soap_flag_Instance = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsc__SecurityContextTokenType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsc__SecurityContextTokenType, sizeof(struct wsc__SecurityContextTokenType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsc__SecurityContextTokenType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Identifier && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsc:Identifier", &a->Identifier, "xsd:string"))
				{	soap_flag_Identifier--;
					continue;
				}
			if (soap_flag_Instance && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsc:Instance", &a->Instance, "xsd:string"))
				{	soap_flag_Instance--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsc__SecurityContextTokenType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsc__SecurityContextTokenType, 0, sizeof(struct wsc__SecurityContextTokenType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsc__SecurityContextTokenType(struct soap *soap, const struct wsc__SecurityContextTokenType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsc__SecurityContextTokenType);
	if (soap_out_wsc__SecurityContextTokenType(soap, tag?tag:"wsc:SecurityContextTokenType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsc__SecurityContextTokenType * SOAP_FMAC4 soap_get_wsc__SecurityContextTokenType(struct soap *soap, struct wsc__SecurityContextTokenType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsc__SecurityContextTokenType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DataReference = NULL;
	a->KeyReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->DataReference);
	soap_serialize_PointerToxenc__ReferenceType(soap, &a->KeyReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___xenc__union_ReferenceList(struct soap *soap, const char *tag, int id, const struct __xenc__union_ReferenceList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:DataReference", -1, &a->DataReference, ""))
		return soap->error;
	if (soap_out_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", -1, &a->KeyReference, ""))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_in___xenc__union_ReferenceList(struct soap *soap, const char *tag, struct __xenc__union_ReferenceList *a, const char *type)
{
	size_t soap_flag_DataReference = 1;
	size_t soap_flag_KeyReference = 1;
	short soap_flag;
	a = (struct __xenc__union_ReferenceList *)soap_id_enter(soap, "", a, SOAP_TYPE___xenc__union_ReferenceList, sizeof(struct __xenc__union_ReferenceList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___xenc__union_ReferenceList(soap, a);
		for (soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DataReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:DataReference", &a->DataReference, "xenc:ReferenceType"))
				{	soap_flag_DataReference--;
					continue;
				}
			if (soap_flag_KeyReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__ReferenceType(soap, "xenc:KeyReference", &a->KeyReference, "xenc:ReferenceType"))
				{	soap_flag_KeyReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_flag)
				{	soap->error = SOAP_OK;
					break;
				}
			if (soap_flag && soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___xenc__union_ReferenceList(struct soap *soap, const struct __xenc__union_ReferenceList *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___xenc__union_ReferenceList(soap, tag?tag:"-xenc:union-ReferenceList", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __xenc__union_ReferenceList * SOAP_FMAC4 soap_get___xenc__union_ReferenceList(struct soap *soap, struct __xenc__union_ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in___xenc__union_ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_ReferenceList = 0;
	a->__union_ReferenceList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__union_ReferenceList)
	{	int i;
		for (i = 0; i < a->__size_ReferenceList; i++)
		{
			soap_serialize___xenc__union_ReferenceList(soap, a->__union_ReferenceList + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__xenc__ReferenceList(struct soap *soap, const char *tag, int id, const struct _xenc__ReferenceList *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__xenc__ReferenceList), type))
		return soap->error;
	if (a->__union_ReferenceList)
	{	int i;
		for (i = 0; i < a->__size_ReferenceList; i++)
			if (soap_out___xenc__union_ReferenceList(soap, "-union-ReferenceList", -1, a->__union_ReferenceList + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_in__xenc__ReferenceList(struct soap *soap, const char *tag, struct _xenc__ReferenceList *a, const char *type)
{
	struct soap_blist *soap_blist___union_ReferenceList = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _xenc__ReferenceList *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__xenc__ReferenceList, sizeof(struct _xenc__ReferenceList), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__xenc__ReferenceList(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__union_ReferenceList == NULL)
				{	if (soap_blist___union_ReferenceList == NULL)
						soap_blist___union_ReferenceList = soap_new_block(soap);
					a->__union_ReferenceList = (struct __xenc__union_ReferenceList *)soap_push_block(soap, soap_blist___union_ReferenceList, sizeof(struct __xenc__union_ReferenceList));
					if (a->__union_ReferenceList == NULL)
						return NULL;
					soap_default___xenc__union_ReferenceList(soap, a->__union_ReferenceList);
				}
				if (soap_in___xenc__union_ReferenceList(soap, "-union-ReferenceList", a->__union_ReferenceList, "-xenc:union-ReferenceList"))
				{	a->__size_ReferenceList++;
					a->__union_ReferenceList = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__union_ReferenceList)
			soap_pop_block(soap, soap_blist___union_ReferenceList);
		if (a->__size_ReferenceList)
			a->__union_ReferenceList = (struct __xenc__union_ReferenceList *)soap_save_block(soap, soap_blist___union_ReferenceList, NULL, 1);
		else
		{	a->__union_ReferenceList = NULL;
			if (soap_blist___union_ReferenceList)
				soap_end_block(soap, soap_blist___union_ReferenceList);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _xenc__ReferenceList *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__xenc__ReferenceList, 0, sizeof(struct _xenc__ReferenceList), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__size_ReferenceList < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__xenc__ReferenceList(struct soap *soap, const struct _xenc__ReferenceList *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__xenc__ReferenceList);
	if (soap_out__xenc__ReferenceList(soap, tag?tag:"xenc:ReferenceList", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _xenc__ReferenceList * SOAP_FMAC4 soap_get__xenc__ReferenceList(struct soap *soap, struct _xenc__ReferenceList *p, const char *tag, const char *type)
{
	if ((p = soap_in__xenc__ReferenceList(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Target);
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertyType *a, const char *type)
{
	if (a->Target)
		soap_set_attr(soap, "Target", a->Target, 1);
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertyType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertyType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertyType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionPropertyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertyType, sizeof(struct xenc__EncryptionPropertyType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Target", 0), &a->Target, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertyType, 0, sizeof(struct xenc__EncryptionPropertyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertyType(struct soap *soap, const struct xenc__EncryptionPropertyType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptionPropertyType);
	if (soap_out_xenc__EncryptionPropertyType(soap, tag?tag:"xenc:EncryptionPropertyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertyType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertyType(struct soap *soap, struct xenc__EncryptionPropertyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeEncryptionProperty = 0;
	a->EncryptionProperty = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->EncryptionProperty)
	{	int i;
		for (i = 0; i < a->__sizeEncryptionProperty; i++)
		{
			soap_embedded(soap, a->EncryptionProperty + i, SOAP_TYPE_xenc__EncryptionPropertyType);
			soap_serialize_xenc__EncryptionPropertyType(soap, a->EncryptionProperty + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionPropertiesType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionPropertiesType), type))
		return soap->error;
	if (a->EncryptionProperty)
	{	int i;
		for (i = 0; i < a->__sizeEncryptionProperty; i++)
			if (soap_out_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", -1, a->EncryptionProperty + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_in_xenc__EncryptionPropertiesType(struct soap *soap, const char *tag, struct xenc__EncryptionPropertiesType *a, const char *type)
{
	struct soap_blist *soap_blist_EncryptionProperty = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionPropertiesType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionPropertiesType, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionPropertiesType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "xenc:EncryptionProperty", 1, NULL))
			{	if (a->EncryptionProperty == NULL)
				{	if (soap_blist_EncryptionProperty == NULL)
						soap_blist_EncryptionProperty = soap_new_block(soap);
					a->EncryptionProperty = (struct xenc__EncryptionPropertyType *)soap_push_block(soap, soap_blist_EncryptionProperty, sizeof(struct xenc__EncryptionPropertyType));
					if (a->EncryptionProperty == NULL)
						return NULL;
					soap_default_xenc__EncryptionPropertyType(soap, a->EncryptionProperty);
				}
				soap_revert(soap);
				if (soap_in_xenc__EncryptionPropertyType(soap, "xenc:EncryptionProperty", a->EncryptionProperty, "xenc:EncryptionPropertyType"))
				{	a->__sizeEncryptionProperty++;
					a->EncryptionProperty = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->EncryptionProperty)
			soap_pop_block(soap, soap_blist_EncryptionProperty);
		if (a->__sizeEncryptionProperty)
			a->EncryptionProperty = (struct xenc__EncryptionPropertyType *)soap_save_block(soap, soap_blist_EncryptionProperty, NULL, 1);
		else
		{	a->EncryptionProperty = NULL;
			if (soap_blist_EncryptionProperty)
				soap_end_block(soap, soap_blist_EncryptionProperty);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionPropertiesType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionPropertiesType, 0, sizeof(struct xenc__EncryptionPropertiesType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeEncryptionProperty < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionPropertiesType(struct soap *soap, const struct xenc__EncryptionPropertiesType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptionPropertiesType);
	if (soap_out_xenc__EncryptionPropertiesType(soap, tag?tag:"xenc:EncryptionPropertiesType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionPropertiesType * SOAP_FMAC4 soap_get_xenc__EncryptionPropertiesType(struct soap *soap, struct xenc__EncryptionPropertiesType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionPropertiesType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__ReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__ReferenceType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__ReferenceType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_in_xenc__ReferenceType(struct soap *soap, const char *tag, struct xenc__ReferenceType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__ReferenceType, sizeof(struct xenc__ReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1), &a->URI, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__ReferenceType, 0, sizeof(struct xenc__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__ReferenceType(struct soap *soap, const struct xenc__ReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__ReferenceType);
	if (soap_out_xenc__ReferenceType(soap, tag?tag:"xenc:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__ReferenceType * SOAP_FMAC4 soap_get_xenc__ReferenceType(struct soap *soap, struct xenc__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KA_Nonce);
	a->OriginatorKeyInfo = NULL;
	a->RecipientKeyInfo = NULL;
	soap_default_string(soap, &a->Algorithm);
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->KA_Nonce);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->OriginatorKeyInfo);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->RecipientKeyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__AgreementMethodType(struct soap *soap, const char *tag, int id, const struct xenc__AgreementMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__AgreementMethodType), type))
		return soap->error;
	if (soap_out_string(soap, "xenc:KA-Nonce", -1, &a->KA_Nonce, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", -1, &a->OriginatorKeyInfo, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", -1, &a->RecipientKeyInfo, ""))
		return soap->error;
	soap_outliteral(soap, "-mixed", &a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_in_xenc__AgreementMethodType(struct soap *soap, const char *tag, struct xenc__AgreementMethodType *a, const char *type)
{
	size_t soap_flag_KA_Nonce = 1;
	size_t soap_flag_OriginatorKeyInfo = 1;
	size_t soap_flag_RecipientKeyInfo = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__AgreementMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__AgreementMethodType, sizeof(struct xenc__AgreementMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__AgreementMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KA_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:KA-Nonce", &a->KA_Nonce, "xsd:string"))
				{	soap_flag_KA_Nonce--;
					continue;
				}
			if (soap_flag_OriginatorKeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "xenc:OriginatorKeyInfo", &a->OriginatorKeyInfo, "ds:KeyInfoType"))
				{	soap_flag_OriginatorKeyInfo--;
					continue;
				}
			if (soap_flag_RecipientKeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "xenc:RecipientKeyInfo", &a->RecipientKeyInfo, "ds:KeyInfoType"))
				{	soap_flag_RecipientKeyInfo--;
					continue;
				}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__AgreementMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__AgreementMethodType, 0, sizeof(struct xenc__AgreementMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__AgreementMethodType(struct soap *soap, const struct xenc__AgreementMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__AgreementMethodType);
	if (soap_out_xenc__AgreementMethodType(soap, tag?tag:"xenc:AgreementMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__AgreementMethodType * SOAP_FMAC4 soap_get_xenc__AgreementMethodType(struct soap *soap, struct xenc__AgreementMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__AgreementMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
	a->ReferenceList = NULL;
	soap_default_string(soap, &a->CarriedKeyName);
	soap_default_string(soap, &a->Recipient);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
	soap_serialize_PointerTo_xenc__ReferenceList(soap, &a->ReferenceList);
	soap_serialize_string(soap, &a->CarriedKeyName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedKeyType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedKeyType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", a->MimeType, 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", a->Encoding, 1);
	if (a->Recipient)
		soap_set_attr(soap, "Recipient", a->Recipient, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedKeyType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (a->CipherData)
	{	if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "xenc:CipherData"))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	if (soap_out_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", -1, &a->ReferenceList, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:CarriedKeyName", -1, &a->CarriedKeyName, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_in_xenc__EncryptedKeyType(struct soap *soap, const char *tag, struct xenc__EncryptedKeyType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	size_t soap_flag_ReferenceList = 1;
	size_t soap_flag_CarriedKeyName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptedKeyType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedKeyType, sizeof(struct xenc__EncryptedKeyType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedKeyType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Recipient", 0), &a->Recipient, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			if (soap_flag_ReferenceList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_xenc__ReferenceList(soap, "xenc:ReferenceList", &a->ReferenceList, ""))
				{	soap_flag_ReferenceList--;
					continue;
				}
			if (soap_flag_CarriedKeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:CarriedKeyName", &a->CarriedKeyName, "xsd:string"))
				{	soap_flag_CarriedKeyName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedKeyType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedKeyType, 0, sizeof(struct xenc__EncryptedKeyType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedKeyType(struct soap *soap, const struct xenc__EncryptedKeyType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptedKeyType);
	if (soap_out_xenc__EncryptedKeyType(soap, tag?tag:"xenc:EncryptedKeyType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedKeyType * SOAP_FMAC4 soap_get_xenc__EncryptedKeyType(struct soap *soap, struct xenc__EncryptedKeyType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedKeyType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedDataType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedDataType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", a->MimeType, 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", a->Encoding, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedDataType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (a->CipherData)
	{	if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "xenc:CipherData"))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_in_xenc__EncryptedDataType(struct soap *soap, const char *tag, struct xenc__EncryptedDataType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptedDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedDataType, sizeof(struct xenc__EncryptedDataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedDataType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedDataType, 0, sizeof(struct xenc__EncryptedDataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedDataType(struct soap *soap, const struct xenc__EncryptedDataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptedDataType);
	if (soap_out_xenc__EncryptedDataType(soap, tag?tag:"xenc:EncryptedDataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedDataType * SOAP_FMAC4 soap_get_xenc__EncryptedDataType(struct soap *soap, struct xenc__EncryptedDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__ds__Transform(soap, &a->ds__Transform);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__ds__Transform(soap, &a->ds__Transform);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__TransformsType(struct soap *soap, const char *tag, int id, const struct xenc__TransformsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__TransformsType), type))
		return soap->error;
	if (soap_out__ds__Transform(soap, "ds:Transform", -1, &a->ds__Transform, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_in_xenc__TransformsType(struct soap *soap, const char *tag, struct xenc__TransformsType *a, const char *type)
{
	size_t soap_flag_ds__Transform = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__TransformsType, sizeof(struct xenc__TransformsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__TransformsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ds__Transform && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in__ds__Transform(soap, "ds:Transform", &a->ds__Transform, ""))
				{	soap_flag_ds__Transform--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__TransformsType, 0, sizeof(struct xenc__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ds__Transform > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__TransformsType(struct soap *soap, const struct xenc__TransformsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__TransformsType);
	if (soap_out_xenc__TransformsType(soap, tag?tag:"xenc:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__TransformsType * SOAP_FMAC4 soap_get_xenc__TransformsType(struct soap *soap, struct xenc__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__TransformsType(soap, &a->Transforms);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherReferenceType(struct soap *soap, const char *tag, int id, const struct xenc__CipherReferenceType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherReferenceType), type))
		return soap->error;
	if (soap_out_PointerToxenc__TransformsType(soap, "xenc:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_in_xenc__CipherReferenceType(struct soap *soap, const char *tag, struct xenc__CipherReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__CipherReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherReferenceType, sizeof(struct xenc__CipherReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 1), &a->URI, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__TransformsType(soap, "xenc:Transforms", &a->Transforms, "xenc:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherReferenceType, 0, sizeof(struct xenc__CipherReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherReferenceType(struct soap *soap, const struct xenc__CipherReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__CipherReferenceType);
	if (soap_out_xenc__CipherReferenceType(soap, tag?tag:"xenc:CipherReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherReferenceType * SOAP_FMAC4 soap_get_xenc__CipherReferenceType(struct soap *soap, struct xenc__CipherReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->CipherValue);
	a->CipherReference = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->CipherValue);
	soap_serialize_PointerToxenc__CipherReferenceType(soap, &a->CipherReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__CipherDataType(struct soap *soap, const char *tag, int id, const struct xenc__CipherDataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__CipherDataType), type))
		return soap->error;
	if (soap_out_string(soap, "xenc:CipherValue", -1, &a->CipherValue, ""))
		return soap->error;
	if (soap_out_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", -1, &a->CipherReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_in_xenc__CipherDataType(struct soap *soap, const char *tag, struct xenc__CipherDataType *a, const char *type)
{
	size_t soap_flag_CipherValue = 1;
	size_t soap_flag_CipherReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__CipherDataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__CipherDataType, sizeof(struct xenc__CipherDataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__CipherDataType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CipherValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:CipherValue", &a->CipherValue, "xsd:string"))
				{	soap_flag_CipherValue--;
					continue;
				}
			if (soap_flag_CipherReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherReferenceType(soap, "xenc:CipherReference", &a->CipherReference, "xenc:CipherReferenceType"))
				{	soap_flag_CipherReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__CipherDataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__CipherDataType, 0, sizeof(struct xenc__CipherDataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__CipherDataType(struct soap *soap, const struct xenc__CipherDataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__CipherDataType);
	if (soap_out_xenc__CipherDataType(soap, tag?tag:"xenc:CipherDataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__CipherDataType * SOAP_FMAC4 soap_get_xenc__CipherDataType(struct soap *soap, struct xenc__CipherDataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__CipherDataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->KeySize = NULL;
	soap_default_string(soap, &a->OAEPparams);
	soap_default_string(soap, &a->Algorithm);
	a->ds__DigestMethod = NULL;
	a->__mixed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->KeySize);
	soap_serialize_string(soap, &a->OAEPparams);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->ds__DigestMethod);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptionMethodType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptionMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptionMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "xenc:KeySize", -1, &a->KeySize, ""))
		return soap->error;
	if (soap_out_string(soap, "xenc:OAEPparams", -1, &a->OAEPparams, ""))
		return soap->error;
	if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->ds__DigestMethod, ""))
		return soap->error;
	soap_outliteral(soap, "-mixed", &a->__mixed, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_in_xenc__EncryptionMethodType(struct soap *soap, const char *tag, struct xenc__EncryptionMethodType *a, const char *type)
{
	size_t soap_flag_KeySize = 1;
	size_t soap_flag_OAEPparams = 1;
	size_t soap_flag_ds__DigestMethod = 1;
	size_t soap_flag___mixed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptionMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptionMethodType, sizeof(struct xenc__EncryptionMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptionMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeySize && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "xenc:KeySize", &a->KeySize, "xsd:int"))
				{	soap_flag_KeySize--;
					continue;
				}
			if (soap_flag_OAEPparams && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "xenc:OAEPparams", &a->OAEPparams, "xsd:string"))
				{	soap_flag_OAEPparams--;
					continue;
				}
			if (soap_flag_ds__DigestMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->ds__DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_ds__DigestMethod--;
					continue;
				}
			if (soap_flag___mixed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-mixed", &a->__mixed))
				{	soap_flag___mixed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptionMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptionMethodType, 0, sizeof(struct xenc__EncryptionMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptionMethodType(struct soap *soap, const struct xenc__EncryptionMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptionMethodType);
	if (soap_out_xenc__EncryptionMethodType(soap, tag?tag:"xenc:EncryptionMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptionMethodType * SOAP_FMAC4 soap_get_xenc__EncryptionMethodType(struct soap *soap, struct xenc__EncryptionMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptionMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->EncryptionMethod = NULL;
	a->ds__KeyInfo = NULL;
	a->CipherData = NULL;
	a->EncryptionProperties = NULL;
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->Type);
	soap_default_string(soap, &a->MimeType);
	soap_default_string(soap, &a->Encoding);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToxenc__EncryptionMethodType(soap, &a->EncryptionMethod);
	soap_serialize_PointerTo_ds__KeyInfo(soap, &a->ds__KeyInfo);
	soap_serialize_PointerToxenc__CipherDataType(soap, &a->CipherData);
	soap_serialize_PointerToxenc__EncryptionPropertiesType(soap, &a->EncryptionProperties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_xenc__EncryptedType(struct soap *soap, const char *tag, int id, const struct xenc__EncryptedType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	if (a->MimeType)
		soap_set_attr(soap, "MimeType", a->MimeType, 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", a->Encoding, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xenc__EncryptedType), type))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", -1, &a->EncryptionMethod, ""))
		return soap->error;
	if (soap_out_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", -1, &a->ds__KeyInfo, ""))
		return soap->error;
	if (a->CipherData)
	{	if (soap_out_PointerToxenc__CipherDataType(soap, "xenc:CipherData", -1, &a->CipherData, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "xenc:CipherData"))
		return soap->error;
	if (soap_out_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", -1, &a->EncryptionProperties, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_in_xenc__EncryptedType(struct soap *soap, const char *tag, struct xenc__EncryptedType *a, const char *type)
{
	size_t soap_flag_EncryptionMethod = 1;
	size_t soap_flag_ds__KeyInfo = 1;
	size_t soap_flag_CipherData = 1;
	size_t soap_flag_EncryptionProperties = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct xenc__EncryptedType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xenc__EncryptedType, sizeof(struct xenc__EncryptedType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_xenc__EncryptedType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "MimeType", 0), &a->MimeType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_EncryptionMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionMethodType(soap, "xenc:EncryptionMethod", &a->EncryptionMethod, "xenc:EncryptionMethodType"))
				{	soap_flag_EncryptionMethod--;
					continue;
				}
			if (soap_flag_ds__KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_ds__KeyInfo(soap, "ds:KeyInfo", &a->ds__KeyInfo, ""))
				{	soap_flag_ds__KeyInfo--;
					continue;
				}
			if (soap_flag_CipherData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__CipherDataType(soap, "xenc:CipherData", &a->CipherData, "xenc:CipherDataType"))
				{	soap_flag_CipherData--;
					continue;
				}
			if (soap_flag_EncryptionProperties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxenc__EncryptionPropertiesType(soap, "xenc:EncryptionProperties", &a->EncryptionProperties, "xenc:EncryptionPropertiesType"))
				{	soap_flag_EncryptionProperties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct xenc__EncryptedType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_xenc__EncryptedType, 0, sizeof(struct xenc__EncryptedType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CipherData > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xenc__EncryptedType(struct soap *soap, const struct xenc__EncryptedType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xenc__EncryptedType);
	if (soap_out_xenc__EncryptedType(soap, tag?tag:"xenc:EncryptedType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct xenc__EncryptedType * SOAP_FMAC4 soap_get_xenc__EncryptedType(struct soap *soap, struct xenc__EncryptedType *p, const char *tag, const char *type)
{
	if ((p = soap_in_xenc__EncryptedType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Modulus);
	soap_default_string(soap, &a->Exponent);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Modulus);
	soap_serialize_string(soap, &a->Exponent);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__RSAKeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RSAKeyValueType), type))
		return soap->error;
	if (a->Modulus)
	{	if (soap_out_string(soap, "ds:Modulus", -1, &a->Modulus, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Modulus"))
		return soap->error;
	if (a->Exponent)
	{	if (soap_out_string(soap, "ds:Exponent", -1, &a->Exponent, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Exponent"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_in_ds__RSAKeyValueType(struct soap *soap, const char *tag, struct ds__RSAKeyValueType *a, const char *type)
{
	size_t soap_flag_Modulus = 1;
	size_t soap_flag_Exponent = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RSAKeyValueType, sizeof(struct ds__RSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Modulus && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Modulus", &a->Modulus, "xsd:string"))
				{	soap_flag_Modulus--;
					continue;
				}
			if (soap_flag_Exponent && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Exponent", &a->Exponent, "xsd:string"))
				{	soap_flag_Exponent--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RSAKeyValueType, 0, sizeof(struct ds__RSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Modulus > 0 || soap_flag_Exponent > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RSAKeyValueType(struct soap *soap, const struct ds__RSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RSAKeyValueType);
	if (soap_out_ds__RSAKeyValueType(soap, tag?tag:"ds:RSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RSAKeyValueType * SOAP_FMAC4 soap_get_ds__RSAKeyValueType(struct soap *soap, struct ds__RSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->G);
	soap_default_string(soap, &a->Y);
	soap_default_string(soap, &a->J);
	soap_default_string(soap, &a->P);
	soap_default_string(soap, &a->Q);
	soap_default_string(soap, &a->Seed);
	soap_default_string(soap, &a->PgenCounter);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->G);
	soap_serialize_string(soap, &a->Y);
	soap_serialize_string(soap, &a->J);
	soap_serialize_string(soap, &a->P);
	soap_serialize_string(soap, &a->Q);
	soap_serialize_string(soap, &a->Seed);
	soap_serialize_string(soap, &a->PgenCounter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DSAKeyValueType(struct soap *soap, const char *tag, int id, const struct ds__DSAKeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DSAKeyValueType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:G", -1, &a->G, ""))
		return soap->error;
	if (a->Y)
	{	if (soap_out_string(soap, "ds:Y", -1, &a->Y, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Y"))
		return soap->error;
	if (soap_out_string(soap, "ds:J", -1, &a->J, ""))
		return soap->error;
	if (a->P)
	{	if (soap_out_string(soap, "ds:P", -1, &a->P, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:P"))
		return soap->error;
	if (a->Q)
	{	if (soap_out_string(soap, "ds:Q", -1, &a->Q, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Q"))
		return soap->error;
	if (a->Seed)
	{	if (soap_out_string(soap, "ds:Seed", -1, &a->Seed, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:Seed"))
		return soap->error;
	if (a->PgenCounter)
	{	if (soap_out_string(soap, "ds:PgenCounter", -1, &a->PgenCounter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:PgenCounter"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_in_ds__DSAKeyValueType(struct soap *soap, const char *tag, struct ds__DSAKeyValueType *a, const char *type)
{
	size_t soap_flag_G = 1;
	size_t soap_flag_Y = 1;
	size_t soap_flag_J = 1;
	size_t soap_flag_P = 1;
	size_t soap_flag_Q = 1;
	size_t soap_flag_Seed = 1;
	size_t soap_flag_PgenCounter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DSAKeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DSAKeyValueType, sizeof(struct ds__DSAKeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DSAKeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_G && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:G", &a->G, "xsd:string"))
				{	soap_flag_G--;
					continue;
				}
			if (soap_flag_Y && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Y", &a->Y, "xsd:string"))
				{	soap_flag_Y--;
					continue;
				}
			if (soap_flag_J && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:J", &a->J, "xsd:string"))
				{	soap_flag_J--;
					continue;
				}
			if (soap_flag_P && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:P", &a->P, "xsd:string"))
				{	soap_flag_P--;
					continue;
				}
			if (soap_flag_Q && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Q", &a->Q, "xsd:string"))
				{	soap_flag_Q--;
					continue;
				}
			if (soap_flag_Seed && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:Seed", &a->Seed, "xsd:string"))
				{	soap_flag_Seed--;
					continue;
				}
			if (soap_flag_PgenCounter && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:PgenCounter", &a->PgenCounter, "xsd:string"))
				{	soap_flag_PgenCounter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DSAKeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DSAKeyValueType, 0, sizeof(struct ds__DSAKeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Y > 0 || soap_flag_P > 0 || soap_flag_Q > 0 || soap_flag_Seed > 0 || soap_flag_PgenCounter > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DSAKeyValueType(struct soap *soap, const struct ds__DSAKeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DSAKeyValueType);
	if (soap_out_ds__DSAKeyValueType(soap, tag?tag:"ds:DSAKeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DSAKeyValueType * SOAP_FMAC4 soap_get_ds__DSAKeyValueType(struct soap *soap, struct ds__DSAKeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DSAKeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->X509IssuerName);
	soap_default_string(soap, &a->X509SerialNumber);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->X509IssuerName);
	soap_serialize_string(soap, &a->X509SerialNumber);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509IssuerSerialType(struct soap *soap, const char *tag, int id, const struct ds__X509IssuerSerialType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509IssuerSerialType), type))
		return soap->error;
	if (a->X509IssuerName)
	{	if (soap_out_string(soap, "ds:X509IssuerName", -1, &a->X509IssuerName, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509IssuerName"))
		return soap->error;
	if (a->X509SerialNumber)
	{	if (soap_out_string(soap, "ds:X509SerialNumber", -1, &a->X509SerialNumber, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:X509SerialNumber"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_in_ds__X509IssuerSerialType(struct soap *soap, const char *tag, struct ds__X509IssuerSerialType *a, const char *type)
{
	size_t soap_flag_X509IssuerName = 1;
	size_t soap_flag_X509SerialNumber = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509IssuerSerialType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509IssuerSerialType, sizeof(struct ds__X509IssuerSerialType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509IssuerSerialType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509IssuerName", &a->X509IssuerName, "xsd:string"))
				{	soap_flag_X509IssuerName--;
					continue;
				}
			if (soap_flag_X509SerialNumber && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SerialNumber", &a->X509SerialNumber, "xsd:string"))
				{	soap_flag_X509SerialNumber--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509IssuerSerialType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509IssuerSerialType, 0, sizeof(struct ds__X509IssuerSerialType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_X509IssuerName > 0 || soap_flag_X509SerialNumber > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509IssuerSerialType(struct soap *soap, const struct ds__X509IssuerSerialType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509IssuerSerialType);
	if (soap_out_ds__X509IssuerSerialType(soap, tag?tag:"ds:X509IssuerSerialType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509IssuerSerialType * SOAP_FMAC4 soap_get_ds__X509IssuerSerialType(struct soap *soap, struct ds__X509IssuerSerialType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509IssuerSerialType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__RetrievalMethodType(struct soap *soap, const char *tag, int id, const struct ds__RetrievalMethodType *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__RetrievalMethodType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_in_ds__RetrievalMethodType(struct soap *soap, const char *tag, struct ds__RetrievalMethodType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__RetrievalMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__RetrievalMethodType, sizeof(struct ds__RetrievalMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__RetrievalMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__RetrievalMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__RetrievalMethodType, 0, sizeof(struct ds__RetrievalMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__RetrievalMethodType(struct soap *soap, const struct ds__RetrievalMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__RetrievalMethodType);
	if (soap_out_ds__RetrievalMethodType(soap, tag?tag:"ds:RetrievalMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__RetrievalMethodType * SOAP_FMAC4 soap_get_ds__RetrievalMethodType(struct soap *soap, struct ds__RetrievalMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__RetrievalMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->DSAKeyValue = NULL;
	a->RSAKeyValue = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__DSAKeyValueType(soap, &a->DSAKeyValue);
	soap_serialize_PointerTods__RSAKeyValueType(soap, &a->RSAKeyValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyValueType(struct soap *soap, const char *tag, int id, const struct ds__KeyValueType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyValueType), type))
		return soap->error;
	if (soap_out_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", -1, &a->DSAKeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", -1, &a->RSAKeyValue, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_in_ds__KeyValueType(struct soap *soap, const char *tag, struct ds__KeyValueType *a, const char *type)
{
	size_t soap_flag_DSAKeyValue = 1;
	size_t soap_flag_RSAKeyValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyValueType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyValueType, sizeof(struct ds__KeyValueType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyValueType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_DSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DSAKeyValueType(soap, "ds:DSAKeyValue", &a->DSAKeyValue, "ds:DSAKeyValueType"))
				{	soap_flag_DSAKeyValue--;
					continue;
				}
			if (soap_flag_RSAKeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RSAKeyValueType(soap, "ds:RSAKeyValue", &a->RSAKeyValue, "ds:RSAKeyValueType"))
				{	soap_flag_RSAKeyValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyValueType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyValueType, 0, sizeof(struct ds__KeyValueType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyValueType(struct soap *soap, const struct ds__KeyValueType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyValueType);
	if (soap_out_ds__KeyValueType(soap, tag?tag:"ds:KeyValueType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyValueType * SOAP_FMAC4 soap_get_ds__KeyValueType(struct soap *soap, struct ds__KeyValueType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyValueType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__DigestMethodType(struct soap *soap, const char *tag, int id, const struct ds__DigestMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__DigestMethodType), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_in_ds__DigestMethodType(struct soap *soap, const char *tag, struct ds__DigestMethodType *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__DigestMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__DigestMethodType, sizeof(struct ds__DigestMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__DigestMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__DigestMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__DigestMethodType, 0, sizeof(struct ds__DigestMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__DigestMethodType(struct soap *soap, const struct ds__DigestMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__DigestMethodType);
	if (soap_out_ds__DigestMethodType(soap, tag?tag:"ds:DigestMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__DigestMethodType * SOAP_FMAC4 soap_get_ds__DigestMethodType(struct soap *soap, struct ds__DigestMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__DigestMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformType(struct soap *soap, struct ds__TransformType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->c14n__InclusiveNamespaces = NULL;
	a->__any = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformType(struct soap *soap, const struct ds__TransformType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformType(struct soap *soap, const char *tag, int id, const struct ds__TransformType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_in_ds__TransformType(struct soap *soap, const char *tag, struct ds__TransformType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformType, sizeof(struct ds__TransformType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 0), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformType, 0, sizeof(struct ds__TransformType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformType(struct soap *soap, const struct ds__TransformType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformType);
	if (soap_out_ds__TransformType(soap, tag?tag:"ds:TransformType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformType * SOAP_FMAC4 soap_get_ds__TransformType(struct soap *soap, struct ds__TransformType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->PrefixList);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, int id, const struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (a->PrefixList)
		soap_set_attr(soap, "PrefixList", a->PrefixList, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__c14n__InclusiveNamespaces), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_in__c14n__InclusiveNamespaces(struct soap *soap, const char *tag, struct _c14n__InclusiveNamespaces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _c14n__InclusiveNamespaces *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__c14n__InclusiveNamespaces, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__c14n__InclusiveNamespaces(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "PrefixList", 0), &a->PrefixList, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _c14n__InclusiveNamespaces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__c14n__InclusiveNamespaces, 0, sizeof(struct _c14n__InclusiveNamespaces), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__c14n__InclusiveNamespaces(struct soap *soap, const struct _c14n__InclusiveNamespaces *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__c14n__InclusiveNamespaces);
	if (soap_out__c14n__InclusiveNamespaces(soap, tag?tag:"c14n:InclusiveNamespaces", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _c14n__InclusiveNamespaces * SOAP_FMAC4 soap_get__c14n__InclusiveNamespaces(struct soap *soap, struct _c14n__InclusiveNamespaces *p, const char *tag, const char *type)
{
	if ((p = soap_in__c14n__InclusiveNamespaces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__TransformsType(struct soap *soap, struct ds__TransformsType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTransform = 0;
	a->Transform = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Transform)
	{	int i;
		for (i = 0; i < a->__sizeTransform; i++)
		{
			soap_embedded(soap, a->Transform + i, SOAP_TYPE_ds__TransformType);
			soap_serialize_ds__TransformType(soap, a->Transform + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__TransformsType(struct soap *soap, const char *tag, int id, const struct ds__TransformsType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__TransformsType), type))
		return soap->error;
	if (a->Transform)
	{	int i;
		for (i = 0; i < a->__sizeTransform; i++)
			if (soap_out_ds__TransformType(soap, "ds:Transform", -1, a->Transform + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_in_ds__TransformsType(struct soap *soap, const char *tag, struct ds__TransformsType *a, const char *type)
{
	struct soap_blist *soap_blist_Transform = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__TransformsType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__TransformsType, sizeof(struct ds__TransformsType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__TransformsType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Transform", 1, NULL))
			{	if (a->Transform == NULL)
				{	if (soap_blist_Transform == NULL)
						soap_blist_Transform = soap_new_block(soap);
					a->Transform = (struct ds__TransformType *)soap_push_block(soap, soap_blist_Transform, sizeof(struct ds__TransformType));
					if (a->Transform == NULL)
						return NULL;
					soap_default_ds__TransformType(soap, a->Transform);
				}
				soap_revert(soap);
				if (soap_in_ds__TransformType(soap, "ds:Transform", a->Transform, "ds:TransformType"))
				{	a->__sizeTransform++;
					a->Transform = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Transform)
			soap_pop_block(soap, soap_blist_Transform);
		if (a->__sizeTransform)
			a->Transform = (struct ds__TransformType *)soap_save_block(soap, soap_blist_Transform, NULL, 1);
		else
		{	a->Transform = NULL;
			if (soap_blist_Transform)
				soap_end_block(soap, soap_blist_Transform);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__TransformsType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__TransformsType, 0, sizeof(struct ds__TransformsType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__TransformsType(struct soap *soap, const struct ds__TransformsType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__TransformsType);
	if (soap_out_ds__TransformsType(soap, tag?tag:"ds:TransformsType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__TransformsType * SOAP_FMAC4 soap_get_ds__TransformsType(struct soap *soap, struct ds__TransformsType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__TransformsType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Transforms = NULL;
	a->DigestMethod = NULL;
	soap_default_string(soap, &a->DigestValue);
	soap_default_string(soap, &a->Id);
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__TransformsType(soap, &a->Transforms);
	soap_serialize_PointerTods__DigestMethodType(soap, &a->DigestMethod);
	soap_serialize_string(soap, &a->DigestValue);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__ReferenceType(struct soap *soap, const char *tag, int id, const struct ds__ReferenceType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__ReferenceType), type))
		return soap->error;
	if (soap_out_PointerTods__TransformsType(soap, "ds:Transforms", -1, &a->Transforms, ""))
		return soap->error;
	if (a->DigestMethod)
	{	if (soap_out_PointerTods__DigestMethodType(soap, "ds:DigestMethod", -1, &a->DigestMethod, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:DigestMethod"))
		return soap->error;
	if (a->DigestValue)
	{	if (soap_out_string(soap, "ds:DigestValue", -1, &a->DigestValue, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:DigestValue"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_in_ds__ReferenceType(struct soap *soap, const char *tag, struct ds__ReferenceType *a, const char *type)
{
	size_t soap_flag_Transforms = 1;
	size_t soap_flag_DigestMethod = 1;
	size_t soap_flag_DigestValue = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__ReferenceType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__ReferenceType, sizeof(struct ds__ReferenceType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__ReferenceType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Transforms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__TransformsType(soap, "ds:Transforms", &a->Transforms, "ds:TransformsType"))
				{	soap_flag_Transforms--;
					continue;
				}
			if (soap_flag_DigestMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__DigestMethodType(soap, "ds:DigestMethod", &a->DigestMethod, "ds:DigestMethodType"))
				{	soap_flag_DigestMethod--;
					continue;
				}
			if (soap_flag_DigestValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:DigestValue", &a->DigestValue, "xsd:string"))
				{	soap_flag_DigestValue--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__ReferenceType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__ReferenceType, 0, sizeof(struct ds__ReferenceType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_DigestMethod > 0 || soap_flag_DigestValue > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__ReferenceType(struct soap *soap, const struct ds__ReferenceType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__ReferenceType);
	if (soap_out_ds__ReferenceType(soap, tag?tag:"ds:ReferenceType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__ReferenceType * SOAP_FMAC4 soap_get_ds__ReferenceType(struct soap *soap, struct ds__ReferenceType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__ReferenceType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->HMACOutputLength = NULL;
	soap_default_string(soap, &a->Algorithm);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToint(soap, &a->HMACOutputLength);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureMethodType(struct soap *soap, const char *tag, int id, const struct ds__SignatureMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureMethodType), type))
		return soap->error;
	if (soap_out_PointerToint(soap, "ds:HMACOutputLength", -1, &a->HMACOutputLength, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_in_ds__SignatureMethodType(struct soap *soap, const char *tag, struct ds__SignatureMethodType *a, const char *type)
{
	size_t soap_flag_HMACOutputLength = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureMethodType, sizeof(struct ds__SignatureMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_HMACOutputLength && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "ds:HMACOutputLength", &a->HMACOutputLength, "xsd:int"))
				{	soap_flag_HMACOutputLength--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureMethodType, 0, sizeof(struct ds__SignatureMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureMethodType(struct soap *soap, const struct ds__SignatureMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureMethodType);
	if (soap_out_ds__SignatureMethodType(soap, tag?tag:"ds:SignatureMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureMethodType * SOAP_FMAC4 soap_get_ds__SignatureMethodType(struct soap *soap, struct ds__SignatureMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Algorithm);
	a->c14n__InclusiveNamespaces = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_c14n__InclusiveNamespaces(soap, &a->c14n__InclusiveNamespaces);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, int id, const struct ds__CanonicalizationMethodType *a, const char *type)
{
	if (a->Algorithm)
		soap_set_attr(soap, "Algorithm", a->Algorithm, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__CanonicalizationMethodType), type))
		return soap->error;
	if (soap_out_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", -1, &a->c14n__InclusiveNamespaces, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_in_ds__CanonicalizationMethodType(struct soap *soap, const char *tag, struct ds__CanonicalizationMethodType *a, const char *type)
{
	size_t soap_flag_c14n__InclusiveNamespaces = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__CanonicalizationMethodType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__CanonicalizationMethodType, sizeof(struct ds__CanonicalizationMethodType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__CanonicalizationMethodType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Algorithm", 1), &a->Algorithm, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_c14n__InclusiveNamespaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_c14n__InclusiveNamespaces(soap, "c14n:InclusiveNamespaces", &a->c14n__InclusiveNamespaces, ""))
				{	soap_flag_c14n__InclusiveNamespaces--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__CanonicalizationMethodType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__CanonicalizationMethodType, 0, sizeof(struct ds__CanonicalizationMethodType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__CanonicalizationMethodType(struct soap *soap, const struct ds__CanonicalizationMethodType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__CanonicalizationMethodType);
	if (soap_out_ds__CanonicalizationMethodType(soap, tag?tag:"ds:CanonicalizationMethodType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__CanonicalizationMethodType * SOAP_FMAC4 soap_get_ds__CanonicalizationMethodType(struct soap *soap, struct ds__CanonicalizationMethodType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__CanonicalizationMethodType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->KeyName);
	a->KeyValue = NULL;
	a->RetrievalMethod = NULL;
	a->X509Data = NULL;
	a->wsse__SecurityTokenReference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->KeyName);
	soap_serialize_PointerTods__KeyValueType(soap, &a->KeyValue);
	soap_serialize_PointerTods__RetrievalMethodType(soap, &a->RetrievalMethod);
	soap_serialize_PointerTods__X509DataType(soap, &a->X509Data);
	soap_serialize_PointerTo_wsse__SecurityTokenReference(soap, &a->wsse__SecurityTokenReference);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__KeyInfoType(struct soap *soap, const char *tag, int id, const struct ds__KeyInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__KeyInfoType), type))
		return soap->error;
	if (soap_out_string(soap, "ds:KeyName", -1, &a->KeyName, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyValueType(soap, "ds:KeyValue", -1, &a->KeyValue, ""))
		return soap->error;
	if (soap_out_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", -1, &a->RetrievalMethod, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->X509Data, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", -1, &a->wsse__SecurityTokenReference, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_in_ds__KeyInfoType(struct soap *soap, const char *tag, struct ds__KeyInfoType *a, const char *type)
{
	size_t soap_flag_KeyName = 1;
	size_t soap_flag_KeyValue = 1;
	size_t soap_flag_RetrievalMethod = 1;
	size_t soap_flag_X509Data = 1;
	size_t soap_flag_wsse__SecurityTokenReference = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__KeyInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__KeyInfoType, sizeof(struct ds__KeyInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__KeyInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_KeyName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:KeyName", &a->KeyName, "xsd:string"))
				{	soap_flag_KeyName--;
					continue;
				}
			if (soap_flag_KeyValue && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyValueType(soap, "ds:KeyValue", &a->KeyValue, "ds:KeyValueType"))
				{	soap_flag_KeyValue--;
					continue;
				}
			if (soap_flag_RetrievalMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__RetrievalMethodType(soap, "ds:RetrievalMethod", &a->RetrievalMethod, "ds:RetrievalMethodType"))
				{	soap_flag_RetrievalMethod--;
					continue;
				}
			if (soap_flag_X509Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->X509Data, "ds:X509DataType"))
				{	soap_flag_X509Data--;
					continue;
				}
			if (soap_flag_wsse__SecurityTokenReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__SecurityTokenReference(soap, "wsse:SecurityTokenReference", &a->wsse__SecurityTokenReference, ""))
				{	soap_flag_wsse__SecurityTokenReference--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__KeyInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__KeyInfoType, 0, sizeof(struct ds__KeyInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__KeyInfoType(struct soap *soap, const struct ds__KeyInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__KeyInfoType);
	if (soap_out_ds__KeyInfoType(soap, tag?tag:"ds:KeyInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__KeyInfoType * SOAP_FMAC4 soap_get_ds__KeyInfoType(struct soap *soap, struct ds__KeyInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__KeyInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CanonicalizationMethod = NULL;
	a->SignatureMethod = NULL;
	a->__sizeReference = 0;
	a->Reference = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__CanonicalizationMethodType(soap, &a->CanonicalizationMethod);
	soap_serialize_PointerTods__SignatureMethodType(soap, &a->SignatureMethod);
	if (a->Reference)
	{	int i;
		for (i = 0; i < a->__sizeReference; i++)
		{
			soap_serialize_PointerTods__ReferenceType(soap, a->Reference + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignedInfoType(struct soap *soap, const char *tag, int id, const struct ds__SignedInfoType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignedInfoType), type))
		return soap->error;
	if (a->CanonicalizationMethod)
	{	if (soap_out_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", -1, &a->CanonicalizationMethod, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:CanonicalizationMethod"))
		return soap->error;
	if (a->SignatureMethod)
	{	if (soap_out_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", -1, &a->SignatureMethod, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "ds:SignatureMethod"))
		return soap->error;
	if (a->Reference)
	{	int i;
		for (i = 0; i < a->__sizeReference; i++)
			if (soap_out_PointerTods__ReferenceType(soap, "ds:Reference", -1, a->Reference + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_in_ds__SignedInfoType(struct soap *soap, const char *tag, struct ds__SignedInfoType *a, const char *type)
{
	size_t soap_flag_CanonicalizationMethod = 1;
	size_t soap_flag_SignatureMethod = 1;
	struct soap_blist *soap_blist_Reference = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignedInfoType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignedInfoType, sizeof(struct ds__SignedInfoType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignedInfoType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CanonicalizationMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__CanonicalizationMethodType(soap, "ds:CanonicalizationMethod", &a->CanonicalizationMethod, "ds:CanonicalizationMethodType"))
				{	soap_flag_CanonicalizationMethod--;
					continue;
				}
			if (soap_flag_SignatureMethod && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignatureMethodType(soap, "ds:SignatureMethod", &a->SignatureMethod, "ds:SignatureMethodType"))
				{	soap_flag_SignatureMethod--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "ds:Reference", 1, NULL))
			{	if (a->Reference == NULL)
				{	if (soap_blist_Reference == NULL)
						soap_blist_Reference = soap_new_block(soap);
					a->Reference = (struct ds__ReferenceType **)soap_push_block(soap, soap_blist_Reference, sizeof(struct ds__ReferenceType *));
					if (a->Reference == NULL)
						return NULL;
					*a->Reference = NULL;
				}
				soap_revert(soap);
				if (soap_in_PointerTods__ReferenceType(soap, "ds:Reference", a->Reference, "ds:ReferenceType"))
				{	a->__sizeReference++;
					a->Reference = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Reference)
			soap_pop_block(soap, soap_blist_Reference);
		if (a->__sizeReference)
			a->Reference = (struct ds__ReferenceType **)soap_save_block(soap, soap_blist_Reference, NULL, 1);
		else
		{	a->Reference = NULL;
			if (soap_blist_Reference)
				soap_end_block(soap, soap_blist_Reference);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignedInfoType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignedInfoType, 0, sizeof(struct ds__SignedInfoType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CanonicalizationMethod > 0 || soap_flag_SignatureMethod > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignedInfoType(struct soap *soap, const struct ds__SignedInfoType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignedInfoType);
	if (soap_out_ds__SignedInfoType(soap, tag?tag:"ds:SignedInfoType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignedInfoType * SOAP_FMAC4 soap_get_ds__SignedInfoType(struct soap *soap, struct ds__SignedInfoType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignedInfoType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__SignatureType(struct soap *soap, struct ds__SignatureType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SignedInfo = NULL;
	soap_default_string(soap, &a->SignatureValue);
	a->KeyInfo = NULL;
	soap_default_string(soap, &a->Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__SignedInfoType(soap, &a->SignedInfo);
	soap_serialize_string(soap, &a->SignatureValue);
	soap_serialize_PointerTods__KeyInfoType(soap, &a->KeyInfo);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__SignatureType(struct soap *soap, const char *tag, int id, const struct ds__SignatureType *a, const char *type)
{
	if (a->Id)
		soap_set_attr(soap, "Id", a->Id, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__SignatureType), type))
		return soap->error;
	if (soap_out_PointerTods__SignedInfoType(soap, "ds:SignedInfo", -1, &a->SignedInfo, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:SignatureValue", -1, &a->SignatureValue, ""))
		return soap->error;
	if (soap_out_PointerTods__KeyInfoType(soap, "ds:KeyInfo", -1, &a->KeyInfo, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_in_ds__SignatureType(struct soap *soap, const char *tag, struct ds__SignatureType *a, const char *type)
{
	size_t soap_flag_SignedInfo = 1;
	size_t soap_flag_SignatureValue = 1;
	size_t soap_flag_KeyInfo = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__SignatureType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__SignatureType, sizeof(struct ds__SignatureType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__SignatureType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Id", 0), &a->Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SignedInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__SignedInfoType(soap, "ds:SignedInfo", &a->SignedInfo, "ds:SignedInfoType"))
				{	soap_flag_SignedInfo--;
					continue;
				}
			if (soap_flag_SignatureValue && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:SignatureValue", &a->SignatureValue, "xsd:string"))
				{	soap_flag_SignatureValue--;
					continue;
				}
			if (soap_flag_KeyInfo && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__KeyInfoType(soap, "ds:KeyInfo", &a->KeyInfo, "ds:KeyInfoType"))
				{	soap_flag_KeyInfo--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__SignatureType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__SignatureType, 0, sizeof(struct ds__SignatureType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__SignatureType(struct soap *soap, const struct ds__SignatureType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__SignatureType);
	if (soap_out_ds__SignatureType(soap, tag?tag:"ds:SignatureType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__SignatureType * SOAP_FMAC4 soap_get_ds__SignatureType(struct soap *soap, struct ds__SignatureType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__SignatureType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ds__X509DataType(struct soap *soap, struct ds__X509DataType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->X509IssuerSerial = NULL;
	soap_default_string(soap, &a->X509SKI);
	soap_default_string(soap, &a->X509SubjectName);
	soap_default_string(soap, &a->X509Certificate);
	soap_default_string(soap, &a->X509CRL);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTods__X509IssuerSerialType(soap, &a->X509IssuerSerial);
	soap_serialize_string(soap, &a->X509SKI);
	soap_serialize_string(soap, &a->X509SubjectName);
	soap_serialize_string(soap, &a->X509Certificate);
	soap_serialize_string(soap, &a->X509CRL);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ds__X509DataType(struct soap *soap, const char *tag, int id, const struct ds__X509DataType *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ds__X509DataType), type))
		return soap->error;
	if (soap_out_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", -1, &a->X509IssuerSerial, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SKI", -1, &a->X509SKI, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509SubjectName", -1, &a->X509SubjectName, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509Certificate", -1, &a->X509Certificate, ""))
		return soap->error;
	if (soap_out_string(soap, "ds:X509CRL", -1, &a->X509CRL, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_in_ds__X509DataType(struct soap *soap, const char *tag, struct ds__X509DataType *a, const char *type)
{
	size_t soap_flag_X509IssuerSerial = 1;
	size_t soap_flag_X509SKI = 1;
	size_t soap_flag_X509SubjectName = 1;
	size_t soap_flag_X509Certificate = 1;
	size_t soap_flag_X509CRL = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ds__X509DataType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ds__X509DataType, sizeof(struct ds__X509DataType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ds__X509DataType(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_X509IssuerSerial && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509IssuerSerialType(soap, "ds:X509IssuerSerial", &a->X509IssuerSerial, "ds:X509IssuerSerialType"))
				{	soap_flag_X509IssuerSerial--;
					continue;
				}
			if (soap_flag_X509SKI && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SKI", &a->X509SKI, "xsd:string"))
				{	soap_flag_X509SKI--;
					continue;
				}
			if (soap_flag_X509SubjectName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509SubjectName", &a->X509SubjectName, "xsd:string"))
				{	soap_flag_X509SubjectName--;
					continue;
				}
			if (soap_flag_X509Certificate && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509Certificate", &a->X509Certificate, "xsd:string"))
				{	soap_flag_X509Certificate--;
					continue;
				}
			if (soap_flag_X509CRL && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "ds:X509CRL", &a->X509CRL, "xsd:string"))
				{	soap_flag_X509CRL--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ds__X509DataType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ds__X509DataType, 0, sizeof(struct ds__X509DataType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ds__X509DataType(struct soap *soap, const struct ds__X509DataType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ds__X509DataType);
	if (soap_out_ds__X509DataType(soap, tag?tag:"ds:X509DataType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ds__X509DataType * SOAP_FMAC4 soap_get_ds__X509DataType(struct soap *soap, struct ds__X509DataType *p, const char *tag, const char *type)
{
	if ((p = soap_in_ds__X509DataType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Reference = NULL;
	a->KeyIdentifier = NULL;
	a->Embedded = NULL;
	a->ds__X509Data = NULL;
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->wsc__Instance);
	soap_default_string(soap, &a->Usage);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTo_wsse__Reference(soap, &a->Reference);
	soap_serialize_PointerTo_wsse__KeyIdentifier(soap, &a->KeyIdentifier);
	soap_serialize_PointerTo_wsse__Embedded(soap, &a->Embedded);
	soap_serialize_PointerTods__X509DataType(soap, &a->ds__X509Data);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__SecurityTokenReference(struct soap *soap, const char *tag, int id, const struct _wsse__SecurityTokenReference *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->wsc__Instance)
		soap_set_attr(soap, "wsc:Instance", a->wsc__Instance, 1);
	if (a->Usage)
		soap_set_attr(soap, "Usage", a->Usage, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__SecurityTokenReference), type))
		return soap->error;
	if (soap_out_PointerTo_wsse__Reference(soap, "wsse:Reference", -1, &a->Reference, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", -1, &a->KeyIdentifier, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Embedded(soap, "wsse:Embedded", -1, &a->Embedded, ""))
		return soap->error;
	if (soap_out_PointerTods__X509DataType(soap, "ds:X509Data", -1, &a->ds__X509Data, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_in__wsse__SecurityTokenReference(struct soap *soap, const char *tag, struct _wsse__SecurityTokenReference *a, const char *type)
{
	size_t soap_flag_Reference = 1;
	size_t soap_flag_KeyIdentifier = 1;
	size_t soap_flag_Embedded = 1;
	size_t soap_flag_ds__X509Data = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__SecurityTokenReference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__SecurityTokenReference, sizeof(struct _wsse__SecurityTokenReference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__SecurityTokenReference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "wsc:Instance", 0), &a->wsc__Instance, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "Usage", 0), &a->Usage, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Reference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Reference(soap, "wsse:Reference", &a->Reference, ""))
				{	soap_flag_Reference--;
					continue;
				}
			if (soap_flag_KeyIdentifier && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__KeyIdentifier(soap, "wsse:KeyIdentifier", &a->KeyIdentifier, ""))
				{	soap_flag_KeyIdentifier--;
					continue;
				}
			if (soap_flag_Embedded && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Embedded(soap, "wsse:Embedded", &a->Embedded, ""))
				{	soap_flag_Embedded--;
					continue;
				}
			if (soap_flag_ds__X509Data && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTods__X509DataType(soap, "ds:X509Data", &a->ds__X509Data, "ds:X509DataType"))
				{	soap_flag_ds__X509Data--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__SecurityTokenReference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__SecurityTokenReference, 0, sizeof(struct _wsse__SecurityTokenReference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__SecurityTokenReference(struct soap *soap, const struct _wsse__SecurityTokenReference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__SecurityTokenReference);
	if (soap_out__wsse__SecurityTokenReference(soap, tag?tag:"wsse:SecurityTokenReference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__SecurityTokenReference * SOAP_FMAC4 soap_get__wsse__SecurityTokenReference(struct soap *soap, struct _wsse__SecurityTokenReference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__SecurityTokenReference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__KeyIdentifier(struct soap *soap, const char *tag, int id, const struct _wsse__KeyIdentifier *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_in__wsse__KeyIdentifier(struct soap *soap, const char *tag, struct _wsse__KeyIdentifier *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__KeyIdentifier *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__KeyIdentifier, sizeof(struct _wsse__KeyIdentifier), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__KeyIdentifier(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__KeyIdentifier(struct soap *soap, const struct _wsse__KeyIdentifier *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__KeyIdentifier);
	if (soap_out__wsse__KeyIdentifier(soap, tag?tag:"wsse:KeyIdentifier", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__KeyIdentifier * SOAP_FMAC4 soap_get__wsse__KeyIdentifier(struct soap *soap, struct _wsse__KeyIdentifier *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__KeyIdentifier(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Embedded(struct soap *soap, const char *tag, int id, const struct _wsse__Embedded *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Embedded), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_in__wsse__Embedded(struct soap *soap, const char *tag, struct _wsse__Embedded *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Embedded *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Embedded, sizeof(struct _wsse__Embedded), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Embedded(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Embedded *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Embedded, 0, sizeof(struct _wsse__Embedded), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Embedded(struct soap *soap, const struct _wsse__Embedded *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Embedded);
	if (soap_out__wsse__Embedded(soap, tag?tag:"wsse:Embedded", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Embedded * SOAP_FMAC4 soap_get__wsse__Embedded(struct soap *soap, struct _wsse__Embedded *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Embedded(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Reference(struct soap *soap, struct _wsse__Reference *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->URI);
	soap_default_string(soap, &a->ValueType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Reference(struct soap *soap, const char *tag, int id, const struct _wsse__Reference *a, const char *type)
{
	if (a->URI)
		soap_set_attr(soap, "URI", a->URI, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__Reference), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_in__wsse__Reference(struct soap *soap, const char *tag, struct _wsse__Reference *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__Reference *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Reference, sizeof(struct _wsse__Reference), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__Reference(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "URI", 0), &a->URI, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__Reference *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__Reference, 0, sizeof(struct _wsse__Reference), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Reference(struct soap *soap, const struct _wsse__Reference *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Reference);
	if (soap_out__wsse__Reference(soap, tag?tag:"wsse:Reference", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Reference * SOAP_FMAC4 soap_get__wsse__Reference(struct soap *soap, struct _wsse__Reference *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Reference(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->ValueType);
	soap_default_string(soap, &a->EncodingType);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__BinarySecurityToken(struct soap *soap, const char *tag, int id, const struct _wsse__BinarySecurityToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	if (a->ValueType)
		soap_set_attr(soap, "ValueType", a->ValueType, 1);
	if (a->EncodingType)
		soap_set_attr(soap, "EncodingType", a->EncodingType, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_in__wsse__BinarySecurityToken(struct soap *soap, const char *tag, struct _wsse__BinarySecurityToken *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__BinarySecurityToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__BinarySecurityToken, sizeof(struct _wsse__BinarySecurityToken), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__BinarySecurityToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "ValueType", 0), &a->ValueType, 0, -1))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "EncodingType", 0), &a->EncodingType, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__BinarySecurityToken(struct soap *soap, const struct _wsse__BinarySecurityToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__BinarySecurityToken);
	if (soap_out__wsse__BinarySecurityToken(soap, tag?tag:"wsse:BinarySecurityToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__BinarySecurityToken * SOAP_FMAC4 soap_get__wsse__BinarySecurityToken(struct soap *soap, struct _wsse__BinarySecurityToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__BinarySecurityToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__Password(struct soap *soap, struct _wsse__Password *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default_string(soap, &a->Type);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__Password(struct soap *soap, const struct _wsse__Password *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__Password(struct soap *soap, const char *tag, int id, const struct _wsse__Password *a, const char *type)
{
	if (a->Type)
		soap_set_attr(soap, "Type", a->Type, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_in__wsse__Password(struct soap *soap, const char *tag, struct _wsse__Password *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsse__Password *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__Password, sizeof(struct _wsse__Password), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsse__Password(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "Type", 0), &a->Type, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__Password(struct soap *soap, const struct _wsse__Password *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__Password);
	if (soap_out__wsse__Password(soap, tag?tag:"wsse:Password", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__Password * SOAP_FMAC4 soap_get__wsse__Password(struct soap *soap, struct _wsse__Password *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__Password(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->Username);
	a->Password = NULL;
	soap_default_string(soap, &a->Nonce);
	soap_default_string(soap, &a->wsu__Created);
	soap_default_string(soap, &a->wsu__Id);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Username);
	soap_serialize_PointerTo_wsse__Password(soap, &a->Password);
	soap_serialize_string(soap, &a->Nonce);
	soap_serialize_string(soap, &a->wsu__Created);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsse__UsernameToken(struct soap *soap, const char *tag, int id, const struct _wsse__UsernameToken *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsse__UsernameToken), type))
		return soap->error;
	if (soap_out_string(soap, "wsse:Username", -1, &a->Username, ""))
		return soap->error;
	if (soap_out_PointerTo_wsse__Password(soap, "wsse:Password", -1, &a->Password, ""))
		return soap->error;
	if (soap_out_string(soap, "wsse:Nonce", -1, &a->Nonce, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->wsu__Created, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_in__wsse__UsernameToken(struct soap *soap, const char *tag, struct _wsse__UsernameToken *a, const char *type)
{
	size_t soap_flag_Username = 1;
	size_t soap_flag_Password = 1;
	size_t soap_flag_Nonce = 1;
	size_t soap_flag_wsu__Created = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsse__UsernameToken *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsse__UsernameToken, sizeof(struct _wsse__UsernameToken), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsse__UsernameToken(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Username && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Username", &a->Username, "xsd:string"))
				{	soap_flag_Username--;
					continue;
				}
			if (soap_flag_Password && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsse__Password(soap, "wsse:Password", &a->Password, ""))
				{	soap_flag_Password--;
					continue;
				}
			if (soap_flag_Nonce && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsse:Nonce", &a->Nonce, "xsd:string"))
				{	soap_flag_Nonce--;
					continue;
				}
			if (soap_flag_wsu__Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->wsu__Created, "xsd:string"))
				{	soap_flag_wsu__Created--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsse__UsernameToken *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsse__UsernameToken, 0, sizeof(struct _wsse__UsernameToken), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsse__UsernameToken(struct soap *soap, const struct _wsse__UsernameToken *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsse__UsernameToken);
	if (soap_out__wsse__UsernameToken(soap, tag?tag:"wsse:UsernameToken", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsse__UsernameToken * SOAP_FMAC4 soap_get__wsse__UsernameToken(struct soap *soap, struct _wsse__UsernameToken *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsse__UsernameToken(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->wsu__Id);
	soap_default_string(soap, &a->Created);
	soap_default_string(soap, &a->Expires);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->Created);
	soap_serialize_string(soap, &a->Expires);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsu__Timestamp(struct soap *soap, const char *tag, int id, const struct _wsu__Timestamp *a, const char *type)
{
	if (a->wsu__Id)
		soap_set_attr(soap, "wsu:Id", a->wsu__Id, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsu__Timestamp), type))
		return soap->error;
	if (soap_out_string(soap, "wsu:Created", -1, &a->Created, ""))
		return soap->error;
	if (soap_out_string(soap, "wsu:Expires", -1, &a->Expires, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_in__wsu__Timestamp(struct soap *soap, const char *tag, struct _wsu__Timestamp *a, const char *type)
{
	size_t soap_flag_Created = 1;
	size_t soap_flag_Expires = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsu__Timestamp *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsu__Timestamp, sizeof(struct _wsu__Timestamp), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsu__Timestamp(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "wsu:Id", 0), &a->wsu__Id, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Created && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Created", &a->Created, "xsd:string"))
				{	soap_flag_Created--;
					continue;
				}
			if (soap_flag_Expires && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "wsu:Expires", &a->Expires, "xsd:string"))
				{	soap_flag_Expires--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsu__Timestamp *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsu__Timestamp, 0, sizeof(struct _wsu__Timestamp), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsu__Timestamp(struct soap *soap, const struct _wsu__Timestamp *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsu__Timestamp);
	if (soap_out__wsu__Timestamp(soap, tag?tag:"wsu:Timestamp", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsu__Timestamp * SOAP_FMAC4 soap_get__wsu__Timestamp(struct soap *soap, struct _wsu__Timestamp *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsu__Timestamp(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tmd__union_SerialData(struct soap *soap, int choice, const union _tmd__union_SerialData *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tmd__union_SerialData_Binary:
		soap_embedded(soap, &a->Binary, SOAP_TYPE_xsd__base64Binary);
		soap_serialize_xsd__base64Binary(soap, &a->Binary);
		break;
	case SOAP_UNION__tmd__union_SerialData_String:
		soap_serialize_string(soap, &a->String);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tmd__union_SerialData(struct soap *soap, int choice, const union _tmd__union_SerialData *a)
{
	switch (choice)
	{
	case SOAP_UNION__tmd__union_SerialData_Binary:
		return soap_out_xsd__base64Binary(soap, "tmd:Binary", -1, &a->Binary, "");
	case SOAP_UNION__tmd__union_SerialData_String:
		return soap_out_string(soap, "tmd:String", -1, &a->String, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tmd__union_SerialData * SOAP_FMAC4 soap_in__tmd__union_SerialData(struct soap *soap, int *choice, union _tmd__union_SerialData *a)
{	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_xsd__base64Binary(soap, "tmd:Binary", &a->Binary, "xsd:base64Binary"))
	{	*choice = SOAP_UNION__tmd__union_SerialData_Binary;
		return a;
	}
	a->String = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_string(soap, "tmd:String", &a->String, "xsd:string"))
	{	*choice = SOAP_UNION__tmd__union_SerialData_String;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_EventStream(struct soap *soap, int choice, const union _tt__union_EventStream *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_EventStream_wsnt__NotificationMessage:
		soap_serialize_PointerTowsnt__NotificationMessageHolderType(soap, &a->wsnt__NotificationMessage);
		break;
	case SOAP_UNION__tt__union_EventStream_Extension:
		soap_serialize_PointerTott__EventStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_EventStream(struct soap *soap, int choice, const union _tt__union_EventStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__tt__union_EventStream_wsnt__NotificationMessage:
		return soap_out_PointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, &a->wsnt__NotificationMessage, "");
	case SOAP_UNION__tt__union_EventStream_Extension:
		return soap_out_PointerTott__EventStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_EventStream * SOAP_FMAC4 soap_in__tt__union_EventStream(struct soap *soap, int *choice, union _tt__union_EventStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->wsnt__NotificationMessage = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTowsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", &a->wsnt__NotificationMessage, "wsnt:NotificationMessageHolderType"))
	{	*choice = SOAP_UNION__tt__union_EventStream_wsnt__NotificationMessage;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__EventStreamExtension(soap, "tt:Extension", &a->Extension, "tt:EventStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_EventStream_Extension;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_PTZStream(struct soap *soap, int choice, const union _tt__union_PTZStream *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZStream_PTZStatus:
		soap_serialize_PointerTott__PTZStatus(soap, &a->PTZStatus);
		break;
	case SOAP_UNION__tt__union_PTZStream_Extension:
		soap_serialize_PointerTott__PTZStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_PTZStream(struct soap *soap, int choice, const union _tt__union_PTZStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZStream_PTZStatus:
		return soap_out_PointerTott__PTZStatus(soap, "tt:PTZStatus", -1, &a->PTZStatus, "");
	case SOAP_UNION__tt__union_PTZStream_Extension:
		return soap_out_PointerTott__PTZStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_PTZStream * SOAP_FMAC4 soap_in__tt__union_PTZStream(struct soap *soap, int *choice, union _tt__union_PTZStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->PTZStatus = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZStatus(soap, "tt:PTZStatus", &a->PTZStatus, "tt:PTZStatus"))
	{	*choice = SOAP_UNION__tt__union_PTZStream_PTZStatus;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZStreamExtension(soap, "tt:Extension", &a->Extension, "tt:PTZStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_PTZStream_Extension;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_VideoAnalyticsStream(struct soap *soap, int choice, const union _tt__union_VideoAnalyticsStream *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Frame:
		soap_serialize_PointerTott__Frame(soap, &a->Frame);
		break;
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Extension:
		soap_serialize_PointerTott__VideoAnalyticsStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_VideoAnalyticsStream(struct soap *soap, int choice, const union _tt__union_VideoAnalyticsStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Frame:
		return soap_out_PointerTott__Frame(soap, "tt:Frame", -1, &a->Frame, "");
	case SOAP_UNION__tt__union_VideoAnalyticsStream_Extension:
		return soap_out_PointerTott__VideoAnalyticsStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_VideoAnalyticsStream * SOAP_FMAC4 soap_in__tt__union_VideoAnalyticsStream(struct soap *soap, int *choice, union _tt__union_VideoAnalyticsStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->Frame = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__Frame(soap, "tt:Frame", &a->Frame, "tt:Frame"))
	{	*choice = SOAP_UNION__tt__union_VideoAnalyticsStream_Frame;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__VideoAnalyticsStreamExtension(soap, "tt:Extension", &a->Extension, "tt:VideoAnalyticsStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_VideoAnalyticsStream_Extension;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_MetadataStream(struct soap *soap, int choice, const union _tt__union_MetadataStream *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_MetadataStream_VideoAnalytics:
		soap_serialize_PointerTott__VideoAnalyticsStream(soap, &a->VideoAnalytics);
		break;
	case SOAP_UNION__tt__union_MetadataStream_PTZ:
		soap_serialize_PointerTott__PTZStream(soap, &a->PTZ);
		break;
	case SOAP_UNION__tt__union_MetadataStream_Event:
		soap_serialize_PointerTott__EventStream(soap, &a->Event);
		break;
	case SOAP_UNION__tt__union_MetadataStream_Extension:
		soap_serialize_PointerTott__MetadataStreamExtension(soap, &a->Extension);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_MetadataStream(struct soap *soap, int choice, const union _tt__union_MetadataStream *a)
{
	switch (choice)
	{
	case SOAP_UNION__tt__union_MetadataStream_VideoAnalytics:
		return soap_out_PointerTott__VideoAnalyticsStream(soap, "tt:VideoAnalytics", -1, &a->VideoAnalytics, "");
	case SOAP_UNION__tt__union_MetadataStream_PTZ:
		return soap_out_PointerTott__PTZStream(soap, "tt:PTZ", -1, &a->PTZ, "");
	case SOAP_UNION__tt__union_MetadataStream_Event:
		return soap_out_PointerTott__EventStream(soap, "tt:Event", -1, &a->Event, "");
	case SOAP_UNION__tt__union_MetadataStream_Extension:
		return soap_out_PointerTott__MetadataStreamExtension(soap, "tt:Extension", -1, &a->Extension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_MetadataStream * SOAP_FMAC4 soap_in__tt__union_MetadataStream(struct soap *soap, int *choice, union _tt__union_MetadataStream *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->VideoAnalytics = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__VideoAnalyticsStream(soap, "tt:VideoAnalytics", &a->VideoAnalytics, "tt:VideoAnalyticsStream"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_VideoAnalytics;
		return a;
	}
	a->PTZ = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZStream(soap, "tt:PTZ", &a->PTZ, "tt:PTZStream"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_PTZ;
		return a;
	}
	a->Event = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__EventStream(soap, "tt:Event", &a->Event, "tt:EventStream"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_Event;
		return a;
	}
	a->Extension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__MetadataStreamExtension(soap, "tt:Extension", &a->Extension, "tt:MetadataStreamExtension"))
	{	*choice = SOAP_UNION__tt__union_MetadataStream_Extension;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tt__union_PTZPresetTourPresetDetail(struct soap *soap, int choice, const union _tt__union_PTZPresetTourPresetDetail *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken:
		soap_serialize_tt__ReferenceToken(soap, &a->PresetToken);
		break;
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home:
		soap_embedded(soap, &a->Home, SOAP_TYPE_xsd__boolean);
		break;
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition:
		soap_serialize_PointerTott__PTZVector(soap, &a->PTZPosition);
		break;
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension:
		soap_serialize_PointerTott__PTZPresetTourTypeExtension(soap, &a->TypeExtension);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tt__union_PTZPresetTourPresetDetail(struct soap *soap, int choice, const union _tt__union_PTZPresetTourPresetDetail *a)
{
	switch (choice)
	{
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken:
		return soap_out_tt__ReferenceToken(soap, "tt:PresetToken", -1, &a->PresetToken, "");
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home:
		return soap_out_xsd__boolean(soap, "tt:Home", -1, &a->Home, "");
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition:
		return soap_out_PointerTott__PTZVector(soap, "tt:PTZPosition", -1, &a->PTZPosition, "");
	case SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension:
		return soap_out_PointerTott__PTZPresetTourTypeExtension(soap, "tt:TypeExtension", -1, &a->TypeExtension, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _tt__union_PTZPresetTourPresetDetail * SOAP_FMAC4 soap_in__tt__union_PTZPresetTourPresetDetail(struct soap *soap, int *choice, union _tt__union_PTZPresetTourPresetDetail *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->PresetToken = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_tt__ReferenceToken(soap, "tt:PresetToken", &a->PresetToken, "tt:ReferenceToken"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PresetToken;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_xsd__boolean(soap, "tt:Home", &a->Home, "xsd:boolean"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_Home;
		return a;
	}
	a->PTZPosition = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZVector(soap, "tt:PTZPosition", &a->PTZPosition, "tt:PTZVector"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_PTZPosition;
		return a;
	}
	a->TypeExtension = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTott__PTZPresetTourTypeExtension(soap, "tt:TypeExtension", &a->TypeExtension, "tt:PTZPresetTourTypeExtension"))
	{	*choice = SOAP_UNION__tt__union_PTZPresetTourPresetDetail_TypeExtension;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__ns1__union_FtpContentConfiguration(struct soap *soap, int choice, const union _ns1__union_FtpContentConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__ns1__union_FtpContentConfiguration_UploadImages:
		soap_serialize_PointerTons1__FtpContentConfigurationUploadImages(soap, &a->UploadImages);
		break;
	case SOAP_UNION__ns1__union_FtpContentConfiguration_UploadFile:
		soap_serialize_PointerTons1__FtpContentConfigurationUploadFile(soap, &a->UploadFile);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__ns1__union_FtpContentConfiguration(struct soap *soap, int choice, const union _ns1__union_FtpContentConfiguration *a)
{
	switch (choice)
	{
	case SOAP_UNION__ns1__union_FtpContentConfiguration_UploadImages:
		return soap_out_PointerTons1__FtpContentConfigurationUploadImages(soap, "ns1:UploadImages", -1, &a->UploadImages, "");
	case SOAP_UNION__ns1__union_FtpContentConfiguration_UploadFile:
		return soap_out_PointerTons1__FtpContentConfigurationUploadFile(soap, "ns1:UploadFile", -1, &a->UploadFile, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _ns1__union_FtpContentConfiguration * SOAP_FMAC4 soap_in__ns1__union_FtpContentConfiguration(struct soap *soap, int *choice, union _ns1__union_FtpContentConfiguration *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->UploadImages = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__FtpContentConfigurationUploadImages(soap, "ns1:UploadImages", &a->UploadImages, "ns1:FtpContentConfigurationUploadImages"))
	{	*choice = SOAP_UNION__ns1__union_FtpContentConfiguration_UploadImages;
		return a;
	}
	a->UploadFile = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTons1__FtpContentConfigurationUploadFile(soap, "ns1:UploadFile", &a->UploadFile, "ns1:FtpContentConfigurationUploadFile"))
	{	*choice = SOAP_UNION__ns1__union_FtpContentConfiguration_UploadFile;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsc__union_DerivedKeyTokenType(struct soap *soap, int choice, const union _wsc__union_DerivedKeyTokenType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation:
		soap_embedded(soap, &a->Generation, SOAP_TYPE_unsignedLONG64);
		break;
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset:
		soap_embedded(soap, &a->Offset, SOAP_TYPE_unsignedLONG64);
		break;
	default:
		break;
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsc__union_DerivedKeyTokenType(struct soap *soap, int choice, const union _wsc__union_DerivedKeyTokenType *a)
{
	switch (choice)
	{
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation:
		return soap_out_unsignedLONG64(soap, "wsc:Generation", -1, &a->Generation, "");
	case SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset:
		return soap_out_unsignedLONG64(soap, "wsc:Offset", -1, &a->Offset, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _wsc__union_DerivedKeyTokenType * SOAP_FMAC4 soap_in__wsc__union_DerivedKeyTokenType(struct soap *soap, int *choice, union _wsc__union_DerivedKeyTokenType *a)
{	soap->error = SOAP_TAG_MISMATCH;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_unsignedLONG64(soap, "wsc:Generation", &a->Generation, "xsd:unsignedLong"))
	{	*choice = SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation;
		return a;
	}
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_unsignedLONG64(soap, "wsc:Offset", &a->Offset, "xsd:unsignedLong"))
	{	*choice = SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset;
		return a;
	}
	*choice = -1;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetMetadataSearchResultsResponse(struct soap *soap, struct _tse__GetMetadataSearchResultsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetMetadataSearchResultsResponse))
		soap_serialize__tse__GetMetadataSearchResultsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetMetadataSearchResultsResponse(struct soap *soap, const char *tag, int id, struct _tse__GetMetadataSearchResultsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetMetadataSearchResultsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetMetadataSearchResultsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResultsResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetMetadataSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetMetadataSearchResultsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetMetadataSearchResultsResponse **)soap_malloc(soap, sizeof(struct _tse__GetMetadataSearchResultsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetMetadataSearchResultsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetMetadataSearchResultsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetMetadataSearchResultsResponse, sizeof(struct _tse__GetMetadataSearchResultsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetMetadataSearchResultsResponse(struct soap *soap, struct _tse__GetMetadataSearchResultsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__GetMetadataSearchResultsResponse);
	if (soap_out_PointerTo_tse__GetMetadataSearchResultsResponse(soap, tag?tag:"tse:GetMetadataSearchResultsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResultsResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetMetadataSearchResultsResponse(struct soap *soap, struct _tse__GetMetadataSearchResultsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetMetadataSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetMetadataSearchResults(struct soap *soap, struct _tse__GetMetadataSearchResults *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetMetadataSearchResults))
		soap_serialize__tse__GetMetadataSearchResults(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetMetadataSearchResults(struct soap *soap, const char *tag, int id, struct _tse__GetMetadataSearchResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetMetadataSearchResults);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetMetadataSearchResults(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResults ** SOAP_FMAC4 soap_in_PointerTo_tse__GetMetadataSearchResults(struct soap *soap, const char *tag, struct _tse__GetMetadataSearchResults **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetMetadataSearchResults **)soap_malloc(soap, sizeof(struct _tse__GetMetadataSearchResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetMetadataSearchResults(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetMetadataSearchResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetMetadataSearchResults, sizeof(struct _tse__GetMetadataSearchResults), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetMetadataSearchResults(struct soap *soap, struct _tse__GetMetadataSearchResults *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__GetMetadataSearchResults);
	if (soap_out_PointerTo_tse__GetMetadataSearchResults(soap, tag?tag:"tse:GetMetadataSearchResults", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResults ** SOAP_FMAC4 soap_get_PointerTo_tse__GetMetadataSearchResults(struct soap *soap, struct _tse__GetMetadataSearchResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetMetadataSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindMetadataResponse(struct soap *soap, struct _tse__FindMetadataResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindMetadataResponse))
		soap_serialize__tse__FindMetadataResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindMetadataResponse(struct soap *soap, const char *tag, int id, struct _tse__FindMetadataResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindMetadataResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindMetadataResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindMetadataResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__FindMetadataResponse(struct soap *soap, const char *tag, struct _tse__FindMetadataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindMetadataResponse **)soap_malloc(soap, sizeof(struct _tse__FindMetadataResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindMetadataResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindMetadataResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindMetadataResponse, sizeof(struct _tse__FindMetadataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindMetadataResponse(struct soap *soap, struct _tse__FindMetadataResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__FindMetadataResponse);
	if (soap_out_PointerTo_tse__FindMetadataResponse(soap, tag?tag:"tse:FindMetadataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindMetadataResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__FindMetadataResponse(struct soap *soap, struct _tse__FindMetadataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindMetadata(struct soap *soap, struct _tse__FindMetadata *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindMetadata))
		soap_serialize__tse__FindMetadata(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindMetadata(struct soap *soap, const char *tag, int id, struct _tse__FindMetadata *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindMetadata);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindMetadata(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindMetadata ** SOAP_FMAC4 soap_in_PointerTo_tse__FindMetadata(struct soap *soap, const char *tag, struct _tse__FindMetadata **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindMetadata **)soap_malloc(soap, sizeof(struct _tse__FindMetadata *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindMetadata(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindMetadata **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindMetadata, sizeof(struct _tse__FindMetadata), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindMetadata(struct soap *soap, struct _tse__FindMetadata *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__FindMetadata);
	if (soap_out_PointerTo_tse__FindMetadata(soap, tag?tag:"tse:FindMetadata", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindMetadata ** SOAP_FMAC4 soap_get_PointerTo_tse__FindMetadata(struct soap *soap, struct _tse__FindMetadata **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__EndSearchResponse(struct soap *soap, struct _tse__EndSearchResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__EndSearchResponse))
		soap_serialize__tse__EndSearchResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__EndSearchResponse(struct soap *soap, const char *tag, int id, struct _tse__EndSearchResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__EndSearchResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tse__EndSearchResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__EndSearchResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__EndSearchResponse(struct soap *soap, const char *tag, struct _tse__EndSearchResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__EndSearchResponse **)soap_malloc(soap, sizeof(struct _tse__EndSearchResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__EndSearchResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__EndSearchResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__EndSearchResponse, sizeof(struct _tse__EndSearchResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__EndSearchResponse(struct soap *soap, struct _tse__EndSearchResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__EndSearchResponse);
	if (soap_out_PointerTo_tse__EndSearchResponse(soap, tag?tag:"tse:EndSearchResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__EndSearchResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__EndSearchResponse(struct soap *soap, struct _tse__EndSearchResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__EndSearchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__EndSearch(struct soap *soap, struct _tse__EndSearch *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__EndSearch))
		soap_serialize__tse__EndSearch(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__EndSearch(struct soap *soap, const char *tag, int id, struct _tse__EndSearch *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__EndSearch);
	if (id < 0)
		return soap->error;
	return soap_out__tse__EndSearch(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__EndSearch ** SOAP_FMAC4 soap_in_PointerTo_tse__EndSearch(struct soap *soap, const char *tag, struct _tse__EndSearch **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__EndSearch **)soap_malloc(soap, sizeof(struct _tse__EndSearch *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__EndSearch(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__EndSearch **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__EndSearch, sizeof(struct _tse__EndSearch), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__EndSearch(struct soap *soap, struct _tse__EndSearch *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__EndSearch);
	if (soap_out_PointerTo_tse__EndSearch(soap, tag?tag:"tse:EndSearch", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__EndSearch ** SOAP_FMAC4 soap_get_PointerTo_tse__EndSearch(struct soap *soap, struct _tse__EndSearch **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__EndSearch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetSearchStateResponse(struct soap *soap, struct _tse__GetSearchStateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetSearchStateResponse))
		soap_serialize__tse__GetSearchStateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetSearchStateResponse(struct soap *soap, const char *tag, int id, struct _tse__GetSearchStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetSearchStateResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetSearchStateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetSearchStateResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetSearchStateResponse(struct soap *soap, const char *tag, struct _tse__GetSearchStateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetSearchStateResponse **)soap_malloc(soap, sizeof(struct _tse__GetSearchStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetSearchStateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetSearchStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetSearchStateResponse, sizeof(struct _tse__GetSearchStateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetSearchStateResponse(struct soap *soap, struct _tse__GetSearchStateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__GetSearchStateResponse);
	if (soap_out_PointerTo_tse__GetSearchStateResponse(soap, tag?tag:"tse:GetSearchStateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetSearchStateResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetSearchStateResponse(struct soap *soap, struct _tse__GetSearchStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetSearchStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetSearchState(struct soap *soap, struct _tse__GetSearchState *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetSearchState))
		soap_serialize__tse__GetSearchState(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetSearchState(struct soap *soap, const char *tag, int id, struct _tse__GetSearchState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetSearchState);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetSearchState(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetSearchState ** SOAP_FMAC4 soap_in_PointerTo_tse__GetSearchState(struct soap *soap, const char *tag, struct _tse__GetSearchState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetSearchState **)soap_malloc(soap, sizeof(struct _tse__GetSearchState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetSearchState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetSearchState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetSearchState, sizeof(struct _tse__GetSearchState), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetSearchState(struct soap *soap, struct _tse__GetSearchState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__GetSearchState);
	if (soap_out_PointerTo_tse__GetSearchState(soap, tag?tag:"tse:GetSearchState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetSearchState ** SOAP_FMAC4 soap_get_PointerTo_tse__GetSearchState(struct soap *soap, struct _tse__GetSearchState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetSearchState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetPTZPositionSearchResultsResponse(struct soap *soap, struct _tse__GetPTZPositionSearchResultsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse))
		soap_serialize__tse__GetPTZPositionSearchResultsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetPTZPositionSearchResultsResponse(struct soap *soap, const char *tag, int id, struct _tse__GetPTZPositionSearchResultsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetPTZPositionSearchResultsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResultsResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetPTZPositionSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetPTZPositionSearchResultsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetPTZPositionSearchResultsResponse **)soap_malloc(soap, sizeof(struct _tse__GetPTZPositionSearchResultsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetPTZPositionSearchResultsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetPTZPositionSearchResultsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse, sizeof(struct _tse__GetPTZPositionSearchResultsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetPTZPositionSearchResultsResponse(struct soap *soap, struct _tse__GetPTZPositionSearchResultsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__GetPTZPositionSearchResultsResponse);
	if (soap_out_PointerTo_tse__GetPTZPositionSearchResultsResponse(soap, tag?tag:"tse:GetPTZPositionSearchResultsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResultsResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetPTZPositionSearchResultsResponse(struct soap *soap, struct _tse__GetPTZPositionSearchResultsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetPTZPositionSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetPTZPositionSearchResults(struct soap *soap, struct _tse__GetPTZPositionSearchResults *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetPTZPositionSearchResults))
		soap_serialize__tse__GetPTZPositionSearchResults(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetPTZPositionSearchResults(struct soap *soap, const char *tag, int id, struct _tse__GetPTZPositionSearchResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetPTZPositionSearchResults);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetPTZPositionSearchResults(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResults ** SOAP_FMAC4 soap_in_PointerTo_tse__GetPTZPositionSearchResults(struct soap *soap, const char *tag, struct _tse__GetPTZPositionSearchResults **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetPTZPositionSearchResults **)soap_malloc(soap, sizeof(struct _tse__GetPTZPositionSearchResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetPTZPositionSearchResults(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetPTZPositionSearchResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetPTZPositionSearchResults, sizeof(struct _tse__GetPTZPositionSearchResults), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetPTZPositionSearchResults(struct soap *soap, struct _tse__GetPTZPositionSearchResults *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__GetPTZPositionSearchResults);
	if (soap_out_PointerTo_tse__GetPTZPositionSearchResults(soap, tag?tag:"tse:GetPTZPositionSearchResults", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResults ** SOAP_FMAC4 soap_get_PointerTo_tse__GetPTZPositionSearchResults(struct soap *soap, struct _tse__GetPTZPositionSearchResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetPTZPositionSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindPTZPositionResponse(struct soap *soap, struct _tse__FindPTZPositionResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindPTZPositionResponse))
		soap_serialize__tse__FindPTZPositionResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindPTZPositionResponse(struct soap *soap, const char *tag, int id, struct _tse__FindPTZPositionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindPTZPositionResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindPTZPositionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindPTZPositionResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__FindPTZPositionResponse(struct soap *soap, const char *tag, struct _tse__FindPTZPositionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindPTZPositionResponse **)soap_malloc(soap, sizeof(struct _tse__FindPTZPositionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindPTZPositionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindPTZPositionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindPTZPositionResponse, sizeof(struct _tse__FindPTZPositionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindPTZPositionResponse(struct soap *soap, struct _tse__FindPTZPositionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__FindPTZPositionResponse);
	if (soap_out_PointerTo_tse__FindPTZPositionResponse(soap, tag?tag:"tse:FindPTZPositionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindPTZPositionResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__FindPTZPositionResponse(struct soap *soap, struct _tse__FindPTZPositionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindPTZPositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindPTZPosition(struct soap *soap, struct _tse__FindPTZPosition *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindPTZPosition))
		soap_serialize__tse__FindPTZPosition(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindPTZPosition(struct soap *soap, const char *tag, int id, struct _tse__FindPTZPosition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindPTZPosition);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindPTZPosition(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindPTZPosition ** SOAP_FMAC4 soap_in_PointerTo_tse__FindPTZPosition(struct soap *soap, const char *tag, struct _tse__FindPTZPosition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindPTZPosition **)soap_malloc(soap, sizeof(struct _tse__FindPTZPosition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindPTZPosition(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindPTZPosition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindPTZPosition, sizeof(struct _tse__FindPTZPosition), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindPTZPosition(struct soap *soap, struct _tse__FindPTZPosition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__FindPTZPosition);
	if (soap_out_PointerTo_tse__FindPTZPosition(soap, tag?tag:"tse:FindPTZPosition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindPTZPosition ** SOAP_FMAC4 soap_get_PointerTo_tse__FindPTZPosition(struct soap *soap, struct _tse__FindPTZPosition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindPTZPosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetEventSearchResultsResponse(struct soap *soap, struct _tse__GetEventSearchResultsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetEventSearchResultsResponse))
		soap_serialize__tse__GetEventSearchResultsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetEventSearchResultsResponse(struct soap *soap, const char *tag, int id, struct _tse__GetEventSearchResultsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetEventSearchResultsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetEventSearchResultsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetEventSearchResultsResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetEventSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetEventSearchResultsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetEventSearchResultsResponse **)soap_malloc(soap, sizeof(struct _tse__GetEventSearchResultsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetEventSearchResultsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetEventSearchResultsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetEventSearchResultsResponse, sizeof(struct _tse__GetEventSearchResultsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetEventSearchResultsResponse(struct soap *soap, struct _tse__GetEventSearchResultsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__GetEventSearchResultsResponse);
	if (soap_out_PointerTo_tse__GetEventSearchResultsResponse(soap, tag?tag:"tse:GetEventSearchResultsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetEventSearchResultsResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetEventSearchResultsResponse(struct soap *soap, struct _tse__GetEventSearchResultsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetEventSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetEventSearchResults(struct soap *soap, struct _tse__GetEventSearchResults *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetEventSearchResults))
		soap_serialize__tse__GetEventSearchResults(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetEventSearchResults(struct soap *soap, const char *tag, int id, struct _tse__GetEventSearchResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetEventSearchResults);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetEventSearchResults(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetEventSearchResults ** SOAP_FMAC4 soap_in_PointerTo_tse__GetEventSearchResults(struct soap *soap, const char *tag, struct _tse__GetEventSearchResults **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetEventSearchResults **)soap_malloc(soap, sizeof(struct _tse__GetEventSearchResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetEventSearchResults(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetEventSearchResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetEventSearchResults, sizeof(struct _tse__GetEventSearchResults), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetEventSearchResults(struct soap *soap, struct _tse__GetEventSearchResults *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__GetEventSearchResults);
	if (soap_out_PointerTo_tse__GetEventSearchResults(soap, tag?tag:"tse:GetEventSearchResults", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetEventSearchResults ** SOAP_FMAC4 soap_get_PointerTo_tse__GetEventSearchResults(struct soap *soap, struct _tse__GetEventSearchResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetEventSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindEventsResponse(struct soap *soap, struct _tse__FindEventsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindEventsResponse))
		soap_serialize__tse__FindEventsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindEventsResponse(struct soap *soap, const char *tag, int id, struct _tse__FindEventsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindEventsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindEventsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindEventsResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__FindEventsResponse(struct soap *soap, const char *tag, struct _tse__FindEventsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindEventsResponse **)soap_malloc(soap, sizeof(struct _tse__FindEventsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindEventsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindEventsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindEventsResponse, sizeof(struct _tse__FindEventsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindEventsResponse(struct soap *soap, struct _tse__FindEventsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__FindEventsResponse);
	if (soap_out_PointerTo_tse__FindEventsResponse(soap, tag?tag:"tse:FindEventsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindEventsResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__FindEventsResponse(struct soap *soap, struct _tse__FindEventsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindEventsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindEvents(struct soap *soap, struct _tse__FindEvents *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindEvents))
		soap_serialize__tse__FindEvents(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindEvents(struct soap *soap, const char *tag, int id, struct _tse__FindEvents *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindEvents);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindEvents(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindEvents ** SOAP_FMAC4 soap_in_PointerTo_tse__FindEvents(struct soap *soap, const char *tag, struct _tse__FindEvents **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindEvents **)soap_malloc(soap, sizeof(struct _tse__FindEvents *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindEvents(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindEvents **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindEvents, sizeof(struct _tse__FindEvents), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindEvents(struct soap *soap, struct _tse__FindEvents *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__FindEvents);
	if (soap_out_PointerTo_tse__FindEvents(soap, tag?tag:"tse:FindEvents", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindEvents ** SOAP_FMAC4 soap_get_PointerTo_tse__FindEvents(struct soap *soap, struct _tse__FindEvents **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetRecordingSearchResultsResponse(struct soap *soap, struct _tse__GetRecordingSearchResultsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetRecordingSearchResultsResponse))
		soap_serialize__tse__GetRecordingSearchResultsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetRecordingSearchResultsResponse(struct soap *soap, const char *tag, int id, struct _tse__GetRecordingSearchResultsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetRecordingSearchResultsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetRecordingSearchResultsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResultsResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetRecordingSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetRecordingSearchResultsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetRecordingSearchResultsResponse **)soap_malloc(soap, sizeof(struct _tse__GetRecordingSearchResultsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetRecordingSearchResultsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSearchResultsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingSearchResultsResponse, sizeof(struct _tse__GetRecordingSearchResultsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetRecordingSearchResultsResponse(struct soap *soap, struct _tse__GetRecordingSearchResultsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__GetRecordingSearchResultsResponse);
	if (soap_out_PointerTo_tse__GetRecordingSearchResultsResponse(soap, tag?tag:"tse:GetRecordingSearchResultsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResultsResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetRecordingSearchResultsResponse(struct soap *soap, struct _tse__GetRecordingSearchResultsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetRecordingSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetRecordingSearchResults(struct soap *soap, struct _tse__GetRecordingSearchResults *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetRecordingSearchResults))
		soap_serialize__tse__GetRecordingSearchResults(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetRecordingSearchResults(struct soap *soap, const char *tag, int id, struct _tse__GetRecordingSearchResults *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetRecordingSearchResults);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetRecordingSearchResults(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResults ** SOAP_FMAC4 soap_in_PointerTo_tse__GetRecordingSearchResults(struct soap *soap, const char *tag, struct _tse__GetRecordingSearchResults **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetRecordingSearchResults **)soap_malloc(soap, sizeof(struct _tse__GetRecordingSearchResults *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetRecordingSearchResults(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSearchResults **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingSearchResults, sizeof(struct _tse__GetRecordingSearchResults), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetRecordingSearchResults(struct soap *soap, struct _tse__GetRecordingSearchResults *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__GetRecordingSearchResults);
	if (soap_out_PointerTo_tse__GetRecordingSearchResults(soap, tag?tag:"tse:GetRecordingSearchResults", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResults ** SOAP_FMAC4 soap_get_PointerTo_tse__GetRecordingSearchResults(struct soap *soap, struct _tse__GetRecordingSearchResults **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetRecordingSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindRecordingsResponse(struct soap *soap, struct _tse__FindRecordingsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindRecordingsResponse))
		soap_serialize__tse__FindRecordingsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindRecordingsResponse(struct soap *soap, const char *tag, int id, struct _tse__FindRecordingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindRecordingsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindRecordingsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindRecordingsResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__FindRecordingsResponse(struct soap *soap, const char *tag, struct _tse__FindRecordingsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindRecordingsResponse **)soap_malloc(soap, sizeof(struct _tse__FindRecordingsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindRecordingsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindRecordingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindRecordingsResponse, sizeof(struct _tse__FindRecordingsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindRecordingsResponse(struct soap *soap, struct _tse__FindRecordingsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__FindRecordingsResponse);
	if (soap_out_PointerTo_tse__FindRecordingsResponse(soap, tag?tag:"tse:FindRecordingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindRecordingsResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__FindRecordingsResponse(struct soap *soap, struct _tse__FindRecordingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindRecordingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__FindRecordings(struct soap *soap, struct _tse__FindRecordings *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__FindRecordings))
		soap_serialize__tse__FindRecordings(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__FindRecordings(struct soap *soap, const char *tag, int id, struct _tse__FindRecordings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__FindRecordings);
	if (id < 0)
		return soap->error;
	return soap_out__tse__FindRecordings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__FindRecordings ** SOAP_FMAC4 soap_in_PointerTo_tse__FindRecordings(struct soap *soap, const char *tag, struct _tse__FindRecordings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__FindRecordings **)soap_malloc(soap, sizeof(struct _tse__FindRecordings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__FindRecordings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__FindRecordings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__FindRecordings, sizeof(struct _tse__FindRecordings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__FindRecordings(struct soap *soap, struct _tse__FindRecordings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__FindRecordings);
	if (soap_out_PointerTo_tse__FindRecordings(soap, tag?tag:"tse:FindRecordings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindRecordings ** SOAP_FMAC4 soap_get_PointerTo_tse__FindRecordings(struct soap *soap, struct _tse__FindRecordings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__FindRecordings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetMediaAttributesResponse(struct soap *soap, struct _tse__GetMediaAttributesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetMediaAttributesResponse))
		soap_serialize__tse__GetMediaAttributesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetMediaAttributesResponse(struct soap *soap, const char *tag, int id, struct _tse__GetMediaAttributesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetMediaAttributesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetMediaAttributesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetMediaAttributesResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetMediaAttributesResponse(struct soap *soap, const char *tag, struct _tse__GetMediaAttributesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetMediaAttributesResponse **)soap_malloc(soap, sizeof(struct _tse__GetMediaAttributesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetMediaAttributesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetMediaAttributesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetMediaAttributesResponse, sizeof(struct _tse__GetMediaAttributesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetMediaAttributesResponse(struct soap *soap, struct _tse__GetMediaAttributesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__GetMediaAttributesResponse);
	if (soap_out_PointerTo_tse__GetMediaAttributesResponse(soap, tag?tag:"tse:GetMediaAttributesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMediaAttributesResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetMediaAttributesResponse(struct soap *soap, struct _tse__GetMediaAttributesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetMediaAttributesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetMediaAttributes(struct soap *soap, struct _tse__GetMediaAttributes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetMediaAttributes))
		soap_serialize__tse__GetMediaAttributes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetMediaAttributes(struct soap *soap, const char *tag, int id, struct _tse__GetMediaAttributes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetMediaAttributes);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetMediaAttributes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetMediaAttributes ** SOAP_FMAC4 soap_in_PointerTo_tse__GetMediaAttributes(struct soap *soap, const char *tag, struct _tse__GetMediaAttributes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetMediaAttributes **)soap_malloc(soap, sizeof(struct _tse__GetMediaAttributes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetMediaAttributes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetMediaAttributes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetMediaAttributes, sizeof(struct _tse__GetMediaAttributes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetMediaAttributes(struct soap *soap, struct _tse__GetMediaAttributes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__GetMediaAttributes);
	if (soap_out_PointerTo_tse__GetMediaAttributes(soap, tag?tag:"tse:GetMediaAttributes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMediaAttributes ** SOAP_FMAC4 soap_get_PointerTo_tse__GetMediaAttributes(struct soap *soap, struct _tse__GetMediaAttributes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetMediaAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetRecordingInformationResponse(struct soap *soap, struct _tse__GetRecordingInformationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetRecordingInformationResponse))
		soap_serialize__tse__GetRecordingInformationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetRecordingInformationResponse(struct soap *soap, const char *tag, int id, struct _tse__GetRecordingInformationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetRecordingInformationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetRecordingInformationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetRecordingInformationResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetRecordingInformationResponse(struct soap *soap, const char *tag, struct _tse__GetRecordingInformationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetRecordingInformationResponse **)soap_malloc(soap, sizeof(struct _tse__GetRecordingInformationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetRecordingInformationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingInformationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingInformationResponse, sizeof(struct _tse__GetRecordingInformationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetRecordingInformationResponse(struct soap *soap, struct _tse__GetRecordingInformationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__GetRecordingInformationResponse);
	if (soap_out_PointerTo_tse__GetRecordingInformationResponse(soap, tag?tag:"tse:GetRecordingInformationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingInformationResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetRecordingInformationResponse(struct soap *soap, struct _tse__GetRecordingInformationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetRecordingInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetRecordingInformation(struct soap *soap, struct _tse__GetRecordingInformation *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetRecordingInformation))
		soap_serialize__tse__GetRecordingInformation(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetRecordingInformation(struct soap *soap, const char *tag, int id, struct _tse__GetRecordingInformation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetRecordingInformation);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetRecordingInformation(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetRecordingInformation ** SOAP_FMAC4 soap_in_PointerTo_tse__GetRecordingInformation(struct soap *soap, const char *tag, struct _tse__GetRecordingInformation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetRecordingInformation **)soap_malloc(soap, sizeof(struct _tse__GetRecordingInformation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetRecordingInformation(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingInformation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingInformation, sizeof(struct _tse__GetRecordingInformation), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetRecordingInformation(struct soap *soap, struct _tse__GetRecordingInformation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__GetRecordingInformation);
	if (soap_out_PointerTo_tse__GetRecordingInformation(soap, tag?tag:"tse:GetRecordingInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingInformation ** SOAP_FMAC4 soap_get_PointerTo_tse__GetRecordingInformation(struct soap *soap, struct _tse__GetRecordingInformation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetRecordingInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetRecordingSummaryResponse(struct soap *soap, struct _tse__GetRecordingSummaryResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetRecordingSummaryResponse))
		soap_serialize__tse__GetRecordingSummaryResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetRecordingSummaryResponse(struct soap *soap, const char *tag, int id, struct _tse__GetRecordingSummaryResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetRecordingSummaryResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetRecordingSummaryResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetRecordingSummaryResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetRecordingSummaryResponse(struct soap *soap, const char *tag, struct _tse__GetRecordingSummaryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetRecordingSummaryResponse **)soap_malloc(soap, sizeof(struct _tse__GetRecordingSummaryResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetRecordingSummaryResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSummaryResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingSummaryResponse, sizeof(struct _tse__GetRecordingSummaryResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetRecordingSummaryResponse(struct soap *soap, struct _tse__GetRecordingSummaryResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__GetRecordingSummaryResponse);
	if (soap_out_PointerTo_tse__GetRecordingSummaryResponse(soap, tag?tag:"tse:GetRecordingSummaryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSummaryResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetRecordingSummaryResponse(struct soap *soap, struct _tse__GetRecordingSummaryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetRecordingSummaryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetRecordingSummary(struct soap *soap, struct _tse__GetRecordingSummary *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetRecordingSummary))
		soap_serialize__tse__GetRecordingSummary(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetRecordingSummary(struct soap *soap, const char *tag, int id, struct _tse__GetRecordingSummary *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetRecordingSummary);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetRecordingSummary(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetRecordingSummary ** SOAP_FMAC4 soap_in_PointerTo_tse__GetRecordingSummary(struct soap *soap, const char *tag, struct _tse__GetRecordingSummary **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetRecordingSummary **)soap_malloc(soap, sizeof(struct _tse__GetRecordingSummary *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetRecordingSummary(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSummary **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetRecordingSummary, sizeof(struct _tse__GetRecordingSummary), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetRecordingSummary(struct soap *soap, struct _tse__GetRecordingSummary *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__GetRecordingSummary);
	if (soap_out_PointerTo_tse__GetRecordingSummary(soap, tag?tag:"tse:GetRecordingSummary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSummary ** SOAP_FMAC4 soap_get_PointerTo_tse__GetRecordingSummary(struct soap *soap, struct _tse__GetRecordingSummary **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetRecordingSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetServiceCapabilitiesResponse(struct soap *soap, struct _tse__GetServiceCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetServiceCapabilitiesResponse))
		soap_serialize__tse__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tse__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tse__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tse__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tse__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetServiceCapabilitiesResponse, sizeof(struct _tse__GetServiceCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetServiceCapabilitiesResponse(struct soap *soap, struct _tse__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_tse__GetServiceCapabilitiesResponse(soap, tag?tag:"tse:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tse__GetServiceCapabilitiesResponse(struct soap *soap, struct _tse__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tse__GetServiceCapabilities(struct soap *soap, struct _tse__GetServiceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tse__GetServiceCapabilities))
		soap_serialize__tse__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tse__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _tse__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tse__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__tse__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tse__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tse__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tse__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _tse__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tse__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tse__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tse__GetServiceCapabilities, sizeof(struct _tse__GetServiceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tse__GetServiceCapabilities(struct soap *soap, struct _tse__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tse__GetServiceCapabilities);
	if (soap_out_PointerTo_tse__GetServiceCapabilities(soap, tag?tag:"tse:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tse__GetServiceCapabilities(struct soap *soap, struct _tse__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tse__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__GetReceiverStateResponse(struct soap *soap, struct _trv__GetReceiverStateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__GetReceiverStateResponse))
		soap_serialize__trv__GetReceiverStateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__GetReceiverStateResponse(struct soap *soap, const char *tag, int id, struct _trv__GetReceiverStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__GetReceiverStateResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trv__GetReceiverStateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__GetReceiverStateResponse ** SOAP_FMAC4 soap_in_PointerTo_trv__GetReceiverStateResponse(struct soap *soap, const char *tag, struct _trv__GetReceiverStateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__GetReceiverStateResponse **)soap_malloc(soap, sizeof(struct _trv__GetReceiverStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__GetReceiverStateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceiverStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceiverStateResponse, sizeof(struct _trv__GetReceiverStateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__GetReceiverStateResponse(struct soap *soap, struct _trv__GetReceiverStateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trv__GetReceiverStateResponse);
	if (soap_out_PointerTo_trv__GetReceiverStateResponse(soap, tag?tag:"trv:GetReceiverStateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiverStateResponse ** SOAP_FMAC4 soap_get_PointerTo_trv__GetReceiverStateResponse(struct soap *soap, struct _trv__GetReceiverStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__GetReceiverStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__GetReceiverState(struct soap *soap, struct _trv__GetReceiverState *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__GetReceiverState))
		soap_serialize__trv__GetReceiverState(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__GetReceiverState(struct soap *soap, const char *tag, int id, struct _trv__GetReceiverState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__GetReceiverState);
	if (id < 0)
		return soap->error;
	return soap_out__trv__GetReceiverState(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__GetReceiverState ** SOAP_FMAC4 soap_in_PointerTo_trv__GetReceiverState(struct soap *soap, const char *tag, struct _trv__GetReceiverState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__GetReceiverState **)soap_malloc(soap, sizeof(struct _trv__GetReceiverState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__GetReceiverState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceiverState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceiverState, sizeof(struct _trv__GetReceiverState), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__GetReceiverState(struct soap *soap, struct _trv__GetReceiverState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trv__GetReceiverState);
	if (soap_out_PointerTo_trv__GetReceiverState(soap, tag?tag:"trv:GetReceiverState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiverState ** SOAP_FMAC4 soap_get_PointerTo_trv__GetReceiverState(struct soap *soap, struct _trv__GetReceiverState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__GetReceiverState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__SetReceiverModeResponse(struct soap *soap, struct _trv__SetReceiverModeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__SetReceiverModeResponse))
		soap_serialize__trv__SetReceiverModeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__SetReceiverModeResponse(struct soap *soap, const char *tag, int id, struct _trv__SetReceiverModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__SetReceiverModeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trv__SetReceiverModeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__SetReceiverModeResponse ** SOAP_FMAC4 soap_in_PointerTo_trv__SetReceiverModeResponse(struct soap *soap, const char *tag, struct _trv__SetReceiverModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__SetReceiverModeResponse **)soap_malloc(soap, sizeof(struct _trv__SetReceiverModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__SetReceiverModeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__SetReceiverModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__SetReceiverModeResponse, sizeof(struct _trv__SetReceiverModeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__SetReceiverModeResponse(struct soap *soap, struct _trv__SetReceiverModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trv__SetReceiverModeResponse);
	if (soap_out_PointerTo_trv__SetReceiverModeResponse(soap, tag?tag:"trv:SetReceiverModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__SetReceiverModeResponse ** SOAP_FMAC4 soap_get_PointerTo_trv__SetReceiverModeResponse(struct soap *soap, struct _trv__SetReceiverModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__SetReceiverModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__SetReceiverMode(struct soap *soap, struct _trv__SetReceiverMode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__SetReceiverMode))
		soap_serialize__trv__SetReceiverMode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__SetReceiverMode(struct soap *soap, const char *tag, int id, struct _trv__SetReceiverMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__SetReceiverMode);
	if (id < 0)
		return soap->error;
	return soap_out__trv__SetReceiverMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__SetReceiverMode ** SOAP_FMAC4 soap_in_PointerTo_trv__SetReceiverMode(struct soap *soap, const char *tag, struct _trv__SetReceiverMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__SetReceiverMode **)soap_malloc(soap, sizeof(struct _trv__SetReceiverMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__SetReceiverMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__SetReceiverMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__SetReceiverMode, sizeof(struct _trv__SetReceiverMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__SetReceiverMode(struct soap *soap, struct _trv__SetReceiverMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trv__SetReceiverMode);
	if (soap_out_PointerTo_trv__SetReceiverMode(soap, tag?tag:"trv:SetReceiverMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__SetReceiverMode ** SOAP_FMAC4 soap_get_PointerTo_trv__SetReceiverMode(struct soap *soap, struct _trv__SetReceiverMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__SetReceiverMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__ConfigureReceiverResponse(struct soap *soap, struct _trv__ConfigureReceiverResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__ConfigureReceiverResponse))
		soap_serialize__trv__ConfigureReceiverResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__ConfigureReceiverResponse(struct soap *soap, const char *tag, int id, struct _trv__ConfigureReceiverResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__ConfigureReceiverResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trv__ConfigureReceiverResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__ConfigureReceiverResponse ** SOAP_FMAC4 soap_in_PointerTo_trv__ConfigureReceiverResponse(struct soap *soap, const char *tag, struct _trv__ConfigureReceiverResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__ConfigureReceiverResponse **)soap_malloc(soap, sizeof(struct _trv__ConfigureReceiverResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__ConfigureReceiverResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__ConfigureReceiverResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__ConfigureReceiverResponse, sizeof(struct _trv__ConfigureReceiverResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__ConfigureReceiverResponse(struct soap *soap, struct _trv__ConfigureReceiverResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trv__ConfigureReceiverResponse);
	if (soap_out_PointerTo_trv__ConfigureReceiverResponse(soap, tag?tag:"trv:ConfigureReceiverResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__ConfigureReceiverResponse ** SOAP_FMAC4 soap_get_PointerTo_trv__ConfigureReceiverResponse(struct soap *soap, struct _trv__ConfigureReceiverResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__ConfigureReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__ConfigureReceiver(struct soap *soap, struct _trv__ConfigureReceiver *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__ConfigureReceiver))
		soap_serialize__trv__ConfigureReceiver(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__ConfigureReceiver(struct soap *soap, const char *tag, int id, struct _trv__ConfigureReceiver *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__ConfigureReceiver);
	if (id < 0)
		return soap->error;
	return soap_out__trv__ConfigureReceiver(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__ConfigureReceiver ** SOAP_FMAC4 soap_in_PointerTo_trv__ConfigureReceiver(struct soap *soap, const char *tag, struct _trv__ConfigureReceiver **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__ConfigureReceiver **)soap_malloc(soap, sizeof(struct _trv__ConfigureReceiver *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__ConfigureReceiver(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__ConfigureReceiver **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__ConfigureReceiver, sizeof(struct _trv__ConfigureReceiver), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__ConfigureReceiver(struct soap *soap, struct _trv__ConfigureReceiver *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trv__ConfigureReceiver);
	if (soap_out_PointerTo_trv__ConfigureReceiver(soap, tag?tag:"trv:ConfigureReceiver", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__ConfigureReceiver ** SOAP_FMAC4 soap_get_PointerTo_trv__ConfigureReceiver(struct soap *soap, struct _trv__ConfigureReceiver **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__ConfigureReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__DeleteReceiverResponse(struct soap *soap, struct _trv__DeleteReceiverResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__DeleteReceiverResponse))
		soap_serialize__trv__DeleteReceiverResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__DeleteReceiverResponse(struct soap *soap, const char *tag, int id, struct _trv__DeleteReceiverResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__DeleteReceiverResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trv__DeleteReceiverResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__DeleteReceiverResponse ** SOAP_FMAC4 soap_in_PointerTo_trv__DeleteReceiverResponse(struct soap *soap, const char *tag, struct _trv__DeleteReceiverResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__DeleteReceiverResponse **)soap_malloc(soap, sizeof(struct _trv__DeleteReceiverResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__DeleteReceiverResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__DeleteReceiverResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__DeleteReceiverResponse, sizeof(struct _trv__DeleteReceiverResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__DeleteReceiverResponse(struct soap *soap, struct _trv__DeleteReceiverResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trv__DeleteReceiverResponse);
	if (soap_out_PointerTo_trv__DeleteReceiverResponse(soap, tag?tag:"trv:DeleteReceiverResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__DeleteReceiverResponse ** SOAP_FMAC4 soap_get_PointerTo_trv__DeleteReceiverResponse(struct soap *soap, struct _trv__DeleteReceiverResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__DeleteReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__DeleteReceiver(struct soap *soap, struct _trv__DeleteReceiver *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__DeleteReceiver))
		soap_serialize__trv__DeleteReceiver(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__DeleteReceiver(struct soap *soap, const char *tag, int id, struct _trv__DeleteReceiver *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__DeleteReceiver);
	if (id < 0)
		return soap->error;
	return soap_out__trv__DeleteReceiver(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__DeleteReceiver ** SOAP_FMAC4 soap_in_PointerTo_trv__DeleteReceiver(struct soap *soap, const char *tag, struct _trv__DeleteReceiver **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__DeleteReceiver **)soap_malloc(soap, sizeof(struct _trv__DeleteReceiver *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__DeleteReceiver(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__DeleteReceiver **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__DeleteReceiver, sizeof(struct _trv__DeleteReceiver), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__DeleteReceiver(struct soap *soap, struct _trv__DeleteReceiver *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trv__DeleteReceiver);
	if (soap_out_PointerTo_trv__DeleteReceiver(soap, tag?tag:"trv:DeleteReceiver", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__DeleteReceiver ** SOAP_FMAC4 soap_get_PointerTo_trv__DeleteReceiver(struct soap *soap, struct _trv__DeleteReceiver **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__DeleteReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__CreateReceiverResponse(struct soap *soap, struct _trv__CreateReceiverResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__CreateReceiverResponse))
		soap_serialize__trv__CreateReceiverResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__CreateReceiverResponse(struct soap *soap, const char *tag, int id, struct _trv__CreateReceiverResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__CreateReceiverResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trv__CreateReceiverResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__CreateReceiverResponse ** SOAP_FMAC4 soap_in_PointerTo_trv__CreateReceiverResponse(struct soap *soap, const char *tag, struct _trv__CreateReceiverResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__CreateReceiverResponse **)soap_malloc(soap, sizeof(struct _trv__CreateReceiverResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__CreateReceiverResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__CreateReceiverResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__CreateReceiverResponse, sizeof(struct _trv__CreateReceiverResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__CreateReceiverResponse(struct soap *soap, struct _trv__CreateReceiverResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trv__CreateReceiverResponse);
	if (soap_out_PointerTo_trv__CreateReceiverResponse(soap, tag?tag:"trv:CreateReceiverResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__CreateReceiverResponse ** SOAP_FMAC4 soap_get_PointerTo_trv__CreateReceiverResponse(struct soap *soap, struct _trv__CreateReceiverResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__CreateReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__CreateReceiver(struct soap *soap, struct _trv__CreateReceiver *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__CreateReceiver))
		soap_serialize__trv__CreateReceiver(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__CreateReceiver(struct soap *soap, const char *tag, int id, struct _trv__CreateReceiver *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__CreateReceiver);
	if (id < 0)
		return soap->error;
	return soap_out__trv__CreateReceiver(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__CreateReceiver ** SOAP_FMAC4 soap_in_PointerTo_trv__CreateReceiver(struct soap *soap, const char *tag, struct _trv__CreateReceiver **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__CreateReceiver **)soap_malloc(soap, sizeof(struct _trv__CreateReceiver *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__CreateReceiver(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__CreateReceiver **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__CreateReceiver, sizeof(struct _trv__CreateReceiver), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__CreateReceiver(struct soap *soap, struct _trv__CreateReceiver *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trv__CreateReceiver);
	if (soap_out_PointerTo_trv__CreateReceiver(soap, tag?tag:"trv:CreateReceiver", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__CreateReceiver ** SOAP_FMAC4 soap_get_PointerTo_trv__CreateReceiver(struct soap *soap, struct _trv__CreateReceiver **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__CreateReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__GetReceiverResponse(struct soap *soap, struct _trv__GetReceiverResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__GetReceiverResponse))
		soap_serialize__trv__GetReceiverResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__GetReceiverResponse(struct soap *soap, const char *tag, int id, struct _trv__GetReceiverResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__GetReceiverResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trv__GetReceiverResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__GetReceiverResponse ** SOAP_FMAC4 soap_in_PointerTo_trv__GetReceiverResponse(struct soap *soap, const char *tag, struct _trv__GetReceiverResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__GetReceiverResponse **)soap_malloc(soap, sizeof(struct _trv__GetReceiverResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__GetReceiverResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceiverResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceiverResponse, sizeof(struct _trv__GetReceiverResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__GetReceiverResponse(struct soap *soap, struct _trv__GetReceiverResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trv__GetReceiverResponse);
	if (soap_out_PointerTo_trv__GetReceiverResponse(soap, tag?tag:"trv:GetReceiverResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiverResponse ** SOAP_FMAC4 soap_get_PointerTo_trv__GetReceiverResponse(struct soap *soap, struct _trv__GetReceiverResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__GetReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__GetReceiver(struct soap *soap, struct _trv__GetReceiver *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__GetReceiver))
		soap_serialize__trv__GetReceiver(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__GetReceiver(struct soap *soap, const char *tag, int id, struct _trv__GetReceiver *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__GetReceiver);
	if (id < 0)
		return soap->error;
	return soap_out__trv__GetReceiver(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__GetReceiver ** SOAP_FMAC4 soap_in_PointerTo_trv__GetReceiver(struct soap *soap, const char *tag, struct _trv__GetReceiver **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__GetReceiver **)soap_malloc(soap, sizeof(struct _trv__GetReceiver *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__GetReceiver(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceiver **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceiver, sizeof(struct _trv__GetReceiver), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__GetReceiver(struct soap *soap, struct _trv__GetReceiver *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trv__GetReceiver);
	if (soap_out_PointerTo_trv__GetReceiver(soap, tag?tag:"trv:GetReceiver", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiver ** SOAP_FMAC4 soap_get_PointerTo_trv__GetReceiver(struct soap *soap, struct _trv__GetReceiver **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__GetReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__GetReceiversResponse(struct soap *soap, struct _trv__GetReceiversResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__GetReceiversResponse))
		soap_serialize__trv__GetReceiversResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__GetReceiversResponse(struct soap *soap, const char *tag, int id, struct _trv__GetReceiversResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__GetReceiversResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trv__GetReceiversResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__GetReceiversResponse ** SOAP_FMAC4 soap_in_PointerTo_trv__GetReceiversResponse(struct soap *soap, const char *tag, struct _trv__GetReceiversResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__GetReceiversResponse **)soap_malloc(soap, sizeof(struct _trv__GetReceiversResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__GetReceiversResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceiversResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceiversResponse, sizeof(struct _trv__GetReceiversResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__GetReceiversResponse(struct soap *soap, struct _trv__GetReceiversResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trv__GetReceiversResponse);
	if (soap_out_PointerTo_trv__GetReceiversResponse(soap, tag?tag:"trv:GetReceiversResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiversResponse ** SOAP_FMAC4 soap_get_PointerTo_trv__GetReceiversResponse(struct soap *soap, struct _trv__GetReceiversResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__GetReceiversResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__GetReceivers(struct soap *soap, struct _trv__GetReceivers *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__GetReceivers))
		soap_serialize__trv__GetReceivers(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__GetReceivers(struct soap *soap, const char *tag, int id, struct _trv__GetReceivers *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__GetReceivers);
	if (id < 0)
		return soap->error;
	return soap_out__trv__GetReceivers(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__GetReceivers ** SOAP_FMAC4 soap_in_PointerTo_trv__GetReceivers(struct soap *soap, const char *tag, struct _trv__GetReceivers **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__GetReceivers **)soap_malloc(soap, sizeof(struct _trv__GetReceivers *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__GetReceivers(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceivers **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetReceivers, sizeof(struct _trv__GetReceivers), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__GetReceivers(struct soap *soap, struct _trv__GetReceivers *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trv__GetReceivers);
	if (soap_out_PointerTo_trv__GetReceivers(soap, tag?tag:"trv:GetReceivers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceivers ** SOAP_FMAC4 soap_get_PointerTo_trv__GetReceivers(struct soap *soap, struct _trv__GetReceivers **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__GetReceivers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__GetServiceCapabilitiesResponse(struct soap *soap, struct _trv__GetServiceCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__GetServiceCapabilitiesResponse))
		soap_serialize__trv__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _trv__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trv__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_trv__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trv__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _trv__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetServiceCapabilitiesResponse, sizeof(struct _trv__GetServiceCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__GetServiceCapabilitiesResponse(struct soap *soap, struct _trv__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trv__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_trv__GetServiceCapabilitiesResponse(soap, tag?tag:"trv:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_trv__GetServiceCapabilitiesResponse(struct soap *soap, struct _trv__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trv__GetServiceCapabilities(struct soap *soap, struct _trv__GetServiceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trv__GetServiceCapabilities))
		soap_serialize__trv__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trv__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _trv__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trv__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__trv__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_trv__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trv__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trv__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _trv__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trv__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trv__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trv__GetServiceCapabilities, sizeof(struct _trv__GetServiceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trv__GetServiceCapabilities(struct soap *soap, struct _trv__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trv__GetServiceCapabilities);
	if (soap_out_PointerTo_trv__GetServiceCapabilities(soap, tag?tag:"trv:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_trv__GetServiceCapabilities(struct soap *soap, struct _trv__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trv__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetSnapshotUriResponse))
		soap_serialize__trt__GetSnapshotUriResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, int id, struct _trt__GetSnapshotUriResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetSnapshotUriResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetSnapshotUriResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, const char *tag, struct _trt__GetSnapshotUriResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetSnapshotUriResponse **)soap_malloc(soap, sizeof(struct _trt__GetSnapshotUriResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetSnapshotUriResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetSnapshotUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetSnapshotUriResponse, sizeof(struct _trt__GetSnapshotUriResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetSnapshotUriResponse);
	if (soap_out_PointerTo_trt__GetSnapshotUriResponse(soap, tag?tag:"trt:GetSnapshotUriResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetSnapshotUriResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetSnapshotUriResponse(struct soap *soap, struct _trt__GetSnapshotUriResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetSnapshotUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetSnapshotUri))
		soap_serialize__trt__GetSnapshotUri(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetSnapshotUri(struct soap *soap, const char *tag, int id, struct _trt__GetSnapshotUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetSnapshotUri);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetSnapshotUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetSnapshotUri ** SOAP_FMAC4 soap_in_PointerTo_trt__GetSnapshotUri(struct soap *soap, const char *tag, struct _trt__GetSnapshotUri **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetSnapshotUri **)soap_malloc(soap, sizeof(struct _trt__GetSnapshotUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetSnapshotUri(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetSnapshotUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetSnapshotUri, sizeof(struct _trt__GetSnapshotUri), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetSnapshotUri);
	if (soap_out_PointerTo_trt__GetSnapshotUri(soap, tag?tag:"trt:GetSnapshotUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetSnapshotUri ** SOAP_FMAC4 soap_get_PointerTo_trt__GetSnapshotUri(struct soap *soap, struct _trt__GetSnapshotUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetSnapshotUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, struct _trt__SetSynchronizationPointResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetSynchronizationPointResponse))
		soap_serialize__trt__SetSynchronizationPointResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, const char *tag, int id, struct _trt__SetSynchronizationPointResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetSynchronizationPointResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetSynchronizationPointResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPointResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, const char *tag, struct _trt__SetSynchronizationPointResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetSynchronizationPointResponse **)soap_malloc(soap, sizeof(struct _trt__SetSynchronizationPointResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetSynchronizationPointResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetSynchronizationPointResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetSynchronizationPointResponse, sizeof(struct _trt__SetSynchronizationPointResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, struct _trt__SetSynchronizationPointResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetSynchronizationPointResponse);
	if (soap_out_PointerTo_trt__SetSynchronizationPointResponse(soap, tag?tag:"trt:SetSynchronizationPointResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPointResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetSynchronizationPointResponse(struct soap *soap, struct _trt__SetSynchronizationPointResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetSynchronizationPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, struct _trt__SetSynchronizationPoint *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetSynchronizationPoint))
		soap_serialize__trt__SetSynchronizationPoint(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, struct _trt__SetSynchronizationPoint *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetSynchronizationPoint);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetSynchronizationPoint(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPoint ** SOAP_FMAC4 soap_in_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, const char *tag, struct _trt__SetSynchronizationPoint **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetSynchronizationPoint **)soap_malloc(soap, sizeof(struct _trt__SetSynchronizationPoint *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetSynchronizationPoint(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetSynchronizationPoint **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetSynchronizationPoint, sizeof(struct _trt__SetSynchronizationPoint), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, struct _trt__SetSynchronizationPoint *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetSynchronizationPoint);
	if (soap_out_PointerTo_trt__SetSynchronizationPoint(soap, tag?tag:"trt:SetSynchronizationPoint", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetSynchronizationPoint ** SOAP_FMAC4 soap_get_PointerTo_trt__SetSynchronizationPoint(struct soap *soap, struct _trt__SetSynchronizationPoint **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetSynchronizationPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, struct _trt__StopMulticastStreamingResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StopMulticastStreamingResponse))
		soap_serialize__trt__StopMulticastStreamingResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, const char *tag, int id, struct _trt__StopMulticastStreamingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StopMulticastStreamingResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__StopMulticastStreamingResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__StopMulticastStreamingResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, const char *tag, struct _trt__StopMulticastStreamingResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__StopMulticastStreamingResponse **)soap_malloc(soap, sizeof(struct _trt__StopMulticastStreamingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__StopMulticastStreamingResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__StopMulticastStreamingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StopMulticastStreamingResponse, sizeof(struct _trt__StopMulticastStreamingResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, struct _trt__StopMulticastStreamingResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__StopMulticastStreamingResponse);
	if (soap_out_PointerTo_trt__StopMulticastStreamingResponse(soap, tag?tag:"trt:StopMulticastStreamingResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StopMulticastStreamingResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__StopMulticastStreamingResponse(struct soap *soap, struct _trt__StopMulticastStreamingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StopMulticastStreamingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StopMulticastStreaming(struct soap *soap, struct _trt__StopMulticastStreaming *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StopMulticastStreaming))
		soap_serialize__trt__StopMulticastStreaming(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StopMulticastStreaming(struct soap *soap, const char *tag, int id, struct _trt__StopMulticastStreaming *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StopMulticastStreaming);
	if (id < 0)
		return soap->error;
	return soap_out__trt__StopMulticastStreaming(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__StopMulticastStreaming ** SOAP_FMAC4 soap_in_PointerTo_trt__StopMulticastStreaming(struct soap *soap, const char *tag, struct _trt__StopMulticastStreaming **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__StopMulticastStreaming **)soap_malloc(soap, sizeof(struct _trt__StopMulticastStreaming *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__StopMulticastStreaming(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__StopMulticastStreaming **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StopMulticastStreaming, sizeof(struct _trt__StopMulticastStreaming), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StopMulticastStreaming(struct soap *soap, struct _trt__StopMulticastStreaming *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__StopMulticastStreaming);
	if (soap_out_PointerTo_trt__StopMulticastStreaming(soap, tag?tag:"trt:StopMulticastStreaming", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StopMulticastStreaming ** SOAP_FMAC4 soap_get_PointerTo_trt__StopMulticastStreaming(struct soap *soap, struct _trt__StopMulticastStreaming **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StopMulticastStreaming(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, struct _trt__StartMulticastStreamingResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StartMulticastStreamingResponse))
		soap_serialize__trt__StartMulticastStreamingResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, const char *tag, int id, struct _trt__StartMulticastStreamingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StartMulticastStreamingResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__StartMulticastStreamingResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__StartMulticastStreamingResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, const char *tag, struct _trt__StartMulticastStreamingResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__StartMulticastStreamingResponse **)soap_malloc(soap, sizeof(struct _trt__StartMulticastStreamingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__StartMulticastStreamingResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__StartMulticastStreamingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StartMulticastStreamingResponse, sizeof(struct _trt__StartMulticastStreamingResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, struct _trt__StartMulticastStreamingResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__StartMulticastStreamingResponse);
	if (soap_out_PointerTo_trt__StartMulticastStreamingResponse(soap, tag?tag:"trt:StartMulticastStreamingResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StartMulticastStreamingResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__StartMulticastStreamingResponse(struct soap *soap, struct _trt__StartMulticastStreamingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StartMulticastStreamingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__StartMulticastStreaming(struct soap *soap, struct _trt__StartMulticastStreaming *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__StartMulticastStreaming))
		soap_serialize__trt__StartMulticastStreaming(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__StartMulticastStreaming(struct soap *soap, const char *tag, int id, struct _trt__StartMulticastStreaming *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__StartMulticastStreaming);
	if (id < 0)
		return soap->error;
	return soap_out__trt__StartMulticastStreaming(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__StartMulticastStreaming ** SOAP_FMAC4 soap_in_PointerTo_trt__StartMulticastStreaming(struct soap *soap, const char *tag, struct _trt__StartMulticastStreaming **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__StartMulticastStreaming **)soap_malloc(soap, sizeof(struct _trt__StartMulticastStreaming *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__StartMulticastStreaming(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__StartMulticastStreaming **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__StartMulticastStreaming, sizeof(struct _trt__StartMulticastStreaming), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__StartMulticastStreaming(struct soap *soap, struct _trt__StartMulticastStreaming *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__StartMulticastStreaming);
	if (soap_out_PointerTo_trt__StartMulticastStreaming(soap, tag?tag:"trt:StartMulticastStreaming", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__StartMulticastStreaming ** SOAP_FMAC4 soap_get_PointerTo_trt__StartMulticastStreaming(struct soap *soap, struct _trt__StartMulticastStreaming **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__StartMulticastStreaming(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetStreamUriResponse(struct soap *soap, struct _trt__GetStreamUriResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetStreamUriResponse))
		soap_serialize__trt__GetStreamUriResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetStreamUriResponse(struct soap *soap, const char *tag, int id, struct _trt__GetStreamUriResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetStreamUriResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetStreamUriResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetStreamUriResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetStreamUriResponse(struct soap *soap, const char *tag, struct _trt__GetStreamUriResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetStreamUriResponse **)soap_malloc(soap, sizeof(struct _trt__GetStreamUriResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetStreamUriResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetStreamUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetStreamUriResponse, sizeof(struct _trt__GetStreamUriResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetStreamUriResponse(struct soap *soap, struct _trt__GetStreamUriResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetStreamUriResponse);
	if (soap_out_PointerTo_trt__GetStreamUriResponse(soap, tag?tag:"trt:GetStreamUriResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetStreamUriResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetStreamUriResponse(struct soap *soap, struct _trt__GetStreamUriResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetStreamUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetStreamUri(struct soap *soap, struct _trt__GetStreamUri *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetStreamUri))
		soap_serialize__trt__GetStreamUri(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetStreamUri(struct soap *soap, const char *tag, int id, struct _trt__GetStreamUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetStreamUri);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetStreamUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetStreamUri ** SOAP_FMAC4 soap_in_PointerTo_trt__GetStreamUri(struct soap *soap, const char *tag, struct _trt__GetStreamUri **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetStreamUri **)soap_malloc(soap, sizeof(struct _trt__GetStreamUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetStreamUri(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetStreamUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetStreamUri, sizeof(struct _trt__GetStreamUri), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetStreamUri(struct soap *soap, struct _trt__GetStreamUri *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetStreamUri);
	if (soap_out_PointerTo_trt__GetStreamUri(soap, tag?tag:"trt:GetStreamUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetStreamUri ** SOAP_FMAC4 soap_get_PointerTo_trt__GetStreamUri(struct soap *soap, struct _trt__GetStreamUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetStreamUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse))
		soap_serialize__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, const char *tag, int id, struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, const char *tag, struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse **)soap_malloc(soap, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse);
	if (soap_out_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, tag?tag:"trt:GetGuaranteedNumberOfVideoEncoderInstancesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstancesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances))
		soap_serialize__trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const char *tag, int id, struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstances ** SOAP_FMAC4 soap_in_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, const char *tag, struct _trt__GetGuaranteedNumberOfVideoEncoderInstances **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstances **)soap_malloc(soap, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetGuaranteedNumberOfVideoEncoderInstances **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetGuaranteedNumberOfVideoEncoderInstances, sizeof(struct _trt__GetGuaranteedNumberOfVideoEncoderInstances), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstances *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances);
	if (soap_out_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag?tag:"trt:GetGuaranteedNumberOfVideoEncoderInstances", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetGuaranteedNumberOfVideoEncoderInstances ** SOAP_FMAC4 soap_get_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(struct soap *soap, struct _trt__GetGuaranteedNumberOfVideoEncoderInstances **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetGuaranteedNumberOfVideoEncoderInstances(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse))
		soap_serialize__trt__GetAudioDecoderConfigurationOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioDecoderConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioDecoderConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioDecoderConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioDecoderConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioDecoderConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptionsResponse, sizeof(struct _trt__GetAudioDecoderConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(soap, tag?tag:"trt:GetAudioDecoderConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions))
		soap_serialize__trt__GetAudioDecoderConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct _trt__GetAudioDecoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioDecoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioDecoderConfigurationOptions **)soap_malloc(soap, sizeof(struct _trt__GetAudioDecoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioDecoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurationOptions, sizeof(struct _trt__GetAudioDecoderConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfigurationOptions);
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurationOptions(soap, tag?tag:"trt:GetAudioDecoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioDecoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse))
		soap_serialize__trt__GetAudioOutputConfigurationOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioOutputConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioOutputConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioOutputConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioOutputConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioOutputConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptionsResponse, sizeof(struct _trt__GetAudioOutputConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(soap, tag?tag:"trt:GetAudioOutputConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions))
		soap_serialize__trt__GetAudioOutputConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, struct _trt__GetAudioOutputConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioOutputConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioOutputConfigurationOptions **)soap_malloc(soap, sizeof(struct _trt__GetAudioOutputConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioOutputConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurationOptions, sizeof(struct _trt__GetAudioOutputConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputConfigurationOptions);
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurationOptions(soap, tag?tag:"trt:GetAudioOutputConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfigurationOptions(struct soap *soap, struct _trt__GetAudioOutputConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse))
		soap_serialize__trt__GetMetadataConfigurationOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetMetadataConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetMetadataConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetMetadataConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _trt__GetMetadataConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetMetadataConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurationOptionsResponse, sizeof(struct _trt__GetMetadataConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetMetadataConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetMetadataConfigurationOptionsResponse(soap, tag?tag:"trt:GetMetadataConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfigurationOptionsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, struct _trt__GetMetadataConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfigurationOptions))
		soap_serialize__trt__GetMetadataConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, const char *tag, int id, struct _trt__GetMetadataConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetMetadataConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetMetadataConfigurationOptions **)soap_malloc(soap, sizeof(struct _trt__GetMetadataConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetMetadataConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurationOptions, sizeof(struct _trt__GetMetadataConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, struct _trt__GetMetadataConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetMetadataConfigurationOptions);
	if (soap_out_PointerTo_trt__GetMetadataConfigurationOptions(soap, tag?tag:"trt:GetMetadataConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfigurationOptions(struct soap *soap, struct _trt__GetMetadataConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse))
		soap_serialize__trt__GetAudioEncoderConfigurationOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioEncoderConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioEncoderConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioEncoderConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioEncoderConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioEncoderConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptionsResponse, sizeof(struct _trt__GetAudioEncoderConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(soap, tag?tag:"trt:GetAudioEncoderConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions))
		soap_serialize__trt__GetAudioEncoderConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct _trt__GetAudioEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioEncoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioEncoderConfigurationOptions **)soap_malloc(soap, sizeof(struct _trt__GetAudioEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioEncoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurationOptions, sizeof(struct _trt__GetAudioEncoderConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfigurationOptions);
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurationOptions(soap, tag?tag:"trt:GetAudioEncoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfigurationOptions(struct soap *soap, struct _trt__GetAudioEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse))
		soap_serialize__trt__GetAudioSourceConfigurationOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioSourceConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioSourceConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioSourceConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioSourceConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioSourceConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptionsResponse, sizeof(struct _trt__GetAudioSourceConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(soap, tag?tag:"trt:GetAudioSourceConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, struct _trt__GetAudioSourceConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions))
		soap_serialize__trt__GetAudioSourceConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, struct _trt__GetAudioSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioSourceConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioSourceConfigurationOptions **)soap_malloc(soap, sizeof(struct _trt__GetAudioSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioSourceConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurationOptions, sizeof(struct _trt__GetAudioSourceConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, struct _trt__GetAudioSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourceConfigurationOptions);
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurationOptions(soap, tag?tag:"trt:GetAudioSourceConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfigurationOptions(struct soap *soap, struct _trt__GetAudioSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse))
		soap_serialize__trt__GetVideoEncoderConfigurationOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoEncoderConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoEncoderConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoEncoderConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoEncoderConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoEncoderConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptionsResponse, sizeof(struct _trt__GetVideoEncoderConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(soap, tag?tag:"trt:GetVideoEncoderConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions))
		soap_serialize__trt__GetVideoEncoderConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, int id, struct _trt__GetVideoEncoderConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoEncoderConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoEncoderConfigurationOptions **)soap_malloc(soap, sizeof(struct _trt__GetVideoEncoderConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoEncoderConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationOptions, sizeof(struct _trt__GetVideoEncoderConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurationOptions);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, tag?tag:"trt:GetVideoEncoderConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurationOptions(struct soap *soap, struct _trt__GetVideoEncoderConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse))
		soap_serialize__trt__GetVideoSourceConfigurationOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoSourceConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoSourceConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoSourceConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoSourceConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoSourceConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptionsResponse, sizeof(struct _trt__GetVideoSourceConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse);
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(soap, tag?tag:"trt:GetVideoSourceConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, struct _trt__GetVideoSourceConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions))
		soap_serialize__trt__GetVideoSourceConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, struct _trt__GetVideoSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoSourceConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoSourceConfigurationOptions **)soap_malloc(soap, sizeof(struct _trt__GetVideoSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoSourceConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurationOptions, sizeof(struct _trt__GetVideoSourceConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, struct _trt__GetVideoSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourceConfigurationOptions);
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurationOptions(soap, tag?tag:"trt:GetVideoSourceConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfigurationOptions(struct soap *soap, struct _trt__GetVideoSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__SetAudioDecoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse))
		soap_serialize__trt__SetAudioDecoderConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__SetAudioDecoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetAudioDecoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetAudioDecoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetAudioDecoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__SetAudioDecoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetAudioDecoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetAudioDecoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioDecoderConfigurationResponse, sizeof(struct _trt__SetAudioDecoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__SetAudioDecoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioDecoderConfigurationResponse);
	if (soap_out_PointerTo_trt__SetAudioDecoderConfigurationResponse(soap, tag?tag:"trt:SetAudioDecoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__SetAudioDecoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, struct _trt__SetAudioDecoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioDecoderConfiguration))
		soap_serialize__trt__SetAudioDecoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__SetAudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioDecoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetAudioDecoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetAudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, const char *tag, struct _trt__SetAudioDecoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetAudioDecoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__SetAudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetAudioDecoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioDecoderConfiguration, sizeof(struct _trt__SetAudioDecoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, struct _trt__SetAudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioDecoderConfiguration);
	if (soap_out_PointerTo_trt__SetAudioDecoderConfiguration(soap, tag?tag:"trt:SetAudioDecoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetAudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioDecoderConfiguration(struct soap *soap, struct _trt__SetAudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioOutputConfigurationResponse(struct soap *soap, struct _trt__SetAudioOutputConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioOutputConfigurationResponse))
		soap_serialize__trt__SetAudioOutputConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__SetAudioOutputConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioOutputConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetAudioOutputConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetAudioOutputConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetAudioOutputConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__SetAudioOutputConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetAudioOutputConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioOutputConfigurationResponse, sizeof(struct _trt__SetAudioOutputConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioOutputConfigurationResponse(struct soap *soap, struct _trt__SetAudioOutputConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioOutputConfigurationResponse);
	if (soap_out_PointerTo_trt__SetAudioOutputConfigurationResponse(soap, tag?tag:"trt:SetAudioOutputConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioOutputConfigurationResponse(struct soap *soap, struct _trt__SetAudioOutputConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, struct _trt__SetAudioOutputConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioOutputConfiguration))
		soap_serialize__trt__SetAudioOutputConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, struct _trt__SetAudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioOutputConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetAudioOutputConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetAudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, const char *tag, struct _trt__SetAudioOutputConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetAudioOutputConfiguration **)soap_malloc(soap, sizeof(struct _trt__SetAudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetAudioOutputConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioOutputConfiguration, sizeof(struct _trt__SetAudioOutputConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, struct _trt__SetAudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioOutputConfiguration);
	if (soap_out_PointerTo_trt__SetAudioOutputConfiguration(soap, tag?tag:"trt:SetAudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetAudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioOutputConfiguration(struct soap *soap, struct _trt__SetAudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetMetadataConfigurationResponse(struct soap *soap, struct _trt__SetMetadataConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetMetadataConfigurationResponse))
		soap_serialize__trt__SetMetadataConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetMetadataConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__SetMetadataConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetMetadataConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetMetadataConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetMetadataConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetMetadataConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetMetadataConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetMetadataConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__SetMetadataConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetMetadataConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetMetadataConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetMetadataConfigurationResponse, sizeof(struct _trt__SetMetadataConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetMetadataConfigurationResponse(struct soap *soap, struct _trt__SetMetadataConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetMetadataConfigurationResponse);
	if (soap_out_PointerTo_trt__SetMetadataConfigurationResponse(soap, tag?tag:"trt:SetMetadataConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetMetadataConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetMetadataConfigurationResponse(struct soap *soap, struct _trt__SetMetadataConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetMetadataConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, struct _trt__SetMetadataConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetMetadataConfiguration))
		soap_serialize__trt__SetMetadataConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, const char *tag, int id, struct _trt__SetMetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetMetadataConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetMetadataConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetMetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, const char *tag, struct _trt__SetMetadataConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetMetadataConfiguration **)soap_malloc(soap, sizeof(struct _trt__SetMetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetMetadataConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetMetadataConfiguration, sizeof(struct _trt__SetMetadataConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, struct _trt__SetMetadataConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetMetadataConfiguration);
	if (soap_out_PointerTo_trt__SetMetadataConfiguration(soap, tag?tag:"trt:SetMetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetMetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetMetadataConfiguration(struct soap *soap, struct _trt__SetMetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__SetVideoAnalyticsConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse))
		soap_serialize__trt__SetVideoAnalyticsConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__SetVideoAnalyticsConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetVideoAnalyticsConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetVideoAnalyticsConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetVideoAnalyticsConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__SetVideoAnalyticsConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetVideoAnalyticsConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoAnalyticsConfigurationResponse, sizeof(struct _trt__SetVideoAnalyticsConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__SetVideoAnalyticsConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoAnalyticsConfigurationResponse);
	if (soap_out_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(soap, tag?tag:"trt:SetVideoAnalyticsConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__SetVideoAnalyticsConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, struct _trt__SetVideoAnalyticsConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoAnalyticsConfiguration))
		soap_serialize__trt__SetVideoAnalyticsConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, struct _trt__SetVideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoAnalyticsConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetVideoAnalyticsConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _trt__SetVideoAnalyticsConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(struct _trt__SetVideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetVideoAnalyticsConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoAnalyticsConfiguration, sizeof(struct _trt__SetVideoAnalyticsConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, struct _trt__SetVideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoAnalyticsConfiguration);
	if (soap_out_PointerTo_trt__SetVideoAnalyticsConfiguration(soap, tag?tag:"trt:SetVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoAnalyticsConfiguration(struct soap *soap, struct _trt__SetVideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__SetAudioEncoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse))
		soap_serialize__trt__SetAudioEncoderConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__SetAudioEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetAudioEncoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetAudioEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetAudioEncoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__SetAudioEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetAudioEncoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetAudioEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioEncoderConfigurationResponse, sizeof(struct _trt__SetAudioEncoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__SetAudioEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__SetAudioEncoderConfigurationResponse(soap, tag?tag:"trt:SetAudioEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__SetAudioEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, struct _trt__SetAudioEncoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioEncoderConfiguration))
		soap_serialize__trt__SetAudioEncoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__SetAudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetAudioEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetAudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__SetAudioEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetAudioEncoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__SetAudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetAudioEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioEncoderConfiguration, sizeof(struct _trt__SetAudioEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, struct _trt__SetAudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioEncoderConfiguration);
	if (soap_out_PointerTo_trt__SetAudioEncoderConfiguration(soap, tag?tag:"trt:SetAudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetAudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioEncoderConfiguration(struct soap *soap, struct _trt__SetAudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioSourceConfigurationResponse(struct soap *soap, struct _trt__SetAudioSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioSourceConfigurationResponse))
		soap_serialize__trt__SetAudioSourceConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__SetAudioSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetAudioSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetAudioSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetAudioSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__SetAudioSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetAudioSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioSourceConfigurationResponse, sizeof(struct _trt__SetAudioSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioSourceConfigurationResponse(struct soap *soap, struct _trt__SetAudioSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__SetAudioSourceConfigurationResponse(soap, tag?tag:"trt:SetAudioSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioSourceConfigurationResponse(struct soap *soap, struct _trt__SetAudioSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, struct _trt__SetAudioSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetAudioSourceConfiguration))
		soap_serialize__trt__SetAudioSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, struct _trt__SetAudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetAudioSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetAudioSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetAudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, const char *tag, struct _trt__SetAudioSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetAudioSourceConfiguration **)soap_malloc(soap, sizeof(struct _trt__SetAudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetAudioSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetAudioSourceConfiguration, sizeof(struct _trt__SetAudioSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, struct _trt__SetAudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetAudioSourceConfiguration);
	if (soap_out_PointerTo_trt__SetAudioSourceConfiguration(soap, tag?tag:"trt:SetAudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetAudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetAudioSourceConfiguration(struct soap *soap, struct _trt__SetAudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__SetVideoEncoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse))
		soap_serialize__trt__SetVideoEncoderConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__SetVideoEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetVideoEncoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetVideoEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetVideoEncoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__SetVideoEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetVideoEncoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetVideoEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoEncoderConfigurationResponse, sizeof(struct _trt__SetVideoEncoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__SetVideoEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__SetVideoEncoderConfigurationResponse(soap, tag?tag:"trt:SetVideoEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__SetVideoEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, struct _trt__SetVideoEncoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoEncoderConfiguration))
		soap_serialize__trt__SetVideoEncoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__SetVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetVideoEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__SetVideoEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetVideoEncoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__SetVideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetVideoEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoEncoderConfiguration, sizeof(struct _trt__SetVideoEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, struct _trt__SetVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoEncoderConfiguration);
	if (soap_out_PointerTo_trt__SetVideoEncoderConfiguration(soap, tag?tag:"trt:SetVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoEncoderConfiguration(struct soap *soap, struct _trt__SetVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoSourceConfigurationResponse(struct soap *soap, struct _trt__SetVideoSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoSourceConfigurationResponse))
		soap_serialize__trt__SetVideoSourceConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__SetVideoSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetVideoSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__SetVideoSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetVideoSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__SetVideoSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetVideoSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoSourceConfigurationResponse, sizeof(struct _trt__SetVideoSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoSourceConfigurationResponse(struct soap *soap, struct _trt__SetVideoSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__SetVideoSourceConfigurationResponse(soap, tag?tag:"trt:SetVideoSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoSourceConfigurationResponse(struct soap *soap, struct _trt__SetVideoSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, struct _trt__SetVideoSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__SetVideoSourceConfiguration))
		soap_serialize__trt__SetVideoSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, struct _trt__SetVideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__SetVideoSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__SetVideoSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__SetVideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, const char *tag, struct _trt__SetVideoSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__SetVideoSourceConfiguration **)soap_malloc(soap, sizeof(struct _trt__SetVideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__SetVideoSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__SetVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__SetVideoSourceConfiguration, sizeof(struct _trt__SetVideoSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, struct _trt__SetVideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__SetVideoSourceConfiguration);
	if (soap_out_PointerTo_trt__SetVideoSourceConfiguration(soap, tag?tag:"trt:SetVideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__SetVideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__SetVideoSourceConfiguration(struct soap *soap, struct _trt__SetVideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__SetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioDecoderConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse))
		soap_serialize__trt__GetCompatibleAudioDecoderConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleAudioDecoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleAudioDecoderConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioDecoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioDecoderConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleAudioDecoderConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleAudioDecoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleAudioDecoderConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioDecoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioDecoderConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioDecoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleAudioDecoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioDecoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioDecoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioDecoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioDecoderConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations))
		soap_serialize__trt__GetCompatibleAudioDecoderConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleAudioDecoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleAudioDecoderConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioDecoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioDecoderConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleAudioDecoderConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleAudioDecoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleAudioDecoderConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioDecoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioDecoderConfigurations, sizeof(struct _trt__GetCompatibleAudioDecoderConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioDecoderConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioDecoderConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(soap, tag?tag:"trt:GetCompatibleAudioDecoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioDecoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioDecoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioDecoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioOutputConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse))
		soap_serialize__trt__GetCompatibleAudioOutputConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleAudioOutputConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleAudioOutputConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioOutputConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioOutputConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleAudioOutputConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleAudioOutputConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleAudioOutputConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioOutputConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioOutputConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioOutputConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleAudioOutputConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioOutputConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioOutputConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioOutputConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioOutputConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations))
		soap_serialize__trt__GetCompatibleAudioOutputConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleAudioOutputConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleAudioOutputConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioOutputConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioOutputConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleAudioOutputConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleAudioOutputConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleAudioOutputConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioOutputConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioOutputConfigurations, sizeof(struct _trt__GetCompatibleAudioOutputConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioOutputConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioOutputConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleAudioOutputConfigurations(soap, tag?tag:"trt:GetCompatibleAudioOutputConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioOutputConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioOutputConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioOutputConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioOutputConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleMetadataConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse))
		soap_serialize__trt__GetCompatibleMetadataConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleMetadataConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleMetadataConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleMetadataConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleMetadataConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleMetadataConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleMetadataConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleMetadataConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleMetadataConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurationsResponse, sizeof(struct _trt__GetCompatibleMetadataConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleMetadataConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleMetadataConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleMetadataConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleMetadataConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleMetadataConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, struct _trt__GetCompatibleMetadataConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations))
		soap_serialize__trt__GetCompatibleMetadataConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleMetadataConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleMetadataConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleMetadataConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleMetadataConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleMetadataConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleMetadataConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleMetadataConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleMetadataConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleMetadataConfigurations, sizeof(struct _trt__GetCompatibleMetadataConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, struct _trt__GetCompatibleMetadataConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleMetadataConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleMetadataConfigurations(soap, tag?tag:"trt:GetCompatibleMetadataConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleMetadataConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleMetadataConfigurations(struct soap *soap, struct _trt__GetCompatibleMetadataConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleMetadataConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse))
		soap_serialize__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleVideoAnalyticsConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurationsResponse, sizeof(struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleVideoAnalyticsConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoAnalyticsConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoAnalyticsConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations))
		soap_serialize__trt__GetCompatibleVideoAnalyticsConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleVideoAnalyticsConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoAnalyticsConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleVideoAnalyticsConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleVideoAnalyticsConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleVideoAnalyticsConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleVideoAnalyticsConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoAnalyticsConfigurations, sizeof(struct _trt__GetCompatibleVideoAnalyticsConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoAnalyticsConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag?tag:"trt:GetCompatibleVideoAnalyticsConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoAnalyticsConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoAnalyticsConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoAnalyticsConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioSourceConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse))
		soap_serialize__trt__GetCompatibleAudioSourceConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleAudioSourceConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleAudioSourceConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioSourceConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioSourceConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleAudioSourceConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleAudioSourceConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleAudioSourceConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioSourceConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioSourceConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioSourceConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleAudioSourceConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioSourceConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioSourceConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioSourceConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations))
		soap_serialize__trt__GetCompatibleAudioSourceConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleAudioSourceConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleAudioSourceConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioSourceConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioSourceConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleAudioSourceConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleAudioSourceConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleAudioSourceConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioSourceConfigurations, sizeof(struct _trt__GetCompatibleAudioSourceConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioSourceConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioSourceConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleAudioSourceConfigurations(soap, tag?tag:"trt:GetCompatibleAudioSourceConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioSourceConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioSourceConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioSourceConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioEncoderConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse))
		soap_serialize__trt__GetCompatibleAudioEncoderConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleAudioEncoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleAudioEncoderConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioEncoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioEncoderConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleAudioEncoderConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleAudioEncoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleAudioEncoderConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioEncoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurationsResponse, sizeof(struct _trt__GetCompatibleAudioEncoderConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioEncoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleAudioEncoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioEncoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleAudioEncoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioEncoderConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations))
		soap_serialize__trt__GetCompatibleAudioEncoderConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleAudioEncoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleAudioEncoderConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioEncoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleAudioEncoderConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleAudioEncoderConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleAudioEncoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleAudioEncoderConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleAudioEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleAudioEncoderConfigurations, sizeof(struct _trt__GetCompatibleAudioEncoderConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioEncoderConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleAudioEncoderConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(soap, tag?tag:"trt:GetCompatibleAudioEncoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleAudioEncoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(struct soap *soap, struct _trt__GetCompatibleAudioEncoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleAudioEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoSourceConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse))
		soap_serialize__trt__GetCompatibleVideoSourceConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleVideoSourceConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleVideoSourceConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoSourceConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleVideoSourceConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleVideoSourceConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleVideoSourceConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleVideoSourceConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleVideoSourceConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurationsResponse, sizeof(struct _trt__GetCompatibleVideoSourceConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoSourceConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleVideoSourceConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoSourceConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoSourceConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoSourceConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations))
		soap_serialize__trt__GetCompatibleVideoSourceConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleVideoSourceConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleVideoSourceConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoSourceConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleVideoSourceConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleVideoSourceConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleVideoSourceConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleVideoSourceConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleVideoSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoSourceConfigurations, sizeof(struct _trt__GetCompatibleVideoSourceConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoSourceConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleVideoSourceConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleVideoSourceConfigurations(soap, tag?tag:"trt:GetCompatibleVideoSourceConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoSourceConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoSourceConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoSourceConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoEncoderConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse))
		soap_serialize__trt__GetCompatibleVideoEncoderConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleVideoEncoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleVideoEncoderConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoEncoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetCompatibleVideoEncoderConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleVideoEncoderConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleVideoEncoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleVideoEncoderConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleVideoEncoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurationsResponse, sizeof(struct _trt__GetCompatibleVideoEncoderConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoEncoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(soap, tag?tag:"trt:GetCompatibleVideoEncoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoEncoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetCompatibleVideoEncoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoEncoderConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations))
		soap_serialize__trt__GetCompatibleVideoEncoderConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetCompatibleVideoEncoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetCompatibleVideoEncoderConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoEncoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetCompatibleVideoEncoderConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetCompatibleVideoEncoderConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetCompatibleVideoEncoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetCompatibleVideoEncoderConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetCompatibleVideoEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetCompatibleVideoEncoderConfigurations, sizeof(struct _trt__GetCompatibleVideoEncoderConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoEncoderConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetCompatibleVideoEncoderConfigurations);
	if (soap_out_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(soap, tag?tag:"trt:GetCompatibleVideoEncoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetCompatibleVideoEncoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(struct soap *soap, struct _trt__GetCompatibleVideoEncoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetCompatibleVideoEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse))
		soap_serialize__trt__GetAudioDecoderConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioDecoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioDecoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioDecoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioDecoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioDecoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurationResponse, sizeof(struct _trt__GetAudioDecoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfigurationResponse);
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurationResponse(soap, tag?tag:"trt:GetAudioDecoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, struct _trt__GetAudioDecoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfiguration))
		soap_serialize__trt__GetAudioDecoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__GetAudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioDecoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioDecoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__GetAudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioDecoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfiguration, sizeof(struct _trt__GetAudioDecoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, struct _trt__GetAudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfiguration);
	if (soap_out_PointerTo_trt__GetAudioDecoderConfiguration(soap, tag?tag:"trt:GetAudioDecoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfiguration(struct soap *soap, struct _trt__GetAudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfigurationResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfigurationResponse))
		soap_serialize__trt__GetAudioOutputConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioOutputConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioOutputConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioOutputConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioOutputConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioOutputConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurationResponse, sizeof(struct _trt__GetAudioOutputConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfigurationResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputConfigurationResponse);
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurationResponse(soap, tag?tag:"trt:GetAudioOutputConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfigurationResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, struct _trt__GetAudioOutputConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfiguration))
		soap_serialize__trt__GetAudioOutputConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, struct _trt__GetAudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioOutputConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioOutputConfiguration **)soap_malloc(soap, sizeof(struct _trt__GetAudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioOutputConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfiguration, sizeof(struct _trt__GetAudioOutputConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, struct _trt__GetAudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputConfiguration);
	if (soap_out_PointerTo_trt__GetAudioOutputConfiguration(soap, tag?tag:"trt:GetAudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfiguration(struct soap *soap, struct _trt__GetAudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfigurationResponse(struct soap *soap, struct _trt__GetMetadataConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfigurationResponse))
		soap_serialize__trt__GetMetadataConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__GetMetadataConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetMetadataConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetMetadataConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__GetMetadataConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetMetadataConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurationResponse, sizeof(struct _trt__GetMetadataConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfigurationResponse(struct soap *soap, struct _trt__GetMetadataConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetMetadataConfigurationResponse);
	if (soap_out_PointerTo_trt__GetMetadataConfigurationResponse(soap, tag?tag:"trt:GetMetadataConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfigurationResponse(struct soap *soap, struct _trt__GetMetadataConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, struct _trt__GetMetadataConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfiguration))
		soap_serialize__trt__GetMetadataConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, const char *tag, int id, struct _trt__GetMetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetMetadataConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetMetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, const char *tag, struct _trt__GetMetadataConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetMetadataConfiguration **)soap_malloc(soap, sizeof(struct _trt__GetMetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetMetadataConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfiguration, sizeof(struct _trt__GetMetadataConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, struct _trt__GetMetadataConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetMetadataConfiguration);
	if (soap_out_PointerTo_trt__GetMetadataConfiguration(soap, tag?tag:"trt:GetMetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfiguration(struct soap *soap, struct _trt__GetMetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse))
		soap_serialize__trt__GetVideoAnalyticsConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoAnalyticsConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoAnalyticsConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetVideoAnalyticsConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoAnalyticsConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoAnalyticsConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoAnalyticsConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationResponse, sizeof(struct _trt__GetVideoAnalyticsConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoAnalyticsConfigurationResponse);
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(soap, tag?tag:"trt:GetVideoAnalyticsConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, struct _trt__GetVideoAnalyticsConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration))
		soap_serialize__trt__GetVideoAnalyticsConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, struct _trt__GetVideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoAnalyticsConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _trt__GetVideoAnalyticsConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(struct _trt__GetVideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoAnalyticsConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoAnalyticsConfiguration, sizeof(struct _trt__GetVideoAnalyticsConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, struct _trt__GetVideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoAnalyticsConfiguration);
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfiguration(soap, tag?tag:"trt:GetVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoAnalyticsConfiguration(struct soap *soap, struct _trt__GetVideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse))
		soap_serialize__trt__GetAudioEncoderConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioEncoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioEncoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioEncoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurationResponse, sizeof(struct _trt__GetAudioEncoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurationResponse(soap, tag?tag:"trt:GetAudioEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, struct _trt__GetAudioEncoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfiguration))
		soap_serialize__trt__GetAudioEncoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__GetAudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioEncoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__GetAudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfiguration, sizeof(struct _trt__GetAudioEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, struct _trt__GetAudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfiguration);
	if (soap_out_PointerTo_trt__GetAudioEncoderConfiguration(soap, tag?tag:"trt:GetAudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfiguration(struct soap *soap, struct _trt__GetAudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfigurationResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfigurationResponse))
		soap_serialize__trt__GetAudioSourceConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurationResponse, sizeof(struct _trt__GetAudioSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfigurationResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurationResponse(soap, tag?tag:"trt:GetAudioSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfigurationResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, struct _trt__GetAudioSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfiguration))
		soap_serialize__trt__GetAudioSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, struct _trt__GetAudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioSourceConfiguration **)soap_malloc(soap, sizeof(struct _trt__GetAudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfiguration, sizeof(struct _trt__GetAudioSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, struct _trt__GetAudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourceConfiguration);
	if (soap_out_PointerTo_trt__GetAudioSourceConfiguration(soap, tag?tag:"trt:GetAudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfiguration(struct soap *soap, struct _trt__GetAudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse))
		soap_serialize__trt__GetVideoEncoderConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoEncoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoEncoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoEncoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationResponse, sizeof(struct _trt__GetVideoEncoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationResponse(soap, tag?tag:"trt:GetVideoEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, struct _trt__GetVideoEncoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfiguration))
		soap_serialize__trt__GetVideoEncoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__GetVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoEncoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__GetVideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfiguration, sizeof(struct _trt__GetVideoEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, struct _trt__GetVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfiguration);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfiguration(soap, tag?tag:"trt:GetVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfiguration(struct soap *soap, struct _trt__GetVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfigurationResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfigurationResponse))
		soap_serialize__trt__GetVideoSourceConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurationResponse, sizeof(struct _trt__GetVideoSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfigurationResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurationResponse(soap, tag?tag:"trt:GetVideoSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfigurationResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, struct _trt__GetVideoSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfiguration))
		soap_serialize__trt__GetVideoSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, struct _trt__GetVideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoSourceConfiguration **)soap_malloc(soap, sizeof(struct _trt__GetVideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfiguration, sizeof(struct _trt__GetVideoSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, struct _trt__GetVideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourceConfiguration);
	if (soap_out_PointerTo_trt__GetVideoSourceConfiguration(soap, tag?tag:"trt:GetVideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfiguration(struct soap *soap, struct _trt__GetVideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse))
		soap_serialize__trt__GetAudioDecoderConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioDecoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioDecoderConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioDecoderConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioDecoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioDecoderConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurationsResponse, sizeof(struct _trt__GetAudioDecoderConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurationsResponse(soap, tag?tag:"trt:GetAudioDecoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioDecoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, struct _trt__GetAudioDecoderConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioDecoderConfigurations))
		soap_serialize__trt__GetAudioDecoderConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetAudioDecoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioDecoderConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioDecoderConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetAudioDecoderConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioDecoderConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetAudioDecoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioDecoderConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioDecoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioDecoderConfigurations, sizeof(struct _trt__GetAudioDecoderConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, struct _trt__GetAudioDecoderConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioDecoderConfigurations);
	if (soap_out_PointerTo_trt__GetAudioDecoderConfigurations(soap, tag?tag:"trt:GetAudioDecoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioDecoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioDecoderConfigurations(struct soap *soap, struct _trt__GetAudioDecoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioDecoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfigurationsResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse))
		soap_serialize__trt__GetAudioOutputConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioOutputConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioOutputConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioOutputConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioOutputConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioOutputConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurationsResponse, sizeof(struct _trt__GetAudioOutputConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfigurationsResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurationsResponse(soap, tag?tag:"trt:GetAudioOutputConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfigurationsResponse(struct soap *soap, struct _trt__GetAudioOutputConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, struct _trt__GetAudioOutputConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputConfigurations))
		soap_serialize__trt__GetAudioOutputConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetAudioOutputConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioOutputConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, const char *tag, struct _trt__GetAudioOutputConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioOutputConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetAudioOutputConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioOutputConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputConfigurations, sizeof(struct _trt__GetAudioOutputConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, struct _trt__GetAudioOutputConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputConfigurations);
	if (soap_out_PointerTo_trt__GetAudioOutputConfigurations(soap, tag?tag:"trt:GetAudioOutputConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputConfigurations(struct soap *soap, struct _trt__GetAudioOutputConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfigurationsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfigurationsResponse))
		soap_serialize__trt__GetMetadataConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetMetadataConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetMetadataConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetMetadataConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetMetadataConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetMetadataConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurationsResponse, sizeof(struct _trt__GetMetadataConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfigurationsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetMetadataConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetMetadataConfigurationsResponse(soap, tag?tag:"trt:GetMetadataConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfigurationsResponse(struct soap *soap, struct _trt__GetMetadataConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, struct _trt__GetMetadataConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetMetadataConfigurations))
		soap_serialize__trt__GetMetadataConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetMetadataConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetMetadataConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetMetadataConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, const char *tag, struct _trt__GetMetadataConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetMetadataConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetMetadataConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetMetadataConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetMetadataConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetMetadataConfigurations, sizeof(struct _trt__GetMetadataConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, struct _trt__GetMetadataConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetMetadataConfigurations);
	if (soap_out_PointerTo_trt__GetMetadataConfigurations(soap, tag?tag:"trt:GetMetadataConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetMetadataConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetMetadataConfigurations(struct soap *soap, struct _trt__GetMetadataConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetMetadataConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse))
		soap_serialize__trt__GetVideoAnalyticsConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoAnalyticsConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoAnalyticsConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoAnalyticsConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoAnalyticsConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoAnalyticsConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoAnalyticsConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoAnalyticsConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurationsResponse, sizeof(struct _trt__GetVideoAnalyticsConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(soap, tag?tag:"trt:GetVideoAnalyticsConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoAnalyticsConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations))
		soap_serialize__trt__GetVideoAnalyticsConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetVideoAnalyticsConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoAnalyticsConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, const char *tag, struct _trt__GetVideoAnalyticsConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoAnalyticsConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetVideoAnalyticsConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoAnalyticsConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoAnalyticsConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoAnalyticsConfigurations, sizeof(struct _trt__GetVideoAnalyticsConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoAnalyticsConfigurations);
	if (soap_out_PointerTo_trt__GetVideoAnalyticsConfigurations(soap, tag?tag:"trt:GetVideoAnalyticsConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoAnalyticsConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoAnalyticsConfigurations(struct soap *soap, struct _trt__GetVideoAnalyticsConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoAnalyticsConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse))
		soap_serialize__trt__GetAudioEncoderConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioEncoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioEncoderConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioEncoderConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioEncoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioEncoderConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurationsResponse, sizeof(struct _trt__GetAudioEncoderConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurationsResponse(soap, tag?tag:"trt:GetAudioEncoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetAudioEncoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, struct _trt__GetAudioEncoderConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioEncoderConfigurations))
		soap_serialize__trt__GetAudioEncoderConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetAudioEncoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioEncoderConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioEncoderConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetAudioEncoderConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioEncoderConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetAudioEncoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioEncoderConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioEncoderConfigurations, sizeof(struct _trt__GetAudioEncoderConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, struct _trt__GetAudioEncoderConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioEncoderConfigurations);
	if (soap_out_PointerTo_trt__GetAudioEncoderConfigurations(soap, tag?tag:"trt:GetAudioEncoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioEncoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioEncoderConfigurations(struct soap *soap, struct _trt__GetAudioEncoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse))
		soap_serialize__trt__GetAudioSourceConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioSourceConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioSourceConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioSourceConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioSourceConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioSourceConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurationsResponse, sizeof(struct _trt__GetAudioSourceConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourceConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurationsResponse(soap, tag?tag:"trt:GetAudioSourceConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfigurationsResponse(struct soap *soap, struct _trt__GetAudioSourceConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, struct _trt__GetAudioSourceConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourceConfigurations))
		soap_serialize__trt__GetAudioSourceConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetAudioSourceConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourceConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioSourceConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, const char *tag, struct _trt__GetAudioSourceConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioSourceConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetAudioSourceConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioSourceConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourceConfigurations, sizeof(struct _trt__GetAudioSourceConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, struct _trt__GetAudioSourceConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourceConfigurations);
	if (soap_out_PointerTo_trt__GetAudioSourceConfigurations(soap, tag?tag:"trt:GetAudioSourceConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourceConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourceConfigurations(struct soap *soap, struct _trt__GetAudioSourceConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse))
		soap_serialize__trt__GetVideoEncoderConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoEncoderConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoEncoderConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoEncoderConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoEncoderConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoEncoderConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurationsResponse, sizeof(struct _trt__GetVideoEncoderConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurationsResponse(soap, tag?tag:"trt:GetVideoEncoderConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurationsResponse(struct soap *soap, struct _trt__GetVideoEncoderConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, struct _trt__GetVideoEncoderConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoEncoderConfigurations))
		soap_serialize__trt__GetVideoEncoderConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetVideoEncoderConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoEncoderConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoEncoderConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, const char *tag, struct _trt__GetVideoEncoderConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoEncoderConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetVideoEncoderConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoEncoderConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoEncoderConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoEncoderConfigurations, sizeof(struct _trt__GetVideoEncoderConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, struct _trt__GetVideoEncoderConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoEncoderConfigurations);
	if (soap_out_PointerTo_trt__GetVideoEncoderConfigurations(soap, tag?tag:"trt:GetVideoEncoderConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoEncoderConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoEncoderConfigurations(struct soap *soap, struct _trt__GetVideoEncoderConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoEncoderConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse))
		soap_serialize__trt__GetVideoSourceConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoSourceConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoSourceConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfigurationsResponse(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoSourceConfigurationsResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoSourceConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoSourceConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurationsResponse, sizeof(struct _trt__GetVideoSourceConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourceConfigurationsResponse);
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurationsResponse(soap, tag?tag:"trt:GetVideoSourceConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfigurationsResponse(struct soap *soap, struct _trt__GetVideoSourceConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, struct _trt__GetVideoSourceConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourceConfigurations))
		soap_serialize__trt__GetVideoSourceConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, const char *tag, int id, struct _trt__GetVideoSourceConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourceConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoSourceConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurations ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, const char *tag, struct _trt__GetVideoSourceConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoSourceConfigurations **)soap_malloc(soap, sizeof(struct _trt__GetVideoSourceConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoSourceConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourceConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourceConfigurations, sizeof(struct _trt__GetVideoSourceConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, struct _trt__GetVideoSourceConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourceConfigurations);
	if (soap_out_PointerTo_trt__GetVideoSourceConfigurations(soap, tag?tag:"trt:GetVideoSourceConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourceConfigurations ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourceConfigurations(struct soap *soap, struct _trt__GetVideoSourceConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourceConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__DeleteProfileResponse(struct soap *soap, struct _trt__DeleteProfileResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__DeleteProfileResponse))
		soap_serialize__trt__DeleteProfileResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__DeleteProfileResponse(struct soap *soap, const char *tag, int id, struct _trt__DeleteProfileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__DeleteProfileResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__DeleteProfileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__DeleteProfileResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__DeleteProfileResponse(struct soap *soap, const char *tag, struct _trt__DeleteProfileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__DeleteProfileResponse **)soap_malloc(soap, sizeof(struct _trt__DeleteProfileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__DeleteProfileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__DeleteProfileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__DeleteProfileResponse, sizeof(struct _trt__DeleteProfileResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__DeleteProfileResponse(struct soap *soap, struct _trt__DeleteProfileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__DeleteProfileResponse);
	if (soap_out_PointerTo_trt__DeleteProfileResponse(soap, tag?tag:"trt:DeleteProfileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__DeleteProfileResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__DeleteProfileResponse(struct soap *soap, struct _trt__DeleteProfileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__DeleteProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__DeleteProfile(struct soap *soap, struct _trt__DeleteProfile *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__DeleteProfile))
		soap_serialize__trt__DeleteProfile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__DeleteProfile(struct soap *soap, const char *tag, int id, struct _trt__DeleteProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__DeleteProfile);
	if (id < 0)
		return soap->error;
	return soap_out__trt__DeleteProfile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__DeleteProfile ** SOAP_FMAC4 soap_in_PointerTo_trt__DeleteProfile(struct soap *soap, const char *tag, struct _trt__DeleteProfile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__DeleteProfile **)soap_malloc(soap, sizeof(struct _trt__DeleteProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__DeleteProfile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__DeleteProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__DeleteProfile, sizeof(struct _trt__DeleteProfile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__DeleteProfile(struct soap *soap, struct _trt__DeleteProfile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__DeleteProfile);
	if (soap_out_PointerTo_trt__DeleteProfile(soap, tag?tag:"trt:DeleteProfile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__DeleteProfile ** SOAP_FMAC4 soap_get_PointerTo_trt__DeleteProfile(struct soap *soap, struct _trt__DeleteProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__DeleteProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioDecoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse))
		soap_serialize__trt__RemoveAudioDecoderConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__RemoveAudioDecoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveAudioDecoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioDecoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveAudioDecoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__RemoveAudioDecoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveAudioDecoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioDecoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioDecoderConfigurationResponse, sizeof(struct _trt__RemoveAudioDecoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioDecoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioDecoderConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(soap, tag?tag:"trt:RemoveAudioDecoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioDecoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, struct _trt__RemoveAudioDecoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration))
		soap_serialize__trt__RemoveAudioDecoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__RemoveAudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveAudioDecoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioDecoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveAudioDecoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__RemoveAudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveAudioDecoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioDecoderConfiguration, sizeof(struct _trt__RemoveAudioDecoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, struct _trt__RemoveAudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioDecoderConfiguration);
	if (soap_out_PointerTo_trt__RemoveAudioDecoderConfiguration(soap, tag?tag:"trt:RemoveAudioDecoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioDecoderConfiguration(struct soap *soap, struct _trt__RemoveAudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioOutputConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse))
		soap_serialize__trt__RemoveAudioOutputConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__RemoveAudioOutputConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveAudioOutputConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioOutputConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveAudioOutputConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__RemoveAudioOutputConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveAudioOutputConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioOutputConfigurationResponse, sizeof(struct _trt__RemoveAudioOutputConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioOutputConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioOutputConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveAudioOutputConfigurationResponse(soap, tag?tag:"trt:RemoveAudioOutputConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioOutputConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioOutputConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, struct _trt__RemoveAudioOutputConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioOutputConfiguration))
		soap_serialize__trt__RemoveAudioOutputConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *tag, int id, struct _trt__RemoveAudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioOutputConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveAudioOutputConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioOutputConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveAudioOutputConfiguration **)soap_malloc(soap, sizeof(struct _trt__RemoveAudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveAudioOutputConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioOutputConfiguration, sizeof(struct _trt__RemoveAudioOutputConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, struct _trt__RemoveAudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioOutputConfiguration);
	if (soap_out_PointerTo_trt__RemoveAudioOutputConfiguration(soap, tag?tag:"trt:RemoveAudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioOutputConfiguration(struct soap *soap, struct _trt__RemoveAudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveMetadataConfigurationResponse(struct soap *soap, struct _trt__RemoveMetadataConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse))
		soap_serialize__trt__RemoveMetadataConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveMetadataConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__RemoveMetadataConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveMetadataConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveMetadataConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveMetadataConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveMetadataConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__RemoveMetadataConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveMetadataConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveMetadataConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveMetadataConfigurationResponse, sizeof(struct _trt__RemoveMetadataConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveMetadataConfigurationResponse(struct soap *soap, struct _trt__RemoveMetadataConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveMetadataConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveMetadataConfigurationResponse(soap, tag?tag:"trt:RemoveMetadataConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveMetadataConfigurationResponse(struct soap *soap, struct _trt__RemoveMetadataConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveMetadataConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, struct _trt__RemoveMetadataConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveMetadataConfiguration))
		soap_serialize__trt__RemoveMetadataConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, const char *tag, int id, struct _trt__RemoveMetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveMetadataConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveMetadataConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveMetadataConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveMetadataConfiguration **)soap_malloc(soap, sizeof(struct _trt__RemoveMetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveMetadataConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveMetadataConfiguration, sizeof(struct _trt__RemoveMetadataConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, struct _trt__RemoveMetadataConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveMetadataConfiguration);
	if (soap_out_PointerTo_trt__RemoveMetadataConfiguration(soap, tag?tag:"trt:RemoveMetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveMetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveMetadataConfiguration(struct soap *soap, struct _trt__RemoveMetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse))
		soap_serialize__trt__RemoveVideoAnalyticsConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__RemoveVideoAnalyticsConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveVideoAnalyticsConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveVideoAnalyticsConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveVideoAnalyticsConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__RemoveVideoAnalyticsConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveVideoAnalyticsConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfigurationResponse, sizeof(struct _trt__RemoveVideoAnalyticsConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(soap, tag?tag:"trt:RemoveVideoAnalyticsConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration))
		soap_serialize__trt__RemoveVideoAnalyticsConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, struct _trt__RemoveVideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveVideoAnalyticsConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveVideoAnalyticsConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(struct _trt__RemoveVideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveVideoAnalyticsConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoAnalyticsConfiguration, sizeof(struct _trt__RemoveVideoAnalyticsConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveVideoAnalyticsConfiguration);
	if (soap_out_PointerTo_trt__RemoveVideoAnalyticsConfiguration(soap, tag?tag:"trt:RemoveVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoAnalyticsConfiguration(struct soap *soap, struct _trt__RemoveVideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemovePTZConfigurationResponse(struct soap *soap, struct _trt__RemovePTZConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemovePTZConfigurationResponse))
		soap_serialize__trt__RemovePTZConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemovePTZConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__RemovePTZConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemovePTZConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemovePTZConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemovePTZConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemovePTZConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemovePTZConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemovePTZConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__RemovePTZConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemovePTZConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemovePTZConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemovePTZConfigurationResponse, sizeof(struct _trt__RemovePTZConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemovePTZConfigurationResponse(struct soap *soap, struct _trt__RemovePTZConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemovePTZConfigurationResponse);
	if (soap_out_PointerTo_trt__RemovePTZConfigurationResponse(soap, tag?tag:"trt:RemovePTZConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemovePTZConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemovePTZConfigurationResponse(struct soap *soap, struct _trt__RemovePTZConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemovePTZConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, struct _trt__RemovePTZConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemovePTZConfiguration))
		soap_serialize__trt__RemovePTZConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, const char *tag, int id, struct _trt__RemovePTZConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemovePTZConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemovePTZConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemovePTZConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, const char *tag, struct _trt__RemovePTZConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemovePTZConfiguration **)soap_malloc(soap, sizeof(struct _trt__RemovePTZConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemovePTZConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemovePTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemovePTZConfiguration, sizeof(struct _trt__RemovePTZConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, struct _trt__RemovePTZConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemovePTZConfiguration);
	if (soap_out_PointerTo_trt__RemovePTZConfiguration(soap, tag?tag:"trt:RemovePTZConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemovePTZConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemovePTZConfiguration(struct soap *soap, struct _trt__RemovePTZConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemovePTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse))
		soap_serialize__trt__RemoveAudioSourceConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__RemoveAudioSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveAudioSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveAudioSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__RemoveAudioSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveAudioSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioSourceConfigurationResponse, sizeof(struct _trt__RemoveAudioSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveAudioSourceConfigurationResponse(soap, tag?tag:"trt:RemoveAudioSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, struct _trt__RemoveAudioSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioSourceConfiguration))
		soap_serialize__trt__RemoveAudioSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *tag, int id, struct _trt__RemoveAudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveAudioSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveAudioSourceConfiguration **)soap_malloc(soap, sizeof(struct _trt__RemoveAudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveAudioSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioSourceConfiguration, sizeof(struct _trt__RemoveAudioSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, struct _trt__RemoveAudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioSourceConfiguration);
	if (soap_out_PointerTo_trt__RemoveAudioSourceConfiguration(soap, tag?tag:"trt:RemoveAudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioSourceConfiguration(struct soap *soap, struct _trt__RemoveAudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioEncoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse))
		soap_serialize__trt__RemoveAudioEncoderConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__RemoveAudioEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveAudioEncoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveAudioEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveAudioEncoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__RemoveAudioEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveAudioEncoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioEncoderConfigurationResponse, sizeof(struct _trt__RemoveAudioEncoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(soap, tag?tag:"trt:RemoveAudioEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveAudioEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, struct _trt__RemoveAudioEncoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration))
		soap_serialize__trt__RemoveAudioEncoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__RemoveAudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveAudioEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveAudioEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveAudioEncoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__RemoveAudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveAudioEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveAudioEncoderConfiguration, sizeof(struct _trt__RemoveAudioEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, struct _trt__RemoveAudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveAudioEncoderConfiguration);
	if (soap_out_PointerTo_trt__RemoveAudioEncoderConfiguration(soap, tag?tag:"trt:RemoveAudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveAudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveAudioEncoderConfiguration(struct soap *soap, struct _trt__RemoveAudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse))
		soap_serialize__trt__RemoveVideoSourceConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__RemoveVideoSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveVideoSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveVideoSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveVideoSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__RemoveVideoSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveVideoSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoSourceConfigurationResponse, sizeof(struct _trt__RemoveVideoSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveVideoSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveVideoSourceConfigurationResponse(soap, tag?tag:"trt:RemoveVideoSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoSourceConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, struct _trt__RemoveVideoSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoSourceConfiguration))
		soap_serialize__trt__RemoveVideoSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *tag, int id, struct _trt__RemoveVideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveVideoSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveVideoSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveVideoSourceConfiguration **)soap_malloc(soap, sizeof(struct _trt__RemoveVideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveVideoSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoSourceConfiguration, sizeof(struct _trt__RemoveVideoSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, struct _trt__RemoveVideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveVideoSourceConfiguration);
	if (soap_out_PointerTo_trt__RemoveVideoSourceConfiguration(soap, tag?tag:"trt:RemoveVideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoSourceConfiguration(struct soap *soap, struct _trt__RemoveVideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoEncoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse))
		soap_serialize__trt__RemoveVideoEncoderConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__RemoveVideoEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveVideoEncoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__RemoveVideoEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveVideoEncoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__RemoveVideoEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveVideoEncoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoEncoderConfigurationResponse, sizeof(struct _trt__RemoveVideoEncoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveVideoEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(soap, tag?tag:"trt:RemoveVideoEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__RemoveVideoEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, struct _trt__RemoveVideoEncoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration))
		soap_serialize__trt__RemoveVideoEncoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__RemoveVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__RemoveVideoEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__RemoveVideoEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__RemoveVideoEncoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__RemoveVideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__RemoveVideoEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__RemoveVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__RemoveVideoEncoderConfiguration, sizeof(struct _trt__RemoveVideoEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, struct _trt__RemoveVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__RemoveVideoEncoderConfiguration);
	if (soap_out_PointerTo_trt__RemoveVideoEncoderConfiguration(soap, tag?tag:"trt:RemoveVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__RemoveVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__RemoveVideoEncoderConfiguration(struct soap *soap, struct _trt__RemoveVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__RemoveVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioDecoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse))
		soap_serialize__trt__AddAudioDecoderConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__AddAudioDecoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddAudioDecoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioDecoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioDecoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddAudioDecoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__AddAudioDecoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddAudioDecoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioDecoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioDecoderConfigurationResponse, sizeof(struct _trt__AddAudioDecoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioDecoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioDecoderConfigurationResponse);
	if (soap_out_PointerTo_trt__AddAudioDecoderConfigurationResponse(soap, tag?tag:"trt:AddAudioDecoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioDecoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioDecoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioDecoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, struct _trt__AddAudioDecoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioDecoderConfiguration))
		soap_serialize__trt__AddAudioDecoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__AddAudioDecoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioDecoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddAudioDecoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioDecoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddAudioDecoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__AddAudioDecoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddAudioDecoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioDecoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioDecoderConfiguration, sizeof(struct _trt__AddAudioDecoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, struct _trt__AddAudioDecoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioDecoderConfiguration);
	if (soap_out_PointerTo_trt__AddAudioDecoderConfiguration(soap, tag?tag:"trt:AddAudioDecoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioDecoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioDecoderConfiguration(struct soap *soap, struct _trt__AddAudioDecoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioDecoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioOutputConfigurationResponse(struct soap *soap, struct _trt__AddAudioOutputConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse))
		soap_serialize__trt__AddAudioOutputConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__AddAudioOutputConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddAudioOutputConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioOutputConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddAudioOutputConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__AddAudioOutputConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddAudioOutputConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioOutputConfigurationResponse, sizeof(struct _trt__AddAudioOutputConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioOutputConfigurationResponse(struct soap *soap, struct _trt__AddAudioOutputConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioOutputConfigurationResponse);
	if (soap_out_PointerTo_trt__AddAudioOutputConfigurationResponse(soap, tag?tag:"trt:AddAudioOutputConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioOutputConfigurationResponse(struct soap *soap, struct _trt__AddAudioOutputConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, struct _trt__AddAudioOutputConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioOutputConfiguration))
		soap_serialize__trt__AddAudioOutputConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, const char *tag, int id, struct _trt__AddAudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioOutputConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddAudioOutputConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioOutputConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddAudioOutputConfiguration **)soap_malloc(soap, sizeof(struct _trt__AddAudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddAudioOutputConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioOutputConfiguration, sizeof(struct _trt__AddAudioOutputConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, struct _trt__AddAudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioOutputConfiguration);
	if (soap_out_PointerTo_trt__AddAudioOutputConfiguration(soap, tag?tag:"trt:AddAudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioOutputConfiguration(struct soap *soap, struct _trt__AddAudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddMetadataConfigurationResponse(struct soap *soap, struct _trt__AddMetadataConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddMetadataConfigurationResponse))
		soap_serialize__trt__AddMetadataConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddMetadataConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__AddMetadataConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddMetadataConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddMetadataConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddMetadataConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddMetadataConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddMetadataConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddMetadataConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__AddMetadataConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddMetadataConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddMetadataConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddMetadataConfigurationResponse, sizeof(struct _trt__AddMetadataConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddMetadataConfigurationResponse(struct soap *soap, struct _trt__AddMetadataConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddMetadataConfigurationResponse);
	if (soap_out_PointerTo_trt__AddMetadataConfigurationResponse(soap, tag?tag:"trt:AddMetadataConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddMetadataConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddMetadataConfigurationResponse(struct soap *soap, struct _trt__AddMetadataConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddMetadataConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, struct _trt__AddMetadataConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddMetadataConfiguration))
		soap_serialize__trt__AddMetadataConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, const char *tag, int id, struct _trt__AddMetadataConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddMetadataConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddMetadataConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddMetadataConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, const char *tag, struct _trt__AddMetadataConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddMetadataConfiguration **)soap_malloc(soap, sizeof(struct _trt__AddMetadataConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddMetadataConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddMetadataConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddMetadataConfiguration, sizeof(struct _trt__AddMetadataConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, struct _trt__AddMetadataConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddMetadataConfiguration);
	if (soap_out_PointerTo_trt__AddMetadataConfiguration(soap, tag?tag:"trt:AddMetadataConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddMetadataConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddMetadataConfiguration(struct soap *soap, struct _trt__AddMetadataConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddMetadataConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__AddVideoAnalyticsConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse))
		soap_serialize__trt__AddVideoAnalyticsConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__AddVideoAnalyticsConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddVideoAnalyticsConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddVideoAnalyticsConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddVideoAnalyticsConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__AddVideoAnalyticsConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddVideoAnalyticsConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoAnalyticsConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoAnalyticsConfigurationResponse, sizeof(struct _trt__AddVideoAnalyticsConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__AddVideoAnalyticsConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddVideoAnalyticsConfigurationResponse);
	if (soap_out_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(soap, tag?tag:"trt:AddVideoAnalyticsConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(struct soap *soap, struct _trt__AddVideoAnalyticsConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoAnalyticsConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, struct _trt__AddVideoAnalyticsConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration))
		soap_serialize__trt__AddVideoAnalyticsConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *tag, int id, struct _trt__AddVideoAnalyticsConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddVideoAnalyticsConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, const char *tag, struct _trt__AddVideoAnalyticsConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddVideoAnalyticsConfiguration **)soap_malloc(soap, sizeof(struct _trt__AddVideoAnalyticsConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddVideoAnalyticsConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoAnalyticsConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoAnalyticsConfiguration, sizeof(struct _trt__AddVideoAnalyticsConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, struct _trt__AddVideoAnalyticsConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddVideoAnalyticsConfiguration);
	if (soap_out_PointerTo_trt__AddVideoAnalyticsConfiguration(soap, tag?tag:"trt:AddVideoAnalyticsConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoAnalyticsConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoAnalyticsConfiguration(struct soap *soap, struct _trt__AddVideoAnalyticsConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoAnalyticsConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddPTZConfigurationResponse(struct soap *soap, struct _trt__AddPTZConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddPTZConfigurationResponse))
		soap_serialize__trt__AddPTZConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddPTZConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__AddPTZConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddPTZConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddPTZConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddPTZConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddPTZConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddPTZConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddPTZConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__AddPTZConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddPTZConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddPTZConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddPTZConfigurationResponse, sizeof(struct _trt__AddPTZConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddPTZConfigurationResponse(struct soap *soap, struct _trt__AddPTZConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddPTZConfigurationResponse);
	if (soap_out_PointerTo_trt__AddPTZConfigurationResponse(soap, tag?tag:"trt:AddPTZConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddPTZConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddPTZConfigurationResponse(struct soap *soap, struct _trt__AddPTZConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddPTZConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddPTZConfiguration(struct soap *soap, struct _trt__AddPTZConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddPTZConfiguration))
		soap_serialize__trt__AddPTZConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddPTZConfiguration(struct soap *soap, const char *tag, int id, struct _trt__AddPTZConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddPTZConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddPTZConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddPTZConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddPTZConfiguration(struct soap *soap, const char *tag, struct _trt__AddPTZConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddPTZConfiguration **)soap_malloc(soap, sizeof(struct _trt__AddPTZConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddPTZConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddPTZConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddPTZConfiguration, sizeof(struct _trt__AddPTZConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddPTZConfiguration(struct soap *soap, struct _trt__AddPTZConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddPTZConfiguration);
	if (soap_out_PointerTo_trt__AddPTZConfiguration(soap, tag?tag:"trt:AddPTZConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddPTZConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddPTZConfiguration(struct soap *soap, struct _trt__AddPTZConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddPTZConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioSourceConfigurationResponse(struct soap *soap, struct _trt__AddAudioSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse))
		soap_serialize__trt__AddAudioSourceConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__AddAudioSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddAudioSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddAudioSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__AddAudioSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddAudioSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioSourceConfigurationResponse, sizeof(struct _trt__AddAudioSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioSourceConfigurationResponse(struct soap *soap, struct _trt__AddAudioSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__AddAudioSourceConfigurationResponse(soap, tag?tag:"trt:AddAudioSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioSourceConfigurationResponse(struct soap *soap, struct _trt__AddAudioSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, struct _trt__AddAudioSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioSourceConfiguration))
		soap_serialize__trt__AddAudioSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, const char *tag, int id, struct _trt__AddAudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddAudioSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddAudioSourceConfiguration **)soap_malloc(soap, sizeof(struct _trt__AddAudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddAudioSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioSourceConfiguration, sizeof(struct _trt__AddAudioSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, struct _trt__AddAudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioSourceConfiguration);
	if (soap_out_PointerTo_trt__AddAudioSourceConfiguration(soap, tag?tag:"trt:AddAudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioSourceConfiguration(struct soap *soap, struct _trt__AddAudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioEncoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse))
		soap_serialize__trt__AddAudioEncoderConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__AddAudioEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddAudioEncoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddAudioEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddAudioEncoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__AddAudioEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddAudioEncoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioEncoderConfigurationResponse, sizeof(struct _trt__AddAudioEncoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__AddAudioEncoderConfigurationResponse(soap, tag?tag:"trt:AddAudioEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioEncoderConfigurationResponse(struct soap *soap, struct _trt__AddAudioEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, struct _trt__AddAudioEncoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddAudioEncoderConfiguration))
		soap_serialize__trt__AddAudioEncoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__AddAudioEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddAudioEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddAudioEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__AddAudioEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddAudioEncoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__AddAudioEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddAudioEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddAudioEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddAudioEncoderConfiguration, sizeof(struct _trt__AddAudioEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, struct _trt__AddAudioEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddAudioEncoderConfiguration);
	if (soap_out_PointerTo_trt__AddAudioEncoderConfiguration(soap, tag?tag:"trt:AddAudioEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddAudioEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddAudioEncoderConfiguration(struct soap *soap, struct _trt__AddAudioEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddAudioEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoSourceConfigurationResponse(struct soap *soap, struct _trt__AddVideoSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse))
		soap_serialize__trt__AddVideoSourceConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__AddVideoSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddVideoSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoSourceConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddVideoSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddVideoSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__AddVideoSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddVideoSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoSourceConfigurationResponse, sizeof(struct _trt__AddVideoSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoSourceConfigurationResponse(struct soap *soap, struct _trt__AddVideoSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddVideoSourceConfigurationResponse);
	if (soap_out_PointerTo_trt__AddVideoSourceConfigurationResponse(soap, tag?tag:"trt:AddVideoSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoSourceConfigurationResponse(struct soap *soap, struct _trt__AddVideoSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, struct _trt__AddVideoSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoSourceConfiguration))
		soap_serialize__trt__AddVideoSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, const char *tag, int id, struct _trt__AddVideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddVideoSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, const char *tag, struct _trt__AddVideoSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddVideoSourceConfiguration **)soap_malloc(soap, sizeof(struct _trt__AddVideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddVideoSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoSourceConfiguration, sizeof(struct _trt__AddVideoSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, struct _trt__AddVideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddVideoSourceConfiguration);
	if (soap_out_PointerTo_trt__AddVideoSourceConfiguration(soap, tag?tag:"trt:AddVideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoSourceConfiguration(struct soap *soap, struct _trt__AddVideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__AddVideoEncoderConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse))
		soap_serialize__trt__AddVideoEncoderConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trt__AddVideoEncoderConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddVideoEncoderConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoEncoderConfigurationResponse(struct soap *soap, const char *tag, struct _trt__AddVideoEncoderConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddVideoEncoderConfigurationResponse **)soap_malloc(soap, sizeof(struct _trt__AddVideoEncoderConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddVideoEncoderConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoEncoderConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoEncoderConfigurationResponse, sizeof(struct _trt__AddVideoEncoderConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__AddVideoEncoderConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddVideoEncoderConfigurationResponse);
	if (soap_out_PointerTo_trt__AddVideoEncoderConfigurationResponse(soap, tag?tag:"trt:AddVideoEncoderConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoEncoderConfigurationResponse(struct soap *soap, struct _trt__AddVideoEncoderConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoEncoderConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, struct _trt__AddVideoEncoderConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__AddVideoEncoderConfiguration))
		soap_serialize__trt__AddVideoEncoderConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, const char *tag, int id, struct _trt__AddVideoEncoderConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__AddVideoEncoderConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trt__AddVideoEncoderConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, const char *tag, struct _trt__AddVideoEncoderConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__AddVideoEncoderConfiguration **)soap_malloc(soap, sizeof(struct _trt__AddVideoEncoderConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__AddVideoEncoderConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__AddVideoEncoderConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__AddVideoEncoderConfiguration, sizeof(struct _trt__AddVideoEncoderConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, struct _trt__AddVideoEncoderConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__AddVideoEncoderConfiguration);
	if (soap_out_PointerTo_trt__AddVideoEncoderConfiguration(soap, tag?tag:"trt:AddVideoEncoderConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__AddVideoEncoderConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trt__AddVideoEncoderConfiguration(struct soap *soap, struct _trt__AddVideoEncoderConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__AddVideoEncoderConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfilesResponse))
		soap_serialize__trt__GetProfilesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfilesResponse(struct soap *soap, const char *tag, int id, struct _trt__GetProfilesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfilesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetProfilesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetProfilesResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfilesResponse(struct soap *soap, const char *tag, struct _trt__GetProfilesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetProfilesResponse **)soap_malloc(soap, sizeof(struct _trt__GetProfilesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetProfilesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfilesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfilesResponse, sizeof(struct _trt__GetProfilesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetProfilesResponse);
	if (soap_out_PointerTo_trt__GetProfilesResponse(soap, tag?tag:"trt:GetProfilesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfilesResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfilesResponse(struct soap *soap, struct _trt__GetProfilesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfilesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfiles))
		soap_serialize__trt__GetProfiles(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfiles(struct soap *soap, const char *tag, int id, struct _trt__GetProfiles *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfiles);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetProfiles(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetProfiles ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfiles(struct soap *soap, const char *tag, struct _trt__GetProfiles **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetProfiles **)soap_malloc(soap, sizeof(struct _trt__GetProfiles *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetProfiles(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfiles **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfiles, sizeof(struct _trt__GetProfiles), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetProfiles);
	if (soap_out_PointerTo_trt__GetProfiles(soap, tag?tag:"trt:GetProfiles", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfiles ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfiles(struct soap *soap, struct _trt__GetProfiles **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfiles(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfileResponse(struct soap *soap, struct _trt__GetProfileResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfileResponse))
		soap_serialize__trt__GetProfileResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfileResponse(struct soap *soap, const char *tag, int id, struct _trt__GetProfileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfileResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetProfileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetProfileResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfileResponse(struct soap *soap, const char *tag, struct _trt__GetProfileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetProfileResponse **)soap_malloc(soap, sizeof(struct _trt__GetProfileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetProfileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfileResponse, sizeof(struct _trt__GetProfileResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfileResponse(struct soap *soap, struct _trt__GetProfileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetProfileResponse);
	if (soap_out_PointerTo_trt__GetProfileResponse(soap, tag?tag:"trt:GetProfileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfileResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfileResponse(struct soap *soap, struct _trt__GetProfileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetProfile(struct soap *soap, struct _trt__GetProfile *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetProfile))
		soap_serialize__trt__GetProfile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetProfile(struct soap *soap, const char *tag, int id, struct _trt__GetProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetProfile);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetProfile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetProfile ** SOAP_FMAC4 soap_in_PointerTo_trt__GetProfile(struct soap *soap, const char *tag, struct _trt__GetProfile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetProfile **)soap_malloc(soap, sizeof(struct _trt__GetProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetProfile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetProfile, sizeof(struct _trt__GetProfile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetProfile(struct soap *soap, struct _trt__GetProfile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetProfile);
	if (soap_out_PointerTo_trt__GetProfile(soap, tag?tag:"trt:GetProfile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetProfile ** SOAP_FMAC4 soap_get_PointerTo_trt__GetProfile(struct soap *soap, struct _trt__GetProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__CreateProfileResponse(struct soap *soap, struct _trt__CreateProfileResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__CreateProfileResponse))
		soap_serialize__trt__CreateProfileResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__CreateProfileResponse(struct soap *soap, const char *tag, int id, struct _trt__CreateProfileResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__CreateProfileResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__CreateProfileResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__CreateProfileResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__CreateProfileResponse(struct soap *soap, const char *tag, struct _trt__CreateProfileResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__CreateProfileResponse **)soap_malloc(soap, sizeof(struct _trt__CreateProfileResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__CreateProfileResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__CreateProfileResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__CreateProfileResponse, sizeof(struct _trt__CreateProfileResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__CreateProfileResponse(struct soap *soap, struct _trt__CreateProfileResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__CreateProfileResponse);
	if (soap_out_PointerTo_trt__CreateProfileResponse(soap, tag?tag:"trt:CreateProfileResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__CreateProfileResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__CreateProfileResponse(struct soap *soap, struct _trt__CreateProfileResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__CreateProfileResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__CreateProfile(struct soap *soap, struct _trt__CreateProfile *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__CreateProfile))
		soap_serialize__trt__CreateProfile(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__CreateProfile(struct soap *soap, const char *tag, int id, struct _trt__CreateProfile *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__CreateProfile);
	if (id < 0)
		return soap->error;
	return soap_out__trt__CreateProfile(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__CreateProfile ** SOAP_FMAC4 soap_in_PointerTo_trt__CreateProfile(struct soap *soap, const char *tag, struct _trt__CreateProfile **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__CreateProfile **)soap_malloc(soap, sizeof(struct _trt__CreateProfile *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__CreateProfile(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__CreateProfile **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__CreateProfile, sizeof(struct _trt__CreateProfile), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__CreateProfile(struct soap *soap, struct _trt__CreateProfile *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__CreateProfile);
	if (soap_out_PointerTo_trt__CreateProfile(soap, tag?tag:"trt:CreateProfile", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__CreateProfile ** SOAP_FMAC4 soap_get_PointerTo_trt__CreateProfile(struct soap *soap, struct _trt__CreateProfile **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__CreateProfile(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, struct _trt__GetServiceCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetServiceCapabilitiesResponse))
		soap_serialize__trt__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _trt__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trt__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _trt__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetServiceCapabilitiesResponse, sizeof(struct _trt__GetServiceCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, struct _trt__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_trt__GetServiceCapabilitiesResponse(soap, tag?tag:"trt:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetServiceCapabilitiesResponse(struct soap *soap, struct _trt__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetServiceCapabilities(struct soap *soap, struct _trt__GetServiceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetServiceCapabilities))
		soap_serialize__trt__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _trt__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_trt__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trt__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _trt__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetServiceCapabilities, sizeof(struct _trt__GetServiceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetServiceCapabilities(struct soap *soap, struct _trt__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetServiceCapabilities);
	if (soap_out_PointerTo_trt__GetServiceCapabilities(soap, tag?tag:"trt:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_trt__GetServiceCapabilities(struct soap *soap, struct _trt__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trp__SetReplayConfigurationResponse(struct soap *soap, struct _trp__SetReplayConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trp__SetReplayConfigurationResponse))
		soap_serialize__trp__SetReplayConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trp__SetReplayConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trp__SetReplayConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trp__SetReplayConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trp__SetReplayConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trp__SetReplayConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trp__SetReplayConfigurationResponse(struct soap *soap, const char *tag, struct _trp__SetReplayConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trp__SetReplayConfigurationResponse **)soap_malloc(soap, sizeof(struct _trp__SetReplayConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trp__SetReplayConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trp__SetReplayConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trp__SetReplayConfigurationResponse, sizeof(struct _trp__SetReplayConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trp__SetReplayConfigurationResponse(struct soap *soap, struct _trp__SetReplayConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trp__SetReplayConfigurationResponse);
	if (soap_out_PointerTo_trp__SetReplayConfigurationResponse(soap, tag?tag:"trp:SetReplayConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__SetReplayConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trp__SetReplayConfigurationResponse(struct soap *soap, struct _trp__SetReplayConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trp__SetReplayConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trp__SetReplayConfiguration(struct soap *soap, struct _trp__SetReplayConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trp__SetReplayConfiguration))
		soap_serialize__trp__SetReplayConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trp__SetReplayConfiguration(struct soap *soap, const char *tag, int id, struct _trp__SetReplayConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trp__SetReplayConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trp__SetReplayConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trp__SetReplayConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trp__SetReplayConfiguration(struct soap *soap, const char *tag, struct _trp__SetReplayConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trp__SetReplayConfiguration **)soap_malloc(soap, sizeof(struct _trp__SetReplayConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trp__SetReplayConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trp__SetReplayConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trp__SetReplayConfiguration, sizeof(struct _trp__SetReplayConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trp__SetReplayConfiguration(struct soap *soap, struct _trp__SetReplayConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trp__SetReplayConfiguration);
	if (soap_out_PointerTo_trp__SetReplayConfiguration(soap, tag?tag:"trp:SetReplayConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__SetReplayConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trp__SetReplayConfiguration(struct soap *soap, struct _trp__SetReplayConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trp__SetReplayConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trp__GetReplayConfigurationResponse(struct soap *soap, struct _trp__GetReplayConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trp__GetReplayConfigurationResponse))
		soap_serialize__trp__GetReplayConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trp__GetReplayConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trp__GetReplayConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trp__GetReplayConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trp__GetReplayConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trp__GetReplayConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trp__GetReplayConfigurationResponse(struct soap *soap, const char *tag, struct _trp__GetReplayConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trp__GetReplayConfigurationResponse **)soap_malloc(soap, sizeof(struct _trp__GetReplayConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trp__GetReplayConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trp__GetReplayConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trp__GetReplayConfigurationResponse, sizeof(struct _trp__GetReplayConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trp__GetReplayConfigurationResponse(struct soap *soap, struct _trp__GetReplayConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trp__GetReplayConfigurationResponse);
	if (soap_out_PointerTo_trp__GetReplayConfigurationResponse(soap, tag?tag:"trp:GetReplayConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetReplayConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trp__GetReplayConfigurationResponse(struct soap *soap, struct _trp__GetReplayConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trp__GetReplayConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trp__GetReplayConfiguration(struct soap *soap, struct _trp__GetReplayConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trp__GetReplayConfiguration))
		soap_serialize__trp__GetReplayConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trp__GetReplayConfiguration(struct soap *soap, const char *tag, int id, struct _trp__GetReplayConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trp__GetReplayConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trp__GetReplayConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trp__GetReplayConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trp__GetReplayConfiguration(struct soap *soap, const char *tag, struct _trp__GetReplayConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trp__GetReplayConfiguration **)soap_malloc(soap, sizeof(struct _trp__GetReplayConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trp__GetReplayConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trp__GetReplayConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trp__GetReplayConfiguration, sizeof(struct _trp__GetReplayConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trp__GetReplayConfiguration(struct soap *soap, struct _trp__GetReplayConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trp__GetReplayConfiguration);
	if (soap_out_PointerTo_trp__GetReplayConfiguration(soap, tag?tag:"trp:GetReplayConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetReplayConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trp__GetReplayConfiguration(struct soap *soap, struct _trp__GetReplayConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trp__GetReplayConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trp__GetReplayUriResponse(struct soap *soap, struct _trp__GetReplayUriResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trp__GetReplayUriResponse))
		soap_serialize__trp__GetReplayUriResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trp__GetReplayUriResponse(struct soap *soap, const char *tag, int id, struct _trp__GetReplayUriResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trp__GetReplayUriResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trp__GetReplayUriResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trp__GetReplayUriResponse ** SOAP_FMAC4 soap_in_PointerTo_trp__GetReplayUriResponse(struct soap *soap, const char *tag, struct _trp__GetReplayUriResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trp__GetReplayUriResponse **)soap_malloc(soap, sizeof(struct _trp__GetReplayUriResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trp__GetReplayUriResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trp__GetReplayUriResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trp__GetReplayUriResponse, sizeof(struct _trp__GetReplayUriResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trp__GetReplayUriResponse(struct soap *soap, struct _trp__GetReplayUriResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trp__GetReplayUriResponse);
	if (soap_out_PointerTo_trp__GetReplayUriResponse(soap, tag?tag:"trp:GetReplayUriResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetReplayUriResponse ** SOAP_FMAC4 soap_get_PointerTo_trp__GetReplayUriResponse(struct soap *soap, struct _trp__GetReplayUriResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trp__GetReplayUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trp__GetReplayUri(struct soap *soap, struct _trp__GetReplayUri *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trp__GetReplayUri))
		soap_serialize__trp__GetReplayUri(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trp__GetReplayUri(struct soap *soap, const char *tag, int id, struct _trp__GetReplayUri *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trp__GetReplayUri);
	if (id < 0)
		return soap->error;
	return soap_out__trp__GetReplayUri(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trp__GetReplayUri ** SOAP_FMAC4 soap_in_PointerTo_trp__GetReplayUri(struct soap *soap, const char *tag, struct _trp__GetReplayUri **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trp__GetReplayUri **)soap_malloc(soap, sizeof(struct _trp__GetReplayUri *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trp__GetReplayUri(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trp__GetReplayUri **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trp__GetReplayUri, sizeof(struct _trp__GetReplayUri), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trp__GetReplayUri(struct soap *soap, struct _trp__GetReplayUri *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trp__GetReplayUri);
	if (soap_out_PointerTo_trp__GetReplayUri(soap, tag?tag:"trp:GetReplayUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetReplayUri ** SOAP_FMAC4 soap_get_PointerTo_trp__GetReplayUri(struct soap *soap, struct _trp__GetReplayUri **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trp__GetReplayUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trp__GetServiceCapabilitiesResponse(struct soap *soap, struct _trp__GetServiceCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trp__GetServiceCapabilitiesResponse))
		soap_serialize__trp__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trp__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _trp__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trp__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trp__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trp__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_trp__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trp__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trp__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _trp__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trp__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trp__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trp__GetServiceCapabilitiesResponse, sizeof(struct _trp__GetServiceCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trp__GetServiceCapabilitiesResponse(struct soap *soap, struct _trp__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trp__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_trp__GetServiceCapabilitiesResponse(soap, tag?tag:"trp:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_trp__GetServiceCapabilitiesResponse(struct soap *soap, struct _trp__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trp__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trp__GetServiceCapabilities(struct soap *soap, struct _trp__GetServiceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trp__GetServiceCapabilities))
		soap_serialize__trp__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trp__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _trp__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trp__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__trp__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trp__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_trp__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trp__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trp__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _trp__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trp__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trp__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trp__GetServiceCapabilities, sizeof(struct _trp__GetServiceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trp__GetServiceCapabilities(struct soap *soap, struct _trp__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trp__GetServiceCapabilities);
	if (soap_out_PointerTo_trp__GetServiceCapabilities(soap, tag?tag:"trp:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_trp__GetServiceCapabilities(struct soap *soap, struct _trp__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trp__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetRecordingJobStateResponse(struct soap *soap, struct _trc__GetRecordingJobStateResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetRecordingJobStateResponse))
		soap_serialize__trc__GetRecordingJobStateResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetRecordingJobStateResponse(struct soap *soap, const char *tag, int id, struct _trc__GetRecordingJobStateResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetRecordingJobStateResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetRecordingJobStateResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetRecordingJobStateResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__GetRecordingJobStateResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingJobStateResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetRecordingJobStateResponse **)soap_malloc(soap, sizeof(struct _trc__GetRecordingJobStateResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetRecordingJobStateResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobStateResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingJobStateResponse, sizeof(struct _trc__GetRecordingJobStateResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetRecordingJobStateResponse(struct soap *soap, struct _trc__GetRecordingJobStateResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__GetRecordingJobStateResponse);
	if (soap_out_PointerTo_trc__GetRecordingJobStateResponse(soap, tag?tag:"trc:GetRecordingJobStateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobStateResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__GetRecordingJobStateResponse(struct soap *soap, struct _trc__GetRecordingJobStateResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetRecordingJobStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetRecordingJobState(struct soap *soap, struct _trc__GetRecordingJobState *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetRecordingJobState))
		soap_serialize__trc__GetRecordingJobState(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetRecordingJobState(struct soap *soap, const char *tag, int id, struct _trc__GetRecordingJobState *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetRecordingJobState);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetRecordingJobState(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetRecordingJobState ** SOAP_FMAC4 soap_in_PointerTo_trc__GetRecordingJobState(struct soap *soap, const char *tag, struct _trc__GetRecordingJobState **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetRecordingJobState **)soap_malloc(soap, sizeof(struct _trc__GetRecordingJobState *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetRecordingJobState(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobState **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingJobState, sizeof(struct _trc__GetRecordingJobState), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetRecordingJobState(struct soap *soap, struct _trc__GetRecordingJobState *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__GetRecordingJobState);
	if (soap_out_PointerTo_trc__GetRecordingJobState(soap, tag?tag:"trc:GetRecordingJobState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobState ** SOAP_FMAC4 soap_get_PointerTo_trc__GetRecordingJobState(struct soap *soap, struct _trc__GetRecordingJobState **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetRecordingJobState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__SetRecordingJobModeResponse(struct soap *soap, struct _trc__SetRecordingJobModeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__SetRecordingJobModeResponse))
		soap_serialize__trc__SetRecordingJobModeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__SetRecordingJobModeResponse(struct soap *soap, const char *tag, int id, struct _trc__SetRecordingJobModeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__SetRecordingJobModeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trc__SetRecordingJobModeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__SetRecordingJobModeResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__SetRecordingJobModeResponse(struct soap *soap, const char *tag, struct _trc__SetRecordingJobModeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__SetRecordingJobModeResponse **)soap_malloc(soap, sizeof(struct _trc__SetRecordingJobModeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__SetRecordingJobModeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingJobModeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__SetRecordingJobModeResponse, sizeof(struct _trc__SetRecordingJobModeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__SetRecordingJobModeResponse(struct soap *soap, struct _trc__SetRecordingJobModeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__SetRecordingJobModeResponse);
	if (soap_out_PointerTo_trc__SetRecordingJobModeResponse(soap, tag?tag:"trc:SetRecordingJobModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingJobModeResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__SetRecordingJobModeResponse(struct soap *soap, struct _trc__SetRecordingJobModeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__SetRecordingJobModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__SetRecordingJobMode(struct soap *soap, struct _trc__SetRecordingJobMode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__SetRecordingJobMode))
		soap_serialize__trc__SetRecordingJobMode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__SetRecordingJobMode(struct soap *soap, const char *tag, int id, struct _trc__SetRecordingJobMode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__SetRecordingJobMode);
	if (id < 0)
		return soap->error;
	return soap_out__trc__SetRecordingJobMode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__SetRecordingJobMode ** SOAP_FMAC4 soap_in_PointerTo_trc__SetRecordingJobMode(struct soap *soap, const char *tag, struct _trc__SetRecordingJobMode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__SetRecordingJobMode **)soap_malloc(soap, sizeof(struct _trc__SetRecordingJobMode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__SetRecordingJobMode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingJobMode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__SetRecordingJobMode, sizeof(struct _trc__SetRecordingJobMode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__SetRecordingJobMode(struct soap *soap, struct _trc__SetRecordingJobMode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__SetRecordingJobMode);
	if (soap_out_PointerTo_trc__SetRecordingJobMode(soap, tag?tag:"trc:SetRecordingJobMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingJobMode ** SOAP_FMAC4 soap_get_PointerTo_trc__SetRecordingJobMode(struct soap *soap, struct _trc__SetRecordingJobMode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__SetRecordingJobMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetRecordingJobConfigurationResponse(struct soap *soap, struct _trc__GetRecordingJobConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetRecordingJobConfigurationResponse))
		soap_serialize__trc__GetRecordingJobConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetRecordingJobConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trc__GetRecordingJobConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetRecordingJobConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetRecordingJobConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__GetRecordingJobConfigurationResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingJobConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetRecordingJobConfigurationResponse **)soap_malloc(soap, sizeof(struct _trc__GetRecordingJobConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetRecordingJobConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingJobConfigurationResponse, sizeof(struct _trc__GetRecordingJobConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetRecordingJobConfigurationResponse(struct soap *soap, struct _trc__GetRecordingJobConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__GetRecordingJobConfigurationResponse);
	if (soap_out_PointerTo_trc__GetRecordingJobConfigurationResponse(soap, tag?tag:"trc:GetRecordingJobConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__GetRecordingJobConfigurationResponse(struct soap *soap, struct _trc__GetRecordingJobConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetRecordingJobConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetRecordingJobConfiguration(struct soap *soap, struct _trc__GetRecordingJobConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetRecordingJobConfiguration))
		soap_serialize__trc__GetRecordingJobConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetRecordingJobConfiguration(struct soap *soap, const char *tag, int id, struct _trc__GetRecordingJobConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetRecordingJobConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetRecordingJobConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trc__GetRecordingJobConfiguration(struct soap *soap, const char *tag, struct _trc__GetRecordingJobConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetRecordingJobConfiguration **)soap_malloc(soap, sizeof(struct _trc__GetRecordingJobConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetRecordingJobConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingJobConfiguration, sizeof(struct _trc__GetRecordingJobConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetRecordingJobConfiguration(struct soap *soap, struct _trc__GetRecordingJobConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__GetRecordingJobConfiguration);
	if (soap_out_PointerTo_trc__GetRecordingJobConfiguration(soap, tag?tag:"trc:GetRecordingJobConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trc__GetRecordingJobConfiguration(struct soap *soap, struct _trc__GetRecordingJobConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetRecordingJobConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__SetRecordingJobConfigurationResponse(struct soap *soap, struct _trc__SetRecordingJobConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__SetRecordingJobConfigurationResponse))
		soap_serialize__trc__SetRecordingJobConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__SetRecordingJobConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trc__SetRecordingJobConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__SetRecordingJobConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trc__SetRecordingJobConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__SetRecordingJobConfigurationResponse(struct soap *soap, const char *tag, struct _trc__SetRecordingJobConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__SetRecordingJobConfigurationResponse **)soap_malloc(soap, sizeof(struct _trc__SetRecordingJobConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__SetRecordingJobConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingJobConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__SetRecordingJobConfigurationResponse, sizeof(struct _trc__SetRecordingJobConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__SetRecordingJobConfigurationResponse(struct soap *soap, struct _trc__SetRecordingJobConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__SetRecordingJobConfigurationResponse);
	if (soap_out_PointerTo_trc__SetRecordingJobConfigurationResponse(soap, tag?tag:"trc:SetRecordingJobConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__SetRecordingJobConfigurationResponse(struct soap *soap, struct _trc__SetRecordingJobConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__SetRecordingJobConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__SetRecordingJobConfiguration(struct soap *soap, struct _trc__SetRecordingJobConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__SetRecordingJobConfiguration))
		soap_serialize__trc__SetRecordingJobConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__SetRecordingJobConfiguration(struct soap *soap, const char *tag, int id, struct _trc__SetRecordingJobConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__SetRecordingJobConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trc__SetRecordingJobConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trc__SetRecordingJobConfiguration(struct soap *soap, const char *tag, struct _trc__SetRecordingJobConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__SetRecordingJobConfiguration **)soap_malloc(soap, sizeof(struct _trc__SetRecordingJobConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__SetRecordingJobConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingJobConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__SetRecordingJobConfiguration, sizeof(struct _trc__SetRecordingJobConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__SetRecordingJobConfiguration(struct soap *soap, struct _trc__SetRecordingJobConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__SetRecordingJobConfiguration);
	if (soap_out_PointerTo_trc__SetRecordingJobConfiguration(soap, tag?tag:"trc:SetRecordingJobConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trc__SetRecordingJobConfiguration(struct soap *soap, struct _trc__SetRecordingJobConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__SetRecordingJobConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetRecordingJobsResponse(struct soap *soap, struct _trc__GetRecordingJobsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetRecordingJobsResponse))
		soap_serialize__trc__GetRecordingJobsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetRecordingJobsResponse(struct soap *soap, const char *tag, int id, struct _trc__GetRecordingJobsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetRecordingJobsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetRecordingJobsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetRecordingJobsResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__GetRecordingJobsResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingJobsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetRecordingJobsResponse **)soap_malloc(soap, sizeof(struct _trc__GetRecordingJobsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetRecordingJobsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingJobsResponse, sizeof(struct _trc__GetRecordingJobsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetRecordingJobsResponse(struct soap *soap, struct _trc__GetRecordingJobsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__GetRecordingJobsResponse);
	if (soap_out_PointerTo_trc__GetRecordingJobsResponse(soap, tag?tag:"trc:GetRecordingJobsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobsResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__GetRecordingJobsResponse(struct soap *soap, struct _trc__GetRecordingJobsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetRecordingJobsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetRecordingJobs(struct soap *soap, struct _trc__GetRecordingJobs *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetRecordingJobs))
		soap_serialize__trc__GetRecordingJobs(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetRecordingJobs(struct soap *soap, const char *tag, int id, struct _trc__GetRecordingJobs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetRecordingJobs);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetRecordingJobs(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetRecordingJobs ** SOAP_FMAC4 soap_in_PointerTo_trc__GetRecordingJobs(struct soap *soap, const char *tag, struct _trc__GetRecordingJobs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetRecordingJobs **)soap_malloc(soap, sizeof(struct _trc__GetRecordingJobs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetRecordingJobs(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingJobs, sizeof(struct _trc__GetRecordingJobs), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetRecordingJobs(struct soap *soap, struct _trc__GetRecordingJobs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__GetRecordingJobs);
	if (soap_out_PointerTo_trc__GetRecordingJobs(soap, tag?tag:"trc:GetRecordingJobs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobs ** SOAP_FMAC4 soap_get_PointerTo_trc__GetRecordingJobs(struct soap *soap, struct _trc__GetRecordingJobs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetRecordingJobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__DeleteRecordingJobResponse(struct soap *soap, struct _trc__DeleteRecordingJobResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__DeleteRecordingJobResponse))
		soap_serialize__trc__DeleteRecordingJobResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__DeleteRecordingJobResponse(struct soap *soap, const char *tag, int id, struct _trc__DeleteRecordingJobResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__DeleteRecordingJobResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trc__DeleteRecordingJobResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__DeleteRecordingJobResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__DeleteRecordingJobResponse(struct soap *soap, const char *tag, struct _trc__DeleteRecordingJobResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__DeleteRecordingJobResponse **)soap_malloc(soap, sizeof(struct _trc__DeleteRecordingJobResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__DeleteRecordingJobResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteRecordingJobResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__DeleteRecordingJobResponse, sizeof(struct _trc__DeleteRecordingJobResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__DeleteRecordingJobResponse(struct soap *soap, struct _trc__DeleteRecordingJobResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__DeleteRecordingJobResponse);
	if (soap_out_PointerTo_trc__DeleteRecordingJobResponse(soap, tag?tag:"trc:DeleteRecordingJobResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteRecordingJobResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__DeleteRecordingJobResponse(struct soap *soap, struct _trc__DeleteRecordingJobResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__DeleteRecordingJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__DeleteRecordingJob(struct soap *soap, struct _trc__DeleteRecordingJob *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__DeleteRecordingJob))
		soap_serialize__trc__DeleteRecordingJob(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__DeleteRecordingJob(struct soap *soap, const char *tag, int id, struct _trc__DeleteRecordingJob *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__DeleteRecordingJob);
	if (id < 0)
		return soap->error;
	return soap_out__trc__DeleteRecordingJob(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__DeleteRecordingJob ** SOAP_FMAC4 soap_in_PointerTo_trc__DeleteRecordingJob(struct soap *soap, const char *tag, struct _trc__DeleteRecordingJob **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__DeleteRecordingJob **)soap_malloc(soap, sizeof(struct _trc__DeleteRecordingJob *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__DeleteRecordingJob(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteRecordingJob **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__DeleteRecordingJob, sizeof(struct _trc__DeleteRecordingJob), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__DeleteRecordingJob(struct soap *soap, struct _trc__DeleteRecordingJob *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__DeleteRecordingJob);
	if (soap_out_PointerTo_trc__DeleteRecordingJob(soap, tag?tag:"trc:DeleteRecordingJob", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteRecordingJob ** SOAP_FMAC4 soap_get_PointerTo_trc__DeleteRecordingJob(struct soap *soap, struct _trc__DeleteRecordingJob **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__DeleteRecordingJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__CreateRecordingJobResponse(struct soap *soap, struct _trc__CreateRecordingJobResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__CreateRecordingJobResponse))
		soap_serialize__trc__CreateRecordingJobResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__CreateRecordingJobResponse(struct soap *soap, const char *tag, int id, struct _trc__CreateRecordingJobResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__CreateRecordingJobResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trc__CreateRecordingJobResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__CreateRecordingJobResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__CreateRecordingJobResponse(struct soap *soap, const char *tag, struct _trc__CreateRecordingJobResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__CreateRecordingJobResponse **)soap_malloc(soap, sizeof(struct _trc__CreateRecordingJobResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__CreateRecordingJobResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__CreateRecordingJobResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__CreateRecordingJobResponse, sizeof(struct _trc__CreateRecordingJobResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__CreateRecordingJobResponse(struct soap *soap, struct _trc__CreateRecordingJobResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__CreateRecordingJobResponse);
	if (soap_out_PointerTo_trc__CreateRecordingJobResponse(soap, tag?tag:"trc:CreateRecordingJobResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateRecordingJobResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__CreateRecordingJobResponse(struct soap *soap, struct _trc__CreateRecordingJobResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__CreateRecordingJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__CreateRecordingJob(struct soap *soap, struct _trc__CreateRecordingJob *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__CreateRecordingJob))
		soap_serialize__trc__CreateRecordingJob(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__CreateRecordingJob(struct soap *soap, const char *tag, int id, struct _trc__CreateRecordingJob *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__CreateRecordingJob);
	if (id < 0)
		return soap->error;
	return soap_out__trc__CreateRecordingJob(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__CreateRecordingJob ** SOAP_FMAC4 soap_in_PointerTo_trc__CreateRecordingJob(struct soap *soap, const char *tag, struct _trc__CreateRecordingJob **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__CreateRecordingJob **)soap_malloc(soap, sizeof(struct _trc__CreateRecordingJob *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__CreateRecordingJob(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__CreateRecordingJob **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__CreateRecordingJob, sizeof(struct _trc__CreateRecordingJob), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__CreateRecordingJob(struct soap *soap, struct _trc__CreateRecordingJob *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__CreateRecordingJob);
	if (soap_out_PointerTo_trc__CreateRecordingJob(soap, tag?tag:"trc:CreateRecordingJob", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateRecordingJob ** SOAP_FMAC4 soap_get_PointerTo_trc__CreateRecordingJob(struct soap *soap, struct _trc__CreateRecordingJob **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__CreateRecordingJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__SetTrackConfigurationResponse(struct soap *soap, struct _trc__SetTrackConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__SetTrackConfigurationResponse))
		soap_serialize__trc__SetTrackConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__SetTrackConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trc__SetTrackConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__SetTrackConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trc__SetTrackConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__SetTrackConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__SetTrackConfigurationResponse(struct soap *soap, const char *tag, struct _trc__SetTrackConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__SetTrackConfigurationResponse **)soap_malloc(soap, sizeof(struct _trc__SetTrackConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__SetTrackConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__SetTrackConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__SetTrackConfigurationResponse, sizeof(struct _trc__SetTrackConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__SetTrackConfigurationResponse(struct soap *soap, struct _trc__SetTrackConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__SetTrackConfigurationResponse);
	if (soap_out_PointerTo_trc__SetTrackConfigurationResponse(soap, tag?tag:"trc:SetTrackConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetTrackConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__SetTrackConfigurationResponse(struct soap *soap, struct _trc__SetTrackConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__SetTrackConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__SetTrackConfiguration(struct soap *soap, struct _trc__SetTrackConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__SetTrackConfiguration))
		soap_serialize__trc__SetTrackConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__SetTrackConfiguration(struct soap *soap, const char *tag, int id, struct _trc__SetTrackConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__SetTrackConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trc__SetTrackConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__SetTrackConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trc__SetTrackConfiguration(struct soap *soap, const char *tag, struct _trc__SetTrackConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__SetTrackConfiguration **)soap_malloc(soap, sizeof(struct _trc__SetTrackConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__SetTrackConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__SetTrackConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__SetTrackConfiguration, sizeof(struct _trc__SetTrackConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__SetTrackConfiguration(struct soap *soap, struct _trc__SetTrackConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__SetTrackConfiguration);
	if (soap_out_PointerTo_trc__SetTrackConfiguration(soap, tag?tag:"trc:SetTrackConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetTrackConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trc__SetTrackConfiguration(struct soap *soap, struct _trc__SetTrackConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__SetTrackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetTrackConfigurationResponse(struct soap *soap, struct _trc__GetTrackConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetTrackConfigurationResponse))
		soap_serialize__trc__GetTrackConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetTrackConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trc__GetTrackConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetTrackConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetTrackConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetTrackConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__GetTrackConfigurationResponse(struct soap *soap, const char *tag, struct _trc__GetTrackConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetTrackConfigurationResponse **)soap_malloc(soap, sizeof(struct _trc__GetTrackConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetTrackConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetTrackConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetTrackConfigurationResponse, sizeof(struct _trc__GetTrackConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetTrackConfigurationResponse(struct soap *soap, struct _trc__GetTrackConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__GetTrackConfigurationResponse);
	if (soap_out_PointerTo_trc__GetTrackConfigurationResponse(soap, tag?tag:"trc:GetTrackConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetTrackConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__GetTrackConfigurationResponse(struct soap *soap, struct _trc__GetTrackConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetTrackConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetTrackConfiguration(struct soap *soap, struct _trc__GetTrackConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetTrackConfiguration))
		soap_serialize__trc__GetTrackConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetTrackConfiguration(struct soap *soap, const char *tag, int id, struct _trc__GetTrackConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetTrackConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetTrackConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetTrackConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trc__GetTrackConfiguration(struct soap *soap, const char *tag, struct _trc__GetTrackConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetTrackConfiguration **)soap_malloc(soap, sizeof(struct _trc__GetTrackConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetTrackConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetTrackConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetTrackConfiguration, sizeof(struct _trc__GetTrackConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetTrackConfiguration(struct soap *soap, struct _trc__GetTrackConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__GetTrackConfiguration);
	if (soap_out_PointerTo_trc__GetTrackConfiguration(soap, tag?tag:"trc:GetTrackConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetTrackConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trc__GetTrackConfiguration(struct soap *soap, struct _trc__GetTrackConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetTrackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__DeleteTrackResponse(struct soap *soap, struct _trc__DeleteTrackResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__DeleteTrackResponse))
		soap_serialize__trc__DeleteTrackResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__DeleteTrackResponse(struct soap *soap, const char *tag, int id, struct _trc__DeleteTrackResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__DeleteTrackResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trc__DeleteTrackResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__DeleteTrackResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__DeleteTrackResponse(struct soap *soap, const char *tag, struct _trc__DeleteTrackResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__DeleteTrackResponse **)soap_malloc(soap, sizeof(struct _trc__DeleteTrackResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__DeleteTrackResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteTrackResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__DeleteTrackResponse, sizeof(struct _trc__DeleteTrackResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__DeleteTrackResponse(struct soap *soap, struct _trc__DeleteTrackResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__DeleteTrackResponse);
	if (soap_out_PointerTo_trc__DeleteTrackResponse(soap, tag?tag:"trc:DeleteTrackResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteTrackResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__DeleteTrackResponse(struct soap *soap, struct _trc__DeleteTrackResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__DeleteTrackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__DeleteTrack(struct soap *soap, struct _trc__DeleteTrack *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__DeleteTrack))
		soap_serialize__trc__DeleteTrack(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__DeleteTrack(struct soap *soap, const char *tag, int id, struct _trc__DeleteTrack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__DeleteTrack);
	if (id < 0)
		return soap->error;
	return soap_out__trc__DeleteTrack(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__DeleteTrack ** SOAP_FMAC4 soap_in_PointerTo_trc__DeleteTrack(struct soap *soap, const char *tag, struct _trc__DeleteTrack **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__DeleteTrack **)soap_malloc(soap, sizeof(struct _trc__DeleteTrack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__DeleteTrack(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__DeleteTrack, sizeof(struct _trc__DeleteTrack), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__DeleteTrack(struct soap *soap, struct _trc__DeleteTrack *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__DeleteTrack);
	if (soap_out_PointerTo_trc__DeleteTrack(soap, tag?tag:"trc:DeleteTrack", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteTrack ** SOAP_FMAC4 soap_get_PointerTo_trc__DeleteTrack(struct soap *soap, struct _trc__DeleteTrack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__DeleteTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__CreateTrackResponse(struct soap *soap, struct _trc__CreateTrackResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__CreateTrackResponse))
		soap_serialize__trc__CreateTrackResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__CreateTrackResponse(struct soap *soap, const char *tag, int id, struct _trc__CreateTrackResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__CreateTrackResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trc__CreateTrackResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__CreateTrackResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__CreateTrackResponse(struct soap *soap, const char *tag, struct _trc__CreateTrackResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__CreateTrackResponse **)soap_malloc(soap, sizeof(struct _trc__CreateTrackResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__CreateTrackResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__CreateTrackResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__CreateTrackResponse, sizeof(struct _trc__CreateTrackResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__CreateTrackResponse(struct soap *soap, struct _trc__CreateTrackResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__CreateTrackResponse);
	if (soap_out_PointerTo_trc__CreateTrackResponse(soap, tag?tag:"trc:CreateTrackResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateTrackResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__CreateTrackResponse(struct soap *soap, struct _trc__CreateTrackResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__CreateTrackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__CreateTrack(struct soap *soap, struct _trc__CreateTrack *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__CreateTrack))
		soap_serialize__trc__CreateTrack(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__CreateTrack(struct soap *soap, const char *tag, int id, struct _trc__CreateTrack *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__CreateTrack);
	if (id < 0)
		return soap->error;
	return soap_out__trc__CreateTrack(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__CreateTrack ** SOAP_FMAC4 soap_in_PointerTo_trc__CreateTrack(struct soap *soap, const char *tag, struct _trc__CreateTrack **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__CreateTrack **)soap_malloc(soap, sizeof(struct _trc__CreateTrack *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__CreateTrack(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__CreateTrack **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__CreateTrack, sizeof(struct _trc__CreateTrack), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__CreateTrack(struct soap *soap, struct _trc__CreateTrack *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__CreateTrack);
	if (soap_out_PointerTo_trc__CreateTrack(soap, tag?tag:"trc:CreateTrack", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateTrack ** SOAP_FMAC4 soap_get_PointerTo_trc__CreateTrack(struct soap *soap, struct _trc__CreateTrack **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__CreateTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetRecordingOptionsResponse(struct soap *soap, struct _trc__GetRecordingOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetRecordingOptionsResponse))
		soap_serialize__trc__GetRecordingOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetRecordingOptionsResponse(struct soap *soap, const char *tag, int id, struct _trc__GetRecordingOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetRecordingOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetRecordingOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetRecordingOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__GetRecordingOptionsResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetRecordingOptionsResponse **)soap_malloc(soap, sizeof(struct _trc__GetRecordingOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetRecordingOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingOptionsResponse, sizeof(struct _trc__GetRecordingOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetRecordingOptionsResponse(struct soap *soap, struct _trc__GetRecordingOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__GetRecordingOptionsResponse);
	if (soap_out_PointerTo_trc__GetRecordingOptionsResponse(soap, tag?tag:"trc:GetRecordingOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__GetRecordingOptionsResponse(struct soap *soap, struct _trc__GetRecordingOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetRecordingOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetRecordingOptions(struct soap *soap, struct _trc__GetRecordingOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetRecordingOptions))
		soap_serialize__trc__GetRecordingOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetRecordingOptions(struct soap *soap, const char *tag, int id, struct _trc__GetRecordingOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetRecordingOptions);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetRecordingOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetRecordingOptions ** SOAP_FMAC4 soap_in_PointerTo_trc__GetRecordingOptions(struct soap *soap, const char *tag, struct _trc__GetRecordingOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetRecordingOptions **)soap_malloc(soap, sizeof(struct _trc__GetRecordingOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetRecordingOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingOptions, sizeof(struct _trc__GetRecordingOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetRecordingOptions(struct soap *soap, struct _trc__GetRecordingOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__GetRecordingOptions);
	if (soap_out_PointerTo_trc__GetRecordingOptions(soap, tag?tag:"trc:GetRecordingOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingOptions ** SOAP_FMAC4 soap_get_PointerTo_trc__GetRecordingOptions(struct soap *soap, struct _trc__GetRecordingOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetRecordingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetRecordingConfigurationResponse(struct soap *soap, struct _trc__GetRecordingConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetRecordingConfigurationResponse))
		soap_serialize__trc__GetRecordingConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetRecordingConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trc__GetRecordingConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetRecordingConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetRecordingConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetRecordingConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__GetRecordingConfigurationResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetRecordingConfigurationResponse **)soap_malloc(soap, sizeof(struct _trc__GetRecordingConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetRecordingConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingConfigurationResponse, sizeof(struct _trc__GetRecordingConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetRecordingConfigurationResponse(struct soap *soap, struct _trc__GetRecordingConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__GetRecordingConfigurationResponse);
	if (soap_out_PointerTo_trc__GetRecordingConfigurationResponse(soap, tag?tag:"trc:GetRecordingConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__GetRecordingConfigurationResponse(struct soap *soap, struct _trc__GetRecordingConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetRecordingConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetRecordingConfiguration(struct soap *soap, struct _trc__GetRecordingConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetRecordingConfiguration))
		soap_serialize__trc__GetRecordingConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetRecordingConfiguration(struct soap *soap, const char *tag, int id, struct _trc__GetRecordingConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetRecordingConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetRecordingConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetRecordingConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trc__GetRecordingConfiguration(struct soap *soap, const char *tag, struct _trc__GetRecordingConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetRecordingConfiguration **)soap_malloc(soap, sizeof(struct _trc__GetRecordingConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetRecordingConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingConfiguration, sizeof(struct _trc__GetRecordingConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetRecordingConfiguration(struct soap *soap, struct _trc__GetRecordingConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__GetRecordingConfiguration);
	if (soap_out_PointerTo_trc__GetRecordingConfiguration(soap, tag?tag:"trc:GetRecordingConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trc__GetRecordingConfiguration(struct soap *soap, struct _trc__GetRecordingConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetRecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__SetRecordingConfigurationResponse(struct soap *soap, struct _trc__SetRecordingConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__SetRecordingConfigurationResponse))
		soap_serialize__trc__SetRecordingConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__SetRecordingConfigurationResponse(struct soap *soap, const char *tag, int id, struct _trc__SetRecordingConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__SetRecordingConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trc__SetRecordingConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__SetRecordingConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__SetRecordingConfigurationResponse(struct soap *soap, const char *tag, struct _trc__SetRecordingConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__SetRecordingConfigurationResponse **)soap_malloc(soap, sizeof(struct _trc__SetRecordingConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__SetRecordingConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__SetRecordingConfigurationResponse, sizeof(struct _trc__SetRecordingConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__SetRecordingConfigurationResponse(struct soap *soap, struct _trc__SetRecordingConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__SetRecordingConfigurationResponse);
	if (soap_out_PointerTo_trc__SetRecordingConfigurationResponse(soap, tag?tag:"trc:SetRecordingConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__SetRecordingConfigurationResponse(struct soap *soap, struct _trc__SetRecordingConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__SetRecordingConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__SetRecordingConfiguration(struct soap *soap, struct _trc__SetRecordingConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__SetRecordingConfiguration))
		soap_serialize__trc__SetRecordingConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__SetRecordingConfiguration(struct soap *soap, const char *tag, int id, struct _trc__SetRecordingConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__SetRecordingConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__trc__SetRecordingConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__SetRecordingConfiguration ** SOAP_FMAC4 soap_in_PointerTo_trc__SetRecordingConfiguration(struct soap *soap, const char *tag, struct _trc__SetRecordingConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__SetRecordingConfiguration **)soap_malloc(soap, sizeof(struct _trc__SetRecordingConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__SetRecordingConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__SetRecordingConfiguration, sizeof(struct _trc__SetRecordingConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__SetRecordingConfiguration(struct soap *soap, struct _trc__SetRecordingConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__SetRecordingConfiguration);
	if (soap_out_PointerTo_trc__SetRecordingConfiguration(soap, tag?tag:"trc:SetRecordingConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingConfiguration ** SOAP_FMAC4 soap_get_PointerTo_trc__SetRecordingConfiguration(struct soap *soap, struct _trc__SetRecordingConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__SetRecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetRecordingsResponse(struct soap *soap, struct _trc__GetRecordingsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetRecordingsResponse))
		soap_serialize__trc__GetRecordingsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetRecordingsResponse(struct soap *soap, const char *tag, int id, struct _trc__GetRecordingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetRecordingsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetRecordingsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetRecordingsResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__GetRecordingsResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetRecordingsResponse **)soap_malloc(soap, sizeof(struct _trc__GetRecordingsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetRecordingsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordingsResponse, sizeof(struct _trc__GetRecordingsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetRecordingsResponse(struct soap *soap, struct _trc__GetRecordingsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__GetRecordingsResponse);
	if (soap_out_PointerTo_trc__GetRecordingsResponse(soap, tag?tag:"trc:GetRecordingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingsResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__GetRecordingsResponse(struct soap *soap, struct _trc__GetRecordingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetRecordingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetRecordings(struct soap *soap, struct _trc__GetRecordings *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetRecordings))
		soap_serialize__trc__GetRecordings(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetRecordings(struct soap *soap, const char *tag, int id, struct _trc__GetRecordings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetRecordings);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetRecordings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetRecordings ** SOAP_FMAC4 soap_in_PointerTo_trc__GetRecordings(struct soap *soap, const char *tag, struct _trc__GetRecordings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetRecordings **)soap_malloc(soap, sizeof(struct _trc__GetRecordings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetRecordings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetRecordings, sizeof(struct _trc__GetRecordings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetRecordings(struct soap *soap, struct _trc__GetRecordings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__GetRecordings);
	if (soap_out_PointerTo_trc__GetRecordings(soap, tag?tag:"trc:GetRecordings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordings ** SOAP_FMAC4 soap_get_PointerTo_trc__GetRecordings(struct soap *soap, struct _trc__GetRecordings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetRecordings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__DeleteRecordingResponse(struct soap *soap, struct _trc__DeleteRecordingResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__DeleteRecordingResponse))
		soap_serialize__trc__DeleteRecordingResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__DeleteRecordingResponse(struct soap *soap, const char *tag, int id, struct _trc__DeleteRecordingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__DeleteRecordingResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trc__DeleteRecordingResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__DeleteRecordingResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__DeleteRecordingResponse(struct soap *soap, const char *tag, struct _trc__DeleteRecordingResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__DeleteRecordingResponse **)soap_malloc(soap, sizeof(struct _trc__DeleteRecordingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__DeleteRecordingResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteRecordingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__DeleteRecordingResponse, sizeof(struct _trc__DeleteRecordingResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__DeleteRecordingResponse(struct soap *soap, struct _trc__DeleteRecordingResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__DeleteRecordingResponse);
	if (soap_out_PointerTo_trc__DeleteRecordingResponse(soap, tag?tag:"trc:DeleteRecordingResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteRecordingResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__DeleteRecordingResponse(struct soap *soap, struct _trc__DeleteRecordingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__DeleteRecordingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__DeleteRecording(struct soap *soap, struct _trc__DeleteRecording *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__DeleteRecording))
		soap_serialize__trc__DeleteRecording(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__DeleteRecording(struct soap *soap, const char *tag, int id, struct _trc__DeleteRecording *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__DeleteRecording);
	if (id < 0)
		return soap->error;
	return soap_out__trc__DeleteRecording(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__DeleteRecording ** SOAP_FMAC4 soap_in_PointerTo_trc__DeleteRecording(struct soap *soap, const char *tag, struct _trc__DeleteRecording **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__DeleteRecording **)soap_malloc(soap, sizeof(struct _trc__DeleteRecording *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__DeleteRecording(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteRecording **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__DeleteRecording, sizeof(struct _trc__DeleteRecording), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__DeleteRecording(struct soap *soap, struct _trc__DeleteRecording *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__DeleteRecording);
	if (soap_out_PointerTo_trc__DeleteRecording(soap, tag?tag:"trc:DeleteRecording", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteRecording ** SOAP_FMAC4 soap_get_PointerTo_trc__DeleteRecording(struct soap *soap, struct _trc__DeleteRecording **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__DeleteRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__CreateRecordingResponse(struct soap *soap, struct _trc__CreateRecordingResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__CreateRecordingResponse))
		soap_serialize__trc__CreateRecordingResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__CreateRecordingResponse(struct soap *soap, const char *tag, int id, struct _trc__CreateRecordingResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__CreateRecordingResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trc__CreateRecordingResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__CreateRecordingResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__CreateRecordingResponse(struct soap *soap, const char *tag, struct _trc__CreateRecordingResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__CreateRecordingResponse **)soap_malloc(soap, sizeof(struct _trc__CreateRecordingResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__CreateRecordingResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__CreateRecordingResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__CreateRecordingResponse, sizeof(struct _trc__CreateRecordingResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__CreateRecordingResponse(struct soap *soap, struct _trc__CreateRecordingResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__CreateRecordingResponse);
	if (soap_out_PointerTo_trc__CreateRecordingResponse(soap, tag?tag:"trc:CreateRecordingResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateRecordingResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__CreateRecordingResponse(struct soap *soap, struct _trc__CreateRecordingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__CreateRecordingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__CreateRecording(struct soap *soap, struct _trc__CreateRecording *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__CreateRecording))
		soap_serialize__trc__CreateRecording(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__CreateRecording(struct soap *soap, const char *tag, int id, struct _trc__CreateRecording *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__CreateRecording);
	if (id < 0)
		return soap->error;
	return soap_out__trc__CreateRecording(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__CreateRecording ** SOAP_FMAC4 soap_in_PointerTo_trc__CreateRecording(struct soap *soap, const char *tag, struct _trc__CreateRecording **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__CreateRecording **)soap_malloc(soap, sizeof(struct _trc__CreateRecording *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__CreateRecording(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__CreateRecording **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__CreateRecording, sizeof(struct _trc__CreateRecording), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__CreateRecording(struct soap *soap, struct _trc__CreateRecording *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__CreateRecording);
	if (soap_out_PointerTo_trc__CreateRecording(soap, tag?tag:"trc:CreateRecording", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateRecording ** SOAP_FMAC4 soap_get_PointerTo_trc__CreateRecording(struct soap *soap, struct _trc__CreateRecording **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__CreateRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetServiceCapabilitiesResponse(struct soap *soap, struct _trc__GetServiceCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetServiceCapabilitiesResponse))
		soap_serialize__trc__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _trc__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_trc__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trc__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _trc__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetServiceCapabilitiesResponse, sizeof(struct _trc__GetServiceCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetServiceCapabilitiesResponse(struct soap *soap, struct _trc__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_trc__GetServiceCapabilitiesResponse(soap, tag?tag:"trc:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_trc__GetServiceCapabilitiesResponse(struct soap *soap, struct _trc__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trc__GetServiceCapabilities(struct soap *soap, struct _trc__GetServiceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trc__GetServiceCapabilities))
		soap_serialize__trc__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trc__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _trc__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trc__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__trc__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_trc__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trc__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trc__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _trc__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trc__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trc__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trc__GetServiceCapabilities, sizeof(struct _trc__GetServiceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trc__GetServiceCapabilities(struct soap *soap, struct _trc__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trc__GetServiceCapabilities);
	if (soap_out_PointerTo_trc__GetServiceCapabilities(soap, tag?tag:"trc:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_trc__GetServiceCapabilities(struct soap *soap, struct _trc__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trc__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RemovePresetTourResponse(struct soap *soap, struct _tptz__RemovePresetTourResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RemovePresetTourResponse))
		soap_serialize__tptz__RemovePresetTourResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RemovePresetTourResponse(struct soap *soap, const char *tag, int id, struct _tptz__RemovePresetTourResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RemovePresetTourResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__RemovePresetTourResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__RemovePresetTourResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__RemovePresetTourResponse(struct soap *soap, const char *tag, struct _tptz__RemovePresetTourResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__RemovePresetTourResponse **)soap_malloc(soap, sizeof(struct _tptz__RemovePresetTourResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__RemovePresetTourResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__RemovePresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RemovePresetTourResponse, sizeof(struct _tptz__RemovePresetTourResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RemovePresetTourResponse(struct soap *soap, struct _tptz__RemovePresetTourResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__RemovePresetTourResponse);
	if (soap_out_PointerTo_tptz__RemovePresetTourResponse(soap, tag?tag:"tptz:RemovePresetTourResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePresetTourResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__RemovePresetTourResponse(struct soap *soap, struct _tptz__RemovePresetTourResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RemovePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RemovePresetTour(struct soap *soap, struct _tptz__RemovePresetTour *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RemovePresetTour))
		soap_serialize__tptz__RemovePresetTour(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RemovePresetTour(struct soap *soap, const char *tag, int id, struct _tptz__RemovePresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RemovePresetTour);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__RemovePresetTour(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__RemovePresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__RemovePresetTour(struct soap *soap, const char *tag, struct _tptz__RemovePresetTour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__RemovePresetTour **)soap_malloc(soap, sizeof(struct _tptz__RemovePresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__RemovePresetTour(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__RemovePresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RemovePresetTour, sizeof(struct _tptz__RemovePresetTour), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RemovePresetTour(struct soap *soap, struct _tptz__RemovePresetTour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__RemovePresetTour);
	if (soap_out_PointerTo_tptz__RemovePresetTour(soap, tag?tag:"tptz:RemovePresetTour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__RemovePresetTour(struct soap *soap, struct _tptz__RemovePresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RemovePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__OperatePresetTourResponse(struct soap *soap, struct _tptz__OperatePresetTourResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__OperatePresetTourResponse))
		soap_serialize__tptz__OperatePresetTourResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__OperatePresetTourResponse(struct soap *soap, const char *tag, int id, struct _tptz__OperatePresetTourResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__OperatePresetTourResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__OperatePresetTourResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__OperatePresetTourResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__OperatePresetTourResponse(struct soap *soap, const char *tag, struct _tptz__OperatePresetTourResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__OperatePresetTourResponse **)soap_malloc(soap, sizeof(struct _tptz__OperatePresetTourResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__OperatePresetTourResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__OperatePresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__OperatePresetTourResponse, sizeof(struct _tptz__OperatePresetTourResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__OperatePresetTourResponse(struct soap *soap, struct _tptz__OperatePresetTourResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__OperatePresetTourResponse);
	if (soap_out_PointerTo_tptz__OperatePresetTourResponse(soap, tag?tag:"tptz:OperatePresetTourResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__OperatePresetTourResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__OperatePresetTourResponse(struct soap *soap, struct _tptz__OperatePresetTourResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__OperatePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__OperatePresetTour(struct soap *soap, struct _tptz__OperatePresetTour *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__OperatePresetTour))
		soap_serialize__tptz__OperatePresetTour(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__OperatePresetTour(struct soap *soap, const char *tag, int id, struct _tptz__OperatePresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__OperatePresetTour);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__OperatePresetTour(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__OperatePresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__OperatePresetTour(struct soap *soap, const char *tag, struct _tptz__OperatePresetTour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__OperatePresetTour **)soap_malloc(soap, sizeof(struct _tptz__OperatePresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__OperatePresetTour(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__OperatePresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__OperatePresetTour, sizeof(struct _tptz__OperatePresetTour), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__OperatePresetTour(struct soap *soap, struct _tptz__OperatePresetTour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__OperatePresetTour);
	if (soap_out_PointerTo_tptz__OperatePresetTour(soap, tag?tag:"tptz:OperatePresetTour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__OperatePresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__OperatePresetTour(struct soap *soap, struct _tptz__OperatePresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__OperatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__ModifyPresetTourResponse(struct soap *soap, struct _tptz__ModifyPresetTourResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__ModifyPresetTourResponse))
		soap_serialize__tptz__ModifyPresetTourResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__ModifyPresetTourResponse(struct soap *soap, const char *tag, int id, struct _tptz__ModifyPresetTourResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__ModifyPresetTourResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__ModifyPresetTourResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTourResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__ModifyPresetTourResponse(struct soap *soap, const char *tag, struct _tptz__ModifyPresetTourResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__ModifyPresetTourResponse **)soap_malloc(soap, sizeof(struct _tptz__ModifyPresetTourResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__ModifyPresetTourResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__ModifyPresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ModifyPresetTourResponse, sizeof(struct _tptz__ModifyPresetTourResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__ModifyPresetTourResponse(struct soap *soap, struct _tptz__ModifyPresetTourResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__ModifyPresetTourResponse);
	if (soap_out_PointerTo_tptz__ModifyPresetTourResponse(soap, tag?tag:"tptz:ModifyPresetTourResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTourResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__ModifyPresetTourResponse(struct soap *soap, struct _tptz__ModifyPresetTourResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__ModifyPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__ModifyPresetTour(struct soap *soap, struct _tptz__ModifyPresetTour *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__ModifyPresetTour))
		soap_serialize__tptz__ModifyPresetTour(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__ModifyPresetTour(struct soap *soap, const char *tag, int id, struct _tptz__ModifyPresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__ModifyPresetTour);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__ModifyPresetTour(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__ModifyPresetTour(struct soap *soap, const char *tag, struct _tptz__ModifyPresetTour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__ModifyPresetTour **)soap_malloc(soap, sizeof(struct _tptz__ModifyPresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__ModifyPresetTour(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__ModifyPresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ModifyPresetTour, sizeof(struct _tptz__ModifyPresetTour), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__ModifyPresetTour(struct soap *soap, struct _tptz__ModifyPresetTour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__ModifyPresetTour);
	if (soap_out_PointerTo_tptz__ModifyPresetTour(soap, tag?tag:"tptz:ModifyPresetTour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__ModifyPresetTour(struct soap *soap, struct _tptz__ModifyPresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__ModifyPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__CreatePresetTourResponse(struct soap *soap, struct _tptz__CreatePresetTourResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__CreatePresetTourResponse))
		soap_serialize__tptz__CreatePresetTourResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__CreatePresetTourResponse(struct soap *soap, const char *tag, int id, struct _tptz__CreatePresetTourResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__CreatePresetTourResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__CreatePresetTourResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__CreatePresetTourResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__CreatePresetTourResponse(struct soap *soap, const char *tag, struct _tptz__CreatePresetTourResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__CreatePresetTourResponse **)soap_malloc(soap, sizeof(struct _tptz__CreatePresetTourResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__CreatePresetTourResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__CreatePresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__CreatePresetTourResponse, sizeof(struct _tptz__CreatePresetTourResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__CreatePresetTourResponse(struct soap *soap, struct _tptz__CreatePresetTourResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__CreatePresetTourResponse);
	if (soap_out_PointerTo_tptz__CreatePresetTourResponse(soap, tag?tag:"tptz:CreatePresetTourResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__CreatePresetTourResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__CreatePresetTourResponse(struct soap *soap, struct _tptz__CreatePresetTourResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__CreatePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__CreatePresetTour(struct soap *soap, struct _tptz__CreatePresetTour *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__CreatePresetTour))
		soap_serialize__tptz__CreatePresetTour(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__CreatePresetTour(struct soap *soap, const char *tag, int id, struct _tptz__CreatePresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__CreatePresetTour);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__CreatePresetTour(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__CreatePresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__CreatePresetTour(struct soap *soap, const char *tag, struct _tptz__CreatePresetTour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__CreatePresetTour **)soap_malloc(soap, sizeof(struct _tptz__CreatePresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__CreatePresetTour(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__CreatePresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__CreatePresetTour, sizeof(struct _tptz__CreatePresetTour), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__CreatePresetTour(struct soap *soap, struct _tptz__CreatePresetTour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__CreatePresetTour);
	if (soap_out_PointerTo_tptz__CreatePresetTour(soap, tag?tag:"tptz:CreatePresetTour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__CreatePresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__CreatePresetTour(struct soap *soap, struct _tptz__CreatePresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__CreatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetTourOptionsResponse(struct soap *soap, struct _tptz__GetPresetTourOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetTourOptionsResponse))
		soap_serialize__tptz__GetPresetTourOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetTourOptionsResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetPresetTourOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetTourOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetPresetTourOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetTourOptionsResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetTourOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetPresetTourOptionsResponse **)soap_malloc(soap, sizeof(struct _tptz__GetPresetTourOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetPresetTourOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTourOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, sizeof(struct _tptz__GetPresetTourOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetTourOptionsResponse(struct soap *soap, struct _tptz__GetPresetTourOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetPresetTourOptionsResponse);
	if (soap_out_PointerTo_tptz__GetPresetTourOptionsResponse(soap, tag?tag:"tptz:GetPresetTourOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetTourOptionsResponse(struct soap *soap, struct _tptz__GetPresetTourOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetTourOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, struct _tptz__GetPresetTourOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetTourOptions))
		soap_serialize__tptz__GetPresetTourOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, const char *tag, int id, struct _tptz__GetPresetTourOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetTourOptions);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetPresetTourOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptions ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, const char *tag, struct _tptz__GetPresetTourOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetPresetTourOptions **)soap_malloc(soap, sizeof(struct _tptz__GetPresetTourOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetPresetTourOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTourOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTourOptions, sizeof(struct _tptz__GetPresetTourOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, struct _tptz__GetPresetTourOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetPresetTourOptions);
	if (soap_out_PointerTo_tptz__GetPresetTourOptions(soap, tag?tag:"tptz:GetPresetTourOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptions ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetTourOptions(struct soap *soap, struct _tptz__GetPresetTourOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetTourOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetTourResponse(struct soap *soap, struct _tptz__GetPresetTourResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetTourResponse))
		soap_serialize__tptz__GetPresetTourResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetTourResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetPresetTourResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetTourResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetPresetTourResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetPresetTourResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetTourResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetTourResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetPresetTourResponse **)soap_malloc(soap, sizeof(struct _tptz__GetPresetTourResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetPresetTourResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTourResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTourResponse, sizeof(struct _tptz__GetPresetTourResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetTourResponse(struct soap *soap, struct _tptz__GetPresetTourResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetPresetTourResponse);
	if (soap_out_PointerTo_tptz__GetPresetTourResponse(soap, tag?tag:"tptz:GetPresetTourResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTourResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetTourResponse(struct soap *soap, struct _tptz__GetPresetTourResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetTour(struct soap *soap, struct _tptz__GetPresetTour *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetTour))
		soap_serialize__tptz__GetPresetTour(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetTour(struct soap *soap, const char *tag, int id, struct _tptz__GetPresetTour *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetTour);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetPresetTour(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetPresetTour ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetTour(struct soap *soap, const char *tag, struct _tptz__GetPresetTour **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetPresetTour **)soap_malloc(soap, sizeof(struct _tptz__GetPresetTour *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetPresetTour(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTour **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTour, sizeof(struct _tptz__GetPresetTour), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetTour(struct soap *soap, struct _tptz__GetPresetTour *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetPresetTour);
	if (soap_out_PointerTo_tptz__GetPresetTour(soap, tag?tag:"tptz:GetPresetTour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTour ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetTour(struct soap *soap, struct _tptz__GetPresetTour **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetToursResponse(struct soap *soap, struct _tptz__GetPresetToursResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetToursResponse))
		soap_serialize__tptz__GetPresetToursResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetToursResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetPresetToursResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetToursResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetPresetToursResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetPresetToursResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetToursResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetToursResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetPresetToursResponse **)soap_malloc(soap, sizeof(struct _tptz__GetPresetToursResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetPresetToursResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetToursResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetToursResponse, sizeof(struct _tptz__GetPresetToursResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetToursResponse(struct soap *soap, struct _tptz__GetPresetToursResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetPresetToursResponse);
	if (soap_out_PointerTo_tptz__GetPresetToursResponse(soap, tag?tag:"tptz:GetPresetToursResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetToursResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetToursResponse(struct soap *soap, struct _tptz__GetPresetToursResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetToursResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetTours(struct soap *soap, struct _tptz__GetPresetTours *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetTours))
		soap_serialize__tptz__GetPresetTours(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetTours(struct soap *soap, const char *tag, int id, struct _tptz__GetPresetTours *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetTours);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetPresetTours(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetPresetTours ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetTours(struct soap *soap, const char *tag, struct _tptz__GetPresetTours **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetPresetTours **)soap_malloc(soap, sizeof(struct _tptz__GetPresetTours *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetPresetTours(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTours **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetTours, sizeof(struct _tptz__GetPresetTours), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetTours(struct soap *soap, struct _tptz__GetPresetTours *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetPresetTours);
	if (soap_out_PointerTo_tptz__GetPresetTours(soap, tag?tag:"tptz:GetPresetTours", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTours ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetTours(struct soap *soap, struct _tptz__GetPresetTours **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetTours(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__StopResponse(struct soap *soap, struct _tptz__StopResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__StopResponse))
		soap_serialize__tptz__StopResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__StopResponse(struct soap *soap, const char *tag, int id, struct _tptz__StopResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__StopResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__StopResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__StopResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__StopResponse(struct soap *soap, const char *tag, struct _tptz__StopResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__StopResponse **)soap_malloc(soap, sizeof(struct _tptz__StopResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__StopResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__StopResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__StopResponse, sizeof(struct _tptz__StopResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__StopResponse(struct soap *soap, struct _tptz__StopResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__StopResponse);
	if (soap_out_PointerTo_tptz__StopResponse(soap, tag?tag:"tptz:StopResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__StopResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__StopResponse(struct soap *soap, struct _tptz__StopResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__StopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__Stop(struct soap *soap, struct _tptz__Stop *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__Stop))
		soap_serialize__tptz__Stop(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__Stop(struct soap *soap, const char *tag, int id, struct _tptz__Stop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__Stop);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__Stop(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__Stop ** SOAP_FMAC4 soap_in_PointerTo_tptz__Stop(struct soap *soap, const char *tag, struct _tptz__Stop **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__Stop **)soap_malloc(soap, sizeof(struct _tptz__Stop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__Stop(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__Stop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__Stop, sizeof(struct _tptz__Stop), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__Stop(struct soap *soap, struct _tptz__Stop *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__Stop);
	if (soap_out_PointerTo_tptz__Stop(soap, tag?tag:"tptz:Stop", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__Stop ** SOAP_FMAC4 soap_get_PointerTo_tptz__Stop(struct soap *soap, struct _tptz__Stop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, struct _tptz__AbsoluteMoveResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__AbsoluteMoveResponse))
		soap_serialize__tptz__AbsoluteMoveResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, const char *tag, int id, struct _tptz__AbsoluteMoveResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__AbsoluteMoveResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__AbsoluteMoveResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__AbsoluteMoveResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, const char *tag, struct _tptz__AbsoluteMoveResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__AbsoluteMoveResponse **)soap_malloc(soap, sizeof(struct _tptz__AbsoluteMoveResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__AbsoluteMoveResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__AbsoluteMoveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__AbsoluteMoveResponse, sizeof(struct _tptz__AbsoluteMoveResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, struct _tptz__AbsoluteMoveResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__AbsoluteMoveResponse);
	if (soap_out_PointerTo_tptz__AbsoluteMoveResponse(soap, tag?tag:"tptz:AbsoluteMoveResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__AbsoluteMoveResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__AbsoluteMoveResponse(struct soap *soap, struct _tptz__AbsoluteMoveResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__AbsoluteMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__AbsoluteMove(struct soap *soap, struct _tptz__AbsoluteMove *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__AbsoluteMove))
		soap_serialize__tptz__AbsoluteMove(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__AbsoluteMove(struct soap *soap, const char *tag, int id, struct _tptz__AbsoluteMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__AbsoluteMove);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__AbsoluteMove(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__AbsoluteMove ** SOAP_FMAC4 soap_in_PointerTo_tptz__AbsoluteMove(struct soap *soap, const char *tag, struct _tptz__AbsoluteMove **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__AbsoluteMove **)soap_malloc(soap, sizeof(struct _tptz__AbsoluteMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__AbsoluteMove(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__AbsoluteMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__AbsoluteMove, sizeof(struct _tptz__AbsoluteMove), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__AbsoluteMove(struct soap *soap, struct _tptz__AbsoluteMove *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__AbsoluteMove);
	if (soap_out_PointerTo_tptz__AbsoluteMove(soap, tag?tag:"tptz:AbsoluteMove", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__AbsoluteMove ** SOAP_FMAC4 soap_get_PointerTo_tptz__AbsoluteMove(struct soap *soap, struct _tptz__AbsoluteMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__AbsoluteMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, struct _tptz__SendAuxiliaryCommandResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse))
		soap_serialize__tptz__SendAuxiliaryCommandResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, struct _tptz__SendAuxiliaryCommandResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SendAuxiliaryCommandResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommandResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, struct _tptz__SendAuxiliaryCommandResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SendAuxiliaryCommandResponse **)soap_malloc(soap, sizeof(struct _tptz__SendAuxiliaryCommandResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SendAuxiliaryCommandResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SendAuxiliaryCommandResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, sizeof(struct _tptz__SendAuxiliaryCommandResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, struct _tptz__SendAuxiliaryCommandResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SendAuxiliaryCommandResponse);
	if (soap_out_PointerTo_tptz__SendAuxiliaryCommandResponse(soap, tag?tag:"tptz:SendAuxiliaryCommandResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommandResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__SendAuxiliaryCommandResponse(struct soap *soap, struct _tptz__SendAuxiliaryCommandResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SendAuxiliaryCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, struct _tptz__SendAuxiliaryCommand *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SendAuxiliaryCommand))
		soap_serialize__tptz__SendAuxiliaryCommand(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, struct _tptz__SendAuxiliaryCommand *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SendAuxiliaryCommand);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SendAuxiliaryCommand(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommand ** SOAP_FMAC4 soap_in_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct _tptz__SendAuxiliaryCommand **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SendAuxiliaryCommand **)soap_malloc(soap, sizeof(struct _tptz__SendAuxiliaryCommand *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SendAuxiliaryCommand(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SendAuxiliaryCommand **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SendAuxiliaryCommand, sizeof(struct _tptz__SendAuxiliaryCommand), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, struct _tptz__SendAuxiliaryCommand *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SendAuxiliaryCommand);
	if (soap_out_PointerTo_tptz__SendAuxiliaryCommand(soap, tag?tag:"tptz:SendAuxiliaryCommand", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommand ** SOAP_FMAC4 soap_get_PointerTo_tptz__SendAuxiliaryCommand(struct soap *soap, struct _tptz__SendAuxiliaryCommand **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, struct _tptz__RelativeMoveResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RelativeMoveResponse))
		soap_serialize__tptz__RelativeMoveResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, const char *tag, int id, struct _tptz__RelativeMoveResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RelativeMoveResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__RelativeMoveResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__RelativeMoveResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, const char *tag, struct _tptz__RelativeMoveResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__RelativeMoveResponse **)soap_malloc(soap, sizeof(struct _tptz__RelativeMoveResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__RelativeMoveResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__RelativeMoveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RelativeMoveResponse, sizeof(struct _tptz__RelativeMoveResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, struct _tptz__RelativeMoveResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__RelativeMoveResponse);
	if (soap_out_PointerTo_tptz__RelativeMoveResponse(soap, tag?tag:"tptz:RelativeMoveResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RelativeMoveResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__RelativeMoveResponse(struct soap *soap, struct _tptz__RelativeMoveResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RelativeMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RelativeMove(struct soap *soap, struct _tptz__RelativeMove *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RelativeMove))
		soap_serialize__tptz__RelativeMove(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RelativeMove(struct soap *soap, const char *tag, int id, struct _tptz__RelativeMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RelativeMove);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__RelativeMove(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__RelativeMove ** SOAP_FMAC4 soap_in_PointerTo_tptz__RelativeMove(struct soap *soap, const char *tag, struct _tptz__RelativeMove **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__RelativeMove **)soap_malloc(soap, sizeof(struct _tptz__RelativeMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__RelativeMove(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__RelativeMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RelativeMove, sizeof(struct _tptz__RelativeMove), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RelativeMove(struct soap *soap, struct _tptz__RelativeMove *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__RelativeMove);
	if (soap_out_PointerTo_tptz__RelativeMove(soap, tag?tag:"tptz:RelativeMove", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RelativeMove ** SOAP_FMAC4 soap_get_PointerTo_tptz__RelativeMove(struct soap *soap, struct _tptz__RelativeMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RelativeMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, struct _tptz__ContinuousMoveResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__ContinuousMoveResponse))
		soap_serialize__tptz__ContinuousMoveResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, const char *tag, int id, struct _tptz__ContinuousMoveResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__ContinuousMoveResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__ContinuousMoveResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__ContinuousMoveResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, const char *tag, struct _tptz__ContinuousMoveResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__ContinuousMoveResponse **)soap_malloc(soap, sizeof(struct _tptz__ContinuousMoveResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__ContinuousMoveResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__ContinuousMoveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ContinuousMoveResponse, sizeof(struct _tptz__ContinuousMoveResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, struct _tptz__ContinuousMoveResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__ContinuousMoveResponse);
	if (soap_out_PointerTo_tptz__ContinuousMoveResponse(soap, tag?tag:"tptz:ContinuousMoveResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ContinuousMoveResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__ContinuousMoveResponse(struct soap *soap, struct _tptz__ContinuousMoveResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__ContinuousMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__ContinuousMove(struct soap *soap, struct _tptz__ContinuousMove *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__ContinuousMove))
		soap_serialize__tptz__ContinuousMove(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__ContinuousMove(struct soap *soap, const char *tag, int id, struct _tptz__ContinuousMove *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__ContinuousMove);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__ContinuousMove(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__ContinuousMove ** SOAP_FMAC4 soap_in_PointerTo_tptz__ContinuousMove(struct soap *soap, const char *tag, struct _tptz__ContinuousMove **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__ContinuousMove **)soap_malloc(soap, sizeof(struct _tptz__ContinuousMove *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__ContinuousMove(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__ContinuousMove **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__ContinuousMove, sizeof(struct _tptz__ContinuousMove), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__ContinuousMove(struct soap *soap, struct _tptz__ContinuousMove *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__ContinuousMove);
	if (soap_out_PointerTo_tptz__ContinuousMove(soap, tag?tag:"tptz:ContinuousMove", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ContinuousMove ** SOAP_FMAC4 soap_get_PointerTo_tptz__ContinuousMove(struct soap *soap, struct _tptz__ContinuousMove **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__ContinuousMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, struct _tptz__SetHomePositionResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetHomePositionResponse))
		soap_serialize__tptz__SetHomePositionResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, const char *tag, int id, struct _tptz__SetHomePositionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetHomePositionResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SetHomePositionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SetHomePositionResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, const char *tag, struct _tptz__SetHomePositionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SetHomePositionResponse **)soap_malloc(soap, sizeof(struct _tptz__SetHomePositionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SetHomePositionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetHomePositionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetHomePositionResponse, sizeof(struct _tptz__SetHomePositionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, struct _tptz__SetHomePositionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SetHomePositionResponse);
	if (soap_out_PointerTo_tptz__SetHomePositionResponse(soap, tag?tag:"tptz:SetHomePositionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetHomePositionResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetHomePositionResponse(struct soap *soap, struct _tptz__SetHomePositionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetHomePositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetHomePosition(struct soap *soap, struct _tptz__SetHomePosition *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetHomePosition))
		soap_serialize__tptz__SetHomePosition(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetHomePosition(struct soap *soap, const char *tag, int id, struct _tptz__SetHomePosition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetHomePosition);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SetHomePosition(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SetHomePosition ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetHomePosition(struct soap *soap, const char *tag, struct _tptz__SetHomePosition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SetHomePosition **)soap_malloc(soap, sizeof(struct _tptz__SetHomePosition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SetHomePosition(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetHomePosition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetHomePosition, sizeof(struct _tptz__SetHomePosition), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetHomePosition(struct soap *soap, struct _tptz__SetHomePosition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SetHomePosition);
	if (soap_out_PointerTo_tptz__SetHomePosition(soap, tag?tag:"tptz:SetHomePosition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetHomePosition ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetHomePosition(struct soap *soap, struct _tptz__SetHomePosition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, struct _tptz__GotoHomePositionResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GotoHomePositionResponse))
		soap_serialize__tptz__GotoHomePositionResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, const char *tag, int id, struct _tptz__GotoHomePositionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GotoHomePositionResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GotoHomePositionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GotoHomePositionResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, const char *tag, struct _tptz__GotoHomePositionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GotoHomePositionResponse **)soap_malloc(soap, sizeof(struct _tptz__GotoHomePositionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GotoHomePositionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GotoHomePositionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoHomePositionResponse, sizeof(struct _tptz__GotoHomePositionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, struct _tptz__GotoHomePositionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GotoHomePositionResponse);
	if (soap_out_PointerTo_tptz__GotoHomePositionResponse(soap, tag?tag:"tptz:GotoHomePositionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoHomePositionResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GotoHomePositionResponse(struct soap *soap, struct _tptz__GotoHomePositionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GotoHomePositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GotoHomePosition(struct soap *soap, struct _tptz__GotoHomePosition *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GotoHomePosition))
		soap_serialize__tptz__GotoHomePosition(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GotoHomePosition(struct soap *soap, const char *tag, int id, struct _tptz__GotoHomePosition *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GotoHomePosition);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GotoHomePosition(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GotoHomePosition ** SOAP_FMAC4 soap_in_PointerTo_tptz__GotoHomePosition(struct soap *soap, const char *tag, struct _tptz__GotoHomePosition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GotoHomePosition **)soap_malloc(soap, sizeof(struct _tptz__GotoHomePosition *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GotoHomePosition(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GotoHomePosition **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoHomePosition, sizeof(struct _tptz__GotoHomePosition), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GotoHomePosition(struct soap *soap, struct _tptz__GotoHomePosition *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GotoHomePosition);
	if (soap_out_PointerTo_tptz__GotoHomePosition(soap, tag?tag:"tptz:GotoHomePosition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoHomePosition ** SOAP_FMAC4 soap_get_PointerTo_tptz__GotoHomePosition(struct soap *soap, struct _tptz__GotoHomePosition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GotoHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfigurationOptionsResponse(struct soap *soap, struct _tptz__GetConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfigurationOptionsResponse))
		soap_serialize__tptz__GetConfigurationOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _tptz__GetConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _tptz__GetConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurationOptionsResponse, sizeof(struct _tptz__GetConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfigurationOptionsResponse(struct soap *soap, struct _tptz__GetConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetConfigurationOptionsResponse);
	if (soap_out_PointerTo_tptz__GetConfigurationOptionsResponse(soap, tag?tag:"tptz:GetConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfigurationOptionsResponse(struct soap *soap, struct _tptz__GetConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, struct _tptz__GetConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfigurationOptions))
		soap_serialize__tptz__GetConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, const char *tag, int id, struct _tptz__GetConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, const char *tag, struct _tptz__GetConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetConfigurationOptions **)soap_malloc(soap, sizeof(struct _tptz__GetConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurationOptions, sizeof(struct _tptz__GetConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, struct _tptz__GetConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetConfigurationOptions);
	if (soap_out_PointerTo_tptz__GetConfigurationOptions(soap, tag?tag:"tptz:GetConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfigurationOptions(struct soap *soap, struct _tptz__GetConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetConfigurationResponse(struct soap *soap, struct _tptz__SetConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetConfigurationResponse))
		soap_serialize__tptz__SetConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tptz__SetConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SetConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SetConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetConfigurationResponse(struct soap *soap, const char *tag, struct _tptz__SetConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SetConfigurationResponse **)soap_malloc(soap, sizeof(struct _tptz__SetConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SetConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetConfigurationResponse, sizeof(struct _tptz__SetConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetConfigurationResponse(struct soap *soap, struct _tptz__SetConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SetConfigurationResponse);
	if (soap_out_PointerTo_tptz__SetConfigurationResponse(soap, tag?tag:"tptz:SetConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetConfigurationResponse(struct soap *soap, struct _tptz__SetConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetConfiguration(struct soap *soap, struct _tptz__SetConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetConfiguration))
		soap_serialize__tptz__SetConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetConfiguration(struct soap *soap, const char *tag, int id, struct _tptz__SetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SetConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SetConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetConfiguration(struct soap *soap, const char *tag, struct _tptz__SetConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SetConfiguration **)soap_malloc(soap, sizeof(struct _tptz__SetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SetConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetConfiguration, sizeof(struct _tptz__SetConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetConfiguration(struct soap *soap, struct _tptz__SetConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SetConfiguration);
	if (soap_out_PointerTo_tptz__SetConfiguration(soap, tag?tag:"tptz:SetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetConfiguration(struct soap *soap, struct _tptz__SetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetNodeResponse(struct soap *soap, struct _tptz__GetNodeResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetNodeResponse))
		soap_serialize__tptz__GetNodeResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetNodeResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetNodeResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetNodeResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetNodeResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetNodeResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetNodeResponse(struct soap *soap, const char *tag, struct _tptz__GetNodeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetNodeResponse **)soap_malloc(soap, sizeof(struct _tptz__GetNodeResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetNodeResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetNodeResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetNodeResponse, sizeof(struct _tptz__GetNodeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetNodeResponse(struct soap *soap, struct _tptz__GetNodeResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetNodeResponse);
	if (soap_out_PointerTo_tptz__GetNodeResponse(soap, tag?tag:"tptz:GetNodeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNodeResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetNodeResponse(struct soap *soap, struct _tptz__GetNodeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetNodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetNode(struct soap *soap, struct _tptz__GetNode *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetNode))
		soap_serialize__tptz__GetNode(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetNode(struct soap *soap, const char *tag, int id, struct _tptz__GetNode *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetNode);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetNode(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetNode ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetNode(struct soap *soap, const char *tag, struct _tptz__GetNode **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetNode **)soap_malloc(soap, sizeof(struct _tptz__GetNode *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetNode(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetNode **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetNode, sizeof(struct _tptz__GetNode), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetNode(struct soap *soap, struct _tptz__GetNode *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetNode);
	if (soap_out_PointerTo_tptz__GetNode(soap, tag?tag:"tptz:GetNode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNode ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetNode(struct soap *soap, struct _tptz__GetNode **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetNodesResponse(struct soap *soap, struct _tptz__GetNodesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetNodesResponse))
		soap_serialize__tptz__GetNodesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetNodesResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetNodesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetNodesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetNodesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetNodesResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetNodesResponse(struct soap *soap, const char *tag, struct _tptz__GetNodesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetNodesResponse **)soap_malloc(soap, sizeof(struct _tptz__GetNodesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetNodesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetNodesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetNodesResponse, sizeof(struct _tptz__GetNodesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetNodesResponse(struct soap *soap, struct _tptz__GetNodesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetNodesResponse);
	if (soap_out_PointerTo_tptz__GetNodesResponse(soap, tag?tag:"tptz:GetNodesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNodesResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetNodesResponse(struct soap *soap, struct _tptz__GetNodesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetNodesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetNodes(struct soap *soap, struct _tptz__GetNodes *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetNodes))
		soap_serialize__tptz__GetNodes(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetNodes(struct soap *soap, const char *tag, int id, struct _tptz__GetNodes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetNodes);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetNodes(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetNodes ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetNodes(struct soap *soap, const char *tag, struct _tptz__GetNodes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetNodes **)soap_malloc(soap, sizeof(struct _tptz__GetNodes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetNodes(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetNodes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetNodes, sizeof(struct _tptz__GetNodes), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetNodes(struct soap *soap, struct _tptz__GetNodes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetNodes);
	if (soap_out_PointerTo_tptz__GetNodes(soap, tag?tag:"tptz:GetNodes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNodes ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetNodes(struct soap *soap, struct _tptz__GetNodes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetNodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfigurationResponse(struct soap *soap, struct _tptz__GetConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfigurationResponse))
		soap_serialize__tptz__GetConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfigurationResponse(struct soap *soap, const char *tag, struct _tptz__GetConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetConfigurationResponse **)soap_malloc(soap, sizeof(struct _tptz__GetConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurationResponse, sizeof(struct _tptz__GetConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfigurationResponse(struct soap *soap, struct _tptz__GetConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetConfigurationResponse);
	if (soap_out_PointerTo_tptz__GetConfigurationResponse(soap, tag?tag:"tptz:GetConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfigurationResponse(struct soap *soap, struct _tptz__GetConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfiguration(struct soap *soap, struct _tptz__GetConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfiguration))
		soap_serialize__tptz__GetConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfiguration(struct soap *soap, const char *tag, int id, struct _tptz__GetConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfiguration(struct soap *soap, const char *tag, struct _tptz__GetConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetConfiguration **)soap_malloc(soap, sizeof(struct _tptz__GetConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfiguration, sizeof(struct _tptz__GetConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfiguration(struct soap *soap, struct _tptz__GetConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetConfiguration);
	if (soap_out_PointerTo_tptz__GetConfiguration(soap, tag?tag:"tptz:GetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfiguration(struct soap *soap, struct _tptz__GetConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetStatusResponse(struct soap *soap, struct _tptz__GetStatusResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetStatusResponse))
		soap_serialize__tptz__GetStatusResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetStatusResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetStatusResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetStatusResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetStatusResponse(struct soap *soap, const char *tag, struct _tptz__GetStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetStatusResponse **)soap_malloc(soap, sizeof(struct _tptz__GetStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetStatusResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetStatusResponse, sizeof(struct _tptz__GetStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetStatusResponse(struct soap *soap, struct _tptz__GetStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetStatusResponse);
	if (soap_out_PointerTo_tptz__GetStatusResponse(soap, tag?tag:"tptz:GetStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetStatusResponse(struct soap *soap, struct _tptz__GetStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetStatus(struct soap *soap, struct _tptz__GetStatus *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetStatus))
		soap_serialize__tptz__GetStatus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetStatus(struct soap *soap, const char *tag, int id, struct _tptz__GetStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetStatus);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetStatus ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetStatus(struct soap *soap, const char *tag, struct _tptz__GetStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetStatus **)soap_malloc(soap, sizeof(struct _tptz__GetStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetStatus, sizeof(struct _tptz__GetStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetStatus(struct soap *soap, struct _tptz__GetStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetStatus);
	if (soap_out_PointerTo_tptz__GetStatus(soap, tag?tag:"tptz:GetStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetStatus ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetStatus(struct soap *soap, struct _tptz__GetStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GotoPresetResponse(struct soap *soap, struct _tptz__GotoPresetResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GotoPresetResponse))
		soap_serialize__tptz__GotoPresetResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GotoPresetResponse(struct soap *soap, const char *tag, int id, struct _tptz__GotoPresetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GotoPresetResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GotoPresetResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GotoPresetResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GotoPresetResponse(struct soap *soap, const char *tag, struct _tptz__GotoPresetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GotoPresetResponse **)soap_malloc(soap, sizeof(struct _tptz__GotoPresetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GotoPresetResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GotoPresetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoPresetResponse, sizeof(struct _tptz__GotoPresetResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GotoPresetResponse(struct soap *soap, struct _tptz__GotoPresetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GotoPresetResponse);
	if (soap_out_PointerTo_tptz__GotoPresetResponse(soap, tag?tag:"tptz:GotoPresetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoPresetResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GotoPresetResponse(struct soap *soap, struct _tptz__GotoPresetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GotoPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GotoPreset(struct soap *soap, struct _tptz__GotoPreset *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GotoPreset))
		soap_serialize__tptz__GotoPreset(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GotoPreset(struct soap *soap, const char *tag, int id, struct _tptz__GotoPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GotoPreset);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GotoPreset(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GotoPreset ** SOAP_FMAC4 soap_in_PointerTo_tptz__GotoPreset(struct soap *soap, const char *tag, struct _tptz__GotoPreset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GotoPreset **)soap_malloc(soap, sizeof(struct _tptz__GotoPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GotoPreset(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GotoPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GotoPreset, sizeof(struct _tptz__GotoPreset), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GotoPreset(struct soap *soap, struct _tptz__GotoPreset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GotoPreset);
	if (soap_out_PointerTo_tptz__GotoPreset(soap, tag?tag:"tptz:GotoPreset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoPreset ** SOAP_FMAC4 soap_get_PointerTo_tptz__GotoPreset(struct soap *soap, struct _tptz__GotoPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GotoPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RemovePresetResponse(struct soap *soap, struct _tptz__RemovePresetResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RemovePresetResponse))
		soap_serialize__tptz__RemovePresetResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RemovePresetResponse(struct soap *soap, const char *tag, int id, struct _tptz__RemovePresetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RemovePresetResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__RemovePresetResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__RemovePresetResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__RemovePresetResponse(struct soap *soap, const char *tag, struct _tptz__RemovePresetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__RemovePresetResponse **)soap_malloc(soap, sizeof(struct _tptz__RemovePresetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__RemovePresetResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__RemovePresetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RemovePresetResponse, sizeof(struct _tptz__RemovePresetResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RemovePresetResponse(struct soap *soap, struct _tptz__RemovePresetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__RemovePresetResponse);
	if (soap_out_PointerTo_tptz__RemovePresetResponse(soap, tag?tag:"tptz:RemovePresetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePresetResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__RemovePresetResponse(struct soap *soap, struct _tptz__RemovePresetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RemovePresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__RemovePreset(struct soap *soap, struct _tptz__RemovePreset *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__RemovePreset))
		soap_serialize__tptz__RemovePreset(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__RemovePreset(struct soap *soap, const char *tag, int id, struct _tptz__RemovePreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__RemovePreset);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__RemovePreset(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__RemovePreset ** SOAP_FMAC4 soap_in_PointerTo_tptz__RemovePreset(struct soap *soap, const char *tag, struct _tptz__RemovePreset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__RemovePreset **)soap_malloc(soap, sizeof(struct _tptz__RemovePreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__RemovePreset(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__RemovePreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__RemovePreset, sizeof(struct _tptz__RemovePreset), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__RemovePreset(struct soap *soap, struct _tptz__RemovePreset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__RemovePreset);
	if (soap_out_PointerTo_tptz__RemovePreset(soap, tag?tag:"tptz:RemovePreset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePreset ** SOAP_FMAC4 soap_get_PointerTo_tptz__RemovePreset(struct soap *soap, struct _tptz__RemovePreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__RemovePreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetPresetResponse(struct soap *soap, struct _tptz__SetPresetResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetPresetResponse))
		soap_serialize__tptz__SetPresetResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetPresetResponse(struct soap *soap, const char *tag, int id, struct _tptz__SetPresetResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetPresetResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SetPresetResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SetPresetResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetPresetResponse(struct soap *soap, const char *tag, struct _tptz__SetPresetResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SetPresetResponse **)soap_malloc(soap, sizeof(struct _tptz__SetPresetResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SetPresetResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetPresetResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetPresetResponse, sizeof(struct _tptz__SetPresetResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetPresetResponse(struct soap *soap, struct _tptz__SetPresetResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SetPresetResponse);
	if (soap_out_PointerTo_tptz__SetPresetResponse(soap, tag?tag:"tptz:SetPresetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetPresetResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetPresetResponse(struct soap *soap, struct _tptz__SetPresetResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__SetPreset(struct soap *soap, struct _tptz__SetPreset *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__SetPreset))
		soap_serialize__tptz__SetPreset(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__SetPreset(struct soap *soap, const char *tag, int id, struct _tptz__SetPreset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__SetPreset);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__SetPreset(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__SetPreset ** SOAP_FMAC4 soap_in_PointerTo_tptz__SetPreset(struct soap *soap, const char *tag, struct _tptz__SetPreset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__SetPreset **)soap_malloc(soap, sizeof(struct _tptz__SetPreset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__SetPreset(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetPreset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__SetPreset, sizeof(struct _tptz__SetPreset), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__SetPreset(struct soap *soap, struct _tptz__SetPreset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__SetPreset);
	if (soap_out_PointerTo_tptz__SetPreset(soap, tag?tag:"tptz:SetPreset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetPreset ** SOAP_FMAC4 soap_get_PointerTo_tptz__SetPreset(struct soap *soap, struct _tptz__SetPreset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__SetPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresetsResponse(struct soap *soap, struct _tptz__GetPresetsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresetsResponse))
		soap_serialize__tptz__GetPresetsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresetsResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetPresetsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresetsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetPresetsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetPresetsResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresetsResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetPresetsResponse **)soap_malloc(soap, sizeof(struct _tptz__GetPresetsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetPresetsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresetsResponse, sizeof(struct _tptz__GetPresetsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresetsResponse(struct soap *soap, struct _tptz__GetPresetsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetPresetsResponse);
	if (soap_out_PointerTo_tptz__GetPresetsResponse(soap, tag?tag:"tptz:GetPresetsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetsResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresetsResponse(struct soap *soap, struct _tptz__GetPresetsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresetsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetPresets(struct soap *soap, struct _tptz__GetPresets *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetPresets))
		soap_serialize__tptz__GetPresets(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetPresets(struct soap *soap, const char *tag, int id, struct _tptz__GetPresets *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetPresets);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetPresets(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetPresets ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetPresets(struct soap *soap, const char *tag, struct _tptz__GetPresets **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetPresets **)soap_malloc(soap, sizeof(struct _tptz__GetPresets *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetPresets(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresets **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetPresets, sizeof(struct _tptz__GetPresets), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetPresets(struct soap *soap, struct _tptz__GetPresets *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetPresets);
	if (soap_out_PointerTo_tptz__GetPresets(soap, tag?tag:"tptz:GetPresets", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresets ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetPresets(struct soap *soap, struct _tptz__GetPresets **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetPresets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfigurationsResponse(struct soap *soap, struct _tptz__GetConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfigurationsResponse))
		soap_serialize__tptz__GetConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfigurationsResponse(struct soap *soap, const char *tag, struct _tptz__GetConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetConfigurationsResponse **)soap_malloc(soap, sizeof(struct _tptz__GetConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurationsResponse, sizeof(struct _tptz__GetConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfigurationsResponse(struct soap *soap, struct _tptz__GetConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetConfigurationsResponse);
	if (soap_out_PointerTo_tptz__GetConfigurationsResponse(soap, tag?tag:"tptz:GetConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfigurationsResponse(struct soap *soap, struct _tptz__GetConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetConfigurations(struct soap *soap, struct _tptz__GetConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetConfigurations))
		soap_serialize__tptz__GetConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetConfigurations(struct soap *soap, const char *tag, int id, struct _tptz__GetConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetConfigurations ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetConfigurations(struct soap *soap, const char *tag, struct _tptz__GetConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetConfigurations **)soap_malloc(soap, sizeof(struct _tptz__GetConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetConfigurations, sizeof(struct _tptz__GetConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetConfigurations(struct soap *soap, struct _tptz__GetConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetConfigurations);
	if (soap_out_PointerTo_tptz__GetConfigurations(soap, tag?tag:"tptz:GetConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurations ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetConfigurations(struct soap *soap, struct _tptz__GetConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetServiceCapabilitiesResponse(struct soap *soap, struct _tptz__GetServiceCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse))
		soap_serialize__tptz__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tptz__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tptz__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tptz__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse, sizeof(struct _tptz__GetServiceCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetServiceCapabilitiesResponse(struct soap *soap, struct _tptz__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_tptz__GetServiceCapabilitiesResponse(soap, tag?tag:"tptz:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetServiceCapabilitiesResponse(struct soap *soap, struct _tptz__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, struct _tptz__GetServiceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tptz__GetServiceCapabilities))
		soap_serialize__tptz__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _tptz__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tptz__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__tptz__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tptz__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tptz__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _tptz__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tptz__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tptz__GetServiceCapabilities, sizeof(struct _tptz__GetServiceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, struct _tptz__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tptz__GetServiceCapabilities);
	if (soap_out_PointerTo_tptz__GetServiceCapabilities(soap, tag?tag:"tptz:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tptz__GetServiceCapabilities(struct soap *soap, struct _tptz__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tptz__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__SendReceiveSerialCommandResponse(struct soap *soap, struct _tmd__SendReceiveSerialCommandResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__SendReceiveSerialCommandResponse))
		soap_serialize__tmd__SendReceiveSerialCommandResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__SendReceiveSerialCommandResponse(struct soap *soap, const char *tag, int id, struct _tmd__SendReceiveSerialCommandResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__SendReceiveSerialCommandResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__SendReceiveSerialCommandResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__SendReceiveSerialCommandResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__SendReceiveSerialCommandResponse(struct soap *soap, const char *tag, struct _tmd__SendReceiveSerialCommandResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__SendReceiveSerialCommandResponse **)soap_malloc(soap, sizeof(struct _tmd__SendReceiveSerialCommandResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__SendReceiveSerialCommandResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__SendReceiveSerialCommandResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SendReceiveSerialCommandResponse, sizeof(struct _tmd__SendReceiveSerialCommandResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__SendReceiveSerialCommandResponse(struct soap *soap, struct _tmd__SendReceiveSerialCommandResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__SendReceiveSerialCommandResponse);
	if (soap_out_PointerTo_tmd__SendReceiveSerialCommandResponse(soap, tag?tag:"tmd:SendReceiveSerialCommandResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SendReceiveSerialCommandResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__SendReceiveSerialCommandResponse(struct soap *soap, struct _tmd__SendReceiveSerialCommandResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__SendReceiveSerialCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__SendReceiveSerialCommand(struct soap *soap, struct _tmd__SendReceiveSerialCommand *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__SendReceiveSerialCommand))
		soap_serialize__tmd__SendReceiveSerialCommand(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__SendReceiveSerialCommand(struct soap *soap, const char *tag, int id, struct _tmd__SendReceiveSerialCommand *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__SendReceiveSerialCommand);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__SendReceiveSerialCommand(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__SendReceiveSerialCommand ** SOAP_FMAC4 soap_in_PointerTo_tmd__SendReceiveSerialCommand(struct soap *soap, const char *tag, struct _tmd__SendReceiveSerialCommand **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__SendReceiveSerialCommand **)soap_malloc(soap, sizeof(struct _tmd__SendReceiveSerialCommand *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__SendReceiveSerialCommand(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__SendReceiveSerialCommand **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SendReceiveSerialCommand, sizeof(struct _tmd__SendReceiveSerialCommand), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__SendReceiveSerialCommand(struct soap *soap, struct _tmd__SendReceiveSerialCommand *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__SendReceiveSerialCommand);
	if (soap_out_PointerTo_tmd__SendReceiveSerialCommand(soap, tag?tag:"tmd:SendReceiveSerialCommand", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SendReceiveSerialCommand ** SOAP_FMAC4 soap_get_PointerTo_tmd__SendReceiveSerialCommand(struct soap *soap, struct _tmd__SendReceiveSerialCommand **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__SendReceiveSerialCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetSerialPortConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetSerialPortConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse))
		soap_serialize__tmd__GetSerialPortConfigurationOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetSerialPortConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _tmd__GetSerialPortConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetSerialPortConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetSerialPortConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _tmd__GetSerialPortConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetSerialPortConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _tmd__GetSerialPortConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetSerialPortConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetSerialPortConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetSerialPortConfigurationOptionsResponse, sizeof(struct _tmd__GetSerialPortConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetSerialPortConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetSerialPortConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetSerialPortConfigurationOptionsResponse);
	if (soap_out_PointerTo_tmd__GetSerialPortConfigurationOptionsResponse(soap, tag?tag:"tmd:GetSerialPortConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetSerialPortConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetSerialPortConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetSerialPortConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetSerialPortConfigurationOptions(struct soap *soap, struct _tmd__GetSerialPortConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetSerialPortConfigurationOptions))
		soap_serialize__tmd__GetSerialPortConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetSerialPortConfigurationOptions(struct soap *soap, const char *tag, int id, struct _tmd__GetSerialPortConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetSerialPortConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetSerialPortConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetSerialPortConfigurationOptions(struct soap *soap, const char *tag, struct _tmd__GetSerialPortConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetSerialPortConfigurationOptions **)soap_malloc(soap, sizeof(struct _tmd__GetSerialPortConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetSerialPortConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetSerialPortConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetSerialPortConfigurationOptions, sizeof(struct _tmd__GetSerialPortConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetSerialPortConfigurationOptions(struct soap *soap, struct _tmd__GetSerialPortConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetSerialPortConfigurationOptions);
	if (soap_out_PointerTo_tmd__GetSerialPortConfigurationOptions(soap, tag?tag:"tmd:GetSerialPortConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetSerialPortConfigurationOptions(struct soap *soap, struct _tmd__GetSerialPortConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetSerialPortConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__SetSerialPortConfigurationResponse(struct soap *soap, struct _tmd__SetSerialPortConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__SetSerialPortConfigurationResponse))
		soap_serialize__tmd__SetSerialPortConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__SetSerialPortConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tmd__SetSerialPortConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__SetSerialPortConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__SetSerialPortConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__SetSerialPortConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__SetSerialPortConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__SetSerialPortConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__SetSerialPortConfigurationResponse **)soap_malloc(soap, sizeof(struct _tmd__SetSerialPortConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__SetSerialPortConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__SetSerialPortConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetSerialPortConfigurationResponse, sizeof(struct _tmd__SetSerialPortConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__SetSerialPortConfigurationResponse(struct soap *soap, struct _tmd__SetSerialPortConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__SetSerialPortConfigurationResponse);
	if (soap_out_PointerTo_tmd__SetSerialPortConfigurationResponse(soap, tag?tag:"tmd:SetSerialPortConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetSerialPortConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__SetSerialPortConfigurationResponse(struct soap *soap, struct _tmd__SetSerialPortConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__SetSerialPortConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__SetSerialPortConfiguration(struct soap *soap, struct _tmd__SetSerialPortConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__SetSerialPortConfiguration))
		soap_serialize__tmd__SetSerialPortConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__SetSerialPortConfiguration(struct soap *soap, const char *tag, int id, struct _tmd__SetSerialPortConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__SetSerialPortConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__SetSerialPortConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__SetSerialPortConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tmd__SetSerialPortConfiguration(struct soap *soap, const char *tag, struct _tmd__SetSerialPortConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__SetSerialPortConfiguration **)soap_malloc(soap, sizeof(struct _tmd__SetSerialPortConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__SetSerialPortConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__SetSerialPortConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetSerialPortConfiguration, sizeof(struct _tmd__SetSerialPortConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__SetSerialPortConfiguration(struct soap *soap, struct _tmd__SetSerialPortConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__SetSerialPortConfiguration);
	if (soap_out_PointerTo_tmd__SetSerialPortConfiguration(soap, tag?tag:"tmd:SetSerialPortConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetSerialPortConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tmd__SetSerialPortConfiguration(struct soap *soap, struct _tmd__SetSerialPortConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__SetSerialPortConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetSerialPortConfigurationResponse(struct soap *soap, struct _tmd__GetSerialPortConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetSerialPortConfigurationResponse))
		soap_serialize__tmd__GetSerialPortConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetSerialPortConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tmd__GetSerialPortConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetSerialPortConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetSerialPortConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetSerialPortConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__GetSerialPortConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetSerialPortConfigurationResponse **)soap_malloc(soap, sizeof(struct _tmd__GetSerialPortConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetSerialPortConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetSerialPortConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetSerialPortConfigurationResponse, sizeof(struct _tmd__GetSerialPortConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetSerialPortConfigurationResponse(struct soap *soap, struct _tmd__GetSerialPortConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetSerialPortConfigurationResponse);
	if (soap_out_PointerTo_tmd__GetSerialPortConfigurationResponse(soap, tag?tag:"tmd:GetSerialPortConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetSerialPortConfigurationResponse(struct soap *soap, struct _tmd__GetSerialPortConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetSerialPortConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetSerialPortConfiguration(struct soap *soap, struct _tmd__GetSerialPortConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetSerialPortConfiguration))
		soap_serialize__tmd__GetSerialPortConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetSerialPortConfiguration(struct soap *soap, const char *tag, int id, struct _tmd__GetSerialPortConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetSerialPortConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetSerialPortConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetSerialPortConfiguration(struct soap *soap, const char *tag, struct _tmd__GetSerialPortConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetSerialPortConfiguration **)soap_malloc(soap, sizeof(struct _tmd__GetSerialPortConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetSerialPortConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetSerialPortConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetSerialPortConfiguration, sizeof(struct _tmd__GetSerialPortConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetSerialPortConfiguration(struct soap *soap, struct _tmd__GetSerialPortConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetSerialPortConfiguration);
	if (soap_out_PointerTo_tmd__GetSerialPortConfiguration(soap, tag?tag:"tmd:GetSerialPortConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetSerialPortConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetSerialPortConfiguration(struct soap *soap, struct _tmd__GetSerialPortConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetSerialPortConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetSerialPortsResponse(struct soap *soap, struct _tmd__GetSerialPortsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetSerialPortsResponse))
		soap_serialize__tmd__GetSerialPortsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetSerialPortsResponse(struct soap *soap, const char *tag, int id, struct _tmd__GetSerialPortsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetSerialPortsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetSerialPortsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetSerialPortsResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetSerialPortsResponse(struct soap *soap, const char *tag, struct _tmd__GetSerialPortsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetSerialPortsResponse **)soap_malloc(soap, sizeof(struct _tmd__GetSerialPortsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetSerialPortsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetSerialPortsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetSerialPortsResponse, sizeof(struct _tmd__GetSerialPortsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetSerialPortsResponse(struct soap *soap, struct _tmd__GetSerialPortsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetSerialPortsResponse);
	if (soap_out_PointerTo_tmd__GetSerialPortsResponse(soap, tag?tag:"tmd:GetSerialPortsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetSerialPortsResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetSerialPortsResponse(struct soap *soap, struct _tmd__GetSerialPortsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetSerialPortsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetSerialPorts(struct soap *soap, struct _tmd__GetSerialPorts *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetSerialPorts))
		soap_serialize__tmd__GetSerialPorts(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetSerialPorts(struct soap *soap, const char *tag, int id, struct _tmd__GetSerialPorts *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetSerialPorts);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetSerialPorts(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetSerialPorts ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetSerialPorts(struct soap *soap, const char *tag, struct _tmd__GetSerialPorts **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetSerialPorts **)soap_malloc(soap, sizeof(struct _tmd__GetSerialPorts *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetSerialPorts(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetSerialPorts **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetSerialPorts, sizeof(struct _tmd__GetSerialPorts), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetSerialPorts(struct soap *soap, struct _tmd__GetSerialPorts *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetSerialPorts);
	if (soap_out_PointerTo_tmd__GetSerialPorts(soap, tag?tag:"tmd:GetSerialPorts", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetSerialPorts ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetSerialPorts(struct soap *soap, struct _tmd__GetSerialPorts **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetSerialPorts(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetDigitalInputsResponse(struct soap *soap, struct _tmd__GetDigitalInputsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetDigitalInputsResponse))
		soap_serialize__tmd__GetDigitalInputsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetDigitalInputsResponse(struct soap *soap, const char *tag, int id, struct _tmd__GetDigitalInputsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetDigitalInputsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetDigitalInputsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetDigitalInputsResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetDigitalInputsResponse(struct soap *soap, const char *tag, struct _tmd__GetDigitalInputsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetDigitalInputsResponse **)soap_malloc(soap, sizeof(struct _tmd__GetDigitalInputsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetDigitalInputsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetDigitalInputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetDigitalInputsResponse, sizeof(struct _tmd__GetDigitalInputsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetDigitalInputsResponse(struct soap *soap, struct _tmd__GetDigitalInputsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetDigitalInputsResponse);
	if (soap_out_PointerTo_tmd__GetDigitalInputsResponse(soap, tag?tag:"tmd:GetDigitalInputsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetDigitalInputsResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetDigitalInputsResponse(struct soap *soap, struct _tmd__GetDigitalInputsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetDigitalInputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetDigitalInputs(struct soap *soap, struct _tmd__GetDigitalInputs *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetDigitalInputs))
		soap_serialize__tmd__GetDigitalInputs(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetDigitalInputs(struct soap *soap, const char *tag, int id, struct _tmd__GetDigitalInputs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetDigitalInputs);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetDigitalInputs(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetDigitalInputs ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetDigitalInputs(struct soap *soap, const char *tag, struct _tmd__GetDigitalInputs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetDigitalInputs **)soap_malloc(soap, sizeof(struct _tmd__GetDigitalInputs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetDigitalInputs(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetDigitalInputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetDigitalInputs, sizeof(struct _tmd__GetDigitalInputs), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetDigitalInputs(struct soap *soap, struct _tmd__GetDigitalInputs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetDigitalInputs);
	if (soap_out_PointerTo_tmd__GetDigitalInputs(soap, tag?tag:"tmd:GetDigitalInputs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetDigitalInputs ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetDigitalInputs(struct soap *soap, struct _tmd__GetDigitalInputs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetDigitalInputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__SetRelayOutputSettingsResponse(struct soap *soap, struct _tmd__SetRelayOutputSettingsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__SetRelayOutputSettingsResponse))
		soap_serialize__tmd__SetRelayOutputSettingsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, int id, struct _tmd__SetRelayOutputSettingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__SetRelayOutputSettingsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__SetRelayOutputSettingsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__SetRelayOutputSettingsResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, struct _tmd__SetRelayOutputSettingsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__SetRelayOutputSettingsResponse **)soap_malloc(soap, sizeof(struct _tmd__SetRelayOutputSettingsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__SetRelayOutputSettingsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__SetRelayOutputSettingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetRelayOutputSettingsResponse, sizeof(struct _tmd__SetRelayOutputSettingsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__SetRelayOutputSettingsResponse(struct soap *soap, struct _tmd__SetRelayOutputSettingsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__SetRelayOutputSettingsResponse);
	if (soap_out_PointerTo_tmd__SetRelayOutputSettingsResponse(soap, tag?tag:"tmd:SetRelayOutputSettingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetRelayOutputSettingsResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__SetRelayOutputSettingsResponse(struct soap *soap, struct _tmd__SetRelayOutputSettingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__SetRelayOutputSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__SetRelayOutputSettings(struct soap *soap, struct _tmd__SetRelayOutputSettings *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__SetRelayOutputSettings))
		soap_serialize__tmd__SetRelayOutputSettings(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, struct _tmd__SetRelayOutputSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__SetRelayOutputSettings);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__SetRelayOutputSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__SetRelayOutputSettings ** SOAP_FMAC4 soap_in_PointerTo_tmd__SetRelayOutputSettings(struct soap *soap, const char *tag, struct _tmd__SetRelayOutputSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__SetRelayOutputSettings **)soap_malloc(soap, sizeof(struct _tmd__SetRelayOutputSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__SetRelayOutputSettings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__SetRelayOutputSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetRelayOutputSettings, sizeof(struct _tmd__SetRelayOutputSettings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__SetRelayOutputSettings(struct soap *soap, struct _tmd__SetRelayOutputSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__SetRelayOutputSettings);
	if (soap_out_PointerTo_tmd__SetRelayOutputSettings(soap, tag?tag:"tmd:SetRelayOutputSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetRelayOutputSettings ** SOAP_FMAC4 soap_get_PointerTo_tmd__SetRelayOutputSettings(struct soap *soap, struct _tmd__SetRelayOutputSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__SetRelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetAudioOutputConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse))
		soap_serialize__tmd__GetAudioOutputConfigurationOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _tmd__GetAudioOutputConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetAudioOutputConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _tmd__GetAudioOutputConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetAudioOutputConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _tmd__GetAudioOutputConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetAudioOutputConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetAudioOutputConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptionsResponse, sizeof(struct _tmd__GetAudioOutputConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetAudioOutputConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetAudioOutputConfigurationOptionsResponse);
	if (soap_out_PointerTo_tmd__GetAudioOutputConfigurationOptionsResponse(soap, tag?tag:"tmd:GetAudioOutputConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetAudioOutputConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetAudioOutputConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetAudioOutputConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetAudioOutputConfigurationOptions(struct soap *soap, struct _tmd__GetAudioOutputConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions))
		soap_serialize__tmd__GetAudioOutputConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, int id, struct _tmd__GetAudioOutputConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetAudioOutputConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetAudioOutputConfigurationOptions(struct soap *soap, const char *tag, struct _tmd__GetAudioOutputConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetAudioOutputConfigurationOptions **)soap_malloc(soap, sizeof(struct _tmd__GetAudioOutputConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetAudioOutputConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetAudioOutputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetAudioOutputConfigurationOptions, sizeof(struct _tmd__GetAudioOutputConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetAudioOutputConfigurationOptions(struct soap *soap, struct _tmd__GetAudioOutputConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetAudioOutputConfigurationOptions);
	if (soap_out_PointerTo_tmd__GetAudioOutputConfigurationOptions(soap, tag?tag:"tmd:GetAudioOutputConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetAudioOutputConfigurationOptions(struct soap *soap, struct _tmd__GetAudioOutputConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetAudioOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetAudioSourceConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse))
		soap_serialize__tmd__GetAudioSourceConfigurationOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _tmd__GetAudioSourceConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetAudioSourceConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _tmd__GetAudioSourceConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetAudioSourceConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _tmd__GetAudioSourceConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetAudioSourceConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetAudioSourceConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptionsResponse, sizeof(struct _tmd__GetAudioSourceConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetAudioSourceConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetAudioSourceConfigurationOptionsResponse);
	if (soap_out_PointerTo_tmd__GetAudioSourceConfigurationOptionsResponse(soap, tag?tag:"tmd:GetAudioSourceConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetAudioSourceConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetAudioSourceConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetAudioSourceConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetAudioSourceConfigurationOptions(struct soap *soap, struct _tmd__GetAudioSourceConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions))
		soap_serialize__tmd__GetAudioSourceConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, int id, struct _tmd__GetAudioSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetAudioSourceConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetAudioSourceConfigurationOptions(struct soap *soap, const char *tag, struct _tmd__GetAudioSourceConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetAudioSourceConfigurationOptions **)soap_malloc(soap, sizeof(struct _tmd__GetAudioSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetAudioSourceConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetAudioSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetAudioSourceConfigurationOptions, sizeof(struct _tmd__GetAudioSourceConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetAudioSourceConfigurationOptions(struct soap *soap, struct _tmd__GetAudioSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetAudioSourceConfigurationOptions);
	if (soap_out_PointerTo_tmd__GetAudioSourceConfigurationOptions(soap, tag?tag:"tmd:GetAudioSourceConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetAudioSourceConfigurationOptions(struct soap *soap, struct _tmd__GetAudioSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetAudioSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetVideoOutputConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetVideoOutputConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse))
		soap_serialize__tmd__GetVideoOutputConfigurationOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetVideoOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _tmd__GetVideoOutputConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetVideoOutputConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetVideoOutputConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _tmd__GetVideoOutputConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetVideoOutputConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _tmd__GetVideoOutputConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetVideoOutputConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoOutputConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptionsResponse, sizeof(struct _tmd__GetVideoOutputConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetVideoOutputConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetVideoOutputConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetVideoOutputConfigurationOptionsResponse);
	if (soap_out_PointerTo_tmd__GetVideoOutputConfigurationOptionsResponse(soap, tag?tag:"tmd:GetVideoOutputConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetVideoOutputConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetVideoOutputConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetVideoOutputConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetVideoOutputConfigurationOptions(struct soap *soap, struct _tmd__GetVideoOutputConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions))
		soap_serialize__tmd__GetVideoOutputConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetVideoOutputConfigurationOptions(struct soap *soap, const char *tag, int id, struct _tmd__GetVideoOutputConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetVideoOutputConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetVideoOutputConfigurationOptions(struct soap *soap, const char *tag, struct _tmd__GetVideoOutputConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetVideoOutputConfigurationOptions **)soap_malloc(soap, sizeof(struct _tmd__GetVideoOutputConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetVideoOutputConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoOutputConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoOutputConfigurationOptions, sizeof(struct _tmd__GetVideoOutputConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetVideoOutputConfigurationOptions(struct soap *soap, struct _tmd__GetVideoOutputConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetVideoOutputConfigurationOptions);
	if (soap_out_PointerTo_tmd__GetVideoOutputConfigurationOptions(soap, tag?tag:"tmd:GetVideoOutputConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetVideoOutputConfigurationOptions(struct soap *soap, struct _tmd__GetVideoOutputConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetVideoOutputConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetVideoSourceConfigurationOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse))
		soap_serialize__tmd__GetVideoSourceConfigurationOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, struct _tmd__GetVideoSourceConfigurationOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetVideoSourceConfigurationOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfigurationOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _tmd__GetVideoSourceConfigurationOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetVideoSourceConfigurationOptionsResponse **)soap_malloc(soap, sizeof(struct _tmd__GetVideoSourceConfigurationOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetVideoSourceConfigurationOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoSourceConfigurationOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptionsResponse, sizeof(struct _tmd__GetVideoSourceConfigurationOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetVideoSourceConfigurationOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetVideoSourceConfigurationOptionsResponse);
	if (soap_out_PointerTo_tmd__GetVideoSourceConfigurationOptionsResponse(soap, tag?tag:"tmd:GetVideoSourceConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfigurationOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetVideoSourceConfigurationOptionsResponse(struct soap *soap, struct _tmd__GetVideoSourceConfigurationOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetVideoSourceConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetVideoSourceConfigurationOptions(struct soap *soap, struct _tmd__GetVideoSourceConfigurationOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions))
		soap_serialize__tmd__GetVideoSourceConfigurationOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, int id, struct _tmd__GetVideoSourceConfigurationOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetVideoSourceConfigurationOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfigurationOptions ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetVideoSourceConfigurationOptions(struct soap *soap, const char *tag, struct _tmd__GetVideoSourceConfigurationOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetVideoSourceConfigurationOptions **)soap_malloc(soap, sizeof(struct _tmd__GetVideoSourceConfigurationOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetVideoSourceConfigurationOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoSourceConfigurationOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoSourceConfigurationOptions, sizeof(struct _tmd__GetVideoSourceConfigurationOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetVideoSourceConfigurationOptions(struct soap *soap, struct _tmd__GetVideoSourceConfigurationOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetVideoSourceConfigurationOptions);
	if (soap_out_PointerTo_tmd__GetVideoSourceConfigurationOptions(soap, tag?tag:"tmd:GetVideoSourceConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfigurationOptions ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetVideoSourceConfigurationOptions(struct soap *soap, struct _tmd__GetVideoSourceConfigurationOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetVideoSourceConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__SetAudioOutputConfigurationResponse(struct soap *soap, struct _tmd__SetAudioOutputConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse))
		soap_serialize__tmd__SetAudioOutputConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__SetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tmd__SetAudioOutputConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__SetAudioOutputConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__SetAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__SetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__SetAudioOutputConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__SetAudioOutputConfigurationResponse **)soap_malloc(soap, sizeof(struct _tmd__SetAudioOutputConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__SetAudioOutputConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__SetAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetAudioOutputConfigurationResponse, sizeof(struct _tmd__SetAudioOutputConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__SetAudioOutputConfigurationResponse(struct soap *soap, struct _tmd__SetAudioOutputConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__SetAudioOutputConfigurationResponse);
	if (soap_out_PointerTo_tmd__SetAudioOutputConfigurationResponse(soap, tag?tag:"tmd:SetAudioOutputConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__SetAudioOutputConfigurationResponse(struct soap *soap, struct _tmd__SetAudioOutputConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__SetAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__SetAudioOutputConfiguration(struct soap *soap, struct _tmd__SetAudioOutputConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__SetAudioOutputConfiguration))
		soap_serialize__tmd__SetAudioOutputConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__SetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, struct _tmd__SetAudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__SetAudioOutputConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__SetAudioOutputConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__SetAudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tmd__SetAudioOutputConfiguration(struct soap *soap, const char *tag, struct _tmd__SetAudioOutputConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__SetAudioOutputConfiguration **)soap_malloc(soap, sizeof(struct _tmd__SetAudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__SetAudioOutputConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__SetAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetAudioOutputConfiguration, sizeof(struct _tmd__SetAudioOutputConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__SetAudioOutputConfiguration(struct soap *soap, struct _tmd__SetAudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__SetAudioOutputConfiguration);
	if (soap_out_PointerTo_tmd__SetAudioOutputConfiguration(soap, tag?tag:"tmd:SetAudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetAudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tmd__SetAudioOutputConfiguration(struct soap *soap, struct _tmd__SetAudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__SetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__SetAudioSourceConfigurationResponse(struct soap *soap, struct _tmd__SetAudioSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse))
		soap_serialize__tmd__SetAudioSourceConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__SetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tmd__SetAudioSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__SetAudioSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__SetAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__SetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__SetAudioSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__SetAudioSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _tmd__SetAudioSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__SetAudioSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__SetAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetAudioSourceConfigurationResponse, sizeof(struct _tmd__SetAudioSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__SetAudioSourceConfigurationResponse(struct soap *soap, struct _tmd__SetAudioSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__SetAudioSourceConfigurationResponse);
	if (soap_out_PointerTo_tmd__SetAudioSourceConfigurationResponse(soap, tag?tag:"tmd:SetAudioSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__SetAudioSourceConfigurationResponse(struct soap *soap, struct _tmd__SetAudioSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__SetAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__SetAudioSourceConfiguration(struct soap *soap, struct _tmd__SetAudioSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__SetAudioSourceConfiguration))
		soap_serialize__tmd__SetAudioSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__SetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, struct _tmd__SetAudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__SetAudioSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__SetAudioSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__SetAudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tmd__SetAudioSourceConfiguration(struct soap *soap, const char *tag, struct _tmd__SetAudioSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__SetAudioSourceConfiguration **)soap_malloc(soap, sizeof(struct _tmd__SetAudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__SetAudioSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__SetAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetAudioSourceConfiguration, sizeof(struct _tmd__SetAudioSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__SetAudioSourceConfiguration(struct soap *soap, struct _tmd__SetAudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__SetAudioSourceConfiguration);
	if (soap_out_PointerTo_tmd__SetAudioSourceConfiguration(soap, tag?tag:"tmd:SetAudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetAudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tmd__SetAudioSourceConfiguration(struct soap *soap, struct _tmd__SetAudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__SetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__SetVideoOutputConfigurationResponse(struct soap *soap, struct _tmd__SetVideoOutputConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse))
		soap_serialize__tmd__SetVideoOutputConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__SetVideoOutputConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tmd__SetVideoOutputConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__SetVideoOutputConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__SetVideoOutputConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__SetVideoOutputConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__SetVideoOutputConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__SetVideoOutputConfigurationResponse **)soap_malloc(soap, sizeof(struct _tmd__SetVideoOutputConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__SetVideoOutputConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__SetVideoOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetVideoOutputConfigurationResponse, sizeof(struct _tmd__SetVideoOutputConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__SetVideoOutputConfigurationResponse(struct soap *soap, struct _tmd__SetVideoOutputConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__SetVideoOutputConfigurationResponse);
	if (soap_out_PointerTo_tmd__SetVideoOutputConfigurationResponse(soap, tag?tag:"tmd:SetVideoOutputConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetVideoOutputConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__SetVideoOutputConfigurationResponse(struct soap *soap, struct _tmd__SetVideoOutputConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__SetVideoOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__SetVideoOutputConfiguration(struct soap *soap, struct _tmd__SetVideoOutputConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__SetVideoOutputConfiguration))
		soap_serialize__tmd__SetVideoOutputConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__SetVideoOutputConfiguration(struct soap *soap, const char *tag, int id, struct _tmd__SetVideoOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__SetVideoOutputConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__SetVideoOutputConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__SetVideoOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tmd__SetVideoOutputConfiguration(struct soap *soap, const char *tag, struct _tmd__SetVideoOutputConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__SetVideoOutputConfiguration **)soap_malloc(soap, sizeof(struct _tmd__SetVideoOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__SetVideoOutputConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__SetVideoOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetVideoOutputConfiguration, sizeof(struct _tmd__SetVideoOutputConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__SetVideoOutputConfiguration(struct soap *soap, struct _tmd__SetVideoOutputConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__SetVideoOutputConfiguration);
	if (soap_out_PointerTo_tmd__SetVideoOutputConfiguration(soap, tag?tag:"tmd:SetVideoOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetVideoOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tmd__SetVideoOutputConfiguration(struct soap *soap, struct _tmd__SetVideoOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__SetVideoOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__SetVideoSourceConfigurationResponse(struct soap *soap, struct _tmd__SetVideoSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse))
		soap_serialize__tmd__SetVideoSourceConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__SetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tmd__SetVideoSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__SetVideoSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__SetVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__SetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__SetVideoSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__SetVideoSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _tmd__SetVideoSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__SetVideoSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__SetVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetVideoSourceConfigurationResponse, sizeof(struct _tmd__SetVideoSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__SetVideoSourceConfigurationResponse(struct soap *soap, struct _tmd__SetVideoSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__SetVideoSourceConfigurationResponse);
	if (soap_out_PointerTo_tmd__SetVideoSourceConfigurationResponse(soap, tag?tag:"tmd:SetVideoSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__SetVideoSourceConfigurationResponse(struct soap *soap, struct _tmd__SetVideoSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__SetVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__SetVideoSourceConfiguration(struct soap *soap, struct _tmd__SetVideoSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__SetVideoSourceConfiguration))
		soap_serialize__tmd__SetVideoSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__SetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, struct _tmd__SetVideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__SetVideoSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__SetVideoSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__SetVideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tmd__SetVideoSourceConfiguration(struct soap *soap, const char *tag, struct _tmd__SetVideoSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__SetVideoSourceConfiguration **)soap_malloc(soap, sizeof(struct _tmd__SetVideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__SetVideoSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__SetVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__SetVideoSourceConfiguration, sizeof(struct _tmd__SetVideoSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__SetVideoSourceConfiguration(struct soap *soap, struct _tmd__SetVideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__SetVideoSourceConfiguration);
	if (soap_out_PointerTo_tmd__SetVideoSourceConfiguration(soap, tag?tag:"tmd:SetVideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__SetVideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tmd__SetVideoSourceConfiguration(struct soap *soap, struct _tmd__SetVideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__SetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetAudioOutputConfigurationResponse(struct soap *soap, struct _tmd__GetAudioOutputConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse))
		soap_serialize__tmd__GetAudioOutputConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tmd__GetAudioOutputConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetAudioOutputConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetAudioOutputConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__GetAudioOutputConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetAudioOutputConfigurationResponse **)soap_malloc(soap, sizeof(struct _tmd__GetAudioOutputConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetAudioOutputConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetAudioOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetAudioOutputConfigurationResponse, sizeof(struct _tmd__GetAudioOutputConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetAudioOutputConfigurationResponse(struct soap *soap, struct _tmd__GetAudioOutputConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetAudioOutputConfigurationResponse);
	if (soap_out_PointerTo_tmd__GetAudioOutputConfigurationResponse(soap, tag?tag:"tmd:GetAudioOutputConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetAudioOutputConfigurationResponse(struct soap *soap, struct _tmd__GetAudioOutputConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetAudioOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetAudioOutputConfiguration(struct soap *soap, struct _tmd__GetAudioOutputConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetAudioOutputConfiguration))
		soap_serialize__tmd__GetAudioOutputConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetAudioOutputConfiguration(struct soap *soap, const char *tag, int id, struct _tmd__GetAudioOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetAudioOutputConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetAudioOutputConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetAudioOutputConfiguration(struct soap *soap, const char *tag, struct _tmd__GetAudioOutputConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetAudioOutputConfiguration **)soap_malloc(soap, sizeof(struct _tmd__GetAudioOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetAudioOutputConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetAudioOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetAudioOutputConfiguration, sizeof(struct _tmd__GetAudioOutputConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetAudioOutputConfiguration(struct soap *soap, struct _tmd__GetAudioOutputConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetAudioOutputConfiguration);
	if (soap_out_PointerTo_tmd__GetAudioOutputConfiguration(soap, tag?tag:"tmd:GetAudioOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetAudioOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetAudioOutputConfiguration(struct soap *soap, struct _tmd__GetAudioOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetAudioOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetAudioSourceConfigurationResponse(struct soap *soap, struct _tmd__GetAudioSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse))
		soap_serialize__tmd__GetAudioSourceConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tmd__GetAudioSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetAudioSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetAudioSourceConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__GetAudioSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetAudioSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _tmd__GetAudioSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetAudioSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetAudioSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetAudioSourceConfigurationResponse, sizeof(struct _tmd__GetAudioSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetAudioSourceConfigurationResponse(struct soap *soap, struct _tmd__GetAudioSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetAudioSourceConfigurationResponse);
	if (soap_out_PointerTo_tmd__GetAudioSourceConfigurationResponse(soap, tag?tag:"tmd:GetAudioSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetAudioSourceConfigurationResponse(struct soap *soap, struct _tmd__GetAudioSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetAudioSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetAudioSourceConfiguration(struct soap *soap, struct _tmd__GetAudioSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetAudioSourceConfiguration))
		soap_serialize__tmd__GetAudioSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetAudioSourceConfiguration(struct soap *soap, const char *tag, int id, struct _tmd__GetAudioSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetAudioSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetAudioSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetAudioSourceConfiguration(struct soap *soap, const char *tag, struct _tmd__GetAudioSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetAudioSourceConfiguration **)soap_malloc(soap, sizeof(struct _tmd__GetAudioSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetAudioSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetAudioSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetAudioSourceConfiguration, sizeof(struct _tmd__GetAudioSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetAudioSourceConfiguration(struct soap *soap, struct _tmd__GetAudioSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetAudioSourceConfiguration);
	if (soap_out_PointerTo_tmd__GetAudioSourceConfiguration(soap, tag?tag:"tmd:GetAudioSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetAudioSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetAudioSourceConfiguration(struct soap *soap, struct _tmd__GetAudioSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetAudioSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetVideoOutputConfigurationResponse(struct soap *soap, struct _tmd__GetVideoOutputConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse))
		soap_serialize__tmd__GetVideoOutputConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetVideoOutputConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tmd__GetVideoOutputConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetVideoOutputConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetVideoOutputConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__GetVideoOutputConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetVideoOutputConfigurationResponse **)soap_malloc(soap, sizeof(struct _tmd__GetVideoOutputConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetVideoOutputConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoOutputConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoOutputConfigurationResponse, sizeof(struct _tmd__GetVideoOutputConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetVideoOutputConfigurationResponse(struct soap *soap, struct _tmd__GetVideoOutputConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetVideoOutputConfigurationResponse);
	if (soap_out_PointerTo_tmd__GetVideoOutputConfigurationResponse(soap, tag?tag:"tmd:GetVideoOutputConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetVideoOutputConfigurationResponse(struct soap *soap, struct _tmd__GetVideoOutputConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetVideoOutputConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetVideoOutputConfiguration(struct soap *soap, struct _tmd__GetVideoOutputConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetVideoOutputConfiguration))
		soap_serialize__tmd__GetVideoOutputConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetVideoOutputConfiguration(struct soap *soap, const char *tag, int id, struct _tmd__GetVideoOutputConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetVideoOutputConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetVideoOutputConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetVideoOutputConfiguration(struct soap *soap, const char *tag, struct _tmd__GetVideoOutputConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetVideoOutputConfiguration **)soap_malloc(soap, sizeof(struct _tmd__GetVideoOutputConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetVideoOutputConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoOutputConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoOutputConfiguration, sizeof(struct _tmd__GetVideoOutputConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetVideoOutputConfiguration(struct soap *soap, struct _tmd__GetVideoOutputConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetVideoOutputConfiguration);
	if (soap_out_PointerTo_tmd__GetVideoOutputConfiguration(soap, tag?tag:"tmd:GetVideoOutputConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetVideoOutputConfiguration(struct soap *soap, struct _tmd__GetVideoOutputConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetVideoOutputConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetVideoSourceConfigurationResponse(struct soap *soap, struct _tmd__GetVideoSourceConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse))
		soap_serialize__tmd__GetVideoSourceConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tmd__GetVideoSourceConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetVideoSourceConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetVideoSourceConfigurationResponse(struct soap *soap, const char *tag, struct _tmd__GetVideoSourceConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetVideoSourceConfigurationResponse **)soap_malloc(soap, sizeof(struct _tmd__GetVideoSourceConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetVideoSourceConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoSourceConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoSourceConfigurationResponse, sizeof(struct _tmd__GetVideoSourceConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetVideoSourceConfigurationResponse(struct soap *soap, struct _tmd__GetVideoSourceConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetVideoSourceConfigurationResponse);
	if (soap_out_PointerTo_tmd__GetVideoSourceConfigurationResponse(soap, tag?tag:"tmd:GetVideoSourceConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetVideoSourceConfigurationResponse(struct soap *soap, struct _tmd__GetVideoSourceConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetVideoSourceConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetVideoSourceConfiguration(struct soap *soap, struct _tmd__GetVideoSourceConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetVideoSourceConfiguration))
		soap_serialize__tmd__GetVideoSourceConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetVideoSourceConfiguration(struct soap *soap, const char *tag, int id, struct _tmd__GetVideoSourceConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetVideoSourceConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetVideoSourceConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetVideoSourceConfiguration(struct soap *soap, const char *tag, struct _tmd__GetVideoSourceConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetVideoSourceConfiguration **)soap_malloc(soap, sizeof(struct _tmd__GetVideoSourceConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetVideoSourceConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoSourceConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoSourceConfiguration, sizeof(struct _tmd__GetVideoSourceConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetVideoSourceConfiguration(struct soap *soap, struct _tmd__GetVideoSourceConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetVideoSourceConfiguration);
	if (soap_out_PointerTo_tmd__GetVideoSourceConfiguration(soap, tag?tag:"tmd:GetVideoSourceConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoSourceConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetVideoSourceConfiguration(struct soap *soap, struct _tmd__GetVideoSourceConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetVideoSourceConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetVideoOutputsResponse(struct soap *soap, struct _tmd__GetVideoOutputsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetVideoOutputsResponse))
		soap_serialize__tmd__GetVideoOutputsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetVideoOutputsResponse(struct soap *soap, const char *tag, int id, struct _tmd__GetVideoOutputsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetVideoOutputsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetVideoOutputsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputsResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetVideoOutputsResponse(struct soap *soap, const char *tag, struct _tmd__GetVideoOutputsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetVideoOutputsResponse **)soap_malloc(soap, sizeof(struct _tmd__GetVideoOutputsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetVideoOutputsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoOutputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoOutputsResponse, sizeof(struct _tmd__GetVideoOutputsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetVideoOutputsResponse(struct soap *soap, struct _tmd__GetVideoOutputsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetVideoOutputsResponse);
	if (soap_out_PointerTo_tmd__GetVideoOutputsResponse(soap, tag?tag:"tmd:GetVideoOutputsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputsResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetVideoOutputsResponse(struct soap *soap, struct _tmd__GetVideoOutputsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetVideoOutputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetVideoOutputs(struct soap *soap, struct _tmd__GetVideoOutputs *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetVideoOutputs))
		soap_serialize__tmd__GetVideoOutputs(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetVideoOutputs(struct soap *soap, const char *tag, int id, struct _tmd__GetVideoOutputs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetVideoOutputs);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetVideoOutputs(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputs ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetVideoOutputs(struct soap *soap, const char *tag, struct _tmd__GetVideoOutputs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetVideoOutputs **)soap_malloc(soap, sizeof(struct _tmd__GetVideoOutputs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetVideoOutputs(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetVideoOutputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetVideoOutputs, sizeof(struct _tmd__GetVideoOutputs), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetVideoOutputs(struct soap *soap, struct _tmd__GetVideoOutputs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetVideoOutputs);
	if (soap_out_PointerTo_tmd__GetVideoOutputs(soap, tag?tag:"tmd:GetVideoOutputs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetVideoOutputs ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetVideoOutputs(struct soap *soap, struct _tmd__GetVideoOutputs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetVideoOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSourcesResponse(struct soap *soap, struct _trt__GetVideoSourcesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSourcesResponse))
		soap_serialize__trt__GetVideoSourcesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSourcesResponse(struct soap *soap, const char *tag, int id, struct _trt__GetVideoSourcesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSourcesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoSourcesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoSourcesResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSourcesResponse(struct soap *soap, const char *tag, struct _trt__GetVideoSourcesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoSourcesResponse **)soap_malloc(soap, sizeof(struct _trt__GetVideoSourcesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoSourcesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSourcesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSourcesResponse, sizeof(struct _trt__GetVideoSourcesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSourcesResponse(struct soap *soap, struct _trt__GetVideoSourcesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSourcesResponse);
	if (soap_out_PointerTo_trt__GetVideoSourcesResponse(soap, tag?tag:"trt:GetVideoSourcesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSourcesResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSourcesResponse(struct soap *soap, struct _trt__GetVideoSourcesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSourcesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetVideoSources(struct soap *soap, struct _trt__GetVideoSources *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetVideoSources))
		soap_serialize__trt__GetVideoSources(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetVideoSources(struct soap *soap, const char *tag, int id, struct _trt__GetVideoSources *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetVideoSources);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetVideoSources(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetVideoSources ** SOAP_FMAC4 soap_in_PointerTo_trt__GetVideoSources(struct soap *soap, const char *tag, struct _trt__GetVideoSources **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetVideoSources **)soap_malloc(soap, sizeof(struct _trt__GetVideoSources *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetVideoSources(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetVideoSources **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetVideoSources, sizeof(struct _trt__GetVideoSources), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetVideoSources(struct soap *soap, struct _trt__GetVideoSources *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetVideoSources);
	if (soap_out_PointerTo_trt__GetVideoSources(soap, tag?tag:"trt:GetVideoSources", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetVideoSources ** SOAP_FMAC4 soap_get_PointerTo_trt__GetVideoSources(struct soap *soap, struct _trt__GetVideoSources **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetVideoSources(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputsResponse(struct soap *soap, struct _trt__GetAudioOutputsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputsResponse))
		soap_serialize__trt__GetAudioOutputsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputsResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioOutputsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioOutputsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioOutputsResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputsResponse(struct soap *soap, const char *tag, struct _trt__GetAudioOutputsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioOutputsResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioOutputsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioOutputsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputsResponse, sizeof(struct _trt__GetAudioOutputsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputsResponse(struct soap *soap, struct _trt__GetAudioOutputsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputsResponse);
	if (soap_out_PointerTo_trt__GetAudioOutputsResponse(soap, tag?tag:"trt:GetAudioOutputsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputsResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputsResponse(struct soap *soap, struct _trt__GetAudioOutputsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioOutputs(struct soap *soap, struct _trt__GetAudioOutputs *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioOutputs))
		soap_serialize__trt__GetAudioOutputs(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioOutputs(struct soap *soap, const char *tag, int id, struct _trt__GetAudioOutputs *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioOutputs);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioOutputs(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioOutputs ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioOutputs(struct soap *soap, const char *tag, struct _trt__GetAudioOutputs **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioOutputs **)soap_malloc(soap, sizeof(struct _trt__GetAudioOutputs *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioOutputs(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioOutputs **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioOutputs, sizeof(struct _trt__GetAudioOutputs), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioOutputs(struct soap *soap, struct _trt__GetAudioOutputs *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioOutputs);
	if (soap_out_PointerTo_trt__GetAudioOutputs(soap, tag?tag:"trt:GetAudioOutputs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioOutputs ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioOutputs(struct soap *soap, struct _trt__GetAudioOutputs **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSourcesResponse(struct soap *soap, struct _trt__GetAudioSourcesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSourcesResponse))
		soap_serialize__trt__GetAudioSourcesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSourcesResponse(struct soap *soap, const char *tag, int id, struct _trt__GetAudioSourcesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSourcesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioSourcesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioSourcesResponse ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSourcesResponse(struct soap *soap, const char *tag, struct _trt__GetAudioSourcesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioSourcesResponse **)soap_malloc(soap, sizeof(struct _trt__GetAudioSourcesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioSourcesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSourcesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSourcesResponse, sizeof(struct _trt__GetAudioSourcesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSourcesResponse(struct soap *soap, struct _trt__GetAudioSourcesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSourcesResponse);
	if (soap_out_PointerTo_trt__GetAudioSourcesResponse(soap, tag?tag:"trt:GetAudioSourcesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSourcesResponse ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSourcesResponse(struct soap *soap, struct _trt__GetAudioSourcesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSourcesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_trt__GetAudioSources(struct soap *soap, struct _trt__GetAudioSources *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__trt__GetAudioSources))
		soap_serialize__trt__GetAudioSources(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_trt__GetAudioSources(struct soap *soap, const char *tag, int id, struct _trt__GetAudioSources *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__trt__GetAudioSources);
	if (id < 0)
		return soap->error;
	return soap_out__trt__GetAudioSources(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _trt__GetAudioSources ** SOAP_FMAC4 soap_in_PointerTo_trt__GetAudioSources(struct soap *soap, const char *tag, struct _trt__GetAudioSources **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _trt__GetAudioSources **)soap_malloc(soap, sizeof(struct _trt__GetAudioSources *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__trt__GetAudioSources(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _trt__GetAudioSources **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__trt__GetAudioSources, sizeof(struct _trt__GetAudioSources), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_trt__GetAudioSources(struct soap *soap, struct _trt__GetAudioSources *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_trt__GetAudioSources);
	if (soap_out_PointerTo_trt__GetAudioSources(soap, tag?tag:"trt:GetAudioSources", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trt__GetAudioSources ** SOAP_FMAC4 soap_get_PointerTo_trt__GetAudioSources(struct soap *soap, struct _trt__GetAudioSources **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_trt__GetAudioSources(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetRelayOutputOptionsResponse(struct soap *soap, struct _tmd__GetRelayOutputOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetRelayOutputOptionsResponse))
		soap_serialize__tmd__GetRelayOutputOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetRelayOutputOptionsResponse(struct soap *soap, const char *tag, int id, struct _tmd__GetRelayOutputOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetRelayOutputOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetRelayOutputOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetRelayOutputOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetRelayOutputOptionsResponse(struct soap *soap, const char *tag, struct _tmd__GetRelayOutputOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetRelayOutputOptionsResponse **)soap_malloc(soap, sizeof(struct _tmd__GetRelayOutputOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetRelayOutputOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetRelayOutputOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetRelayOutputOptionsResponse, sizeof(struct _tmd__GetRelayOutputOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetRelayOutputOptionsResponse(struct soap *soap, struct _tmd__GetRelayOutputOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetRelayOutputOptionsResponse);
	if (soap_out_PointerTo_tmd__GetRelayOutputOptionsResponse(soap, tag?tag:"tmd:GetRelayOutputOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetRelayOutputOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetRelayOutputOptionsResponse(struct soap *soap, struct _tmd__GetRelayOutputOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetRelayOutputOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetRelayOutputOptions(struct soap *soap, struct _tmd__GetRelayOutputOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetRelayOutputOptions))
		soap_serialize__tmd__GetRelayOutputOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetRelayOutputOptions(struct soap *soap, const char *tag, int id, struct _tmd__GetRelayOutputOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetRelayOutputOptions);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetRelayOutputOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetRelayOutputOptions ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetRelayOutputOptions(struct soap *soap, const char *tag, struct _tmd__GetRelayOutputOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetRelayOutputOptions **)soap_malloc(soap, sizeof(struct _tmd__GetRelayOutputOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetRelayOutputOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetRelayOutputOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetRelayOutputOptions, sizeof(struct _tmd__GetRelayOutputOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetRelayOutputOptions(struct soap *soap, struct _tmd__GetRelayOutputOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetRelayOutputOptions);
	if (soap_out_PointerTo_tmd__GetRelayOutputOptions(soap, tag?tag:"tmd:GetRelayOutputOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetRelayOutputOptions ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetRelayOutputOptions(struct soap *soap, struct _tmd__GetRelayOutputOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetRelayOutputOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetServiceCapabilitiesResponse(struct soap *soap, struct _tmd__GetServiceCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetServiceCapabilitiesResponse))
		soap_serialize__tmd__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tmd__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tmd__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tmd__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetServiceCapabilitiesResponse, sizeof(struct _tmd__GetServiceCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetServiceCapabilitiesResponse(struct soap *soap, struct _tmd__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_tmd__GetServiceCapabilitiesResponse(soap, tag?tag:"tmd:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetServiceCapabilitiesResponse(struct soap *soap, struct _tmd__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tmd__GetServiceCapabilities(struct soap *soap, struct _tmd__GetServiceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tmd__GetServiceCapabilities))
		soap_serialize__tmd__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tmd__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _tmd__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tmd__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__tmd__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tmd__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tmd__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tmd__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tmd__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _tmd__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tmd__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tmd__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tmd__GetServiceCapabilities, sizeof(struct _tmd__GetServiceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tmd__GetServiceCapabilities(struct soap *soap, struct _tmd__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tmd__GetServiceCapabilities);
	if (soap_out_PointerTo_tmd__GetServiceCapabilities(soap, tag?tag:"tmd:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tmd__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tmd__GetServiceCapabilities(struct soap *soap, struct _tmd__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tmd__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__DeletePaneConfigurationResponse(struct soap *soap, struct _tls__DeletePaneConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__DeletePaneConfigurationResponse))
		soap_serialize__tls__DeletePaneConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__DeletePaneConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tls__DeletePaneConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__DeletePaneConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tls__DeletePaneConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__DeletePaneConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tls__DeletePaneConfigurationResponse(struct soap *soap, const char *tag, struct _tls__DeletePaneConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__DeletePaneConfigurationResponse **)soap_malloc(soap, sizeof(struct _tls__DeletePaneConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__DeletePaneConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__DeletePaneConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__DeletePaneConfigurationResponse, sizeof(struct _tls__DeletePaneConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__DeletePaneConfigurationResponse(struct soap *soap, struct _tls__DeletePaneConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__DeletePaneConfigurationResponse);
	if (soap_out_PointerTo_tls__DeletePaneConfigurationResponse(soap, tag?tag:"tls:DeletePaneConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__DeletePaneConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tls__DeletePaneConfigurationResponse(struct soap *soap, struct _tls__DeletePaneConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__DeletePaneConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__DeletePaneConfiguration(struct soap *soap, struct _tls__DeletePaneConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__DeletePaneConfiguration))
		soap_serialize__tls__DeletePaneConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__DeletePaneConfiguration(struct soap *soap, const char *tag, int id, struct _tls__DeletePaneConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__DeletePaneConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tls__DeletePaneConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__DeletePaneConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tls__DeletePaneConfiguration(struct soap *soap, const char *tag, struct _tls__DeletePaneConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__DeletePaneConfiguration **)soap_malloc(soap, sizeof(struct _tls__DeletePaneConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__DeletePaneConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__DeletePaneConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__DeletePaneConfiguration, sizeof(struct _tls__DeletePaneConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__DeletePaneConfiguration(struct soap *soap, struct _tls__DeletePaneConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__DeletePaneConfiguration);
	if (soap_out_PointerTo_tls__DeletePaneConfiguration(soap, tag?tag:"tls:DeletePaneConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__DeletePaneConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tls__DeletePaneConfiguration(struct soap *soap, struct _tls__DeletePaneConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__DeletePaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__CreatePaneConfigurationResponse(struct soap *soap, struct _tls__CreatePaneConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__CreatePaneConfigurationResponse))
		soap_serialize__tls__CreatePaneConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__CreatePaneConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tls__CreatePaneConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__CreatePaneConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tls__CreatePaneConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__CreatePaneConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tls__CreatePaneConfigurationResponse(struct soap *soap, const char *tag, struct _tls__CreatePaneConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__CreatePaneConfigurationResponse **)soap_malloc(soap, sizeof(struct _tls__CreatePaneConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__CreatePaneConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__CreatePaneConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__CreatePaneConfigurationResponse, sizeof(struct _tls__CreatePaneConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__CreatePaneConfigurationResponse(struct soap *soap, struct _tls__CreatePaneConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__CreatePaneConfigurationResponse);
	if (soap_out_PointerTo_tls__CreatePaneConfigurationResponse(soap, tag?tag:"tls:CreatePaneConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__CreatePaneConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tls__CreatePaneConfigurationResponse(struct soap *soap, struct _tls__CreatePaneConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__CreatePaneConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__CreatePaneConfiguration(struct soap *soap, struct _tls__CreatePaneConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__CreatePaneConfiguration))
		soap_serialize__tls__CreatePaneConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__CreatePaneConfiguration(struct soap *soap, const char *tag, int id, struct _tls__CreatePaneConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__CreatePaneConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tls__CreatePaneConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__CreatePaneConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tls__CreatePaneConfiguration(struct soap *soap, const char *tag, struct _tls__CreatePaneConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__CreatePaneConfiguration **)soap_malloc(soap, sizeof(struct _tls__CreatePaneConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__CreatePaneConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__CreatePaneConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__CreatePaneConfiguration, sizeof(struct _tls__CreatePaneConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__CreatePaneConfiguration(struct soap *soap, struct _tls__CreatePaneConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__CreatePaneConfiguration);
	if (soap_out_PointerTo_tls__CreatePaneConfiguration(soap, tag?tag:"tls:CreatePaneConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__CreatePaneConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tls__CreatePaneConfiguration(struct soap *soap, struct _tls__CreatePaneConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__CreatePaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__SetPaneConfigurationResponse(struct soap *soap, struct _tls__SetPaneConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__SetPaneConfigurationResponse))
		soap_serialize__tls__SetPaneConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__SetPaneConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tls__SetPaneConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__SetPaneConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tls__SetPaneConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tls__SetPaneConfigurationResponse(struct soap *soap, const char *tag, struct _tls__SetPaneConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__SetPaneConfigurationResponse **)soap_malloc(soap, sizeof(struct _tls__SetPaneConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__SetPaneConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__SetPaneConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__SetPaneConfigurationResponse, sizeof(struct _tls__SetPaneConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__SetPaneConfigurationResponse(struct soap *soap, struct _tls__SetPaneConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__SetPaneConfigurationResponse);
	if (soap_out_PointerTo_tls__SetPaneConfigurationResponse(soap, tag?tag:"tls:SetPaneConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tls__SetPaneConfigurationResponse(struct soap *soap, struct _tls__SetPaneConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__SetPaneConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__SetPaneConfiguration(struct soap *soap, struct _tls__SetPaneConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__SetPaneConfiguration))
		soap_serialize__tls__SetPaneConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__SetPaneConfiguration(struct soap *soap, const char *tag, int id, struct _tls__SetPaneConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__SetPaneConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tls__SetPaneConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__SetPaneConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tls__SetPaneConfiguration(struct soap *soap, const char *tag, struct _tls__SetPaneConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__SetPaneConfiguration **)soap_malloc(soap, sizeof(struct _tls__SetPaneConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__SetPaneConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__SetPaneConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__SetPaneConfiguration, sizeof(struct _tls__SetPaneConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__SetPaneConfiguration(struct soap *soap, struct _tls__SetPaneConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__SetPaneConfiguration);
	if (soap_out_PointerTo_tls__SetPaneConfiguration(soap, tag?tag:"tls:SetPaneConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetPaneConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tls__SetPaneConfiguration(struct soap *soap, struct _tls__SetPaneConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__SetPaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__SetPaneConfigurationsResponse(struct soap *soap, struct _tls__SetPaneConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__SetPaneConfigurationsResponse))
		soap_serialize__tls__SetPaneConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__SetPaneConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _tls__SetPaneConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__SetPaneConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tls__SetPaneConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_tls__SetPaneConfigurationsResponse(struct soap *soap, const char *tag, struct _tls__SetPaneConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__SetPaneConfigurationsResponse **)soap_malloc(soap, sizeof(struct _tls__SetPaneConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__SetPaneConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__SetPaneConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__SetPaneConfigurationsResponse, sizeof(struct _tls__SetPaneConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__SetPaneConfigurationsResponse(struct soap *soap, struct _tls__SetPaneConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__SetPaneConfigurationsResponse);
	if (soap_out_PointerTo_tls__SetPaneConfigurationsResponse(soap, tag?tag:"tls:SetPaneConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_tls__SetPaneConfigurationsResponse(struct soap *soap, struct _tls__SetPaneConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__SetPaneConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__SetPaneConfigurations(struct soap *soap, struct _tls__SetPaneConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__SetPaneConfigurations))
		soap_serialize__tls__SetPaneConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__SetPaneConfigurations(struct soap *soap, const char *tag, int id, struct _tls__SetPaneConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__SetPaneConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__tls__SetPaneConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurations ** SOAP_FMAC4 soap_in_PointerTo_tls__SetPaneConfigurations(struct soap *soap, const char *tag, struct _tls__SetPaneConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__SetPaneConfigurations **)soap_malloc(soap, sizeof(struct _tls__SetPaneConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__SetPaneConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__SetPaneConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__SetPaneConfigurations, sizeof(struct _tls__SetPaneConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__SetPaneConfigurations(struct soap *soap, struct _tls__SetPaneConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__SetPaneConfigurations);
	if (soap_out_PointerTo_tls__SetPaneConfigurations(soap, tag?tag:"tls:SetPaneConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurations ** SOAP_FMAC4 soap_get_PointerTo_tls__SetPaneConfigurations(struct soap *soap, struct _tls__SetPaneConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__SetPaneConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__GetPaneConfigurationResponse(struct soap *soap, struct _tls__GetPaneConfigurationResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__GetPaneConfigurationResponse))
		soap_serialize__tls__GetPaneConfigurationResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__GetPaneConfigurationResponse(struct soap *soap, const char *tag, int id, struct _tls__GetPaneConfigurationResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__GetPaneConfigurationResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tls__GetPaneConfigurationResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationResponse ** SOAP_FMAC4 soap_in_PointerTo_tls__GetPaneConfigurationResponse(struct soap *soap, const char *tag, struct _tls__GetPaneConfigurationResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__GetPaneConfigurationResponse **)soap_malloc(soap, sizeof(struct _tls__GetPaneConfigurationResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__GetPaneConfigurationResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__GetPaneConfigurationResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetPaneConfigurationResponse, sizeof(struct _tls__GetPaneConfigurationResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__GetPaneConfigurationResponse(struct soap *soap, struct _tls__GetPaneConfigurationResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__GetPaneConfigurationResponse);
	if (soap_out_PointerTo_tls__GetPaneConfigurationResponse(soap, tag?tag:"tls:GetPaneConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationResponse ** SOAP_FMAC4 soap_get_PointerTo_tls__GetPaneConfigurationResponse(struct soap *soap, struct _tls__GetPaneConfigurationResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__GetPaneConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__GetPaneConfiguration(struct soap *soap, struct _tls__GetPaneConfiguration *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__GetPaneConfiguration))
		soap_serialize__tls__GetPaneConfiguration(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__GetPaneConfiguration(struct soap *soap, const char *tag, int id, struct _tls__GetPaneConfiguration *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__GetPaneConfiguration);
	if (id < 0)
		return soap->error;
	return soap_out__tls__GetPaneConfiguration(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__GetPaneConfiguration ** SOAP_FMAC4 soap_in_PointerTo_tls__GetPaneConfiguration(struct soap *soap, const char *tag, struct _tls__GetPaneConfiguration **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__GetPaneConfiguration **)soap_malloc(soap, sizeof(struct _tls__GetPaneConfiguration *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__GetPaneConfiguration(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__GetPaneConfiguration **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetPaneConfiguration, sizeof(struct _tls__GetPaneConfiguration), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__GetPaneConfiguration(struct soap *soap, struct _tls__GetPaneConfiguration *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__GetPaneConfiguration);
	if (soap_out_PointerTo_tls__GetPaneConfiguration(soap, tag?tag:"tls:GetPaneConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetPaneConfiguration ** SOAP_FMAC4 soap_get_PointerTo_tls__GetPaneConfiguration(struct soap *soap, struct _tls__GetPaneConfiguration **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__GetPaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__GetPaneConfigurationsResponse(struct soap *soap, struct _tls__GetPaneConfigurationsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__GetPaneConfigurationsResponse))
		soap_serialize__tls__GetPaneConfigurationsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__GetPaneConfigurationsResponse(struct soap *soap, const char *tag, int id, struct _tls__GetPaneConfigurationsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__GetPaneConfigurationsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tls__GetPaneConfigurationsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationsResponse ** SOAP_FMAC4 soap_in_PointerTo_tls__GetPaneConfigurationsResponse(struct soap *soap, const char *tag, struct _tls__GetPaneConfigurationsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__GetPaneConfigurationsResponse **)soap_malloc(soap, sizeof(struct _tls__GetPaneConfigurationsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__GetPaneConfigurationsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__GetPaneConfigurationsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetPaneConfigurationsResponse, sizeof(struct _tls__GetPaneConfigurationsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__GetPaneConfigurationsResponse(struct soap *soap, struct _tls__GetPaneConfigurationsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__GetPaneConfigurationsResponse);
	if (soap_out_PointerTo_tls__GetPaneConfigurationsResponse(soap, tag?tag:"tls:GetPaneConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationsResponse ** SOAP_FMAC4 soap_get_PointerTo_tls__GetPaneConfigurationsResponse(struct soap *soap, struct _tls__GetPaneConfigurationsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__GetPaneConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__GetPaneConfigurations(struct soap *soap, struct _tls__GetPaneConfigurations *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__GetPaneConfigurations))
		soap_serialize__tls__GetPaneConfigurations(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__GetPaneConfigurations(struct soap *soap, const char *tag, int id, struct _tls__GetPaneConfigurations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__GetPaneConfigurations);
	if (id < 0)
		return soap->error;
	return soap_out__tls__GetPaneConfigurations(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurations ** SOAP_FMAC4 soap_in_PointerTo_tls__GetPaneConfigurations(struct soap *soap, const char *tag, struct _tls__GetPaneConfigurations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__GetPaneConfigurations **)soap_malloc(soap, sizeof(struct _tls__GetPaneConfigurations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__GetPaneConfigurations(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__GetPaneConfigurations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetPaneConfigurations, sizeof(struct _tls__GetPaneConfigurations), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__GetPaneConfigurations(struct soap *soap, struct _tls__GetPaneConfigurations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__GetPaneConfigurations);
	if (soap_out_PointerTo_tls__GetPaneConfigurations(soap, tag?tag:"tls:GetPaneConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurations ** SOAP_FMAC4 soap_get_PointerTo_tls__GetPaneConfigurations(struct soap *soap, struct _tls__GetPaneConfigurations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__GetPaneConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__GetDisplayOptionsResponse(struct soap *soap, struct _tls__GetDisplayOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__GetDisplayOptionsResponse))
		soap_serialize__tls__GetDisplayOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__GetDisplayOptionsResponse(struct soap *soap, const char *tag, int id, struct _tls__GetDisplayOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__GetDisplayOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tls__GetDisplayOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__GetDisplayOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_tls__GetDisplayOptionsResponse(struct soap *soap, const char *tag, struct _tls__GetDisplayOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__GetDisplayOptionsResponse **)soap_malloc(soap, sizeof(struct _tls__GetDisplayOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__GetDisplayOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__GetDisplayOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetDisplayOptionsResponse, sizeof(struct _tls__GetDisplayOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__GetDisplayOptionsResponse(struct soap *soap, struct _tls__GetDisplayOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__GetDisplayOptionsResponse);
	if (soap_out_PointerTo_tls__GetDisplayOptionsResponse(soap, tag?tag:"tls:GetDisplayOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetDisplayOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_tls__GetDisplayOptionsResponse(struct soap *soap, struct _tls__GetDisplayOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__GetDisplayOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__GetDisplayOptions(struct soap *soap, struct _tls__GetDisplayOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__GetDisplayOptions))
		soap_serialize__tls__GetDisplayOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__GetDisplayOptions(struct soap *soap, const char *tag, int id, struct _tls__GetDisplayOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__GetDisplayOptions);
	if (id < 0)
		return soap->error;
	return soap_out__tls__GetDisplayOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__GetDisplayOptions ** SOAP_FMAC4 soap_in_PointerTo_tls__GetDisplayOptions(struct soap *soap, const char *tag, struct _tls__GetDisplayOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__GetDisplayOptions **)soap_malloc(soap, sizeof(struct _tls__GetDisplayOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__GetDisplayOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__GetDisplayOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetDisplayOptions, sizeof(struct _tls__GetDisplayOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__GetDisplayOptions(struct soap *soap, struct _tls__GetDisplayOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__GetDisplayOptions);
	if (soap_out_PointerTo_tls__GetDisplayOptions(soap, tag?tag:"tls:GetDisplayOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetDisplayOptions ** SOAP_FMAC4 soap_get_PointerTo_tls__GetDisplayOptions(struct soap *soap, struct _tls__GetDisplayOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__GetDisplayOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__SetLayoutResponse(struct soap *soap, struct _tls__SetLayoutResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__SetLayoutResponse))
		soap_serialize__tls__SetLayoutResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__SetLayoutResponse(struct soap *soap, const char *tag, int id, struct _tls__SetLayoutResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__SetLayoutResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tls__SetLayoutResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__SetLayoutResponse ** SOAP_FMAC4 soap_in_PointerTo_tls__SetLayoutResponse(struct soap *soap, const char *tag, struct _tls__SetLayoutResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__SetLayoutResponse **)soap_malloc(soap, sizeof(struct _tls__SetLayoutResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__SetLayoutResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__SetLayoutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__SetLayoutResponse, sizeof(struct _tls__SetLayoutResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__SetLayoutResponse(struct soap *soap, struct _tls__SetLayoutResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__SetLayoutResponse);
	if (soap_out_PointerTo_tls__SetLayoutResponse(soap, tag?tag:"tls:SetLayoutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetLayoutResponse ** SOAP_FMAC4 soap_get_PointerTo_tls__SetLayoutResponse(struct soap *soap, struct _tls__SetLayoutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__SetLayoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__SetLayout(struct soap *soap, struct _tls__SetLayout *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__SetLayout))
		soap_serialize__tls__SetLayout(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__SetLayout(struct soap *soap, const char *tag, int id, struct _tls__SetLayout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__SetLayout);
	if (id < 0)
		return soap->error;
	return soap_out__tls__SetLayout(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__SetLayout ** SOAP_FMAC4 soap_in_PointerTo_tls__SetLayout(struct soap *soap, const char *tag, struct _tls__SetLayout **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__SetLayout **)soap_malloc(soap, sizeof(struct _tls__SetLayout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__SetLayout(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__SetLayout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__SetLayout, sizeof(struct _tls__SetLayout), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__SetLayout(struct soap *soap, struct _tls__SetLayout *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__SetLayout);
	if (soap_out_PointerTo_tls__SetLayout(soap, tag?tag:"tls:SetLayout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetLayout ** SOAP_FMAC4 soap_get_PointerTo_tls__SetLayout(struct soap *soap, struct _tls__SetLayout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__SetLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__GetLayoutResponse(struct soap *soap, struct _tls__GetLayoutResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__GetLayoutResponse))
		soap_serialize__tls__GetLayoutResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__GetLayoutResponse(struct soap *soap, const char *tag, int id, struct _tls__GetLayoutResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__GetLayoutResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tls__GetLayoutResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__GetLayoutResponse ** SOAP_FMAC4 soap_in_PointerTo_tls__GetLayoutResponse(struct soap *soap, const char *tag, struct _tls__GetLayoutResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__GetLayoutResponse **)soap_malloc(soap, sizeof(struct _tls__GetLayoutResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__GetLayoutResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__GetLayoutResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetLayoutResponse, sizeof(struct _tls__GetLayoutResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__GetLayoutResponse(struct soap *soap, struct _tls__GetLayoutResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__GetLayoutResponse);
	if (soap_out_PointerTo_tls__GetLayoutResponse(soap, tag?tag:"tls:GetLayoutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetLayoutResponse ** SOAP_FMAC4 soap_get_PointerTo_tls__GetLayoutResponse(struct soap *soap, struct _tls__GetLayoutResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__GetLayoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__GetLayout(struct soap *soap, struct _tls__GetLayout *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__GetLayout))
		soap_serialize__tls__GetLayout(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__GetLayout(struct soap *soap, const char *tag, int id, struct _tls__GetLayout *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__GetLayout);
	if (id < 0)
		return soap->error;
	return soap_out__tls__GetLayout(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__GetLayout ** SOAP_FMAC4 soap_in_PointerTo_tls__GetLayout(struct soap *soap, const char *tag, struct _tls__GetLayout **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__GetLayout **)soap_malloc(soap, sizeof(struct _tls__GetLayout *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__GetLayout(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__GetLayout **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetLayout, sizeof(struct _tls__GetLayout), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__GetLayout(struct soap *soap, struct _tls__GetLayout *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__GetLayout);
	if (soap_out_PointerTo_tls__GetLayout(soap, tag?tag:"tls:GetLayout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetLayout ** SOAP_FMAC4 soap_get_PointerTo_tls__GetLayout(struct soap *soap, struct _tls__GetLayout **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__GetLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__GetServiceCapabilitiesResponse(struct soap *soap, struct _tls__GetServiceCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__GetServiceCapabilitiesResponse))
		soap_serialize__tls__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _tls__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__tls__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_tls__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tls__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _tls__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetServiceCapabilitiesResponse, sizeof(struct _tls__GetServiceCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__GetServiceCapabilitiesResponse(struct soap *soap, struct _tls__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_tls__GetServiceCapabilitiesResponse(soap, tag?tag:"tls:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_tls__GetServiceCapabilitiesResponse(struct soap *soap, struct _tls__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_tls__GetServiceCapabilities(struct soap *soap, struct _tls__GetServiceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__tls__GetServiceCapabilities))
		soap_serialize__tls__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_tls__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _tls__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__tls__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__tls__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _tls__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_tls__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tls__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _tls__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _tls__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__tls__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _tls__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__tls__GetServiceCapabilities, sizeof(struct _tls__GetServiceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_tls__GetServiceCapabilities(struct soap *soap, struct _tls__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_tls__GetServiceCapabilities);
	if (soap_out_PointerTo_tls__GetServiceCapabilities(soap, tag?tag:"tls:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_tls__GetServiceCapabilities(struct soap *soap, struct _tls__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_tls__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetMoveOptionsResponse(struct soap *soap, struct _timg__GetMoveOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetMoveOptionsResponse))
		soap_serialize__timg__GetMoveOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetMoveOptionsResponse(struct soap *soap, const char *tag, int id, struct _timg__GetMoveOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetMoveOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetMoveOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetMoveOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__GetMoveOptionsResponse(struct soap *soap, const char *tag, struct _timg__GetMoveOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetMoveOptionsResponse **)soap_malloc(soap, sizeof(struct _timg__GetMoveOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetMoveOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetMoveOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetMoveOptionsResponse, sizeof(struct _timg__GetMoveOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetMoveOptionsResponse(struct soap *soap, struct _timg__GetMoveOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetMoveOptionsResponse);
	if (soap_out_PointerTo_timg__GetMoveOptionsResponse(soap, tag?tag:"timg:GetMoveOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetMoveOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__GetMoveOptionsResponse(struct soap *soap, struct _timg__GetMoveOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetMoveOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetMoveOptions(struct soap *soap, struct _timg__GetMoveOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetMoveOptions))
		soap_serialize__timg__GetMoveOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetMoveOptions(struct soap *soap, const char *tag, int id, struct _timg__GetMoveOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetMoveOptions);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetMoveOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetMoveOptions ** SOAP_FMAC4 soap_in_PointerTo_timg__GetMoveOptions(struct soap *soap, const char *tag, struct _timg__GetMoveOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetMoveOptions **)soap_malloc(soap, sizeof(struct _timg__GetMoveOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetMoveOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetMoveOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetMoveOptions, sizeof(struct _timg__GetMoveOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetMoveOptions(struct soap *soap, struct _timg__GetMoveOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetMoveOptions);
	if (soap_out_PointerTo_timg__GetMoveOptions(soap, tag?tag:"timg:GetMoveOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetMoveOptions ** SOAP_FMAC4 soap_get_PointerTo_timg__GetMoveOptions(struct soap *soap, struct _timg__GetMoveOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetMoveOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetStatusResponse(struct soap *soap, struct _timg__GetStatusResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetStatusResponse))
		soap_serialize__timg__GetStatusResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetStatusResponse(struct soap *soap, const char *tag, int id, struct _timg__GetStatusResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetStatusResponse);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetStatusResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetStatusResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__GetStatusResponse(struct soap *soap, const char *tag, struct _timg__GetStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetStatusResponse **)soap_malloc(soap, sizeof(struct _timg__GetStatusResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetStatusResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetStatusResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetStatusResponse, sizeof(struct _timg__GetStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetStatusResponse(struct soap *soap, struct _timg__GetStatusResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetStatusResponse);
	if (soap_out_PointerTo_timg__GetStatusResponse(soap, tag?tag:"timg:GetStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetStatusResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__GetStatusResponse(struct soap *soap, struct _timg__GetStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetStatus(struct soap *soap, struct _timg__GetStatus *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetStatus))
		soap_serialize__timg__GetStatus(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetStatus(struct soap *soap, const char *tag, int id, struct _timg__GetStatus *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetStatus);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetStatus(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetStatus ** SOAP_FMAC4 soap_in_PointerTo_timg__GetStatus(struct soap *soap, const char *tag, struct _timg__GetStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetStatus **)soap_malloc(soap, sizeof(struct _timg__GetStatus *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetStatus(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetStatus **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetStatus, sizeof(struct _timg__GetStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetStatus(struct soap *soap, struct _timg__GetStatus *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetStatus);
	if (soap_out_PointerTo_timg__GetStatus(soap, tag?tag:"timg:GetStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetStatus ** SOAP_FMAC4 soap_get_PointerTo_timg__GetStatus(struct soap *soap, struct _timg__GetStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__StopResponse(struct soap *soap, struct _timg__StopResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__StopResponse))
		soap_serialize__timg__StopResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__StopResponse(struct soap *soap, const char *tag, int id, struct _timg__StopResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__StopResponse);
	if (id < 0)
		return soap->error;
	return soap_out__timg__StopResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__StopResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__StopResponse(struct soap *soap, const char *tag, struct _timg__StopResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__StopResponse **)soap_malloc(soap, sizeof(struct _timg__StopResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__StopResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__StopResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__StopResponse, sizeof(struct _timg__StopResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__StopResponse(struct soap *soap, struct _timg__StopResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__StopResponse);
	if (soap_out_PointerTo_timg__StopResponse(soap, tag?tag:"timg:StopResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__StopResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__StopResponse(struct soap *soap, struct _timg__StopResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__StopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__Stop(struct soap *soap, struct _timg__Stop *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__Stop))
		soap_serialize__timg__Stop(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__Stop(struct soap *soap, const char *tag, int id, struct _timg__Stop *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__Stop);
	if (id < 0)
		return soap->error;
	return soap_out__timg__Stop(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__Stop ** SOAP_FMAC4 soap_in_PointerTo_timg__Stop(struct soap *soap, const char *tag, struct _timg__Stop **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__Stop **)soap_malloc(soap, sizeof(struct _timg__Stop *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__Stop(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__Stop **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__Stop, sizeof(struct _timg__Stop), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__Stop(struct soap *soap, struct _timg__Stop *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__Stop);
	if (soap_out_PointerTo_timg__Stop(soap, tag?tag:"timg:Stop", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__Stop ** SOAP_FMAC4 soap_get_PointerTo_timg__Stop(struct soap *soap, struct _timg__Stop **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__MoveResponse(struct soap *soap, struct _timg__MoveResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__MoveResponse))
		soap_serialize__timg__MoveResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__MoveResponse(struct soap *soap, const char *tag, int id, struct _timg__MoveResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__MoveResponse);
	if (id < 0)
		return soap->error;
	return soap_out__timg__MoveResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__MoveResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__MoveResponse(struct soap *soap, const char *tag, struct _timg__MoveResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__MoveResponse **)soap_malloc(soap, sizeof(struct _timg__MoveResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__MoveResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__MoveResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__MoveResponse, sizeof(struct _timg__MoveResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__MoveResponse(struct soap *soap, struct _timg__MoveResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__MoveResponse);
	if (soap_out_PointerTo_timg__MoveResponse(soap, tag?tag:"timg:MoveResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__MoveResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__MoveResponse(struct soap *soap, struct _timg__MoveResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__MoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__Move(struct soap *soap, struct _timg__Move *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__Move))
		soap_serialize__timg__Move(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__Move(struct soap *soap, const char *tag, int id, struct _timg__Move *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__Move);
	if (id < 0)
		return soap->error;
	return soap_out__timg__Move(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__Move ** SOAP_FMAC4 soap_in_PointerTo_timg__Move(struct soap *soap, const char *tag, struct _timg__Move **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__Move **)soap_malloc(soap, sizeof(struct _timg__Move *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__Move(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__Move **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__Move, sizeof(struct _timg__Move), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__Move(struct soap *soap, struct _timg__Move *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__Move);
	if (soap_out_PointerTo_timg__Move(soap, tag?tag:"timg:Move", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__Move ** SOAP_FMAC4 soap_get_PointerTo_timg__Move(struct soap *soap, struct _timg__Move **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__Move(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetOptionsResponse(struct soap *soap, struct _timg__GetOptionsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetOptionsResponse))
		soap_serialize__timg__GetOptionsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetOptionsResponse(struct soap *soap, const char *tag, int id, struct _timg__GetOptionsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetOptionsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetOptionsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetOptionsResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__GetOptionsResponse(struct soap *soap, const char *tag, struct _timg__GetOptionsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetOptionsResponse **)soap_malloc(soap, sizeof(struct _timg__GetOptionsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetOptionsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetOptionsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetOptionsResponse, sizeof(struct _timg__GetOptionsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetOptionsResponse(struct soap *soap, struct _timg__GetOptionsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetOptionsResponse);
	if (soap_out_PointerTo_timg__GetOptionsResponse(soap, tag?tag:"timg:GetOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetOptionsResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__GetOptionsResponse(struct soap *soap, struct _timg__GetOptionsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetOptions(struct soap *soap, struct _timg__GetOptions *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetOptions))
		soap_serialize__timg__GetOptions(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetOptions(struct soap *soap, const char *tag, int id, struct _timg__GetOptions *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetOptions);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetOptions(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetOptions ** SOAP_FMAC4 soap_in_PointerTo_timg__GetOptions(struct soap *soap, const char *tag, struct _timg__GetOptions **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetOptions **)soap_malloc(soap, sizeof(struct _timg__GetOptions *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetOptions(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetOptions **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetOptions, sizeof(struct _timg__GetOptions), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetOptions(struct soap *soap, struct _timg__GetOptions *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetOptions);
	if (soap_out_PointerTo_timg__GetOptions(soap, tag?tag:"timg:GetOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetOptions ** SOAP_FMAC4 soap_get_PointerTo_timg__GetOptions(struct soap *soap, struct _timg__GetOptions **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__SetImagingSettingsResponse(struct soap *soap, struct _timg__SetImagingSettingsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__SetImagingSettingsResponse))
		soap_serialize__timg__SetImagingSettingsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__SetImagingSettingsResponse(struct soap *soap, const char *tag, int id, struct _timg__SetImagingSettingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__SetImagingSettingsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__timg__SetImagingSettingsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__SetImagingSettingsResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__SetImagingSettingsResponse(struct soap *soap, const char *tag, struct _timg__SetImagingSettingsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__SetImagingSettingsResponse **)soap_malloc(soap, sizeof(struct _timg__SetImagingSettingsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__SetImagingSettingsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__SetImagingSettingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__SetImagingSettingsResponse, sizeof(struct _timg__SetImagingSettingsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__SetImagingSettingsResponse(struct soap *soap, struct _timg__SetImagingSettingsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__SetImagingSettingsResponse);
	if (soap_out_PointerTo_timg__SetImagingSettingsResponse(soap, tag?tag:"timg:SetImagingSettingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__SetImagingSettingsResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__SetImagingSettingsResponse(struct soap *soap, struct _timg__SetImagingSettingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__SetImagingSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__SetImagingSettings(struct soap *soap, struct _timg__SetImagingSettings *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__SetImagingSettings))
		soap_serialize__timg__SetImagingSettings(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__SetImagingSettings(struct soap *soap, const char *tag, int id, struct _timg__SetImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__SetImagingSettings);
	if (id < 0)
		return soap->error;
	return soap_out__timg__SetImagingSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__SetImagingSettings ** SOAP_FMAC4 soap_in_PointerTo_timg__SetImagingSettings(struct soap *soap, const char *tag, struct _timg__SetImagingSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__SetImagingSettings **)soap_malloc(soap, sizeof(struct _timg__SetImagingSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__SetImagingSettings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__SetImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__SetImagingSettings, sizeof(struct _timg__SetImagingSettings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__SetImagingSettings(struct soap *soap, struct _timg__SetImagingSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__SetImagingSettings);
	if (soap_out_PointerTo_timg__SetImagingSettings(soap, tag?tag:"timg:SetImagingSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__SetImagingSettings ** SOAP_FMAC4 soap_get_PointerTo_timg__SetImagingSettings(struct soap *soap, struct _timg__SetImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__SetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetImagingSettingsResponse(struct soap *soap, struct _timg__GetImagingSettingsResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetImagingSettingsResponse))
		soap_serialize__timg__GetImagingSettingsResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetImagingSettingsResponse(struct soap *soap, const char *tag, int id, struct _timg__GetImagingSettingsResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetImagingSettingsResponse);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetImagingSettingsResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetImagingSettingsResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__GetImagingSettingsResponse(struct soap *soap, const char *tag, struct _timg__GetImagingSettingsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetImagingSettingsResponse **)soap_malloc(soap, sizeof(struct _timg__GetImagingSettingsResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetImagingSettingsResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetImagingSettingsResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetImagingSettingsResponse, sizeof(struct _timg__GetImagingSettingsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetImagingSettingsResponse(struct soap *soap, struct _timg__GetImagingSettingsResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetImagingSettingsResponse);
	if (soap_out_PointerTo_timg__GetImagingSettingsResponse(soap, tag?tag:"timg:GetImagingSettingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetImagingSettingsResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__GetImagingSettingsResponse(struct soap *soap, struct _timg__GetImagingSettingsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetImagingSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetImagingSettings(struct soap *soap, struct _timg__GetImagingSettings *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetImagingSettings))
		soap_serialize__timg__GetImagingSettings(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetImagingSettings(struct soap *soap, const char *tag, int id, struct _timg__GetImagingSettings *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetImagingSettings);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetImagingSettings(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetImagingSettings ** SOAP_FMAC4 soap_in_PointerTo_timg__GetImagingSettings(struct soap *soap, const char *tag, struct _timg__GetImagingSettings **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetImagingSettings **)soap_malloc(soap, sizeof(struct _timg__GetImagingSettings *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetImagingSettings(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetImagingSettings **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetImagingSettings, sizeof(struct _timg__GetImagingSettings), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetImagingSettings(struct soap *soap, struct _timg__GetImagingSettings *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetImagingSettings);
	if (soap_out_PointerTo_timg__GetImagingSettings(soap, tag?tag:"timg:GetImagingSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetImagingSettings ** SOAP_FMAC4 soap_get_PointerTo_timg__GetImagingSettings(struct soap *soap, struct _timg__GetImagingSettings **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetServiceCapabilitiesResponse(struct soap *soap, struct _timg__GetServiceCapabilitiesResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetServiceCapabilitiesResponse))
		soap_serialize__timg__GetServiceCapabilitiesResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, struct _timg__GetServiceCapabilitiesResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetServiceCapabilitiesResponse);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetServiceCapabilitiesResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_in_PointerTo_timg__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _timg__GetServiceCapabilitiesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetServiceCapabilitiesResponse **)soap_malloc(soap, sizeof(struct _timg__GetServiceCapabilitiesResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetServiceCapabilitiesResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetServiceCapabilitiesResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetServiceCapabilitiesResponse, sizeof(struct _timg__GetServiceCapabilitiesResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetServiceCapabilitiesResponse(struct soap *soap, struct _timg__GetServiceCapabilitiesResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetServiceCapabilitiesResponse);
	if (soap_out_PointerTo_timg__GetServiceCapabilitiesResponse(soap, tag?tag:"timg:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilitiesResponse ** SOAP_FMAC4 soap_get_PointerTo_timg__GetServiceCapabilitiesResponse(struct soap *soap, struct _timg__GetServiceCapabilitiesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_timg__GetServiceCapabilities(struct soap *soap, struct _timg__GetServiceCapabilities *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__timg__GetServiceCapabilities))
		soap_serialize__timg__GetServiceCapabilities(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_timg__GetServiceCapabilities(struct soap *soap, const char *tag, int id, struct _timg__GetServiceCapabilities *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__timg__GetServiceCapabilities);
	if (id < 0)
		return soap->error;
	return soap_out__timg__GetServiceCapabilities(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilities ** SOAP_FMAC4 soap_in_PointerTo_timg__GetServiceCapabilities(struct soap *soap, const char *tag, struct _timg__GetServiceCapabilities **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _timg__GetServiceCapabilities **)soap_malloc(soap, sizeof(struct _timg__GetServiceCapabilities *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__timg__GetServiceCapabilities(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _timg__GetServiceCapabilities **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__timg__GetServiceCapabilities, sizeof(struct _timg__GetServiceCapabilities), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_timg__GetServiceCapabilities(struct soap *soap, struct _timg__GetServiceCapabilities *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_timg__GetServiceCapabilities);
	if (soap_out_PointerTo_timg__GetServiceCapabilities(soap, tag?tag:"timg:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilities ** SOAP_FMAC4 soap_get_PointerTo_timg__GetServiceCapabilities(struct soap *soap, struct _timg__GetServiceCapabilities **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_timg__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__ResumeSubscriptionResponse(struct soap *soap, struct _wsnt__ResumeSubscriptionResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse))
		soap_serialize__wsnt__ResumeSubscriptionResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *tag, int id, struct _wsnt__ResumeSubscriptionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__ResumeSubscriptionResponse);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__ResumeSubscriptionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscriptionResponse ** SOAP_FMAC4 soap_in_PointerTo_wsnt__ResumeSubscriptionResponse(struct soap *soap, const char *tag, struct _wsnt__ResumeSubscriptionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__ResumeSubscriptionResponse **)soap_malloc(soap, sizeof(struct _wsnt__ResumeSubscriptionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__ResumeSubscriptionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeSubscriptionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeSubscriptionResponse, sizeof(struct _wsnt__ResumeSubscriptionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__ResumeSubscriptionResponse(struct soap *soap, struct _wsnt__ResumeSubscriptionResponse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__ResumeSubscriptionResponse);
	if (soap_out_PointerTo_wsnt__ResumeSubscriptionResponse(soap, tag?tag:"wsnt:ResumeSubscriptionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscriptionResponse ** SOAP_FMAC4 soap_get_PointerTo_wsnt__ResumeSubscriptionResponse(struct soap *soap, struct _wsnt__ResumeSubscriptionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__ResumeSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__ResumeSubscription(struct soap *soap, struct _wsnt__ResumeSubscription *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__ResumeSubscription))
		soap_serialize__wsnt__ResumeSubscription(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__ResumeSubscription(struct soap *soap, const char *tag, int id, struct _wsnt__ResumeSubscription *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__ResumeSubscription);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__ResumeSubscription(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscription ** SOAP_FMAC4 soap_in_PointerTo_wsnt__ResumeSubscription(struct soap *soap, const char *tag, struct _wsnt__ResumeSubscription **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__ResumeSubscription **)soap_malloc(soap, sizeof(struct _wsnt__ResumeSubscription *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__ResumeSubscription(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__ResumeSubscription **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__ResumeSubscription, sizeof(struct _wsnt__ResumeSubscription), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_wsnt__ResumeSubscription(struct soap *soap, struct _wsnt__ResumeSubscription *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_wsnt__ResumeSubscription);
	if (soap_out_PointerTo_wsnt__ResumeSubscription(soap, tag?tag:"wsnt:ResumeSubscription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__ResumeSubscription ** SOAP_FMAC4 soap_get_PointerTo_wsnt__ResumeSubscription(struct soap *soap, struct _wsnt__ResumeSubscription **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_wsnt__ResumeSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_wsnt__PauseSubscriptionResponse(struct soap *soap, struct _wsnt__PauseSubscriptionResponse *const*a)
{
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE__wsnt__PauseSubscriptionResponse))
		soap_serialize__wsnt__PauseSubscriptionResponse(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_wsnt__PauseSubscriptionResponse(struct soap *soap, const char *tag, int id, struct _wsnt__PauseSubscriptionResponse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__wsnt__PauseSubscriptionResponse);
	if (id < 0)
		return soap->error;
	return soap_out__wsnt__PauseSubscriptionResponse(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct _wsnt__PauseSubscriptionResponse ** SOAP_FMAC4 soap_in_PointerTo_wsnt__PauseSubscriptionResponse(struct soap *soap, const char *tag, struct _wsnt__PauseSubscriptionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct _wsnt__PauseSubscriptionResponse **)soap_malloc(soap, sizeof(struct _wsnt__PauseSubscriptionResponse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in__wsnt__PauseSubscriptionResponse(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct _wsnt__PauseSubscriptionResponse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__wsnt__PauseSubscriptionResponse, sizeof(struct _wsnt__PauseSubscriptionResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifdef __cplusplus
}
#endif
