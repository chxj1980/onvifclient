#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, struct wsnt__InvalidTopicExpressionFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_time(soap, &a->Timestamp);
	a->Originator = NULL;
	a->ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->Description = NULL;
	a->FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const struct wsnt__InvalidTopicExpressionFaultType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->Originator);
	soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, &a->ErrorCode);
	if (a->Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->Description + i, SOAP_TYPE__wsnt__InvalidTopicExpressionFaultType_Description);
			soap_serialize__wsnt__InvalidTopicExpressionFaultType_Description(soap, a->Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, &a->FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__InvalidTopicExpressionFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_time(soap, "wsnt:Timestamp", -1, &a->Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:Originator", -1, &a->Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, "wsnt:ErrorCode", -1, &a->ErrorCode, ""))
		return soap->error;
	if (a->Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out__wsnt__InvalidTopicExpressionFaultType_Description(soap, "wsnt:Description", -1, a->Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, "wsnt:FaultCause", -1, &a->FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidTopicExpressionFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Timestamp = 1;
	size_t soap_flag_Originator = 1;
	size_t soap_flag_ErrorCode = 1;
	struct soap_blist *soap_blist_Description = NULL;
	size_t soap_flag_FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__InvalidTopicExpressionFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, sizeof(struct wsnt__InvalidTopicExpressionFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__InvalidTopicExpressionFaultType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsnt:Timestamp", &a->Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp--;
					continue;
				}
			if (soap_flag_Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:Originator", &a->Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator--;
					continue;
				}
			if (soap_flag_ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_ErrorCode(soap, "wsnt:ErrorCode", &a->ErrorCode, ""))
				{	soap_flag_ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:Description", 1, NULL))
			{	if (a->Description == NULL)
				{	if (soap_blist_Description == NULL)
						soap_blist_Description = soap_new_block(soap);
					a->Description = (struct _wsnt__InvalidTopicExpressionFaultType_Description *)soap_push_block(soap, soap_blist_Description, sizeof(struct _wsnt__InvalidTopicExpressionFaultType_Description));
					if (a->Description == NULL)
						return NULL;
					soap_default__wsnt__InvalidTopicExpressionFaultType_Description(soap, a->Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__InvalidTopicExpressionFaultType_Description(soap, "wsnt:Description", a->Description, ""))
				{	a->__sizeDescription++;
					a->Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__InvalidTopicExpressionFaultType_FaultCause(soap, "wsnt:FaultCause", &a->FaultCause, ""))
				{	soap_flag_FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->Description)
			soap_pop_block(soap, soap_blist_Description);
		if (a->__sizeDescription)
			a->Description = (struct _wsnt__InvalidTopicExpressionFaultType_Description *)soap_save_block(soap, soap_blist_Description, NULL, 1);
		else
		{	a->Description = NULL;
			if (soap_blist_Description)
				soap_end_block(soap, soap_blist_Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__InvalidTopicExpressionFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType, 0, sizeof(struct wsnt__InvalidTopicExpressionFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, const struct wsnt__InvalidTopicExpressionFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsnt__InvalidTopicExpressionFaultType);
	if (soap_out_wsnt__InvalidTopicExpressionFaultType(soap, tag?tag:"wsnt:InvalidTopicExpressionFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidTopicExpressionFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidTopicExpressionFaultType(struct soap *soap, struct wsnt__InvalidTopicExpressionFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidTopicExpressionFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause, 0, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause);
	if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag?tag:"wsnt:TopicExpressionDialectUnknownFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", a->xml__lang, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description * SOAP_FMAC4 soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "xml:lang", 0), &a->xml__lang, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description);
	if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag?tag:"wsnt:TopicExpressionDialectUnknownFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_Description * SOAP_FMAC4 soap_get__wsnt__TopicExpressionDialectUnknownFaultType_Description(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a, const char *type)
{
	if (a->dialect)
		soap_set_attr(soap, "dialect", a->dialect, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "dialect", 1), &a->dialect, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode, 0, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, const struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode);
	if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag?tag:"wsnt:TopicExpressionDialectUnknownFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(struct soap *soap, struct _wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct wsnt__TopicExpressionDialectUnknownFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_time(soap, &a->Timestamp);
	a->Originator = NULL;
	a->ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->Description = NULL;
	a->FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const struct wsnt__TopicExpressionDialectUnknownFaultType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->Originator);
	soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, &a->ErrorCode);
	if (a->Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->Description + i, SOAP_TYPE__wsnt__TopicExpressionDialectUnknownFaultType_Description);
			soap_serialize__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, a->Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, &a->FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_time(soap, "wsnt:Timestamp", -1, &a->Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:Originator", -1, &a->Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, "wsnt:ErrorCode", -1, &a->ErrorCode, ""))
		return soap->error;
	if (a->Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, "wsnt:Description", -1, a->Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, "wsnt:FaultCause", -1, &a->FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_in_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const char *tag, struct wsnt__TopicExpressionDialectUnknownFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Timestamp = 1;
	size_t soap_flag_Originator = 1;
	size_t soap_flag_ErrorCode = 1;
	struct soap_blist *soap_blist_Description = NULL;
	size_t soap_flag_FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__TopicExpressionDialectUnknownFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__TopicExpressionDialectUnknownFaultType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsnt:Timestamp", &a->Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp--;
					continue;
				}
			if (soap_flag_Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:Originator", &a->Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator--;
					continue;
				}
			if (soap_flag_ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_ErrorCode(soap, "wsnt:ErrorCode", &a->ErrorCode, ""))
				{	soap_flag_ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:Description", 1, NULL))
			{	if (a->Description == NULL)
				{	if (soap_blist_Description == NULL)
						soap_blist_Description = soap_new_block(soap);
					a->Description = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)soap_push_block(soap, soap_blist_Description, sizeof(struct _wsnt__TopicExpressionDialectUnknownFaultType_Description));
					if (a->Description == NULL)
						return NULL;
					soap_default__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, a->Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__TopicExpressionDialectUnknownFaultType_Description(soap, "wsnt:Description", a->Description, ""))
				{	a->__sizeDescription++;
					a->Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__TopicExpressionDialectUnknownFaultType_FaultCause(soap, "wsnt:FaultCause", &a->FaultCause, ""))
				{	soap_flag_FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->Description)
			soap_pop_block(soap, soap_blist_Description);
		if (a->__sizeDescription)
			a->Description = (struct _wsnt__TopicExpressionDialectUnknownFaultType_Description *)soap_save_block(soap, soap_blist_Description, NULL, 1);
		else
		{	a->Description = NULL;
			if (soap_blist_Description)
				soap_end_block(soap, soap_blist_Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__TopicExpressionDialectUnknownFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType, 0, sizeof(struct wsnt__TopicExpressionDialectUnknownFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, const struct wsnt__TopicExpressionDialectUnknownFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsnt__TopicExpressionDialectUnknownFaultType);
	if (soap_out_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag?tag:"wsnt:TopicExpressionDialectUnknownFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__TopicExpressionDialectUnknownFaultType * SOAP_FMAC4 soap_get_wsnt__TopicExpressionDialectUnknownFaultType(struct soap *soap, struct wsnt__TopicExpressionDialectUnknownFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__TopicExpressionDialectUnknownFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_FaultCause *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidFilterFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__InvalidFilterFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidFilterFaultType_FaultCause(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause, 0, sizeof(struct _wsnt__InvalidFilterFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_FaultCause *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__InvalidFilterFaultType_FaultCause);
	if (soap_out__wsnt__InvalidFilterFaultType_FaultCause(soap, tag?tag:"wsnt:InvalidFilterFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__InvalidFilterFaultType_FaultCause(struct soap *soap, struct _wsnt__InvalidFilterFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidFilterFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_Description *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidFilterFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", a->xml__lang, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description * SOAP_FMAC4 soap_in__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_Description *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsnt__InvalidFilterFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description, sizeof(struct _wsnt__InvalidFilterFaultType_Description), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__InvalidFilterFaultType_Description(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "xml:lang", 0), &a->xml__lang, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidFilterFaultType_Description(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_Description *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description);
	if (soap_out__wsnt__InvalidFilterFaultType_Description(soap, tag?tag:"wsnt:InvalidFilterFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_Description * SOAP_FMAC4 soap_get__wsnt__InvalidFilterFaultType_Description(struct soap *soap, struct _wsnt__InvalidFilterFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidFilterFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_ErrorCode *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__InvalidFilterFaultType_ErrorCode *a, const char *type)
{
	if (a->dialect)
		soap_set_attr(soap, "dialect", a->dialect, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__InvalidFilterFaultType_ErrorCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__InvalidFilterFaultType_ErrorCode(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "dialect", 1), &a->dialect, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__InvalidFilterFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode, 0, sizeof(struct _wsnt__InvalidFilterFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, const struct _wsnt__InvalidFilterFaultType_ErrorCode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__InvalidFilterFaultType_ErrorCode);
	if (soap_out__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag?tag:"wsnt:InvalidFilterFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__InvalidFilterFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__InvalidFilterFaultType_ErrorCode(struct soap *soap, struct _wsnt__InvalidFilterFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__InvalidFilterFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__InvalidFilterFaultType(struct soap *soap, struct wsnt__InvalidFilterFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_time(soap, &a->Timestamp);
	a->Originator = NULL;
	a->ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->Description = NULL;
	a->FaultCause = NULL;
	a->__anyAttribute = NULL;
	a->__sizeUnknownFilter = 0;
	a->UnknownFilter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__InvalidFilterFaultType(struct soap *soap, const struct wsnt__InvalidFilterFaultType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->Originator);
	soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, &a->ErrorCode);
	if (a->Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->Description + i, SOAP_TYPE__wsnt__InvalidFilterFaultType_Description);
			soap_serialize__wsnt__InvalidFilterFaultType_Description(soap, a->Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, &a->FaultCause);
	if (a->UnknownFilter)
	{	int i;
		for (i = 0; i < a->__sizeUnknownFilter; i++)
		{
			soap_serialize__QName(soap, a->UnknownFilter + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__InvalidFilterFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__InvalidFilterFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_time(soap, "wsnt:Timestamp", -1, &a->Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:Originator", -1, &a->Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, "wsnt:ErrorCode", -1, &a->ErrorCode, ""))
		return soap->error;
	if (a->Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out__wsnt__InvalidFilterFaultType_Description(soap, "wsnt:Description", -1, a->Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, "wsnt:FaultCause", -1, &a->FaultCause, ""))
		return soap->error;
	if (a->UnknownFilter)
	{	int i;
		for (i = 0; i < a->__sizeUnknownFilter; i++)
		{	const char *soap_tmp_UnknownFilter = soap_QName2s(soap, a->UnknownFilter[i]);
			if (soap_out__QName(soap, "wsnt:UnknownFilter", -1, (char*const*)&soap_tmp_UnknownFilter, ""))
				return soap->error;
		}
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_in_wsnt__InvalidFilterFaultType(struct soap *soap, const char *tag, struct wsnt__InvalidFilterFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Timestamp = 1;
	size_t soap_flag_Originator = 1;
	size_t soap_flag_ErrorCode = 1;
	struct soap_blist *soap_blist_Description = NULL;
	size_t soap_flag_FaultCause = 1;
	struct soap_blist *soap_blist_UnknownFilter = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__InvalidFilterFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__InvalidFilterFaultType, sizeof(struct wsnt__InvalidFilterFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__InvalidFilterFaultType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsnt:Timestamp", &a->Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp--;
					continue;
				}
			if (soap_flag_Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:Originator", &a->Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator--;
					continue;
				}
			if (soap_flag_ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__InvalidFilterFaultType_ErrorCode(soap, "wsnt:ErrorCode", &a->ErrorCode, ""))
				{	soap_flag_ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:Description", 1, NULL))
			{	if (a->Description == NULL)
				{	if (soap_blist_Description == NULL)
						soap_blist_Description = soap_new_block(soap);
					a->Description = (struct _wsnt__InvalidFilterFaultType_Description *)soap_push_block(soap, soap_blist_Description, sizeof(struct _wsnt__InvalidFilterFaultType_Description));
					if (a->Description == NULL)
						return NULL;
					soap_default__wsnt__InvalidFilterFaultType_Description(soap, a->Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__InvalidFilterFaultType_Description(soap, "wsnt:Description", a->Description, ""))
				{	a->__sizeDescription++;
					a->Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__InvalidFilterFaultType_FaultCause(soap, "wsnt:FaultCause", &a->FaultCause, ""))
				{	soap_flag_FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:UnknownFilter", 1, NULL))
			{	if (a->UnknownFilter == NULL)
				{	if (soap_blist_UnknownFilter == NULL)
						soap_blist_UnknownFilter = soap_new_block(soap);
					a->UnknownFilter = (char **)soap_push_block(soap, soap_blist_UnknownFilter, sizeof(char *));
					if (a->UnknownFilter == NULL)
						return NULL;
					*a->UnknownFilter = NULL;
				}
				soap_revert(soap);
				if (soap_in__QName(soap, "wsnt:UnknownFilter", a->UnknownFilter, ""))
				{	a->__sizeUnknownFilter++;
					a->UnknownFilter = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->Description)
			soap_pop_block(soap, soap_blist_Description);
		if (a->__sizeDescription)
			a->Description = (struct _wsnt__InvalidFilterFaultType_Description *)soap_save_block(soap, soap_blist_Description, NULL, 1);
		else
		{	a->Description = NULL;
			if (soap_blist_Description)
				soap_end_block(soap, soap_blist_Description);
		}
		if (a->UnknownFilter)
			soap_pop_block(soap, soap_blist_UnknownFilter);
		if (a->__sizeUnknownFilter)
			a->UnknownFilter = (char **)soap_save_block(soap, soap_blist_UnknownFilter, NULL, 1);
		else
		{	a->UnknownFilter = NULL;
			if (soap_blist_UnknownFilter)
				soap_end_block(soap, soap_blist_UnknownFilter);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__InvalidFilterFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__InvalidFilterFaultType, 0, sizeof(struct wsnt__InvalidFilterFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp > 0 || a->__sizeUnknownFilter < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__InvalidFilterFaultType(struct soap *soap, const struct wsnt__InvalidFilterFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsnt__InvalidFilterFaultType);
	if (soap_out_wsnt__InvalidFilterFaultType(soap, tag?tag:"wsnt:InvalidFilterFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__InvalidFilterFaultType * SOAP_FMAC4 soap_get_wsnt__InvalidFilterFaultType(struct soap *soap, struct wsnt__InvalidFilterFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__InvalidFilterFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause), type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause * SOAP_FMAC4 soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a, const char *type)
{
	size_t soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause, 0, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_FaultCause), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_FaultCause);
	if (soap_out__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag?tag:"wsnt:SubscribeCreationFailedFaultType-FaultCause", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_FaultCause * SOAP_FMAC4 soap_get__wsnt__SubscribeCreationFailedFaultType_FaultCause(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_FaultCause *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->__item);
	soap_default__xml__lang(soap, &a->xml__lang);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_Description *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->__item);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeCreationFailedFaultType_Description *a, const char *type)
{
	if (a->xml__lang)
		soap_set_attr(soap, "xml:lang", a->xml__lang, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	return soap_out_string(soap, tag, id, &a->__item, "");
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description * SOAP_FMAC4 soap_in__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_Description *a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!(a = (struct _wsnt__SubscribeCreationFailedFaultType_Description *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description), 0, NULL, NULL, NULL)))
		return NULL;
	soap_revert(soap);
	*soap->id = '\0';
	soap_default__wsnt__SubscribeCreationFailedFaultType_Description(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "xml:lang", 0), &a->xml__lang, 0, -1))
		return NULL;
	if (!soap_in_string(soap, tag, &a->__item, ""))
		return NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_Description *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description);
	if (soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag?tag:"wsnt:SubscribeCreationFailedFaultType-Description", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_Description * SOAP_FMAC4 soap_get__wsnt__SubscribeCreationFailedFaultType_Description(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_Description *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->dialect);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, int id, const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a, const char *type)
{
	if (a->dialect)
		soap_set_attr(soap, "dialect", a->dialect, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode * SOAP_FMAC4 soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const char *tag, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "dialect", 1), &a->dialect, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode, 0, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, const struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_ErrorCode);
	if (soap_out__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag?tag:"wsnt:SubscribeCreationFailedFaultType-ErrorCode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode * SOAP_FMAC4 soap_get__wsnt__SubscribeCreationFailedFaultType_ErrorCode(struct soap *soap, struct _wsnt__SubscribeCreationFailedFaultType_ErrorCode *p, const char *tag, const char *type)
{
	if ((p = soap_in__wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, struct wsnt__SubscribeCreationFailedFaultType *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	soap_default_time(soap, &a->Timestamp);
	a->Originator = NULL;
	a->ErrorCode = NULL;
	a->__sizeDescription = 0;
	a->Description = NULL;
	a->FaultCause = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const struct wsnt__SubscribeCreationFailedFaultType *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Timestamp, SOAP_TYPE_time);
	soap_serialize_PointerTowsa5__EndpointReferenceType(soap, &a->Originator);
	soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, &a->ErrorCode);
	if (a->Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
		{
			soap_embedded(soap, a->Description + i, SOAP_TYPE__wsnt__SubscribeCreationFailedFaultType_Description);
			soap_serialize__wsnt__SubscribeCreationFailedFaultType_Description(soap, a->Description + i);
		}
	}
	soap_serialize_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, &a->FaultCause);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, int id, const struct wsnt__SubscribeCreationFailedFaultType *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	if (soap_out_time(soap, "wsnt:Timestamp", -1, &a->Timestamp, ""))
		return soap->error;
	if (soap_out_PointerTowsa5__EndpointReferenceType(soap, "wsnt:Originator", -1, &a->Originator, ""))
		return soap->error;
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, "wsnt:ErrorCode", -1, &a->ErrorCode, ""))
		return soap->error;
	if (a->Description)
	{	int i;
		for (i = 0; i < a->__sizeDescription; i++)
			if (soap_out__wsnt__SubscribeCreationFailedFaultType_Description(soap, "wsnt:Description", -1, a->Description + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, "wsnt:FaultCause", -1, &a->FaultCause, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_in_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const char *tag, struct wsnt__SubscribeCreationFailedFaultType *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	size_t soap_flag_Timestamp = 1;
	size_t soap_flag_Originator = 1;
	size_t soap_flag_ErrorCode = 1;
	struct soap_blist *soap_blist_Description = NULL;
	size_t soap_flag_FaultCause = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct wsnt__SubscribeCreationFailedFaultType *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, sizeof(struct wsnt__SubscribeCreationFailedFaultType), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_wsnt__SubscribeCreationFailedFaultType(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timestamp && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsnt:Timestamp", &a->Timestamp, "xsd:dateTime"))
				{	soap_flag_Timestamp--;
					continue;
				}
			if (soap_flag_Originator && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsa5__EndpointReferenceType(soap, "wsnt:Originator", &a->Originator, "wsa5:EndpointReferenceType"))
				{	soap_flag_Originator--;
					continue;
				}
			if (soap_flag_ErrorCode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_ErrorCode(soap, "wsnt:ErrorCode", &a->ErrorCode, ""))
				{	soap_flag_ErrorCode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:Description", 1, NULL))
			{	if (a->Description == NULL)
				{	if (soap_blist_Description == NULL)
						soap_blist_Description = soap_new_block(soap);
					a->Description = (struct _wsnt__SubscribeCreationFailedFaultType_Description *)soap_push_block(soap, soap_blist_Description, sizeof(struct _wsnt__SubscribeCreationFailedFaultType_Description));
					if (a->Description == NULL)
						return NULL;
					soap_default__wsnt__SubscribeCreationFailedFaultType_Description(soap, a->Description);
				}
				soap_revert(soap);
				if (soap_in__wsnt__SubscribeCreationFailedFaultType_Description(soap, "wsnt:Description", a->Description, ""))
				{	a->__sizeDescription++;
					a->Description = NULL;
					continue;
				}
			}
			if (soap_flag_FaultCause && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_wsnt__SubscribeCreationFailedFaultType_FaultCause(soap, "wsnt:FaultCause", &a->FaultCause, ""))
				{	soap_flag_FaultCause--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (a->Description)
			soap_pop_block(soap, soap_blist_Description);
		if (a->__sizeDescription)
			a->Description = (struct _wsnt__SubscribeCreationFailedFaultType_Description *)soap_save_block(soap, soap_blist_Description, NULL, 1);
		else
		{	a->Description = NULL;
			if (soap_blist_Description)
				soap_end_block(soap, soap_blist_Description);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct wsnt__SubscribeCreationFailedFaultType *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType, 0, sizeof(struct wsnt__SubscribeCreationFailedFaultType), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timestamp > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, const struct wsnt__SubscribeCreationFailedFaultType *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_wsnt__SubscribeCreationFailedFaultType);
	if (soap_out_wsnt__SubscribeCreationFailedFaultType(soap, tag?tag:"wsnt:SubscribeCreationFailedFaultType", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct wsnt__SubscribeCreationFailedFaultType * SOAP_FMAC4 soap_get_wsnt__SubscribeCreationFailedFaultType(struct soap *soap, struct wsnt__SubscribeCreationFailedFaultType *p, const char *tag, const char *type)
{
	if ((p = soap_in_wsnt__SubscribeCreationFailedFaultType(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__EndSearchResponse(struct soap *soap, struct _tse__EndSearchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->Endpoint);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__EndSearchResponse(struct soap *soap, const struct _tse__EndSearchResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Endpoint, SOAP_TYPE_time);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__EndSearchResponse(struct soap *soap, const char *tag, int id, const struct _tse__EndSearchResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__EndSearchResponse), type))
		return soap->error;
	soap_element_result(soap, "tse:Endpoint");
	if (soap_out_time(soap, "tse:Endpoint", -1, &a->Endpoint, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__EndSearchResponse * SOAP_FMAC4 soap_in__tse__EndSearchResponse(struct soap *soap, const char *tag, struct _tse__EndSearchResponse *a, const char *type)
{
	size_t soap_flag_Endpoint = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__EndSearchResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__EndSearchResponse, sizeof(struct _tse__EndSearchResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__EndSearchResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Endpoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tse:Endpoint", &a->Endpoint, "xsd:dateTime"))
				{	soap_flag_Endpoint--;
					continue;
				}
			soap_check_result(soap, "tse:Endpoint");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__EndSearchResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__EndSearchResponse, 0, sizeof(struct _tse__EndSearchResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Endpoint > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__EndSearchResponse(struct soap *soap, const struct _tse__EndSearchResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__EndSearchResponse);
	if (soap_out__tse__EndSearchResponse(soap, tag?tag:"tse:EndSearchResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__EndSearchResponse * SOAP_FMAC4 soap_get__tse__EndSearchResponse(struct soap *soap, struct _tse__EndSearchResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__EndSearchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__EndSearch(struct soap *soap, struct _tse__EndSearch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__EndSearch(struct soap *soap, const struct _tse__EndSearch *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__JobToken(soap, &a->SearchToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__EndSearch(struct soap *soap, const char *tag, int id, const struct _tse__EndSearch *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__EndSearch), type))
		return soap->error;
	if (a->SearchToken)
	{	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, &a->SearchToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:SearchToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__EndSearch * SOAP_FMAC4 soap_in__tse__EndSearch(struct soap *soap, const char *tag, struct _tse__EndSearch *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__EndSearch *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__EndSearch, sizeof(struct _tse__EndSearch), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__EndSearch(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", &a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__EndSearch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__EndSearch, 0, sizeof(struct _tse__EndSearch), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__EndSearch(struct soap *soap, const struct _tse__EndSearch *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__EndSearch);
	if (soap_out__tse__EndSearch(soap, tag?tag:"tse:EndSearch", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__EndSearch * SOAP_FMAC4 soap_get__tse__EndSearch(struct soap *soap, struct _tse__EndSearch *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__EndSearch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetSearchStateResponse(struct soap *soap, struct _tse__GetSearchStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__SearchState(soap, &a->State);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetSearchStateResponse(struct soap *soap, const struct _tse__GetSearchStateResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetSearchStateResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetSearchStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetSearchStateResponse), type))
		return soap->error;
	soap_element_result(soap, "tse:State");
	if (soap_out_tt__SearchState(soap, "tse:State", -1, &a->State, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetSearchStateResponse * SOAP_FMAC4 soap_in__tse__GetSearchStateResponse(struct soap *soap, const char *tag, struct _tse__GetSearchStateResponse *a, const char *type)
{
	size_t soap_flag_State = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetSearchStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetSearchStateResponse, sizeof(struct _tse__GetSearchStateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetSearchStateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__SearchState(soap, "tse:State", &a->State, "tt:SearchState"))
				{	soap_flag_State--;
					continue;
				}
			soap_check_result(soap, "tse:State");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetSearchStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetSearchStateResponse, 0, sizeof(struct _tse__GetSearchStateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetSearchStateResponse(struct soap *soap, const struct _tse__GetSearchStateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__GetSearchStateResponse);
	if (soap_out__tse__GetSearchStateResponse(soap, tag?tag:"tse:GetSearchStateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetSearchStateResponse * SOAP_FMAC4 soap_get__tse__GetSearchStateResponse(struct soap *soap, struct _tse__GetSearchStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetSearchStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetSearchState(struct soap *soap, struct _tse__GetSearchState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetSearchState(struct soap *soap, const struct _tse__GetSearchState *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__JobToken(soap, &a->SearchToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetSearchState(struct soap *soap, const char *tag, int id, const struct _tse__GetSearchState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetSearchState), type))
		return soap->error;
	if (a->SearchToken)
	{	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, &a->SearchToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:SearchToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetSearchState * SOAP_FMAC4 soap_in__tse__GetSearchState(struct soap *soap, const char *tag, struct _tse__GetSearchState *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetSearchState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetSearchState, sizeof(struct _tse__GetSearchState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetSearchState(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", &a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetSearchState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetSearchState, 0, sizeof(struct _tse__GetSearchState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetSearchState(struct soap *soap, const struct _tse__GetSearchState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__GetSearchState);
	if (soap_out__tse__GetSearchState(soap, tag?tag:"tse:GetSearchState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetSearchState * SOAP_FMAC4 soap_get__tse__GetSearchState(struct soap *soap, struct _tse__GetSearchState *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetSearchState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetMetadataSearchResultsResponse(struct soap *soap, struct _tse__GetMetadataSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ResultList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetMetadataSearchResultsResponse(struct soap *soap, const struct _tse__GetMetadataSearchResultsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__FindMetadataResultList(soap, &a->ResultList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetMetadataSearchResultsResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetMetadataSearchResultsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetMetadataSearchResultsResponse), type))
		return soap->error;
	if (a->ResultList)
		soap_element_result(soap, "tse:ResultList");
	if (a->ResultList)
	{	if (soap_out_PointerTott__FindMetadataResultList(soap, "tse:ResultList", -1, &a->ResultList, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:ResultList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResultsResponse * SOAP_FMAC4 soap_in__tse__GetMetadataSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetMetadataSearchResultsResponse *a, const char *type)
{
	size_t soap_flag_ResultList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetMetadataSearchResultsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetMetadataSearchResultsResponse, sizeof(struct _tse__GetMetadataSearchResultsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetMetadataSearchResultsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FindMetadataResultList(soap, "tse:ResultList", &a->ResultList, "tt:FindMetadataResultList"))
				{	soap_flag_ResultList--;
					continue;
				}
			soap_check_result(soap, "tse:ResultList");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetMetadataSearchResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetMetadataSearchResultsResponse, 0, sizeof(struct _tse__GetMetadataSearchResultsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ResultList > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetMetadataSearchResultsResponse(struct soap *soap, const struct _tse__GetMetadataSearchResultsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__GetMetadataSearchResultsResponse);
	if (soap_out__tse__GetMetadataSearchResultsResponse(soap, tag?tag:"tse:GetMetadataSearchResultsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResultsResponse * SOAP_FMAC4 soap_get__tse__GetMetadataSearchResultsResponse(struct soap *soap, struct _tse__GetMetadataSearchResultsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetMetadataSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetMetadataSearchResults(struct soap *soap, struct _tse__GetMetadataSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
	a->MinResults = NULL;
	a->MaxResults = NULL;
	a->WaitTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetMetadataSearchResults(struct soap *soap, const struct _tse__GetMetadataSearchResults *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__JobToken(soap, &a->SearchToken);
	soap_serialize_PointerToint(soap, &a->MinResults);
	soap_serialize_PointerToint(soap, &a->MaxResults);
	soap_serialize_PointerToxsd__duration(soap, &a->WaitTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetMetadataSearchResults(struct soap *soap, const char *tag, int id, const struct _tse__GetMetadataSearchResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetMetadataSearchResults), type))
		return soap->error;
	if (a->SearchToken)
	{	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, &a->SearchToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:SearchToken"))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MinResults", -1, &a->MinResults, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxResults", -1, &a->MaxResults, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tse:WaitTime", -1, &a->WaitTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResults * SOAP_FMAC4 soap_in__tse__GetMetadataSearchResults(struct soap *soap, const char *tag, struct _tse__GetMetadataSearchResults *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	size_t soap_flag_MinResults = 1;
	size_t soap_flag_MaxResults = 1;
	size_t soap_flag_WaitTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetMetadataSearchResults *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetMetadataSearchResults, sizeof(struct _tse__GetMetadataSearchResults), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetMetadataSearchResults(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", &a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			if (soap_flag_MinResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MinResults", &a->MinResults, "xsd:int"))
				{	soap_flag_MinResults--;
					continue;
				}
			if (soap_flag_MaxResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MaxResults", &a->MaxResults, "xsd:int"))
				{	soap_flag_MaxResults--;
					continue;
				}
			if (soap_flag_WaitTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "tse:WaitTime", &a->WaitTime, "xsd:duration"))
				{	soap_flag_WaitTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetMetadataSearchResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetMetadataSearchResults, 0, sizeof(struct _tse__GetMetadataSearchResults), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetMetadataSearchResults(struct soap *soap, const struct _tse__GetMetadataSearchResults *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__GetMetadataSearchResults);
	if (soap_out__tse__GetMetadataSearchResults(soap, tag?tag:"tse:GetMetadataSearchResults", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMetadataSearchResults * SOAP_FMAC4 soap_get__tse__GetMetadataSearchResults(struct soap *soap, struct _tse__GetMetadataSearchResults *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetMetadataSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindMetadataResponse(struct soap *soap, struct _tse__FindMetadataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindMetadataResponse(struct soap *soap, const struct _tse__FindMetadataResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__JobToken(soap, &a->SearchToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindMetadataResponse(struct soap *soap, const char *tag, int id, const struct _tse__FindMetadataResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindMetadataResponse), type))
		return soap->error;
	if (a->SearchToken)
		soap_element_result(soap, "tse:SearchToken");
	if (a->SearchToken)
	{	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, &a->SearchToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:SearchToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindMetadataResponse * SOAP_FMAC4 soap_in__tse__FindMetadataResponse(struct soap *soap, const char *tag, struct _tse__FindMetadataResponse *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__FindMetadataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindMetadataResponse, sizeof(struct _tse__FindMetadataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindMetadataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", &a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			soap_check_result(soap, "tse:SearchToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__FindMetadataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindMetadataResponse, 0, sizeof(struct _tse__FindMetadataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindMetadataResponse(struct soap *soap, const struct _tse__FindMetadataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__FindMetadataResponse);
	if (soap_out__tse__FindMetadataResponse(soap, tag?tag:"tse:FindMetadataResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindMetadataResponse * SOAP_FMAC4 soap_get__tse__FindMetadataResponse(struct soap *soap, struct _tse__FindMetadataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindMetadataResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindMetadata(struct soap *soap, struct _tse__FindMetadata *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->StartPoint);
	a->EndPoint = NULL;
	a->Scope = NULL;
	a->MetadataFilter = NULL;
	a->MaxMatches = NULL;
	soap_default_xsd__duration(soap, &a->KeepAliveTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindMetadata(struct soap *soap, const struct _tse__FindMetadata *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->StartPoint, SOAP_TYPE_time);
	soap_serialize_PointerTotime(soap, &a->EndPoint);
	soap_serialize_PointerTott__SearchScope(soap, &a->Scope);
	soap_serialize_PointerTott__MetadataFilter(soap, &a->MetadataFilter);
	soap_serialize_PointerToint(soap, &a->MaxMatches);
	soap_embedded(soap, &a->KeepAliveTime, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindMetadata(struct soap *soap, const char *tag, int id, const struct _tse__FindMetadata *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindMetadata), type))
		return soap->error;
	if (soap_out_time(soap, "tse:StartPoint", -1, &a->StartPoint, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "tse:EndPoint", -1, &a->EndPoint, ""))
		return soap->error;
	if (a->Scope)
	{	if (soap_out_PointerTott__SearchScope(soap, "tse:Scope", -1, &a->Scope, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:Scope"))
		return soap->error;
	if (a->MetadataFilter)
	{	if (soap_out_PointerTott__MetadataFilter(soap, "tse:MetadataFilter", -1, &a->MetadataFilter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:MetadataFilter"))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxMatches", -1, &a->MaxMatches, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tse:KeepAliveTime", -1, &a->KeepAliveTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindMetadata * SOAP_FMAC4 soap_in__tse__FindMetadata(struct soap *soap, const char *tag, struct _tse__FindMetadata *a, const char *type)
{
	size_t soap_flag_StartPoint = 1;
	size_t soap_flag_EndPoint = 1;
	size_t soap_flag_Scope = 1;
	size_t soap_flag_MetadataFilter = 1;
	size_t soap_flag_MaxMatches = 1;
	size_t soap_flag_KeepAliveTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__FindMetadata *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindMetadata, sizeof(struct _tse__FindMetadata), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindMetadata(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartPoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tse:StartPoint", &a->StartPoint, "xsd:dateTime"))
				{	soap_flag_StartPoint--;
					continue;
				}
			if (soap_flag_EndPoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "tse:EndPoint", &a->EndPoint, "xsd:dateTime"))
				{	soap_flag_EndPoint--;
					continue;
				}
			if (soap_flag_Scope && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SearchScope(soap, "tse:Scope", &a->Scope, "tt:SearchScope"))
				{	soap_flag_Scope--;
					continue;
				}
			if (soap_flag_MetadataFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MetadataFilter(soap, "tse:MetadataFilter", &a->MetadataFilter, "tt:MetadataFilter"))
				{	soap_flag_MetadataFilter--;
					continue;
				}
			if (soap_flag_MaxMatches && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MaxMatches", &a->MaxMatches, "xsd:int"))
				{	soap_flag_MaxMatches--;
					continue;
				}
			if (soap_flag_KeepAliveTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tse:KeepAliveTime", &a->KeepAliveTime, "xsd:duration"))
				{	soap_flag_KeepAliveTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__FindMetadata *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindMetadata, 0, sizeof(struct _tse__FindMetadata), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartPoint > 0 || soap_flag_Scope > 0 || soap_flag_MetadataFilter > 0 || soap_flag_KeepAliveTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindMetadata(struct soap *soap, const struct _tse__FindMetadata *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__FindMetadata);
	if (soap_out__tse__FindMetadata(soap, tag?tag:"tse:FindMetadata", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindMetadata * SOAP_FMAC4 soap_get__tse__FindMetadata(struct soap *soap, struct _tse__FindMetadata *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindMetadata(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, struct _tse__GetPTZPositionSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ResultList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, const struct _tse__GetPTZPositionSearchResultsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__FindPTZPositionResultList(soap, &a->ResultList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetPTZPositionSearchResultsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse), type))
		return soap->error;
	if (a->ResultList)
		soap_element_result(soap, "tse:ResultList");
	if (a->ResultList)
	{	if (soap_out_PointerTott__FindPTZPositionResultList(soap, "tse:ResultList", -1, &a->ResultList, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:ResultList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResultsResponse * SOAP_FMAC4 soap_in__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetPTZPositionSearchResultsResponse *a, const char *type)
{
	size_t soap_flag_ResultList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetPTZPositionSearchResultsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse, sizeof(struct _tse__GetPTZPositionSearchResultsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetPTZPositionSearchResultsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FindPTZPositionResultList(soap, "tse:ResultList", &a->ResultList, "tt:FindPTZPositionResultList"))
				{	soap_flag_ResultList--;
					continue;
				}
			soap_check_result(soap, "tse:ResultList");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetPTZPositionSearchResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse, 0, sizeof(struct _tse__GetPTZPositionSearchResultsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ResultList > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, const struct _tse__GetPTZPositionSearchResultsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__GetPTZPositionSearchResultsResponse);
	if (soap_out__tse__GetPTZPositionSearchResultsResponse(soap, tag?tag:"tse:GetPTZPositionSearchResultsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResultsResponse * SOAP_FMAC4 soap_get__tse__GetPTZPositionSearchResultsResponse(struct soap *soap, struct _tse__GetPTZPositionSearchResultsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetPTZPositionSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetPTZPositionSearchResults(struct soap *soap, struct _tse__GetPTZPositionSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
	a->MinResults = NULL;
	a->MaxResults = NULL;
	a->WaitTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetPTZPositionSearchResults(struct soap *soap, const struct _tse__GetPTZPositionSearchResults *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__JobToken(soap, &a->SearchToken);
	soap_serialize_PointerToint(soap, &a->MinResults);
	soap_serialize_PointerToint(soap, &a->MaxResults);
	soap_serialize_PointerToxsd__duration(soap, &a->WaitTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetPTZPositionSearchResults(struct soap *soap, const char *tag, int id, const struct _tse__GetPTZPositionSearchResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetPTZPositionSearchResults), type))
		return soap->error;
	if (a->SearchToken)
	{	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, &a->SearchToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:SearchToken"))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MinResults", -1, &a->MinResults, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxResults", -1, &a->MaxResults, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tse:WaitTime", -1, &a->WaitTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResults * SOAP_FMAC4 soap_in__tse__GetPTZPositionSearchResults(struct soap *soap, const char *tag, struct _tse__GetPTZPositionSearchResults *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	size_t soap_flag_MinResults = 1;
	size_t soap_flag_MaxResults = 1;
	size_t soap_flag_WaitTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetPTZPositionSearchResults *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetPTZPositionSearchResults, sizeof(struct _tse__GetPTZPositionSearchResults), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetPTZPositionSearchResults(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", &a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			if (soap_flag_MinResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MinResults", &a->MinResults, "xsd:int"))
				{	soap_flag_MinResults--;
					continue;
				}
			if (soap_flag_MaxResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MaxResults", &a->MaxResults, "xsd:int"))
				{	soap_flag_MaxResults--;
					continue;
				}
			if (soap_flag_WaitTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "tse:WaitTime", &a->WaitTime, "xsd:duration"))
				{	soap_flag_WaitTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetPTZPositionSearchResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetPTZPositionSearchResults, 0, sizeof(struct _tse__GetPTZPositionSearchResults), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetPTZPositionSearchResults(struct soap *soap, const struct _tse__GetPTZPositionSearchResults *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__GetPTZPositionSearchResults);
	if (soap_out__tse__GetPTZPositionSearchResults(soap, tag?tag:"tse:GetPTZPositionSearchResults", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetPTZPositionSearchResults * SOAP_FMAC4 soap_get__tse__GetPTZPositionSearchResults(struct soap *soap, struct _tse__GetPTZPositionSearchResults *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetPTZPositionSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindPTZPositionResponse(struct soap *soap, struct _tse__FindPTZPositionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindPTZPositionResponse(struct soap *soap, const struct _tse__FindPTZPositionResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__JobToken(soap, &a->SearchToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindPTZPositionResponse(struct soap *soap, const char *tag, int id, const struct _tse__FindPTZPositionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindPTZPositionResponse), type))
		return soap->error;
	if (a->SearchToken)
		soap_element_result(soap, "tse:SearchToken");
	if (a->SearchToken)
	{	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, &a->SearchToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:SearchToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindPTZPositionResponse * SOAP_FMAC4 soap_in__tse__FindPTZPositionResponse(struct soap *soap, const char *tag, struct _tse__FindPTZPositionResponse *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__FindPTZPositionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindPTZPositionResponse, sizeof(struct _tse__FindPTZPositionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindPTZPositionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", &a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			soap_check_result(soap, "tse:SearchToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__FindPTZPositionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindPTZPositionResponse, 0, sizeof(struct _tse__FindPTZPositionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindPTZPositionResponse(struct soap *soap, const struct _tse__FindPTZPositionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__FindPTZPositionResponse);
	if (soap_out__tse__FindPTZPositionResponse(soap, tag?tag:"tse:FindPTZPositionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindPTZPositionResponse * SOAP_FMAC4 soap_get__tse__FindPTZPositionResponse(struct soap *soap, struct _tse__FindPTZPositionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindPTZPositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindPTZPosition(struct soap *soap, struct _tse__FindPTZPosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->StartPoint);
	a->EndPoint = NULL;
	a->Scope = NULL;
	a->SearchFilter = NULL;
	a->MaxMatches = NULL;
	soap_default_xsd__duration(soap, &a->KeepAliveTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindPTZPosition(struct soap *soap, const struct _tse__FindPTZPosition *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->StartPoint, SOAP_TYPE_time);
	soap_serialize_PointerTotime(soap, &a->EndPoint);
	soap_serialize_PointerTott__SearchScope(soap, &a->Scope);
	soap_serialize_PointerTott__PTZPositionFilter(soap, &a->SearchFilter);
	soap_serialize_PointerToint(soap, &a->MaxMatches);
	soap_embedded(soap, &a->KeepAliveTime, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindPTZPosition(struct soap *soap, const char *tag, int id, const struct _tse__FindPTZPosition *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindPTZPosition), type))
		return soap->error;
	if (soap_out_time(soap, "tse:StartPoint", -1, &a->StartPoint, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "tse:EndPoint", -1, &a->EndPoint, ""))
		return soap->error;
	if (a->Scope)
	{	if (soap_out_PointerTott__SearchScope(soap, "tse:Scope", -1, &a->Scope, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:Scope"))
		return soap->error;
	if (a->SearchFilter)
	{	if (soap_out_PointerTott__PTZPositionFilter(soap, "tse:SearchFilter", -1, &a->SearchFilter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:SearchFilter"))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxMatches", -1, &a->MaxMatches, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tse:KeepAliveTime", -1, &a->KeepAliveTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindPTZPosition * SOAP_FMAC4 soap_in__tse__FindPTZPosition(struct soap *soap, const char *tag, struct _tse__FindPTZPosition *a, const char *type)
{
	size_t soap_flag_StartPoint = 1;
	size_t soap_flag_EndPoint = 1;
	size_t soap_flag_Scope = 1;
	size_t soap_flag_SearchFilter = 1;
	size_t soap_flag_MaxMatches = 1;
	size_t soap_flag_KeepAliveTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__FindPTZPosition *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindPTZPosition, sizeof(struct _tse__FindPTZPosition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindPTZPosition(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartPoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tse:StartPoint", &a->StartPoint, "xsd:dateTime"))
				{	soap_flag_StartPoint--;
					continue;
				}
			if (soap_flag_EndPoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "tse:EndPoint", &a->EndPoint, "xsd:dateTime"))
				{	soap_flag_EndPoint--;
					continue;
				}
			if (soap_flag_Scope && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SearchScope(soap, "tse:Scope", &a->Scope, "tt:SearchScope"))
				{	soap_flag_Scope--;
					continue;
				}
			if (soap_flag_SearchFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZPositionFilter(soap, "tse:SearchFilter", &a->SearchFilter, "tt:PTZPositionFilter"))
				{	soap_flag_SearchFilter--;
					continue;
				}
			if (soap_flag_MaxMatches && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MaxMatches", &a->MaxMatches, "xsd:int"))
				{	soap_flag_MaxMatches--;
					continue;
				}
			if (soap_flag_KeepAliveTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tse:KeepAliveTime", &a->KeepAliveTime, "xsd:duration"))
				{	soap_flag_KeepAliveTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__FindPTZPosition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindPTZPosition, 0, sizeof(struct _tse__FindPTZPosition), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartPoint > 0 || soap_flag_Scope > 0 || soap_flag_SearchFilter > 0 || soap_flag_KeepAliveTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindPTZPosition(struct soap *soap, const struct _tse__FindPTZPosition *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__FindPTZPosition);
	if (soap_out__tse__FindPTZPosition(soap, tag?tag:"tse:FindPTZPosition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindPTZPosition * SOAP_FMAC4 soap_get__tse__FindPTZPosition(struct soap *soap, struct _tse__FindPTZPosition *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindPTZPosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetEventSearchResultsResponse(struct soap *soap, struct _tse__GetEventSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ResultList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetEventSearchResultsResponse(struct soap *soap, const struct _tse__GetEventSearchResultsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__FindEventResultList(soap, &a->ResultList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetEventSearchResultsResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetEventSearchResultsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetEventSearchResultsResponse), type))
		return soap->error;
	if (a->ResultList)
		soap_element_result(soap, "tse:ResultList");
	if (a->ResultList)
	{	if (soap_out_PointerTott__FindEventResultList(soap, "tse:ResultList", -1, &a->ResultList, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:ResultList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetEventSearchResultsResponse * SOAP_FMAC4 soap_in__tse__GetEventSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetEventSearchResultsResponse *a, const char *type)
{
	size_t soap_flag_ResultList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetEventSearchResultsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetEventSearchResultsResponse, sizeof(struct _tse__GetEventSearchResultsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetEventSearchResultsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FindEventResultList(soap, "tse:ResultList", &a->ResultList, "tt:FindEventResultList"))
				{	soap_flag_ResultList--;
					continue;
				}
			soap_check_result(soap, "tse:ResultList");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetEventSearchResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetEventSearchResultsResponse, 0, sizeof(struct _tse__GetEventSearchResultsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ResultList > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetEventSearchResultsResponse(struct soap *soap, const struct _tse__GetEventSearchResultsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__GetEventSearchResultsResponse);
	if (soap_out__tse__GetEventSearchResultsResponse(soap, tag?tag:"tse:GetEventSearchResultsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetEventSearchResultsResponse * SOAP_FMAC4 soap_get__tse__GetEventSearchResultsResponse(struct soap *soap, struct _tse__GetEventSearchResultsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetEventSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetEventSearchResults(struct soap *soap, struct _tse__GetEventSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
	a->MinResults = NULL;
	a->MaxResults = NULL;
	a->WaitTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetEventSearchResults(struct soap *soap, const struct _tse__GetEventSearchResults *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__JobToken(soap, &a->SearchToken);
	soap_serialize_PointerToint(soap, &a->MinResults);
	soap_serialize_PointerToint(soap, &a->MaxResults);
	soap_serialize_PointerToxsd__duration(soap, &a->WaitTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetEventSearchResults(struct soap *soap, const char *tag, int id, const struct _tse__GetEventSearchResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetEventSearchResults), type))
		return soap->error;
	if (a->SearchToken)
	{	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, &a->SearchToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:SearchToken"))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MinResults", -1, &a->MinResults, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxResults", -1, &a->MaxResults, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tse:WaitTime", -1, &a->WaitTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetEventSearchResults * SOAP_FMAC4 soap_in__tse__GetEventSearchResults(struct soap *soap, const char *tag, struct _tse__GetEventSearchResults *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	size_t soap_flag_MinResults = 1;
	size_t soap_flag_MaxResults = 1;
	size_t soap_flag_WaitTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetEventSearchResults *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetEventSearchResults, sizeof(struct _tse__GetEventSearchResults), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetEventSearchResults(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", &a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			if (soap_flag_MinResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MinResults", &a->MinResults, "xsd:int"))
				{	soap_flag_MinResults--;
					continue;
				}
			if (soap_flag_MaxResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MaxResults", &a->MaxResults, "xsd:int"))
				{	soap_flag_MaxResults--;
					continue;
				}
			if (soap_flag_WaitTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "tse:WaitTime", &a->WaitTime, "xsd:duration"))
				{	soap_flag_WaitTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetEventSearchResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetEventSearchResults, 0, sizeof(struct _tse__GetEventSearchResults), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetEventSearchResults(struct soap *soap, const struct _tse__GetEventSearchResults *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__GetEventSearchResults);
	if (soap_out__tse__GetEventSearchResults(soap, tag?tag:"tse:GetEventSearchResults", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetEventSearchResults * SOAP_FMAC4 soap_get__tse__GetEventSearchResults(struct soap *soap, struct _tse__GetEventSearchResults *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetEventSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindEventsResponse(struct soap *soap, struct _tse__FindEventsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindEventsResponse(struct soap *soap, const struct _tse__FindEventsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__JobToken(soap, &a->SearchToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindEventsResponse(struct soap *soap, const char *tag, int id, const struct _tse__FindEventsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindEventsResponse), type))
		return soap->error;
	if (a->SearchToken)
		soap_element_result(soap, "tse:SearchToken");
	if (a->SearchToken)
	{	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, &a->SearchToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:SearchToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindEventsResponse * SOAP_FMAC4 soap_in__tse__FindEventsResponse(struct soap *soap, const char *tag, struct _tse__FindEventsResponse *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__FindEventsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindEventsResponse, sizeof(struct _tse__FindEventsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindEventsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", &a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			soap_check_result(soap, "tse:SearchToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__FindEventsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindEventsResponse, 0, sizeof(struct _tse__FindEventsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindEventsResponse(struct soap *soap, const struct _tse__FindEventsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__FindEventsResponse);
	if (soap_out__tse__FindEventsResponse(soap, tag?tag:"tse:FindEventsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindEventsResponse * SOAP_FMAC4 soap_get__tse__FindEventsResponse(struct soap *soap, struct _tse__FindEventsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindEventsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__EventFilter(struct soap *soap, struct tt__EventFilter *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__EventFilter(struct soap *soap, const struct tt__EventFilter *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__EventFilter(struct soap *soap, const char *tag, int id, const struct tt__EventFilter *a, const char *type)
{
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__EventFilter), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__EventFilter * SOAP_FMAC4 soap_in_tt__EventFilter(struct soap *soap, const char *tag, struct tt__EventFilter *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__EventFilter *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__EventFilter, sizeof(struct tt__EventFilter), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__EventFilter(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__EventFilter *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__EventFilter, 0, sizeof(struct tt__EventFilter), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__EventFilter(struct soap *soap, const struct tt__EventFilter *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__EventFilter);
	if (soap_out_tt__EventFilter(soap, tag?tag:"tt:EventFilter", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__EventFilter * SOAP_FMAC4 soap_get_tt__EventFilter(struct soap *soap, struct tt__EventFilter *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__EventFilter(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindEvents(struct soap *soap, struct _tse__FindEvents *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->StartPoint);
	a->EndPoint = NULL;
	a->Scope = NULL;
	a->SearchFilter = NULL;
	soap_default_xsd__boolean(soap, &a->IncludeStartState);
	a->MaxMatches = NULL;
	soap_default_xsd__duration(soap, &a->KeepAliveTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindEvents(struct soap *soap, const struct _tse__FindEvents *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->StartPoint, SOAP_TYPE_time);
	soap_serialize_PointerTotime(soap, &a->EndPoint);
	soap_serialize_PointerTott__SearchScope(soap, &a->Scope);
	soap_serialize_PointerTott__EventFilter(soap, &a->SearchFilter);
	soap_embedded(soap, &a->IncludeStartState, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerToint(soap, &a->MaxMatches);
	soap_embedded(soap, &a->KeepAliveTime, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindEvents(struct soap *soap, const char *tag, int id, const struct _tse__FindEvents *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindEvents), type))
		return soap->error;
	if (soap_out_time(soap, "tse:StartPoint", -1, &a->StartPoint, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "tse:EndPoint", -1, &a->EndPoint, ""))
		return soap->error;
	if (a->Scope)
	{	if (soap_out_PointerTott__SearchScope(soap, "tse:Scope", -1, &a->Scope, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:Scope"))
		return soap->error;
	if (a->SearchFilter)
	{	if (soap_out_PointerTott__EventFilter(soap, "tse:SearchFilter", -1, &a->SearchFilter, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:SearchFilter"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tse:IncludeStartState", -1, &a->IncludeStartState, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxMatches", -1, &a->MaxMatches, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tse:KeepAliveTime", -1, &a->KeepAliveTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindEvents * SOAP_FMAC4 soap_in__tse__FindEvents(struct soap *soap, const char *tag, struct _tse__FindEvents *a, const char *type)
{
	size_t soap_flag_StartPoint = 1;
	size_t soap_flag_EndPoint = 1;
	size_t soap_flag_Scope = 1;
	size_t soap_flag_SearchFilter = 1;
	size_t soap_flag_IncludeStartState = 1;
	size_t soap_flag_MaxMatches = 1;
	size_t soap_flag_KeepAliveTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__FindEvents *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindEvents, sizeof(struct _tse__FindEvents), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindEvents(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StartPoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tse:StartPoint", &a->StartPoint, "xsd:dateTime"))
				{	soap_flag_StartPoint--;
					continue;
				}
			if (soap_flag_EndPoint && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "tse:EndPoint", &a->EndPoint, "xsd:dateTime"))
				{	soap_flag_EndPoint--;
					continue;
				}
			if (soap_flag_Scope && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SearchScope(soap, "tse:Scope", &a->Scope, "tt:SearchScope"))
				{	soap_flag_Scope--;
					continue;
				}
			if (soap_flag_SearchFilter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__EventFilter(soap, "tse:SearchFilter", &a->SearchFilter, "tt:EventFilter"))
				{	soap_flag_SearchFilter--;
					continue;
				}
			if (soap_flag_IncludeStartState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tse:IncludeStartState", &a->IncludeStartState, "xsd:boolean"))
				{	soap_flag_IncludeStartState--;
					continue;
				}
			if (soap_flag_MaxMatches && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MaxMatches", &a->MaxMatches, "xsd:int"))
				{	soap_flag_MaxMatches--;
					continue;
				}
			if (soap_flag_KeepAliveTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tse:KeepAliveTime", &a->KeepAliveTime, "xsd:duration"))
				{	soap_flag_KeepAliveTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__FindEvents *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindEvents, 0, sizeof(struct _tse__FindEvents), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StartPoint > 0 || soap_flag_Scope > 0 || soap_flag_SearchFilter > 0 || soap_flag_IncludeStartState > 0 || soap_flag_KeepAliveTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindEvents(struct soap *soap, const struct _tse__FindEvents *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__FindEvents);
	if (soap_out__tse__FindEvents(soap, tag?tag:"tse:FindEvents", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindEvents * SOAP_FMAC4 soap_get__tse__FindEvents(struct soap *soap, struct _tse__FindEvents *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindEvents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetRecordingSearchResultsResponse(struct soap *soap, struct _tse__GetRecordingSearchResultsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ResultList = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetRecordingSearchResultsResponse(struct soap *soap, const struct _tse__GetRecordingSearchResultsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__FindRecordingResultList(soap, &a->ResultList);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetRecordingSearchResultsResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetRecordingSearchResultsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetRecordingSearchResultsResponse), type))
		return soap->error;
	if (a->ResultList)
		soap_element_result(soap, "tse:ResultList");
	if (a->ResultList)
	{	if (soap_out_PointerTott__FindRecordingResultList(soap, "tse:ResultList", -1, &a->ResultList, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:ResultList"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResultsResponse * SOAP_FMAC4 soap_in__tse__GetRecordingSearchResultsResponse(struct soap *soap, const char *tag, struct _tse__GetRecordingSearchResultsResponse *a, const char *type)
{
	size_t soap_flag_ResultList = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetRecordingSearchResultsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingSearchResultsResponse, sizeof(struct _tse__GetRecordingSearchResultsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetRecordingSearchResultsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ResultList && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FindRecordingResultList(soap, "tse:ResultList", &a->ResultList, "tt:FindRecordingResultList"))
				{	soap_flag_ResultList--;
					continue;
				}
			soap_check_result(soap, "tse:ResultList");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSearchResultsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingSearchResultsResponse, 0, sizeof(struct _tse__GetRecordingSearchResultsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ResultList > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetRecordingSearchResultsResponse(struct soap *soap, const struct _tse__GetRecordingSearchResultsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__GetRecordingSearchResultsResponse);
	if (soap_out__tse__GetRecordingSearchResultsResponse(soap, tag?tag:"tse:GetRecordingSearchResultsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResultsResponse * SOAP_FMAC4 soap_get__tse__GetRecordingSearchResultsResponse(struct soap *soap, struct _tse__GetRecordingSearchResultsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetRecordingSearchResultsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetRecordingSearchResults(struct soap *soap, struct _tse__GetRecordingSearchResults *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
	a->MinResults = NULL;
	a->MaxResults = NULL;
	a->WaitTime = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetRecordingSearchResults(struct soap *soap, const struct _tse__GetRecordingSearchResults *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__JobToken(soap, &a->SearchToken);
	soap_serialize_PointerToint(soap, &a->MinResults);
	soap_serialize_PointerToint(soap, &a->MaxResults);
	soap_serialize_PointerToxsd__duration(soap, &a->WaitTime);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetRecordingSearchResults(struct soap *soap, const char *tag, int id, const struct _tse__GetRecordingSearchResults *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetRecordingSearchResults), type))
		return soap->error;
	if (a->SearchToken)
	{	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, &a->SearchToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:SearchToken"))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MinResults", -1, &a->MinResults, ""))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxResults", -1, &a->MaxResults, ""))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tse:WaitTime", -1, &a->WaitTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResults * SOAP_FMAC4 soap_in__tse__GetRecordingSearchResults(struct soap *soap, const char *tag, struct _tse__GetRecordingSearchResults *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	size_t soap_flag_MinResults = 1;
	size_t soap_flag_MaxResults = 1;
	size_t soap_flag_WaitTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetRecordingSearchResults *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingSearchResults, sizeof(struct _tse__GetRecordingSearchResults), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetRecordingSearchResults(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", &a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			if (soap_flag_MinResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MinResults", &a->MinResults, "xsd:int"))
				{	soap_flag_MinResults--;
					continue;
				}
			if (soap_flag_MaxResults && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MaxResults", &a->MaxResults, "xsd:int"))
				{	soap_flag_MaxResults--;
					continue;
				}
			if (soap_flag_WaitTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "tse:WaitTime", &a->WaitTime, "xsd:duration"))
				{	soap_flag_WaitTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSearchResults *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingSearchResults, 0, sizeof(struct _tse__GetRecordingSearchResults), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetRecordingSearchResults(struct soap *soap, const struct _tse__GetRecordingSearchResults *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__GetRecordingSearchResults);
	if (soap_out__tse__GetRecordingSearchResults(soap, tag?tag:"tse:GetRecordingSearchResults", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSearchResults * SOAP_FMAC4 soap_get__tse__GetRecordingSearchResults(struct soap *soap, struct _tse__GetRecordingSearchResults *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetRecordingSearchResults(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindRecordingsResponse(struct soap *soap, struct _tse__FindRecordingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__JobToken(soap, &a->SearchToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindRecordingsResponse(struct soap *soap, const struct _tse__FindRecordingsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__JobToken(soap, &a->SearchToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindRecordingsResponse(struct soap *soap, const char *tag, int id, const struct _tse__FindRecordingsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindRecordingsResponse), type))
		return soap->error;
	if (a->SearchToken)
		soap_element_result(soap, "tse:SearchToken");
	if (a->SearchToken)
	{	if (soap_out_tt__JobToken(soap, "tse:SearchToken", -1, &a->SearchToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:SearchToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindRecordingsResponse * SOAP_FMAC4 soap_in__tse__FindRecordingsResponse(struct soap *soap, const char *tag, struct _tse__FindRecordingsResponse *a, const char *type)
{
	size_t soap_flag_SearchToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__FindRecordingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindRecordingsResponse, sizeof(struct _tse__FindRecordingsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindRecordingsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SearchToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__JobToken(soap, "tse:SearchToken", &a->SearchToken, "tt:JobToken"))
				{	soap_flag_SearchToken--;
					continue;
				}
			soap_check_result(soap, "tse:SearchToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__FindRecordingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindRecordingsResponse, 0, sizeof(struct _tse__FindRecordingsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SearchToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindRecordingsResponse(struct soap *soap, const struct _tse__FindRecordingsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__FindRecordingsResponse);
	if (soap_out__tse__FindRecordingsResponse(soap, tag?tag:"tse:FindRecordingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindRecordingsResponse * SOAP_FMAC4 soap_get__tse__FindRecordingsResponse(struct soap *soap, struct _tse__FindRecordingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindRecordingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__FindRecordings(struct soap *soap, struct _tse__FindRecordings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Scope = NULL;
	a->MaxMatches = NULL;
	soap_default_xsd__duration(soap, &a->KeepAliveTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__FindRecordings(struct soap *soap, const struct _tse__FindRecordings *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__SearchScope(soap, &a->Scope);
	soap_serialize_PointerToint(soap, &a->MaxMatches);
	soap_embedded(soap, &a->KeepAliveTime, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__FindRecordings(struct soap *soap, const char *tag, int id, const struct _tse__FindRecordings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__FindRecordings), type))
		return soap->error;
	if (a->Scope)
	{	if (soap_out_PointerTott__SearchScope(soap, "tse:Scope", -1, &a->Scope, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:Scope"))
		return soap->error;
	if (soap_out_PointerToint(soap, "tse:MaxMatches", -1, &a->MaxMatches, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tse:KeepAliveTime", -1, &a->KeepAliveTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__FindRecordings * SOAP_FMAC4 soap_in__tse__FindRecordings(struct soap *soap, const char *tag, struct _tse__FindRecordings *a, const char *type)
{
	size_t soap_flag_Scope = 1;
	size_t soap_flag_MaxMatches = 1;
	size_t soap_flag_KeepAliveTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__FindRecordings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__FindRecordings, sizeof(struct _tse__FindRecordings), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__FindRecordings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Scope && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SearchScope(soap, "tse:Scope", &a->Scope, "tt:SearchScope"))
				{	soap_flag_Scope--;
					continue;
				}
			if (soap_flag_MaxMatches && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToint(soap, "tse:MaxMatches", &a->MaxMatches, "xsd:int"))
				{	soap_flag_MaxMatches--;
					continue;
				}
			if (soap_flag_KeepAliveTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tse:KeepAliveTime", &a->KeepAliveTime, "xsd:duration"))
				{	soap_flag_KeepAliveTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__FindRecordings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__FindRecordings, 0, sizeof(struct _tse__FindRecordings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Scope > 0 || soap_flag_KeepAliveTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__FindRecordings(struct soap *soap, const struct _tse__FindRecordings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__FindRecordings);
	if (soap_out__tse__FindRecordings(soap, tag?tag:"tse:FindRecordings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__FindRecordings * SOAP_FMAC4 soap_get__tse__FindRecordings(struct soap *soap, struct _tse__FindRecordings *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__FindRecordings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetMediaAttributesResponse(struct soap *soap, struct _tse__GetMediaAttributesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeMediaAttributes = 0;
	a->MediaAttributes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetMediaAttributesResponse(struct soap *soap, const struct _tse__GetMediaAttributesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->MediaAttributes)
	{	int i;
		for (i = 0; i < a->__sizeMediaAttributes; i++)
		{
			soap_embedded(soap, a->MediaAttributes + i, SOAP_TYPE_tt__MediaAttributes);
			soap_serialize_tt__MediaAttributes(soap, a->MediaAttributes + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetMediaAttributesResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetMediaAttributesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetMediaAttributesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeMediaAttributes");
	if (a->MediaAttributes)
	{	int i;
		for (i = 0; i < a->__sizeMediaAttributes; i++)
			if (soap_out_tt__MediaAttributes(soap, "tse:MediaAttributes", -1, a->MediaAttributes + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetMediaAttributesResponse * SOAP_FMAC4 soap_in__tse__GetMediaAttributesResponse(struct soap *soap, const char *tag, struct _tse__GetMediaAttributesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_MediaAttributes = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetMediaAttributesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetMediaAttributesResponse, sizeof(struct _tse__GetMediaAttributesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetMediaAttributesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tse:MediaAttributes", 1, NULL))
			{	if (a->MediaAttributes == NULL)
				{	if (soap_blist_MediaAttributes == NULL)
						soap_blist_MediaAttributes = soap_new_block(soap);
					a->MediaAttributes = (struct tt__MediaAttributes *)soap_push_block(soap, soap_blist_MediaAttributes, sizeof(struct tt__MediaAttributes));
					if (a->MediaAttributes == NULL)
						return NULL;
					soap_default_tt__MediaAttributes(soap, a->MediaAttributes);
				}
				soap_revert(soap);
				if (soap_in_tt__MediaAttributes(soap, "tse:MediaAttributes", a->MediaAttributes, "tt:MediaAttributes"))
				{	a->__sizeMediaAttributes++;
					a->MediaAttributes = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeMediaAttributes");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->MediaAttributes)
			soap_pop_block(soap, soap_blist_MediaAttributes);
		if (a->__sizeMediaAttributes)
			a->MediaAttributes = (struct tt__MediaAttributes *)soap_save_block(soap, soap_blist_MediaAttributes, NULL, 1);
		else
		{	a->MediaAttributes = NULL;
			if (soap_blist_MediaAttributes)
				soap_end_block(soap, soap_blist_MediaAttributes);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetMediaAttributesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetMediaAttributesResponse, 0, sizeof(struct _tse__GetMediaAttributesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetMediaAttributesResponse(struct soap *soap, const struct _tse__GetMediaAttributesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__GetMediaAttributesResponse);
	if (soap_out__tse__GetMediaAttributesResponse(soap, tag?tag:"tse:GetMediaAttributesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMediaAttributesResponse * SOAP_FMAC4 soap_get__tse__GetMediaAttributesResponse(struct soap *soap, struct _tse__GetMediaAttributesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetMediaAttributesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetMediaAttributes(struct soap *soap, struct _tse__GetMediaAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRecordingTokens = 0;
	a->RecordingTokens = NULL;
	soap_default_time(soap, &a->Time);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetMediaAttributes(struct soap *soap, const struct _tse__GetMediaAttributes *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->RecordingTokens)
	{	int i;
		for (i = 0; i < a->__sizeRecordingTokens; i++)
		{
			soap_serialize_tt__RecordingReference(soap, a->RecordingTokens + i);
		}
	}
	soap_embedded(soap, &a->Time, SOAP_TYPE_time);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetMediaAttributes(struct soap *soap, const char *tag, int id, const struct _tse__GetMediaAttributes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetMediaAttributes), type))
		return soap->error;
	if (a->RecordingTokens)
	{	int i;
		for (i = 0; i < a->__sizeRecordingTokens; i++)
			if (soap_out_tt__RecordingReference(soap, "tse:RecordingTokens", -1, a->RecordingTokens + i, ""))
				return soap->error;
	}
	if (soap_out_time(soap, "tse:Time", -1, &a->Time, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetMediaAttributes * SOAP_FMAC4 soap_in__tse__GetMediaAttributes(struct soap *soap, const char *tag, struct _tse__GetMediaAttributes *a, const char *type)
{
	struct soap_blist *soap_blist_RecordingTokens = NULL;
	size_t soap_flag_Time = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetMediaAttributes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetMediaAttributes, sizeof(struct _tse__GetMediaAttributes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetMediaAttributes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tse:RecordingTokens", 1, NULL))
			{	if (a->RecordingTokens == NULL)
				{	if (soap_blist_RecordingTokens == NULL)
						soap_blist_RecordingTokens = soap_new_block(soap);
					a->RecordingTokens = (char **)soap_push_block(soap, soap_blist_RecordingTokens, sizeof(char *));
					if (a->RecordingTokens == NULL)
						return NULL;
					*a->RecordingTokens = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__RecordingReference(soap, "tse:RecordingTokens", a->RecordingTokens, "tt:RecordingReference"))
				{	a->__sizeRecordingTokens++;
					a->RecordingTokens = NULL;
					continue;
				}
			}
			if (soap_flag_Time && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tse:Time", &a->Time, "xsd:dateTime"))
				{	soap_flag_Time--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RecordingTokens)
			soap_pop_block(soap, soap_blist_RecordingTokens);
		if (a->__sizeRecordingTokens)
			a->RecordingTokens = (char **)soap_save_block(soap, soap_blist_RecordingTokens, NULL, 1);
		else
		{	a->RecordingTokens = NULL;
			if (soap_blist_RecordingTokens)
				soap_end_block(soap, soap_blist_RecordingTokens);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetMediaAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetMediaAttributes, 0, sizeof(struct _tse__GetMediaAttributes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Time > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetMediaAttributes(struct soap *soap, const struct _tse__GetMediaAttributes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__GetMediaAttributes);
	if (soap_out__tse__GetMediaAttributes(soap, tag?tag:"tse:GetMediaAttributes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetMediaAttributes * SOAP_FMAC4 soap_get__tse__GetMediaAttributes(struct soap *soap, struct _tse__GetMediaAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetMediaAttributes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetRecordingInformationResponse(struct soap *soap, struct _tse__GetRecordingInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RecordingInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetRecordingInformationResponse(struct soap *soap, const struct _tse__GetRecordingInformationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__RecordingInformation(soap, &a->RecordingInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetRecordingInformationResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetRecordingInformationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetRecordingInformationResponse), type))
		return soap->error;
	if (a->RecordingInformation)
		soap_element_result(soap, "tse:RecordingInformation");
	if (a->RecordingInformation)
	{	if (soap_out_PointerTott__RecordingInformation(soap, "tse:RecordingInformation", -1, &a->RecordingInformation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:RecordingInformation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetRecordingInformationResponse * SOAP_FMAC4 soap_in__tse__GetRecordingInformationResponse(struct soap *soap, const char *tag, struct _tse__GetRecordingInformationResponse *a, const char *type)
{
	size_t soap_flag_RecordingInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetRecordingInformationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingInformationResponse, sizeof(struct _tse__GetRecordingInformationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetRecordingInformationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingInformation(soap, "tse:RecordingInformation", &a->RecordingInformation, "tt:RecordingInformation"))
				{	soap_flag_RecordingInformation--;
					continue;
				}
			soap_check_result(soap, "tse:RecordingInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingInformationResponse, 0, sizeof(struct _tse__GetRecordingInformationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingInformation > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetRecordingInformationResponse(struct soap *soap, const struct _tse__GetRecordingInformationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__GetRecordingInformationResponse);
	if (soap_out__tse__GetRecordingInformationResponse(soap, tag?tag:"tse:GetRecordingInformationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingInformationResponse * SOAP_FMAC4 soap_get__tse__GetRecordingInformationResponse(struct soap *soap, struct _tse__GetRecordingInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetRecordingInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetRecordingInformation(struct soap *soap, struct _tse__GetRecordingInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetRecordingInformation(struct soap *soap, const struct _tse__GetRecordingInformation *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingReference(soap, &a->RecordingToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetRecordingInformation(struct soap *soap, const char *tag, int id, const struct _tse__GetRecordingInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetRecordingInformation), type))
		return soap->error;
	if (a->RecordingToken)
	{	if (soap_out_tt__RecordingReference(soap, "tse:RecordingToken", -1, &a->RecordingToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:RecordingToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetRecordingInformation * SOAP_FMAC4 soap_in__tse__GetRecordingInformation(struct soap *soap, const char *tag, struct _tse__GetRecordingInformation *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetRecordingInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingInformation, sizeof(struct _tse__GetRecordingInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetRecordingInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "tse:RecordingToken", &a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingInformation, 0, sizeof(struct _tse__GetRecordingInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetRecordingInformation(struct soap *soap, const struct _tse__GetRecordingInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__GetRecordingInformation);
	if (soap_out__tse__GetRecordingInformation(soap, tag?tag:"tse:GetRecordingInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingInformation * SOAP_FMAC4 soap_get__tse__GetRecordingInformation(struct soap *soap, struct _tse__GetRecordingInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetRecordingInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetRecordingSummaryResponse(struct soap *soap, struct _tse__GetRecordingSummaryResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Summary = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetRecordingSummaryResponse(struct soap *soap, const struct _tse__GetRecordingSummaryResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__RecordingSummary(soap, &a->Summary);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetRecordingSummaryResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetRecordingSummaryResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetRecordingSummaryResponse), type))
		return soap->error;
	if (a->Summary)
		soap_element_result(soap, "tse:Summary");
	if (a->Summary)
	{	if (soap_out_PointerTott__RecordingSummary(soap, "tse:Summary", -1, &a->Summary, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:Summary"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetRecordingSummaryResponse * SOAP_FMAC4 soap_in__tse__GetRecordingSummaryResponse(struct soap *soap, const char *tag, struct _tse__GetRecordingSummaryResponse *a, const char *type)
{
	size_t soap_flag_Summary = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetRecordingSummaryResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingSummaryResponse, sizeof(struct _tse__GetRecordingSummaryResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetRecordingSummaryResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Summary && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingSummary(soap, "tse:Summary", &a->Summary, "tt:RecordingSummary"))
				{	soap_flag_Summary--;
					continue;
				}
			soap_check_result(soap, "tse:Summary");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSummaryResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingSummaryResponse, 0, sizeof(struct _tse__GetRecordingSummaryResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Summary > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetRecordingSummaryResponse(struct soap *soap, const struct _tse__GetRecordingSummaryResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__GetRecordingSummaryResponse);
	if (soap_out__tse__GetRecordingSummaryResponse(soap, tag?tag:"tse:GetRecordingSummaryResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSummaryResponse * SOAP_FMAC4 soap_get__tse__GetRecordingSummaryResponse(struct soap *soap, struct _tse__GetRecordingSummaryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetRecordingSummaryResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetRecordingSummary(struct soap *soap, struct _tse__GetRecordingSummary *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetRecordingSummary(struct soap *soap, const struct _tse__GetRecordingSummary *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetRecordingSummary(struct soap *soap, const char *tag, int id, const struct _tse__GetRecordingSummary *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetRecordingSummary), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetRecordingSummary * SOAP_FMAC4 soap_in__tse__GetRecordingSummary(struct soap *soap, const char *tag, struct _tse__GetRecordingSummary *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetRecordingSummary *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetRecordingSummary, sizeof(struct _tse__GetRecordingSummary), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetRecordingSummary(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetRecordingSummary *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetRecordingSummary, 0, sizeof(struct _tse__GetRecordingSummary), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetRecordingSummary(struct soap *soap, const struct _tse__GetRecordingSummary *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__GetRecordingSummary);
	if (soap_out__tse__GetRecordingSummary(soap, tag?tag:"tse:GetRecordingSummary", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetRecordingSummary * SOAP_FMAC4 soap_get__tse__GetRecordingSummary(struct soap *soap, struct _tse__GetRecordingSummary *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetRecordingSummary(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetServiceCapabilitiesResponse(struct soap *soap, struct _tse__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tse__GetServiceCapabilitiesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotse__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tse__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tse:Capabilities");
	if (a->Capabilities)
	{	if (soap_out_PointerTotse__Capabilities(soap, "tse:Capabilities", -1, &a->Capabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tse:Capabilities"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tse__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tse__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetServiceCapabilitiesResponse, sizeof(struct _tse__GetServiceCapabilitiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotse__Capabilities(soap, "tse:Capabilities", &a->Capabilities, "tse:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "tse:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetServiceCapabilitiesResponse, 0, sizeof(struct _tse__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tse__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__GetServiceCapabilitiesResponse);
	if (soap_out__tse__GetServiceCapabilitiesResponse(soap, tag?tag:"tse:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tse__GetServiceCapabilitiesResponse(struct soap *soap, struct _tse__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tse__GetServiceCapabilities(struct soap *soap, struct _tse__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tse__GetServiceCapabilities(struct soap *soap, const struct _tse__GetServiceCapabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tse__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tse__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tse__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilities * SOAP_FMAC4 soap_in__tse__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tse__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tse__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tse__GetServiceCapabilities, sizeof(struct _tse__GetServiceCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tse__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tse__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tse__GetServiceCapabilities, 0, sizeof(struct _tse__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tse__GetServiceCapabilities(struct soap *soap, const struct _tse__GetServiceCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tse__GetServiceCapabilities);
	if (soap_out__tse__GetServiceCapabilities(soap, tag?tag:"tse:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tse__GetServiceCapabilities * SOAP_FMAC4 soap_get__tse__GetServiceCapabilities(struct soap *soap, struct _tse__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tse__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tse__Capabilities(struct soap *soap, struct tse__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->MetadataSearch = NULL;
	a->GeneralStartEvents = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tse__Capabilities(struct soap *soap, const struct tse__Capabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tse__Capabilities(struct soap *soap, const char *tag, int id, const struct tse__Capabilities *a, const char *type)
{
	if (a->MetadataSearch)
		soap_set_attr(soap, "MetadataSearch", soap_xsd__boolean2s(soap, *a->MetadataSearch), 1);
	if (a->GeneralStartEvents)
		soap_set_attr(soap, "GeneralStartEvents", soap_xsd__boolean2s(soap, *a->GeneralStartEvents), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tse__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tse__Capabilities * SOAP_FMAC4 soap_in_tse__Capabilities(struct soap *soap, const char *tag, struct tse__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tse__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tse__Capabilities, sizeof(struct tse__Capabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tse__Capabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "MetadataSearch", 0);
		if (t)
		{
			if (!(a->MetadataSearch = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->MetadataSearch))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "GeneralStartEvents", 0);
		if (t)
		{
			if (!(a->GeneralStartEvents = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->GeneralStartEvents))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tse__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tse__Capabilities, 0, sizeof(struct tse__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tse__Capabilities(struct soap *soap, const struct tse__Capabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tse__Capabilities);
	if (soap_out_tse__Capabilities(soap, tag?tag:"tse:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tse__Capabilities * SOAP_FMAC4 soap_get_tse__Capabilities(struct soap *soap, struct tse__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tse__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__GetReplayConfigurationResponse(struct soap *soap, struct _trp__GetReplayConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__GetReplayConfigurationResponse(struct soap *soap, const struct _trp__GetReplayConfigurationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ReplayConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__GetReplayConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trp__GetReplayConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__GetReplayConfigurationResponse), type))
		return soap->error;
	if (a->Configuration)
		soap_element_result(soap, "trp:Configuration");
	if (a->Configuration)
	{	if (soap_out_PointerTott__ReplayConfiguration(soap, "trp:Configuration", -1, &a->Configuration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trp:Configuration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__GetReplayConfigurationResponse * SOAP_FMAC4 soap_in__trp__GetReplayConfigurationResponse(struct soap *soap, const char *tag, struct _trp__GetReplayConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trp__GetReplayConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetReplayConfigurationResponse, sizeof(struct _trp__GetReplayConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__GetReplayConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ReplayConfiguration(soap, "trp:Configuration", &a->Configuration, "tt:ReplayConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			soap_check_result(soap, "trp:Configuration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trp__GetReplayConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetReplayConfigurationResponse, 0, sizeof(struct _trp__GetReplayConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__GetReplayConfigurationResponse(struct soap *soap, const struct _trp__GetReplayConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trp__GetReplayConfigurationResponse);
	if (soap_out__trp__GetReplayConfigurationResponse(soap, tag?tag:"trp:GetReplayConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetReplayConfigurationResponse * SOAP_FMAC4 soap_get__trp__GetReplayConfigurationResponse(struct soap *soap, struct _trp__GetReplayConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__GetReplayConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__GetReplayConfiguration(struct soap *soap, struct _trp__GetReplayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__GetReplayConfiguration(struct soap *soap, const struct _trp__GetReplayConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__GetReplayConfiguration(struct soap *soap, const char *tag, int id, const struct _trp__GetReplayConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__GetReplayConfiguration), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__GetReplayConfiguration * SOAP_FMAC4 soap_in__trp__GetReplayConfiguration(struct soap *soap, const char *tag, struct _trp__GetReplayConfiguration *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trp__GetReplayConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetReplayConfiguration, sizeof(struct _trp__GetReplayConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__GetReplayConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trp__GetReplayConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetReplayConfiguration, 0, sizeof(struct _trp__GetReplayConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__GetReplayConfiguration(struct soap *soap, const struct _trp__GetReplayConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trp__GetReplayConfiguration);
	if (soap_out__trp__GetReplayConfiguration(soap, tag?tag:"trp:GetReplayConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetReplayConfiguration * SOAP_FMAC4 soap_get__trp__GetReplayConfiguration(struct soap *soap, struct _trp__GetReplayConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__GetReplayConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__SetReplayConfigurationResponse(struct soap *soap, struct _trp__SetReplayConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__SetReplayConfigurationResponse(struct soap *soap, const struct _trp__SetReplayConfigurationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__SetReplayConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trp__SetReplayConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__SetReplayConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__SetReplayConfigurationResponse * SOAP_FMAC4 soap_in__trp__SetReplayConfigurationResponse(struct soap *soap, const char *tag, struct _trp__SetReplayConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trp__SetReplayConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__SetReplayConfigurationResponse, sizeof(struct _trp__SetReplayConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__SetReplayConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trp__SetReplayConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__SetReplayConfigurationResponse, 0, sizeof(struct _trp__SetReplayConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__SetReplayConfigurationResponse(struct soap *soap, const struct _trp__SetReplayConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trp__SetReplayConfigurationResponse);
	if (soap_out__trp__SetReplayConfigurationResponse(soap, tag?tag:"trp:SetReplayConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__SetReplayConfigurationResponse * SOAP_FMAC4 soap_get__trp__SetReplayConfigurationResponse(struct soap *soap, struct _trp__SetReplayConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__SetReplayConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__SetReplayConfiguration(struct soap *soap, struct _trp__SetReplayConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__SetReplayConfiguration(struct soap *soap, const struct _trp__SetReplayConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ReplayConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__SetReplayConfiguration(struct soap *soap, const char *tag, int id, const struct _trp__SetReplayConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__SetReplayConfiguration), type))
		return soap->error;
	if (a->Configuration)
	{	if (soap_out_PointerTott__ReplayConfiguration(soap, "trp:Configuration", -1, &a->Configuration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trp:Configuration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__SetReplayConfiguration * SOAP_FMAC4 soap_in__trp__SetReplayConfiguration(struct soap *soap, const char *tag, struct _trp__SetReplayConfiguration *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trp__SetReplayConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__SetReplayConfiguration, sizeof(struct _trp__SetReplayConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__SetReplayConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ReplayConfiguration(soap, "trp:Configuration", &a->Configuration, "tt:ReplayConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trp__SetReplayConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__SetReplayConfiguration, 0, sizeof(struct _trp__SetReplayConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__SetReplayConfiguration(struct soap *soap, const struct _trp__SetReplayConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trp__SetReplayConfiguration);
	if (soap_out__trp__SetReplayConfiguration(soap, tag?tag:"trp:SetReplayConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__SetReplayConfiguration * SOAP_FMAC4 soap_get__trp__SetReplayConfiguration(struct soap *soap, struct _trp__SetReplayConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__SetReplayConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__GetReplayUriResponse(struct soap *soap, struct _trp__GetReplayUriResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->Uri);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__GetReplayUriResponse(struct soap *soap, const struct _trp__GetReplayUriResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->Uri);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__GetReplayUriResponse(struct soap *soap, const char *tag, int id, const struct _trp__GetReplayUriResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__GetReplayUriResponse), type))
		return soap->error;
	if (a->Uri)
		soap_element_result(soap, "trp:Uri");
	if (a->Uri)
	{	if (soap_out_xsd__anyURI(soap, "trp:Uri", -1, &a->Uri, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trp:Uri"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__GetReplayUriResponse * SOAP_FMAC4 soap_in__trp__GetReplayUriResponse(struct soap *soap, const char *tag, struct _trp__GetReplayUriResponse *a, const char *type)
{
	size_t soap_flag_Uri = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trp__GetReplayUriResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetReplayUriResponse, sizeof(struct _trp__GetReplayUriResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__GetReplayUriResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Uri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "trp:Uri", &a->Uri, "xsd:anyURI"))
				{	soap_flag_Uri--;
					continue;
				}
			soap_check_result(soap, "trp:Uri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trp__GetReplayUriResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetReplayUriResponse, 0, sizeof(struct _trp__GetReplayUriResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Uri > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__GetReplayUriResponse(struct soap *soap, const struct _trp__GetReplayUriResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trp__GetReplayUriResponse);
	if (soap_out__trp__GetReplayUriResponse(soap, tag?tag:"trp:GetReplayUriResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetReplayUriResponse * SOAP_FMAC4 soap_get__trp__GetReplayUriResponse(struct soap *soap, struct _trp__GetReplayUriResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__GetReplayUriResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__GetReplayUri(struct soap *soap, struct _trp__GetReplayUri *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->StreamSetup = NULL;
	soap_default_tt__ReferenceToken(soap, &a->RecordingToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__GetReplayUri(struct soap *soap, const struct _trp__GetReplayUri *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__StreamSetup(soap, &a->StreamSetup);
	soap_serialize_tt__ReferenceToken(soap, &a->RecordingToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__GetReplayUri(struct soap *soap, const char *tag, int id, const struct _trp__GetReplayUri *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__GetReplayUri), type))
		return soap->error;
	if (a->StreamSetup)
	{	if (soap_out_PointerTott__StreamSetup(soap, "trp:StreamSetup", -1, &a->StreamSetup, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trp:StreamSetup"))
		return soap->error;
	if (a->RecordingToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trp:RecordingToken", -1, &a->RecordingToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trp:RecordingToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__GetReplayUri * SOAP_FMAC4 soap_in__trp__GetReplayUri(struct soap *soap, const char *tag, struct _trp__GetReplayUri *a, const char *type)
{
	size_t soap_flag_StreamSetup = 1;
	size_t soap_flag_RecordingToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trp__GetReplayUri *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetReplayUri, sizeof(struct _trp__GetReplayUri), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__GetReplayUri(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_StreamSetup && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__StreamSetup(soap, "trp:StreamSetup", &a->StreamSetup, "tt:StreamSetup"))
				{	soap_flag_StreamSetup--;
					continue;
				}
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trp:RecordingToken", &a->RecordingToken, "tt:ReferenceToken"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trp__GetReplayUri *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetReplayUri, 0, sizeof(struct _trp__GetReplayUri), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_StreamSetup > 0 || soap_flag_RecordingToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__GetReplayUri(struct soap *soap, const struct _trp__GetReplayUri *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trp__GetReplayUri);
	if (soap_out__trp__GetReplayUri(soap, tag?tag:"trp:GetReplayUri", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetReplayUri * SOAP_FMAC4 soap_get__trp__GetReplayUri(struct soap *soap, struct _trp__GetReplayUri *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__GetReplayUri(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__GetServiceCapabilitiesResponse(struct soap *soap, struct _trp__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trp__GetServiceCapabilitiesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotrp__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _trp__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "trp:Capabilities");
	if (a->Capabilities)
	{	if (soap_out_PointerTotrp__Capabilities(soap, "trp:Capabilities", -1, &a->Capabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trp:Capabilities"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__trp__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trp__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trp__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetServiceCapabilitiesResponse, sizeof(struct _trp__GetServiceCapabilitiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotrp__Capabilities(soap, "trp:Capabilities", &a->Capabilities, "trp:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "trp:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trp__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetServiceCapabilitiesResponse, 0, sizeof(struct _trp__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trp__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trp__GetServiceCapabilitiesResponse);
	if (soap_out__trp__GetServiceCapabilitiesResponse(soap, tag?tag:"trp:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__trp__GetServiceCapabilitiesResponse(struct soap *soap, struct _trp__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trp__GetServiceCapabilities(struct soap *soap, struct _trp__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trp__GetServiceCapabilities(struct soap *soap, const struct _trp__GetServiceCapabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trp__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _trp__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trp__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trp__GetServiceCapabilities * SOAP_FMAC4 soap_in__trp__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trp__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trp__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trp__GetServiceCapabilities, sizeof(struct _trp__GetServiceCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trp__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trp__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trp__GetServiceCapabilities, 0, sizeof(struct _trp__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trp__GetServiceCapabilities(struct soap *soap, const struct _trp__GetServiceCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trp__GetServiceCapabilities);
	if (soap_out__trp__GetServiceCapabilities(soap, tag?tag:"trp:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trp__GetServiceCapabilities * SOAP_FMAC4 soap_get__trp__GetServiceCapabilities(struct soap *soap, struct _trp__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__trp__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trp__Capabilities(struct soap *soap, struct trp__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->ReversePlayback = (enum xsd__boolean)0;
	soap_default_tt__FloatAttrList(soap, &a->SessionTimeoutRange);
	a->RTP_USCORERTSP_USCORETCP = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trp__Capabilities(struct soap *soap, const struct trp__Capabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trp__Capabilities(struct soap *soap, const char *tag, int id, const struct trp__Capabilities *a, const char *type)
{
	soap_set_attr(soap, "ReversePlayback", soap_xsd__boolean2s(soap, a->ReversePlayback), 1);
	if (a->SessionTimeoutRange)
		soap_set_attr(soap, "SessionTimeoutRange", a->SessionTimeoutRange, 1);
	if (a->RTP_USCORERTSP_USCORETCP)
		soap_set_attr(soap, "RTP_RTSP_TCP", soap_xsd__boolean2s(soap, *a->RTP_USCORERTSP_USCORETCP), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trp__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trp__Capabilities * SOAP_FMAC4 soap_in_trp__Capabilities(struct soap *soap, const char *tag, struct trp__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trp__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trp__Capabilities, sizeof(struct trp__Capabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trp__Capabilities(soap, a);
	if (soap_s2xsd__boolean(soap, soap_attr_value(soap, "ReversePlayback", 0), &a->ReversePlayback))
		return NULL;
	if (soap_s2string(soap, soap_attr_value(soap, "SessionTimeoutRange", 0), &a->SessionTimeoutRange, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "RTP_RTSP_TCP", 0);
		if (t)
		{
			if (!(a->RTP_USCORERTSP_USCORETCP = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RTP_USCORERTSP_USCORETCP))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trp__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trp__Capabilities, 0, sizeof(struct trp__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trp__Capabilities(struct soap *soap, const struct trp__Capabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trp__Capabilities);
	if (soap_out_trp__Capabilities(soap, tag?tag:"trp:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trp__Capabilities * SOAP_FMAC4 soap_get_trp__Capabilities(struct soap *soap, struct trp__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_trp__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingOptionsResponse(struct soap *soap, struct _trc__GetRecordingOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingOptionsResponse(struct soap *soap, const struct _trc__GetRecordingOptionsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotrc__RecordingOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingOptionsResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "trc:Options");
	if (a->Options)
	{	if (soap_out_PointerTotrc__RecordingOptions(soap, "trc:Options", -1, &a->Options, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:Options"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingOptionsResponse * SOAP_FMAC4 soap_in__trc__GetRecordingOptionsResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingOptionsResponse, sizeof(struct _trc__GetRecordingOptionsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotrc__RecordingOptions(soap, "trc:Options", &a->Options, "trc:RecordingOptions"))
				{	soap_flag_Options--;
					continue;
				}
			soap_check_result(soap, "trc:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingOptionsResponse, 0, sizeof(struct _trc__GetRecordingOptionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Options > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingOptionsResponse(struct soap *soap, const struct _trc__GetRecordingOptionsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__GetRecordingOptionsResponse);
	if (soap_out__trc__GetRecordingOptionsResponse(soap, tag?tag:"trc:GetRecordingOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingOptionsResponse * SOAP_FMAC4 soap_get__trc__GetRecordingOptionsResponse(struct soap *soap, struct _trc__GetRecordingOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingOptions(struct soap *soap, struct _trc__GetRecordingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingOptions(struct soap *soap, const struct _trc__GetRecordingOptions *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingReference(soap, &a->RecordingToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingOptions(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingOptions), type))
		return soap->error;
	if (a->RecordingToken)
	{	if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, &a->RecordingToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:RecordingToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingOptions * SOAP_FMAC4 soap_in__trc__GetRecordingOptions(struct soap *soap, const char *tag, struct _trc__GetRecordingOptions *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingOptions, sizeof(struct _trc__GetRecordingOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", &a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingOptions, 0, sizeof(struct _trc__GetRecordingOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingOptions(struct soap *soap, const struct _trc__GetRecordingOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__GetRecordingOptions);
	if (soap_out__trc__GetRecordingOptions(soap, tag?tag:"trc:GetRecordingOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingOptions * SOAP_FMAC4 soap_get__trc__GetRecordingOptions(struct soap *soap, struct _trc__GetRecordingOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingJobStateResponse(struct soap *soap, struct _trc__GetRecordingJobStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->State = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingJobStateResponse(struct soap *soap, const struct _trc__GetRecordingJobStateResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__RecordingJobStateInformation(soap, &a->State);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingJobStateResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingJobStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingJobStateResponse), type))
		return soap->error;
	if (a->State)
		soap_element_result(soap, "trc:State");
	if (a->State)
	{	if (soap_out_PointerTott__RecordingJobStateInformation(soap, "trc:State", -1, &a->State, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:State"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingJobStateResponse * SOAP_FMAC4 soap_in__trc__GetRecordingJobStateResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingJobStateResponse *a, const char *type)
{
	size_t soap_flag_State = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingJobStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobStateResponse, sizeof(struct _trc__GetRecordingJobStateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingJobStateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_State && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobStateInformation(soap, "trc:State", &a->State, "tt:RecordingJobStateInformation"))
				{	soap_flag_State--;
					continue;
				}
			soap_check_result(soap, "trc:State");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobStateResponse, 0, sizeof(struct _trc__GetRecordingJobStateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_State > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingJobStateResponse(struct soap *soap, const struct _trc__GetRecordingJobStateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__GetRecordingJobStateResponse);
	if (soap_out__trc__GetRecordingJobStateResponse(soap, tag?tag:"trc:GetRecordingJobStateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobStateResponse * SOAP_FMAC4 soap_get__trc__GetRecordingJobStateResponse(struct soap *soap, struct _trc__GetRecordingJobStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingJobStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingJobState(struct soap *soap, struct _trc__GetRecordingJobState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingJobState(struct soap *soap, const struct _trc__GetRecordingJobState *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingJobReference(soap, &a->JobToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingJobState(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingJobState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingJobState), type))
		return soap->error;
	if (a->JobToken)
	{	if (soap_out_tt__RecordingJobReference(soap, "trc:JobToken", -1, &a->JobToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:JobToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingJobState * SOAP_FMAC4 soap_in__trc__GetRecordingJobState(struct soap *soap, const char *tag, struct _trc__GetRecordingJobState *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingJobState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobState, sizeof(struct _trc__GetRecordingJobState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingJobState(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobReference(soap, "trc:JobToken", &a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobState, 0, sizeof(struct _trc__GetRecordingJobState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingJobState(struct soap *soap, const struct _trc__GetRecordingJobState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__GetRecordingJobState);
	if (soap_out__trc__GetRecordingJobState(soap, tag?tag:"trc:GetRecordingJobState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobState * SOAP_FMAC4 soap_get__trc__GetRecordingJobState(struct soap *soap, struct _trc__GetRecordingJobState *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingJobState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetRecordingJobModeResponse(struct soap *soap, struct _trc__SetRecordingJobModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetRecordingJobModeResponse(struct soap *soap, const struct _trc__SetRecordingJobModeResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetRecordingJobModeResponse(struct soap *soap, const char *tag, int id, const struct _trc__SetRecordingJobModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetRecordingJobModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetRecordingJobModeResponse * SOAP_FMAC4 soap_in__trc__SetRecordingJobModeResponse(struct soap *soap, const char *tag, struct _trc__SetRecordingJobModeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__SetRecordingJobModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingJobModeResponse, sizeof(struct _trc__SetRecordingJobModeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetRecordingJobModeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingJobModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingJobModeResponse, 0, sizeof(struct _trc__SetRecordingJobModeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetRecordingJobModeResponse(struct soap *soap, const struct _trc__SetRecordingJobModeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__SetRecordingJobModeResponse);
	if (soap_out__trc__SetRecordingJobModeResponse(soap, tag?tag:"trc:SetRecordingJobModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingJobModeResponse * SOAP_FMAC4 soap_get__trc__SetRecordingJobModeResponse(struct soap *soap, struct _trc__SetRecordingJobModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetRecordingJobModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetRecordingJobMode(struct soap *soap, struct _trc__SetRecordingJobMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
	soap_default_tt__RecordingJobMode(soap, &a->Mode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetRecordingJobMode(struct soap *soap, const struct _trc__SetRecordingJobMode *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingJobReference(soap, &a->JobToken);
	soap_serialize_tt__RecordingJobMode(soap, &a->Mode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetRecordingJobMode(struct soap *soap, const char *tag, int id, const struct _trc__SetRecordingJobMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetRecordingJobMode), type))
		return soap->error;
	if (a->JobToken)
	{	if (soap_out_tt__RecordingJobReference(soap, "trc:JobToken", -1, &a->JobToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:JobToken"))
		return soap->error;
	if (a->Mode)
	{	if (soap_out_tt__RecordingJobMode(soap, "trc:Mode", -1, &a->Mode, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:Mode"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetRecordingJobMode * SOAP_FMAC4 soap_in__trc__SetRecordingJobMode(struct soap *soap, const char *tag, struct _trc__SetRecordingJobMode *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	size_t soap_flag_Mode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__SetRecordingJobMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingJobMode, sizeof(struct _trc__SetRecordingJobMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetRecordingJobMode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobReference(soap, "trc:JobToken", &a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			if (soap_flag_Mode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobMode(soap, "trc:Mode", &a->Mode, "tt:RecordingJobMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingJobMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingJobMode, 0, sizeof(struct _trc__SetRecordingJobMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobToken > 0 || soap_flag_Mode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetRecordingJobMode(struct soap *soap, const struct _trc__SetRecordingJobMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__SetRecordingJobMode);
	if (soap_out__trc__SetRecordingJobMode(soap, tag?tag:"trc:SetRecordingJobMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingJobMode * SOAP_FMAC4 soap_get__trc__SetRecordingJobMode(struct soap *soap, struct _trc__SetRecordingJobMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetRecordingJobMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingJobConfigurationResponse(struct soap *soap, struct _trc__GetRecordingJobConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingJobConfigurationResponse(struct soap *soap, const struct _trc__GetRecordingJobConfigurationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__RecordingJobConfiguration(soap, &a->JobConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingJobConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingJobConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingJobConfigurationResponse), type))
		return soap->error;
	if (a->JobConfiguration)
		soap_element_result(soap, "trc:JobConfiguration");
	if (a->JobConfiguration)
	{	if (soap_out_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", -1, &a->JobConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:JobConfiguration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfigurationResponse * SOAP_FMAC4 soap_in__trc__GetRecordingJobConfigurationResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingJobConfigurationResponse *a, const char *type)
{
	size_t soap_flag_JobConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingJobConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobConfigurationResponse, sizeof(struct _trc__GetRecordingJobConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingJobConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", &a->JobConfiguration, "tt:RecordingJobConfiguration"))
				{	soap_flag_JobConfiguration--;
					continue;
				}
			soap_check_result(soap, "trc:JobConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobConfigurationResponse, 0, sizeof(struct _trc__GetRecordingJobConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingJobConfigurationResponse(struct soap *soap, const struct _trc__GetRecordingJobConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__GetRecordingJobConfigurationResponse);
	if (soap_out__trc__GetRecordingJobConfigurationResponse(soap, tag?tag:"trc:GetRecordingJobConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfigurationResponse * SOAP_FMAC4 soap_get__trc__GetRecordingJobConfigurationResponse(struct soap *soap, struct _trc__GetRecordingJobConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingJobConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingJobConfiguration(struct soap *soap, struct _trc__GetRecordingJobConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingJobConfiguration(struct soap *soap, const struct _trc__GetRecordingJobConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingJobReference(soap, &a->JobToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingJobConfiguration(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingJobConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingJobConfiguration), type))
		return soap->error;
	if (a->JobToken)
	{	if (soap_out_tt__RecordingJobReference(soap, "trc:JobToken", -1, &a->JobToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:JobToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfiguration * SOAP_FMAC4 soap_in__trc__GetRecordingJobConfiguration(struct soap *soap, const char *tag, struct _trc__GetRecordingJobConfiguration *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingJobConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobConfiguration, sizeof(struct _trc__GetRecordingJobConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingJobConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobReference(soap, "trc:JobToken", &a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobConfiguration, 0, sizeof(struct _trc__GetRecordingJobConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingJobConfiguration(struct soap *soap, const struct _trc__GetRecordingJobConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__GetRecordingJobConfiguration);
	if (soap_out__trc__GetRecordingJobConfiguration(soap, tag?tag:"trc:GetRecordingJobConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobConfiguration * SOAP_FMAC4 soap_get__trc__GetRecordingJobConfiguration(struct soap *soap, struct _trc__GetRecordingJobConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingJobConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetRecordingJobConfigurationResponse(struct soap *soap, struct _trc__SetRecordingJobConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetRecordingJobConfigurationResponse(struct soap *soap, const struct _trc__SetRecordingJobConfigurationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__RecordingJobConfiguration(soap, &a->JobConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetRecordingJobConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trc__SetRecordingJobConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetRecordingJobConfigurationResponse), type))
		return soap->error;
	if (a->JobConfiguration)
		soap_element_result(soap, "trc:JobConfiguration");
	if (a->JobConfiguration)
	{	if (soap_out_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", -1, &a->JobConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:JobConfiguration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfigurationResponse * SOAP_FMAC4 soap_in__trc__SetRecordingJobConfigurationResponse(struct soap *soap, const char *tag, struct _trc__SetRecordingJobConfigurationResponse *a, const char *type)
{
	size_t soap_flag_JobConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__SetRecordingJobConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingJobConfigurationResponse, sizeof(struct _trc__SetRecordingJobConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetRecordingJobConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", &a->JobConfiguration, "tt:RecordingJobConfiguration"))
				{	soap_flag_JobConfiguration--;
					continue;
				}
			soap_check_result(soap, "trc:JobConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingJobConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingJobConfigurationResponse, 0, sizeof(struct _trc__SetRecordingJobConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetRecordingJobConfigurationResponse(struct soap *soap, const struct _trc__SetRecordingJobConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__SetRecordingJobConfigurationResponse);
	if (soap_out__trc__SetRecordingJobConfigurationResponse(soap, tag?tag:"trc:SetRecordingJobConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfigurationResponse * SOAP_FMAC4 soap_get__trc__SetRecordingJobConfigurationResponse(struct soap *soap, struct _trc__SetRecordingJobConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetRecordingJobConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetRecordingJobConfiguration(struct soap *soap, struct _trc__SetRecordingJobConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
	a->JobConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetRecordingJobConfiguration(struct soap *soap, const struct _trc__SetRecordingJobConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingJobReference(soap, &a->JobToken);
	soap_serialize_PointerTott__RecordingJobConfiguration(soap, &a->JobConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetRecordingJobConfiguration(struct soap *soap, const char *tag, int id, const struct _trc__SetRecordingJobConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetRecordingJobConfiguration), type))
		return soap->error;
	if (a->JobToken)
	{	if (soap_out_tt__RecordingJobReference(soap, "trc:JobToken", -1, &a->JobToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:JobToken"))
		return soap->error;
	if (a->JobConfiguration)
	{	if (soap_out_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", -1, &a->JobConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:JobConfiguration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfiguration * SOAP_FMAC4 soap_in__trc__SetRecordingJobConfiguration(struct soap *soap, const char *tag, struct _trc__SetRecordingJobConfiguration *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	size_t soap_flag_JobConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__SetRecordingJobConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingJobConfiguration, sizeof(struct _trc__SetRecordingJobConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetRecordingJobConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobReference(soap, "trc:JobToken", &a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", &a->JobConfiguration, "tt:RecordingJobConfiguration"))
				{	soap_flag_JobConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingJobConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingJobConfiguration, 0, sizeof(struct _trc__SetRecordingJobConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobToken > 0 || soap_flag_JobConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetRecordingJobConfiguration(struct soap *soap, const struct _trc__SetRecordingJobConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__SetRecordingJobConfiguration);
	if (soap_out__trc__SetRecordingJobConfiguration(soap, tag?tag:"trc:SetRecordingJobConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingJobConfiguration * SOAP_FMAC4 soap_get__trc__SetRecordingJobConfiguration(struct soap *soap, struct _trc__SetRecordingJobConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetRecordingJobConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingJobsResponse(struct soap *soap, struct _trc__GetRecordingJobsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeJobItem = 0;
	a->JobItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingJobsResponse(struct soap *soap, const struct _trc__GetRecordingJobsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->JobItem)
	{	int i;
		for (i = 0; i < a->__sizeJobItem; i++)
		{
			soap_embedded(soap, a->JobItem + i, SOAP_TYPE_tt__GetRecordingJobsResponseItem);
			soap_serialize_tt__GetRecordingJobsResponseItem(soap, a->JobItem + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingJobsResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingJobsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingJobsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeJobItem");
	if (a->JobItem)
	{	int i;
		for (i = 0; i < a->__sizeJobItem; i++)
			if (soap_out_tt__GetRecordingJobsResponseItem(soap, "trc:JobItem", -1, a->JobItem + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingJobsResponse * SOAP_FMAC4 soap_in__trc__GetRecordingJobsResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingJobsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_JobItem = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingJobsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobsResponse, sizeof(struct _trc__GetRecordingJobsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingJobsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trc:JobItem", 1, NULL))
			{	if (a->JobItem == NULL)
				{	if (soap_blist_JobItem == NULL)
						soap_blist_JobItem = soap_new_block(soap);
					a->JobItem = (struct tt__GetRecordingJobsResponseItem *)soap_push_block(soap, soap_blist_JobItem, sizeof(struct tt__GetRecordingJobsResponseItem));
					if (a->JobItem == NULL)
						return NULL;
					soap_default_tt__GetRecordingJobsResponseItem(soap, a->JobItem);
				}
				soap_revert(soap);
				if (soap_in_tt__GetRecordingJobsResponseItem(soap, "trc:JobItem", a->JobItem, "tt:GetRecordingJobsResponseItem"))
				{	a->__sizeJobItem++;
					a->JobItem = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeJobItem");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->JobItem)
			soap_pop_block(soap, soap_blist_JobItem);
		if (a->__sizeJobItem)
			a->JobItem = (struct tt__GetRecordingJobsResponseItem *)soap_save_block(soap, soap_blist_JobItem, NULL, 1);
		else
		{	a->JobItem = NULL;
			if (soap_blist_JobItem)
				soap_end_block(soap, soap_blist_JobItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobsResponse, 0, sizeof(struct _trc__GetRecordingJobsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingJobsResponse(struct soap *soap, const struct _trc__GetRecordingJobsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__GetRecordingJobsResponse);
	if (soap_out__trc__GetRecordingJobsResponse(soap, tag?tag:"trc:GetRecordingJobsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobsResponse * SOAP_FMAC4 soap_get__trc__GetRecordingJobsResponse(struct soap *soap, struct _trc__GetRecordingJobsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingJobsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingJobs(struct soap *soap, struct _trc__GetRecordingJobs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingJobs(struct soap *soap, const struct _trc__GetRecordingJobs *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingJobs(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingJobs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingJobs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingJobs * SOAP_FMAC4 soap_in__trc__GetRecordingJobs(struct soap *soap, const char *tag, struct _trc__GetRecordingJobs *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingJobs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingJobs, sizeof(struct _trc__GetRecordingJobs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingJobs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingJobs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingJobs, 0, sizeof(struct _trc__GetRecordingJobs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingJobs(struct soap *soap, const struct _trc__GetRecordingJobs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__GetRecordingJobs);
	if (soap_out__trc__GetRecordingJobs(soap, tag?tag:"trc:GetRecordingJobs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingJobs * SOAP_FMAC4 soap_get__trc__GetRecordingJobs(struct soap *soap, struct _trc__GetRecordingJobs *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingJobs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__DeleteRecordingJobResponse(struct soap *soap, struct _trc__DeleteRecordingJobResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__DeleteRecordingJobResponse(struct soap *soap, const struct _trc__DeleteRecordingJobResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__DeleteRecordingJobResponse(struct soap *soap, const char *tag, int id, const struct _trc__DeleteRecordingJobResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__DeleteRecordingJobResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__DeleteRecordingJobResponse * SOAP_FMAC4 soap_in__trc__DeleteRecordingJobResponse(struct soap *soap, const char *tag, struct _trc__DeleteRecordingJobResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__DeleteRecordingJobResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteRecordingJobResponse, sizeof(struct _trc__DeleteRecordingJobResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__DeleteRecordingJobResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteRecordingJobResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteRecordingJobResponse, 0, sizeof(struct _trc__DeleteRecordingJobResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__DeleteRecordingJobResponse(struct soap *soap, const struct _trc__DeleteRecordingJobResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__DeleteRecordingJobResponse);
	if (soap_out__trc__DeleteRecordingJobResponse(soap, tag?tag:"trc:DeleteRecordingJobResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteRecordingJobResponse * SOAP_FMAC4 soap_get__trc__DeleteRecordingJobResponse(struct soap *soap, struct _trc__DeleteRecordingJobResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__DeleteRecordingJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__DeleteRecordingJob(struct soap *soap, struct _trc__DeleteRecordingJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__DeleteRecordingJob(struct soap *soap, const struct _trc__DeleteRecordingJob *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingJobReference(soap, &a->JobToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__DeleteRecordingJob(struct soap *soap, const char *tag, int id, const struct _trc__DeleteRecordingJob *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__DeleteRecordingJob), type))
		return soap->error;
	if (a->JobToken)
	{	if (soap_out_tt__RecordingJobReference(soap, "trc:JobToken", -1, &a->JobToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:JobToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__DeleteRecordingJob * SOAP_FMAC4 soap_in__trc__DeleteRecordingJob(struct soap *soap, const char *tag, struct _trc__DeleteRecordingJob *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__DeleteRecordingJob *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteRecordingJob, sizeof(struct _trc__DeleteRecordingJob), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__DeleteRecordingJob(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobReference(soap, "trc:JobToken", &a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteRecordingJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteRecordingJob, 0, sizeof(struct _trc__DeleteRecordingJob), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__DeleteRecordingJob(struct soap *soap, const struct _trc__DeleteRecordingJob *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__DeleteRecordingJob);
	if (soap_out__trc__DeleteRecordingJob(soap, tag?tag:"trc:DeleteRecordingJob", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteRecordingJob * SOAP_FMAC4 soap_get__trc__DeleteRecordingJob(struct soap *soap, struct _trc__DeleteRecordingJob *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__DeleteRecordingJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__CreateRecordingJobResponse(struct soap *soap, struct _trc__CreateRecordingJobResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingJobReference(soap, &a->JobToken);
	a->JobConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__CreateRecordingJobResponse(struct soap *soap, const struct _trc__CreateRecordingJobResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingJobReference(soap, &a->JobToken);
	soap_serialize_PointerTott__RecordingJobConfiguration(soap, &a->JobConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__CreateRecordingJobResponse(struct soap *soap, const char *tag, int id, const struct _trc__CreateRecordingJobResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__CreateRecordingJobResponse), type))
		return soap->error;
	if (a->JobToken)
		soap_element_result(soap, "trc:JobToken");
	if (a->JobToken)
	{	if (soap_out_tt__RecordingJobReference(soap, "trc:JobToken", -1, &a->JobToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:JobToken"))
		return soap->error;
	if (a->JobConfiguration)
	{	if (soap_out_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", -1, &a->JobConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:JobConfiguration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__CreateRecordingJobResponse * SOAP_FMAC4 soap_in__trc__CreateRecordingJobResponse(struct soap *soap, const char *tag, struct _trc__CreateRecordingJobResponse *a, const char *type)
{
	size_t soap_flag_JobToken = 1;
	size_t soap_flag_JobConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__CreateRecordingJobResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateRecordingJobResponse, sizeof(struct _trc__CreateRecordingJobResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__CreateRecordingJobResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingJobReference(soap, "trc:JobToken", &a->JobToken, "tt:RecordingJobReference"))
				{	soap_flag_JobToken--;
					continue;
				}
			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", &a->JobConfiguration, "tt:RecordingJobConfiguration"))
				{	soap_flag_JobConfiguration--;
					continue;
				}
			soap_check_result(soap, "trc:JobToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__CreateRecordingJobResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateRecordingJobResponse, 0, sizeof(struct _trc__CreateRecordingJobResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobToken > 0 || soap_flag_JobConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__CreateRecordingJobResponse(struct soap *soap, const struct _trc__CreateRecordingJobResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__CreateRecordingJobResponse);
	if (soap_out__trc__CreateRecordingJobResponse(soap, tag?tag:"trc:CreateRecordingJobResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateRecordingJobResponse * SOAP_FMAC4 soap_get__trc__CreateRecordingJobResponse(struct soap *soap, struct _trc__CreateRecordingJobResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__CreateRecordingJobResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__CreateRecordingJob(struct soap *soap, struct _trc__CreateRecordingJob *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->JobConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__CreateRecordingJob(struct soap *soap, const struct _trc__CreateRecordingJob *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__RecordingJobConfiguration(soap, &a->JobConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__CreateRecordingJob(struct soap *soap, const char *tag, int id, const struct _trc__CreateRecordingJob *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__CreateRecordingJob), type))
		return soap->error;
	if (a->JobConfiguration)
	{	if (soap_out_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", -1, &a->JobConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:JobConfiguration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__CreateRecordingJob * SOAP_FMAC4 soap_in__trc__CreateRecordingJob(struct soap *soap, const char *tag, struct _trc__CreateRecordingJob *a, const char *type)
{
	size_t soap_flag_JobConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__CreateRecordingJob *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateRecordingJob, sizeof(struct _trc__CreateRecordingJob), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__CreateRecordingJob(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_JobConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingJobConfiguration(soap, "trc:JobConfiguration", &a->JobConfiguration, "tt:RecordingJobConfiguration"))
				{	soap_flag_JobConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__CreateRecordingJob *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateRecordingJob, 0, sizeof(struct _trc__CreateRecordingJob), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_JobConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__CreateRecordingJob(struct soap *soap, const struct _trc__CreateRecordingJob *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__CreateRecordingJob);
	if (soap_out__trc__CreateRecordingJob(soap, tag?tag:"trc:CreateRecordingJob", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateRecordingJob * SOAP_FMAC4 soap_get__trc__CreateRecordingJob(struct soap *soap, struct _trc__CreateRecordingJob *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__CreateRecordingJob(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetTrackConfigurationResponse(struct soap *soap, struct _trc__SetTrackConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetTrackConfigurationResponse(struct soap *soap, const struct _trc__SetTrackConfigurationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetTrackConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trc__SetTrackConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetTrackConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetTrackConfigurationResponse * SOAP_FMAC4 soap_in__trc__SetTrackConfigurationResponse(struct soap *soap, const char *tag, struct _trc__SetTrackConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__SetTrackConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetTrackConfigurationResponse, sizeof(struct _trc__SetTrackConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetTrackConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__SetTrackConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetTrackConfigurationResponse, 0, sizeof(struct _trc__SetTrackConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetTrackConfigurationResponse(struct soap *soap, const struct _trc__SetTrackConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__SetTrackConfigurationResponse);
	if (soap_out__trc__SetTrackConfigurationResponse(soap, tag?tag:"trc:SetTrackConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetTrackConfigurationResponse * SOAP_FMAC4 soap_get__trc__SetTrackConfigurationResponse(struct soap *soap, struct _trc__SetTrackConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetTrackConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetTrackConfiguration(struct soap *soap, struct _trc__SetTrackConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__TrackReference(soap, &a->TrackToken);
	a->TrackConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetTrackConfiguration(struct soap *soap, const struct _trc__SetTrackConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingReference(soap, &a->RecordingToken);
	soap_serialize_tt__TrackReference(soap, &a->TrackToken);
	soap_serialize_PointerTott__TrackConfiguration(soap, &a->TrackConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetTrackConfiguration(struct soap *soap, const char *tag, int id, const struct _trc__SetTrackConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetTrackConfiguration), type))
		return soap->error;
	if (a->RecordingToken)
	{	if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, &a->RecordingToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:RecordingToken"))
		return soap->error;
	if (a->TrackToken)
	{	if (soap_out_tt__TrackReference(soap, "trc:TrackToken", -1, &a->TrackToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:TrackToken"))
		return soap->error;
	if (a->TrackConfiguration)
	{	if (soap_out_PointerTott__TrackConfiguration(soap, "trc:TrackConfiguration", -1, &a->TrackConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:TrackConfiguration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetTrackConfiguration * SOAP_FMAC4 soap_in__trc__SetTrackConfiguration(struct soap *soap, const char *tag, struct _trc__SetTrackConfiguration *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackToken = 1;
	size_t soap_flag_TrackConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__SetTrackConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetTrackConfiguration, sizeof(struct _trc__SetTrackConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetTrackConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", &a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "trc:TrackToken", &a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			if (soap_flag_TrackConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TrackConfiguration(soap, "trc:TrackConfiguration", &a->TrackConfiguration, "tt:TrackConfiguration"))
				{	soap_flag_TrackConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__SetTrackConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetTrackConfiguration, 0, sizeof(struct _trc__SetTrackConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_TrackToken > 0 || soap_flag_TrackConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetTrackConfiguration(struct soap *soap, const struct _trc__SetTrackConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__SetTrackConfiguration);
	if (soap_out__trc__SetTrackConfiguration(soap, tag?tag:"trc:SetTrackConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetTrackConfiguration * SOAP_FMAC4 soap_get__trc__SetTrackConfiguration(struct soap *soap, struct _trc__SetTrackConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetTrackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetTrackConfigurationResponse(struct soap *soap, struct _trc__GetTrackConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->TrackConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetTrackConfigurationResponse(struct soap *soap, const struct _trc__GetTrackConfigurationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__TrackConfiguration(soap, &a->TrackConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetTrackConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetTrackConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetTrackConfigurationResponse), type))
		return soap->error;
	if (a->TrackConfiguration)
		soap_element_result(soap, "trc:TrackConfiguration");
	if (a->TrackConfiguration)
	{	if (soap_out_PointerTott__TrackConfiguration(soap, "trc:TrackConfiguration", -1, &a->TrackConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:TrackConfiguration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetTrackConfigurationResponse * SOAP_FMAC4 soap_in__trc__GetTrackConfigurationResponse(struct soap *soap, const char *tag, struct _trc__GetTrackConfigurationResponse *a, const char *type)
{
	size_t soap_flag_TrackConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetTrackConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetTrackConfigurationResponse, sizeof(struct _trc__GetTrackConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetTrackConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TrackConfiguration(soap, "trc:TrackConfiguration", &a->TrackConfiguration, "tt:TrackConfiguration"))
				{	soap_flag_TrackConfiguration--;
					continue;
				}
			soap_check_result(soap, "trc:TrackConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetTrackConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetTrackConfigurationResponse, 0, sizeof(struct _trc__GetTrackConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TrackConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetTrackConfigurationResponse(struct soap *soap, const struct _trc__GetTrackConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__GetTrackConfigurationResponse);
	if (soap_out__trc__GetTrackConfigurationResponse(soap, tag?tag:"trc:GetTrackConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetTrackConfigurationResponse * SOAP_FMAC4 soap_get__trc__GetTrackConfigurationResponse(struct soap *soap, struct _trc__GetTrackConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetTrackConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetTrackConfiguration(struct soap *soap, struct _trc__GetTrackConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__TrackReference(soap, &a->TrackToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetTrackConfiguration(struct soap *soap, const struct _trc__GetTrackConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingReference(soap, &a->RecordingToken);
	soap_serialize_tt__TrackReference(soap, &a->TrackToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetTrackConfiguration(struct soap *soap, const char *tag, int id, const struct _trc__GetTrackConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetTrackConfiguration), type))
		return soap->error;
	if (a->RecordingToken)
	{	if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, &a->RecordingToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:RecordingToken"))
		return soap->error;
	if (a->TrackToken)
	{	if (soap_out_tt__TrackReference(soap, "trc:TrackToken", -1, &a->TrackToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:TrackToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetTrackConfiguration * SOAP_FMAC4 soap_in__trc__GetTrackConfiguration(struct soap *soap, const char *tag, struct _trc__GetTrackConfiguration *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetTrackConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetTrackConfiguration, sizeof(struct _trc__GetTrackConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetTrackConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", &a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "trc:TrackToken", &a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetTrackConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetTrackConfiguration, 0, sizeof(struct _trc__GetTrackConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_TrackToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetTrackConfiguration(struct soap *soap, const struct _trc__GetTrackConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__GetTrackConfiguration);
	if (soap_out__trc__GetTrackConfiguration(soap, tag?tag:"trc:GetTrackConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetTrackConfiguration * SOAP_FMAC4 soap_get__trc__GetTrackConfiguration(struct soap *soap, struct _trc__GetTrackConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetTrackConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__DeleteTrackResponse(struct soap *soap, struct _trc__DeleteTrackResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__DeleteTrackResponse(struct soap *soap, const struct _trc__DeleteTrackResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__DeleteTrackResponse(struct soap *soap, const char *tag, int id, const struct _trc__DeleteTrackResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__DeleteTrackResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__DeleteTrackResponse * SOAP_FMAC4 soap_in__trc__DeleteTrackResponse(struct soap *soap, const char *tag, struct _trc__DeleteTrackResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__DeleteTrackResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteTrackResponse, sizeof(struct _trc__DeleteTrackResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__DeleteTrackResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteTrackResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteTrackResponse, 0, sizeof(struct _trc__DeleteTrackResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__DeleteTrackResponse(struct soap *soap, const struct _trc__DeleteTrackResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__DeleteTrackResponse);
	if (soap_out__trc__DeleteTrackResponse(soap, tag?tag:"trc:DeleteTrackResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteTrackResponse * SOAP_FMAC4 soap_get__trc__DeleteTrackResponse(struct soap *soap, struct _trc__DeleteTrackResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__DeleteTrackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__DeleteTrack(struct soap *soap, struct _trc__DeleteTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	soap_default_tt__TrackReference(soap, &a->TrackToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__DeleteTrack(struct soap *soap, const struct _trc__DeleteTrack *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingReference(soap, &a->RecordingToken);
	soap_serialize_tt__TrackReference(soap, &a->TrackToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__DeleteTrack(struct soap *soap, const char *tag, int id, const struct _trc__DeleteTrack *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__DeleteTrack), type))
		return soap->error;
	if (a->RecordingToken)
	{	if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, &a->RecordingToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:RecordingToken"))
		return soap->error;
	if (a->TrackToken)
	{	if (soap_out_tt__TrackReference(soap, "trc:TrackToken", -1, &a->TrackToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:TrackToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__DeleteTrack * SOAP_FMAC4 soap_in__trc__DeleteTrack(struct soap *soap, const char *tag, struct _trc__DeleteTrack *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__DeleteTrack *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteTrack, sizeof(struct _trc__DeleteTrack), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__DeleteTrack(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", &a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "trc:TrackToken", &a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteTrack, 0, sizeof(struct _trc__DeleteTrack), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_TrackToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__DeleteTrack(struct soap *soap, const struct _trc__DeleteTrack *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__DeleteTrack);
	if (soap_out__trc__DeleteTrack(soap, tag?tag:"trc:DeleteTrack", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteTrack * SOAP_FMAC4 soap_get__trc__DeleteTrack(struct soap *soap, struct _trc__DeleteTrack *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__DeleteTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__CreateTrackResponse(struct soap *soap, struct _trc__CreateTrackResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__TrackReference(soap, &a->TrackToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__CreateTrackResponse(struct soap *soap, const struct _trc__CreateTrackResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__TrackReference(soap, &a->TrackToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__CreateTrackResponse(struct soap *soap, const char *tag, int id, const struct _trc__CreateTrackResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__CreateTrackResponse), type))
		return soap->error;
	if (a->TrackToken)
		soap_element_result(soap, "trc:TrackToken");
	if (a->TrackToken)
	{	if (soap_out_tt__TrackReference(soap, "trc:TrackToken", -1, &a->TrackToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:TrackToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__CreateTrackResponse * SOAP_FMAC4 soap_in__trc__CreateTrackResponse(struct soap *soap, const char *tag, struct _trc__CreateTrackResponse *a, const char *type)
{
	size_t soap_flag_TrackToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__CreateTrackResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateTrackResponse, sizeof(struct _trc__CreateTrackResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__CreateTrackResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_TrackToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__TrackReference(soap, "trc:TrackToken", &a->TrackToken, "tt:TrackReference"))
				{	soap_flag_TrackToken--;
					continue;
				}
			soap_check_result(soap, "trc:TrackToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__CreateTrackResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateTrackResponse, 0, sizeof(struct _trc__CreateTrackResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_TrackToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__CreateTrackResponse(struct soap *soap, const struct _trc__CreateTrackResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__CreateTrackResponse);
	if (soap_out__trc__CreateTrackResponse(soap, tag?tag:"trc:CreateTrackResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateTrackResponse * SOAP_FMAC4 soap_get__trc__CreateTrackResponse(struct soap *soap, struct _trc__CreateTrackResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__CreateTrackResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__CreateTrack(struct soap *soap, struct _trc__CreateTrack *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	a->TrackConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__CreateTrack(struct soap *soap, const struct _trc__CreateTrack *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingReference(soap, &a->RecordingToken);
	soap_serialize_PointerTott__TrackConfiguration(soap, &a->TrackConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__CreateTrack(struct soap *soap, const char *tag, int id, const struct _trc__CreateTrack *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__CreateTrack), type))
		return soap->error;
	if (a->RecordingToken)
	{	if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, &a->RecordingToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:RecordingToken"))
		return soap->error;
	if (a->TrackConfiguration)
	{	if (soap_out_PointerTott__TrackConfiguration(soap, "trc:TrackConfiguration", -1, &a->TrackConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:TrackConfiguration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__CreateTrack * SOAP_FMAC4 soap_in__trc__CreateTrack(struct soap *soap, const char *tag, struct _trc__CreateTrack *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_TrackConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__CreateTrack *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateTrack, sizeof(struct _trc__CreateTrack), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__CreateTrack(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", &a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_TrackConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__TrackConfiguration(soap, "trc:TrackConfiguration", &a->TrackConfiguration, "tt:TrackConfiguration"))
				{	soap_flag_TrackConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__CreateTrack *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateTrack, 0, sizeof(struct _trc__CreateTrack), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_TrackConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__CreateTrack(struct soap *soap, const struct _trc__CreateTrack *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__CreateTrack);
	if (soap_out__trc__CreateTrack(soap, tag?tag:"trc:CreateTrack", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateTrack * SOAP_FMAC4 soap_get__trc__CreateTrack(struct soap *soap, struct _trc__CreateTrack *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__CreateTrack(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingConfigurationResponse(struct soap *soap, struct _trc__GetRecordingConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RecordingConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingConfigurationResponse(struct soap *soap, const struct _trc__GetRecordingConfigurationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__RecordingConfiguration(soap, &a->RecordingConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingConfigurationResponse), type))
		return soap->error;
	if (a->RecordingConfiguration)
		soap_element_result(soap, "trc:RecordingConfiguration");
	if (a->RecordingConfiguration)
	{	if (soap_out_PointerTott__RecordingConfiguration(soap, "trc:RecordingConfiguration", -1, &a->RecordingConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:RecordingConfiguration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingConfigurationResponse * SOAP_FMAC4 soap_in__trc__GetRecordingConfigurationResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingConfigurationResponse *a, const char *type)
{
	size_t soap_flag_RecordingConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingConfigurationResponse, sizeof(struct _trc__GetRecordingConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingConfiguration(soap, "trc:RecordingConfiguration", &a->RecordingConfiguration, "tt:RecordingConfiguration"))
				{	soap_flag_RecordingConfiguration--;
					continue;
				}
			soap_check_result(soap, "trc:RecordingConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingConfigurationResponse, 0, sizeof(struct _trc__GetRecordingConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingConfigurationResponse(struct soap *soap, const struct _trc__GetRecordingConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__GetRecordingConfigurationResponse);
	if (soap_out__trc__GetRecordingConfigurationResponse(soap, tag?tag:"trc:GetRecordingConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingConfigurationResponse * SOAP_FMAC4 soap_get__trc__GetRecordingConfigurationResponse(struct soap *soap, struct _trc__GetRecordingConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingConfiguration(struct soap *soap, struct _trc__GetRecordingConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingConfiguration(struct soap *soap, const struct _trc__GetRecordingConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingReference(soap, &a->RecordingToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingConfiguration(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingConfiguration), type))
		return soap->error;
	if (a->RecordingToken)
	{	if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, &a->RecordingToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:RecordingToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingConfiguration * SOAP_FMAC4 soap_in__trc__GetRecordingConfiguration(struct soap *soap, const char *tag, struct _trc__GetRecordingConfiguration *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingConfiguration, sizeof(struct _trc__GetRecordingConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", &a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingConfiguration, 0, sizeof(struct _trc__GetRecordingConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingConfiguration(struct soap *soap, const struct _trc__GetRecordingConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__GetRecordingConfiguration);
	if (soap_out__trc__GetRecordingConfiguration(soap, tag?tag:"trc:GetRecordingConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingConfiguration * SOAP_FMAC4 soap_get__trc__GetRecordingConfiguration(struct soap *soap, struct _trc__GetRecordingConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetRecordingConfigurationResponse(struct soap *soap, struct _trc__SetRecordingConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetRecordingConfigurationResponse(struct soap *soap, const struct _trc__SetRecordingConfigurationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetRecordingConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _trc__SetRecordingConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetRecordingConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetRecordingConfigurationResponse * SOAP_FMAC4 soap_in__trc__SetRecordingConfigurationResponse(struct soap *soap, const char *tag, struct _trc__SetRecordingConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__SetRecordingConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingConfigurationResponse, sizeof(struct _trc__SetRecordingConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetRecordingConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingConfigurationResponse, 0, sizeof(struct _trc__SetRecordingConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetRecordingConfigurationResponse(struct soap *soap, const struct _trc__SetRecordingConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__SetRecordingConfigurationResponse);
	if (soap_out__trc__SetRecordingConfigurationResponse(soap, tag?tag:"trc:SetRecordingConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingConfigurationResponse * SOAP_FMAC4 soap_get__trc__SetRecordingConfigurationResponse(struct soap *soap, struct _trc__SetRecordingConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetRecordingConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__SetRecordingConfiguration(struct soap *soap, struct _trc__SetRecordingConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
	a->RecordingConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__SetRecordingConfiguration(struct soap *soap, const struct _trc__SetRecordingConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingReference(soap, &a->RecordingToken);
	soap_serialize_PointerTott__RecordingConfiguration(soap, &a->RecordingConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__SetRecordingConfiguration(struct soap *soap, const char *tag, int id, const struct _trc__SetRecordingConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__SetRecordingConfiguration), type))
		return soap->error;
	if (a->RecordingToken)
	{	if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, &a->RecordingToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:RecordingToken"))
		return soap->error;
	if (a->RecordingConfiguration)
	{	if (soap_out_PointerTott__RecordingConfiguration(soap, "trc:RecordingConfiguration", -1, &a->RecordingConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:RecordingConfiguration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__SetRecordingConfiguration * SOAP_FMAC4 soap_in__trc__SetRecordingConfiguration(struct soap *soap, const char *tag, struct _trc__SetRecordingConfiguration *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	size_t soap_flag_RecordingConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__SetRecordingConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__SetRecordingConfiguration, sizeof(struct _trc__SetRecordingConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__SetRecordingConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", &a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap_flag_RecordingConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingConfiguration(soap, "trc:RecordingConfiguration", &a->RecordingConfiguration, "tt:RecordingConfiguration"))
				{	soap_flag_RecordingConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__SetRecordingConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__SetRecordingConfiguration, 0, sizeof(struct _trc__SetRecordingConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0 || soap_flag_RecordingConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__SetRecordingConfiguration(struct soap *soap, const struct _trc__SetRecordingConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__SetRecordingConfiguration);
	if (soap_out__trc__SetRecordingConfiguration(soap, tag?tag:"trc:SetRecordingConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__SetRecordingConfiguration * SOAP_FMAC4 soap_get__trc__SetRecordingConfiguration(struct soap *soap, struct _trc__SetRecordingConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__SetRecordingConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordingsResponse(struct soap *soap, struct _trc__GetRecordingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRecordingItem = 0;
	a->RecordingItem = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordingsResponse(struct soap *soap, const struct _trc__GetRecordingsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->RecordingItem)
	{	int i;
		for (i = 0; i < a->__sizeRecordingItem; i++)
		{
			soap_embedded(soap, a->RecordingItem + i, SOAP_TYPE_tt__GetRecordingsResponseItem);
			soap_serialize_tt__GetRecordingsResponseItem(soap, a->RecordingItem + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordingsResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordingsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordingsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeRecordingItem");
	if (a->RecordingItem)
	{	int i;
		for (i = 0; i < a->__sizeRecordingItem; i++)
			if (soap_out_tt__GetRecordingsResponseItem(soap, "trc:RecordingItem", -1, a->RecordingItem + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordingsResponse * SOAP_FMAC4 soap_in__trc__GetRecordingsResponse(struct soap *soap, const char *tag, struct _trc__GetRecordingsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_RecordingItem = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordingsResponse, sizeof(struct _trc__GetRecordingsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordingsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trc:RecordingItem", 1, NULL))
			{	if (a->RecordingItem == NULL)
				{	if (soap_blist_RecordingItem == NULL)
						soap_blist_RecordingItem = soap_new_block(soap);
					a->RecordingItem = (struct tt__GetRecordingsResponseItem *)soap_push_block(soap, soap_blist_RecordingItem, sizeof(struct tt__GetRecordingsResponseItem));
					if (a->RecordingItem == NULL)
						return NULL;
					soap_default_tt__GetRecordingsResponseItem(soap, a->RecordingItem);
				}
				soap_revert(soap);
				if (soap_in_tt__GetRecordingsResponseItem(soap, "trc:RecordingItem", a->RecordingItem, "tt:GetRecordingsResponseItem"))
				{	a->__sizeRecordingItem++;
					a->RecordingItem = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeRecordingItem");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RecordingItem)
			soap_pop_block(soap, soap_blist_RecordingItem);
		if (a->__sizeRecordingItem)
			a->RecordingItem = (struct tt__GetRecordingsResponseItem *)soap_save_block(soap, soap_blist_RecordingItem, NULL, 1);
		else
		{	a->RecordingItem = NULL;
			if (soap_blist_RecordingItem)
				soap_end_block(soap, soap_blist_RecordingItem);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordingsResponse, 0, sizeof(struct _trc__GetRecordingsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordingsResponse(struct soap *soap, const struct _trc__GetRecordingsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__GetRecordingsResponse);
	if (soap_out__trc__GetRecordingsResponse(soap, tag?tag:"trc:GetRecordingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordingsResponse * SOAP_FMAC4 soap_get__trc__GetRecordingsResponse(struct soap *soap, struct _trc__GetRecordingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetRecordings(struct soap *soap, struct _trc__GetRecordings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetRecordings(struct soap *soap, const struct _trc__GetRecordings *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetRecordings(struct soap *soap, const char *tag, int id, const struct _trc__GetRecordings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetRecordings), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetRecordings * SOAP_FMAC4 soap_in__trc__GetRecordings(struct soap *soap, const char *tag, struct _trc__GetRecordings *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetRecordings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetRecordings, sizeof(struct _trc__GetRecordings), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetRecordings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetRecordings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetRecordings, 0, sizeof(struct _trc__GetRecordings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetRecordings(struct soap *soap, const struct _trc__GetRecordings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__GetRecordings);
	if (soap_out__trc__GetRecordings(soap, tag?tag:"trc:GetRecordings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetRecordings * SOAP_FMAC4 soap_get__trc__GetRecordings(struct soap *soap, struct _trc__GetRecordings *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetRecordings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__DeleteRecordingResponse(struct soap *soap, struct _trc__DeleteRecordingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__DeleteRecordingResponse(struct soap *soap, const struct _trc__DeleteRecordingResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__DeleteRecordingResponse(struct soap *soap, const char *tag, int id, const struct _trc__DeleteRecordingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__DeleteRecordingResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__DeleteRecordingResponse * SOAP_FMAC4 soap_in__trc__DeleteRecordingResponse(struct soap *soap, const char *tag, struct _trc__DeleteRecordingResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__DeleteRecordingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteRecordingResponse, sizeof(struct _trc__DeleteRecordingResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__DeleteRecordingResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteRecordingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteRecordingResponse, 0, sizeof(struct _trc__DeleteRecordingResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__DeleteRecordingResponse(struct soap *soap, const struct _trc__DeleteRecordingResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__DeleteRecordingResponse);
	if (soap_out__trc__DeleteRecordingResponse(soap, tag?tag:"trc:DeleteRecordingResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteRecordingResponse * SOAP_FMAC4 soap_get__trc__DeleteRecordingResponse(struct soap *soap, struct _trc__DeleteRecordingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__DeleteRecordingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__DeleteRecording(struct soap *soap, struct _trc__DeleteRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__DeleteRecording(struct soap *soap, const struct _trc__DeleteRecording *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingReference(soap, &a->RecordingToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__DeleteRecording(struct soap *soap, const char *tag, int id, const struct _trc__DeleteRecording *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__DeleteRecording), type))
		return soap->error;
	if (a->RecordingToken)
	{	if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, &a->RecordingToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:RecordingToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__DeleteRecording * SOAP_FMAC4 soap_in__trc__DeleteRecording(struct soap *soap, const char *tag, struct _trc__DeleteRecording *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__DeleteRecording *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__DeleteRecording, sizeof(struct _trc__DeleteRecording), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__DeleteRecording(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", &a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__DeleteRecording *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__DeleteRecording, 0, sizeof(struct _trc__DeleteRecording), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__DeleteRecording(struct soap *soap, const struct _trc__DeleteRecording *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__DeleteRecording);
	if (soap_out__trc__DeleteRecording(soap, tag?tag:"trc:DeleteRecording", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__DeleteRecording * SOAP_FMAC4 soap_get__trc__DeleteRecording(struct soap *soap, struct _trc__DeleteRecording *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__DeleteRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__CreateRecordingResponse(struct soap *soap, struct _trc__CreateRecordingResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__RecordingReference(soap, &a->RecordingToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__CreateRecordingResponse(struct soap *soap, const struct _trc__CreateRecordingResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__RecordingReference(soap, &a->RecordingToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__CreateRecordingResponse(struct soap *soap, const char *tag, int id, const struct _trc__CreateRecordingResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__CreateRecordingResponse), type))
		return soap->error;
	if (a->RecordingToken)
		soap_element_result(soap, "trc:RecordingToken");
	if (a->RecordingToken)
	{	if (soap_out_tt__RecordingReference(soap, "trc:RecordingToken", -1, &a->RecordingToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:RecordingToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__CreateRecordingResponse * SOAP_FMAC4 soap_in__trc__CreateRecordingResponse(struct soap *soap, const char *tag, struct _trc__CreateRecordingResponse *a, const char *type)
{
	size_t soap_flag_RecordingToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__CreateRecordingResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateRecordingResponse, sizeof(struct _trc__CreateRecordingResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__CreateRecordingResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__RecordingReference(soap, "trc:RecordingToken", &a->RecordingToken, "tt:RecordingReference"))
				{	soap_flag_RecordingToken--;
					continue;
				}
			soap_check_result(soap, "trc:RecordingToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__CreateRecordingResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateRecordingResponse, 0, sizeof(struct _trc__CreateRecordingResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__CreateRecordingResponse(struct soap *soap, const struct _trc__CreateRecordingResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__CreateRecordingResponse);
	if (soap_out__trc__CreateRecordingResponse(soap, tag?tag:"trc:CreateRecordingResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateRecordingResponse * SOAP_FMAC4 soap_get__trc__CreateRecordingResponse(struct soap *soap, struct _trc__CreateRecordingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__CreateRecordingResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__CreateRecording(struct soap *soap, struct _trc__CreateRecording *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->RecordingConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__CreateRecording(struct soap *soap, const struct _trc__CreateRecording *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__RecordingConfiguration(soap, &a->RecordingConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__CreateRecording(struct soap *soap, const char *tag, int id, const struct _trc__CreateRecording *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__CreateRecording), type))
		return soap->error;
	if (a->RecordingConfiguration)
	{	if (soap_out_PointerTott__RecordingConfiguration(soap, "trc:RecordingConfiguration", -1, &a->RecordingConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:RecordingConfiguration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__CreateRecording * SOAP_FMAC4 soap_in__trc__CreateRecording(struct soap *soap, const char *tag, struct _trc__CreateRecording *a, const char *type)
{
	size_t soap_flag_RecordingConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__CreateRecording *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__CreateRecording, sizeof(struct _trc__CreateRecording), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__CreateRecording(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RecordingConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RecordingConfiguration(soap, "trc:RecordingConfiguration", &a->RecordingConfiguration, "tt:RecordingConfiguration"))
				{	soap_flag_RecordingConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__CreateRecording *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__CreateRecording, 0, sizeof(struct _trc__CreateRecording), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RecordingConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__CreateRecording(struct soap *soap, const struct _trc__CreateRecording *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__CreateRecording);
	if (soap_out__trc__CreateRecording(soap, tag?tag:"trc:CreateRecording", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__CreateRecording * SOAP_FMAC4 soap_get__trc__CreateRecording(struct soap *soap, struct _trc__CreateRecording *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__CreateRecording(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetServiceCapabilitiesResponse(struct soap *soap, struct _trc__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trc__GetServiceCapabilitiesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotrc__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _trc__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "trc:Capabilities");
	if (a->Capabilities)
	{	if (soap_out_PointerTotrc__Capabilities(soap, "trc:Capabilities", -1, &a->Capabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:Capabilities"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__trc__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trc__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetServiceCapabilitiesResponse, sizeof(struct _trc__GetServiceCapabilitiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotrc__Capabilities(soap, "trc:Capabilities", &a->Capabilities, "trc:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "trc:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetServiceCapabilitiesResponse, 0, sizeof(struct _trc__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trc__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__GetServiceCapabilitiesResponse);
	if (soap_out__trc__GetServiceCapabilitiesResponse(soap, tag?tag:"trc:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__trc__GetServiceCapabilitiesResponse(struct soap *soap, struct _trc__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trc__GetServiceCapabilities(struct soap *soap, struct _trc__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trc__GetServiceCapabilities(struct soap *soap, const struct _trc__GetServiceCapabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trc__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _trc__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trc__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilities * SOAP_FMAC4 soap_in__trc__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trc__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trc__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trc__GetServiceCapabilities, sizeof(struct _trc__GetServiceCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trc__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trc__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trc__GetServiceCapabilities, 0, sizeof(struct _trc__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trc__GetServiceCapabilities(struct soap *soap, const struct _trc__GetServiceCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trc__GetServiceCapabilities);
	if (soap_out__trc__GetServiceCapabilities(soap, tag?tag:"trc:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trc__GetServiceCapabilities * SOAP_FMAC4 soap_get__trc__GetServiceCapabilities(struct soap *soap, struct _trc__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__trc__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trc__TrackOptions(struct soap *soap, struct trc__TrackOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SpareTotal = NULL;
	a->SpareVideo = NULL;
	a->SpareAudio = NULL;
	a->SpareMetadata = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trc__TrackOptions(struct soap *soap, const struct trc__TrackOptions *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trc__TrackOptions(struct soap *soap, const char *tag, int id, const struct trc__TrackOptions *a, const char *type)
{
	if (a->SpareTotal)
		soap_set_attr(soap, "SpareTotal", soap_int2s(soap, *a->SpareTotal), 1);
	if (a->SpareVideo)
		soap_set_attr(soap, "SpareVideo", soap_int2s(soap, *a->SpareVideo), 1);
	if (a->SpareAudio)
		soap_set_attr(soap, "SpareAudio", soap_int2s(soap, *a->SpareAudio), 1);
	if (a->SpareMetadata)
		soap_set_attr(soap, "SpareMetadata", soap_int2s(soap, *a->SpareMetadata), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trc__TrackOptions), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trc__TrackOptions * SOAP_FMAC4 soap_in_trc__TrackOptions(struct soap *soap, const char *tag, struct trc__TrackOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trc__TrackOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trc__TrackOptions, sizeof(struct trc__TrackOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trc__TrackOptions(soap, a);
	{	const char *t = soap_attr_value(soap, "SpareTotal", 0);
		if (t)
		{
			if (!(a->SpareTotal = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->SpareTotal))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "SpareVideo", 0);
		if (t)
		{
			if (!(a->SpareVideo = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->SpareVideo))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "SpareAudio", 0);
		if (t)
		{
			if (!(a->SpareAudio = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->SpareAudio))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "SpareMetadata", 0);
		if (t)
		{
			if (!(a->SpareMetadata = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->SpareMetadata))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trc__TrackOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trc__TrackOptions, 0, sizeof(struct trc__TrackOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trc__TrackOptions(struct soap *soap, const struct trc__TrackOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trc__TrackOptions);
	if (soap_out_trc__TrackOptions(soap, tag?tag:"trc:TrackOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__TrackOptions * SOAP_FMAC4 soap_get_trc__TrackOptions(struct soap *soap, struct trc__TrackOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_trc__TrackOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trc__JobOptions(struct soap *soap, struct trc__JobOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Spare = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trc__JobOptions(struct soap *soap, const struct trc__JobOptions *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trc__JobOptions(struct soap *soap, const char *tag, int id, const struct trc__JobOptions *a, const char *type)
{
	if (a->Spare)
		soap_set_attr(soap, "Spare", soap_int2s(soap, *a->Spare), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trc__JobOptions), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trc__JobOptions * SOAP_FMAC4 soap_in_trc__JobOptions(struct soap *soap, const char *tag, struct trc__JobOptions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trc__JobOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trc__JobOptions, sizeof(struct trc__JobOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trc__JobOptions(soap, a);
	{	const char *t = soap_attr_value(soap, "Spare", 0);
		if (t)
		{
			if (!(a->Spare = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->Spare))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trc__JobOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trc__JobOptions, 0, sizeof(struct trc__JobOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trc__JobOptions(struct soap *soap, const struct trc__JobOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trc__JobOptions);
	if (soap_out_trc__JobOptions(soap, tag?tag:"trc:JobOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__JobOptions * SOAP_FMAC4 soap_get_trc__JobOptions(struct soap *soap, struct trc__JobOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_trc__JobOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trc__RecordingOptions(struct soap *soap, struct trc__RecordingOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Job = NULL;
	a->Track = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trc__RecordingOptions(struct soap *soap, const struct trc__RecordingOptions *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotrc__JobOptions(soap, &a->Job);
	soap_serialize_PointerTotrc__TrackOptions(soap, &a->Track);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trc__RecordingOptions(struct soap *soap, const char *tag, int id, const struct trc__RecordingOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trc__RecordingOptions), type))
		return soap->error;
	if (a->Job)
	{	if (soap_out_PointerTotrc__JobOptions(soap, "trc:Job", -1, &a->Job, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:Job"))
		return soap->error;
	if (a->Track)
	{	if (soap_out_PointerTotrc__TrackOptions(soap, "trc:Track", -1, &a->Track, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trc:Track"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trc__RecordingOptions * SOAP_FMAC4 soap_in_trc__RecordingOptions(struct soap *soap, const char *tag, struct trc__RecordingOptions *a, const char *type)
{
	size_t soap_flag_Job = 1;
	size_t soap_flag_Track = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trc__RecordingOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trc__RecordingOptions, sizeof(struct trc__RecordingOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trc__RecordingOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Job && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotrc__JobOptions(soap, "trc:Job", &a->Job, "trc:JobOptions"))
				{	soap_flag_Job--;
					continue;
				}
			if (soap_flag_Track && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotrc__TrackOptions(soap, "trc:Track", &a->Track, "trc:TrackOptions"))
				{	soap_flag_Track--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trc__RecordingOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trc__RecordingOptions, 0, sizeof(struct trc__RecordingOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Job > 0 || soap_flag_Track > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trc__RecordingOptions(struct soap *soap, const struct trc__RecordingOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trc__RecordingOptions);
	if (soap_out_trc__RecordingOptions(soap, tag?tag:"trc:RecordingOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__RecordingOptions * SOAP_FMAC4 soap_get_trc__RecordingOptions(struct soap *soap, struct trc__RecordingOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in_trc__RecordingOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trc__Capabilities(struct soap *soap, struct trc__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->DynamicRecordings = NULL;
	a->DynamicTracks = NULL;
	soap_default_trc__EncodingTypes(soap, &a->Encoding);
	a->MaxRate = NULL;
	a->MaxTotalRate = NULL;
	a->MaxRecordings = NULL;
	a->MaxRecordingJobs = NULL;
	a->Options = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trc__Capabilities(struct soap *soap, const struct trc__Capabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trc__Capabilities(struct soap *soap, const char *tag, int id, const struct trc__Capabilities *a, const char *type)
{
	if (a->DynamicRecordings)
		soap_set_attr(soap, "DynamicRecordings", soap_xsd__boolean2s(soap, *a->DynamicRecordings), 1);
	if (a->DynamicTracks)
		soap_set_attr(soap, "DynamicTracks", soap_xsd__boolean2s(soap, *a->DynamicTracks), 1);
	if (a->Encoding)
		soap_set_attr(soap, "Encoding", a->Encoding, 1);
	if (a->MaxRate)
		soap_set_attr(soap, "MaxRate", soap_float2s(soap, *a->MaxRate), 1);
	if (a->MaxTotalRate)
		soap_set_attr(soap, "MaxTotalRate", soap_float2s(soap, *a->MaxTotalRate), 1);
	if (a->MaxRecordings)
		soap_set_attr(soap, "MaxRecordings", soap_float2s(soap, *a->MaxRecordings), 1);
	if (a->MaxRecordingJobs)
		soap_set_attr(soap, "MaxRecordingJobs", soap_int2s(soap, *a->MaxRecordingJobs), 1);
	if (a->Options)
		soap_set_attr(soap, "Options", soap_xsd__boolean2s(soap, *a->Options), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trc__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trc__Capabilities * SOAP_FMAC4 soap_in_trc__Capabilities(struct soap *soap, const char *tag, struct trc__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trc__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trc__Capabilities, sizeof(struct trc__Capabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trc__Capabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "DynamicRecordings", 0);
		if (t)
		{
			if (!(a->DynamicRecordings = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->DynamicRecordings))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "DynamicTracks", 0);
		if (t)
		{
			if (!(a->DynamicTracks = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->DynamicTracks))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "Encoding", 0), &a->Encoding, 0, -1))
		return NULL;
	{	const char *t = soap_attr_value(soap, "MaxRate", 0);
		if (t)
		{
			if (!(a->MaxRate = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->MaxRate))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "MaxTotalRate", 0);
		if (t)
		{
			if (!(a->MaxTotalRate = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->MaxTotalRate))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "MaxRecordings", 0);
		if (t)
		{
			if (!(a->MaxRecordings = (float *)soap_malloc(soap, sizeof(float))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2float(soap, t, a->MaxRecordings))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "MaxRecordingJobs", 0);
		if (t)
		{
			if (!(a->MaxRecordingJobs = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxRecordingJobs))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Options", 0);
		if (t)
		{
			if (!(a->Options = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Options))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trc__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trc__Capabilities, 0, sizeof(struct trc__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trc__Capabilities(struct soap *soap, const struct trc__Capabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trc__Capabilities);
	if (soap_out_trc__Capabilities(soap, tag?tag:"trc:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trc__Capabilities * SOAP_FMAC4 soap_get_trc__Capabilities(struct soap *soap, struct trc__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_trc__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetReceiverStateResponse(struct soap *soap, struct _trv__GetReceiverStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ReceiverState = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetReceiverStateResponse(struct soap *soap, const struct _trv__GetReceiverStateResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ReceiverStateInformation(soap, &a->ReceiverState);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetReceiverStateResponse(struct soap *soap, const char *tag, int id, const struct _trv__GetReceiverStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetReceiverStateResponse), type))
		return soap->error;
	if (a->ReceiverState)
		soap_element_result(soap, "trv:ReceiverState");
	if (a->ReceiverState)
	{	if (soap_out_PointerTott__ReceiverStateInformation(soap, "trv:ReceiverState", -1, &a->ReceiverState, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trv:ReceiverState"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetReceiverStateResponse * SOAP_FMAC4 soap_in__trv__GetReceiverStateResponse(struct soap *soap, const char *tag, struct _trv__GetReceiverStateResponse *a, const char *type)
{
	size_t soap_flag_ReceiverState = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__GetReceiverStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiverStateResponse, sizeof(struct _trv__GetReceiverStateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetReceiverStateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReceiverState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ReceiverStateInformation(soap, "trv:ReceiverState", &a->ReceiverState, "tt:ReceiverStateInformation"))
				{	soap_flag_ReceiverState--;
					continue;
				}
			soap_check_result(soap, "trv:ReceiverState");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceiverStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiverStateResponse, 0, sizeof(struct _trv__GetReceiverStateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ReceiverState > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetReceiverStateResponse(struct soap *soap, const struct _trv__GetReceiverStateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trv__GetReceiverStateResponse);
	if (soap_out__trv__GetReceiverStateResponse(soap, tag?tag:"trv:GetReceiverStateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiverStateResponse * SOAP_FMAC4 soap_get__trv__GetReceiverStateResponse(struct soap *soap, struct _trv__GetReceiverStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetReceiverStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetReceiverState(struct soap *soap, struct _trv__GetReceiverState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ReceiverToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetReceiverState(struct soap *soap, const struct _trv__GetReceiverState *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ReceiverToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetReceiverState(struct soap *soap, const char *tag, int id, const struct _trv__GetReceiverState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetReceiverState), type))
		return soap->error;
	if (a->ReceiverToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trv:ReceiverToken", -1, &a->ReceiverToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trv:ReceiverToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetReceiverState * SOAP_FMAC4 soap_in__trv__GetReceiverState(struct soap *soap, const char *tag, struct _trv__GetReceiverState *a, const char *type)
{
	size_t soap_flag_ReceiverToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__GetReceiverState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiverState, sizeof(struct _trv__GetReceiverState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetReceiverState(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trv:ReceiverToken", &a->ReceiverToken, "tt:ReferenceToken"))
				{	soap_flag_ReceiverToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceiverState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiverState, 0, sizeof(struct _trv__GetReceiverState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ReceiverToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetReceiverState(struct soap *soap, const struct _trv__GetReceiverState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trv__GetReceiverState);
	if (soap_out__trv__GetReceiverState(soap, tag?tag:"trv:GetReceiverState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiverState * SOAP_FMAC4 soap_get__trv__GetReceiverState(struct soap *soap, struct _trv__GetReceiverState *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetReceiverState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__SetReceiverModeResponse(struct soap *soap, struct _trv__SetReceiverModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__SetReceiverModeResponse(struct soap *soap, const struct _trv__SetReceiverModeResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__SetReceiverModeResponse(struct soap *soap, const char *tag, int id, const struct _trv__SetReceiverModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__SetReceiverModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__SetReceiverModeResponse * SOAP_FMAC4 soap_in__trv__SetReceiverModeResponse(struct soap *soap, const char *tag, struct _trv__SetReceiverModeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__SetReceiverModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__SetReceiverModeResponse, sizeof(struct _trv__SetReceiverModeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__SetReceiverModeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__SetReceiverModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__SetReceiverModeResponse, 0, sizeof(struct _trv__SetReceiverModeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__SetReceiverModeResponse(struct soap *soap, const struct _trv__SetReceiverModeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trv__SetReceiverModeResponse);
	if (soap_out__trv__SetReceiverModeResponse(soap, tag?tag:"trv:SetReceiverModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__SetReceiverModeResponse * SOAP_FMAC4 soap_get__trv__SetReceiverModeResponse(struct soap *soap, struct _trv__SetReceiverModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__SetReceiverModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__SetReceiverMode(struct soap *soap, struct _trv__SetReceiverMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ReceiverToken);
	soap_default_tt__ReceiverMode(soap, &a->Mode);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__SetReceiverMode(struct soap *soap, const struct _trv__SetReceiverMode *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ReceiverToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__SetReceiverMode(struct soap *soap, const char *tag, int id, const struct _trv__SetReceiverMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__SetReceiverMode), type))
		return soap->error;
	if (a->ReceiverToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trv:ReceiverToken", -1, &a->ReceiverToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trv:ReceiverToken"))
		return soap->error;
	if (soap_out_tt__ReceiverMode(soap, "trv:Mode", -1, &a->Mode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__SetReceiverMode * SOAP_FMAC4 soap_in__trv__SetReceiverMode(struct soap *soap, const char *tag, struct _trv__SetReceiverMode *a, const char *type)
{
	size_t soap_flag_ReceiverToken = 1;
	size_t soap_flag_Mode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__SetReceiverMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__SetReceiverMode, sizeof(struct _trv__SetReceiverMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__SetReceiverMode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trv:ReceiverToken", &a->ReceiverToken, "tt:ReferenceToken"))
				{	soap_flag_ReceiverToken--;
					continue;
				}
			if (soap_flag_Mode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__ReceiverMode(soap, "trv:Mode", &a->Mode, "tt:ReceiverMode"))
				{	soap_flag_Mode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__SetReceiverMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__SetReceiverMode, 0, sizeof(struct _trv__SetReceiverMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ReceiverToken > 0 || soap_flag_Mode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__SetReceiverMode(struct soap *soap, const struct _trv__SetReceiverMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trv__SetReceiverMode);
	if (soap_out__trv__SetReceiverMode(soap, tag?tag:"trv:SetReceiverMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__SetReceiverMode * SOAP_FMAC4 soap_get__trv__SetReceiverMode(struct soap *soap, struct _trv__SetReceiverMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__SetReceiverMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__ConfigureReceiverResponse(struct soap *soap, struct _trv__ConfigureReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__ConfigureReceiverResponse(struct soap *soap, const struct _trv__ConfigureReceiverResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__ConfigureReceiverResponse(struct soap *soap, const char *tag, int id, const struct _trv__ConfigureReceiverResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__ConfigureReceiverResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__ConfigureReceiverResponse * SOAP_FMAC4 soap_in__trv__ConfigureReceiverResponse(struct soap *soap, const char *tag, struct _trv__ConfigureReceiverResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__ConfigureReceiverResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__ConfigureReceiverResponse, sizeof(struct _trv__ConfigureReceiverResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__ConfigureReceiverResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__ConfigureReceiverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__ConfigureReceiverResponse, 0, sizeof(struct _trv__ConfigureReceiverResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__ConfigureReceiverResponse(struct soap *soap, const struct _trv__ConfigureReceiverResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trv__ConfigureReceiverResponse);
	if (soap_out__trv__ConfigureReceiverResponse(soap, tag?tag:"trv:ConfigureReceiverResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__ConfigureReceiverResponse * SOAP_FMAC4 soap_get__trv__ConfigureReceiverResponse(struct soap *soap, struct _trv__ConfigureReceiverResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__ConfigureReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__ConfigureReceiver(struct soap *soap, struct _trv__ConfigureReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ReceiverToken);
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__ConfigureReceiver(struct soap *soap, const struct _trv__ConfigureReceiver *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ReceiverToken);
	soap_serialize_PointerTott__ReceiverConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__ConfigureReceiver(struct soap *soap, const char *tag, int id, const struct _trv__ConfigureReceiver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__ConfigureReceiver), type))
		return soap->error;
	if (a->ReceiverToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trv:ReceiverToken", -1, &a->ReceiverToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trv:ReceiverToken"))
		return soap->error;
	if (a->Configuration)
	{	if (soap_out_PointerTott__ReceiverConfiguration(soap, "trv:Configuration", -1, &a->Configuration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trv:Configuration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__ConfigureReceiver * SOAP_FMAC4 soap_in__trv__ConfigureReceiver(struct soap *soap, const char *tag, struct _trv__ConfigureReceiver *a, const char *type)
{
	size_t soap_flag_ReceiverToken = 1;
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__ConfigureReceiver *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__ConfigureReceiver, sizeof(struct _trv__ConfigureReceiver), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__ConfigureReceiver(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trv:ReceiverToken", &a->ReceiverToken, "tt:ReferenceToken"))
				{	soap_flag_ReceiverToken--;
					continue;
				}
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ReceiverConfiguration(soap, "trv:Configuration", &a->Configuration, "tt:ReceiverConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__ConfigureReceiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__ConfigureReceiver, 0, sizeof(struct _trv__ConfigureReceiver), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ReceiverToken > 0 || soap_flag_Configuration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__ConfigureReceiver(struct soap *soap, const struct _trv__ConfigureReceiver *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trv__ConfigureReceiver);
	if (soap_out__trv__ConfigureReceiver(soap, tag?tag:"trv:ConfigureReceiver", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__ConfigureReceiver * SOAP_FMAC4 soap_get__trv__ConfigureReceiver(struct soap *soap, struct _trv__ConfigureReceiver *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__ConfigureReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__DeleteReceiverResponse(struct soap *soap, struct _trv__DeleteReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__DeleteReceiverResponse(struct soap *soap, const struct _trv__DeleteReceiverResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__DeleteReceiverResponse(struct soap *soap, const char *tag, int id, const struct _trv__DeleteReceiverResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__DeleteReceiverResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__DeleteReceiverResponse * SOAP_FMAC4 soap_in__trv__DeleteReceiverResponse(struct soap *soap, const char *tag, struct _trv__DeleteReceiverResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__DeleteReceiverResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__DeleteReceiverResponse, sizeof(struct _trv__DeleteReceiverResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__DeleteReceiverResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__DeleteReceiverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__DeleteReceiverResponse, 0, sizeof(struct _trv__DeleteReceiverResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__DeleteReceiverResponse(struct soap *soap, const struct _trv__DeleteReceiverResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trv__DeleteReceiverResponse);
	if (soap_out__trv__DeleteReceiverResponse(soap, tag?tag:"trv:DeleteReceiverResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__DeleteReceiverResponse * SOAP_FMAC4 soap_get__trv__DeleteReceiverResponse(struct soap *soap, struct _trv__DeleteReceiverResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__DeleteReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__DeleteReceiver(struct soap *soap, struct _trv__DeleteReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ReceiverToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__DeleteReceiver(struct soap *soap, const struct _trv__DeleteReceiver *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ReceiverToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__DeleteReceiver(struct soap *soap, const char *tag, int id, const struct _trv__DeleteReceiver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__DeleteReceiver), type))
		return soap->error;
	if (a->ReceiverToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trv:ReceiverToken", -1, &a->ReceiverToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trv:ReceiverToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__DeleteReceiver * SOAP_FMAC4 soap_in__trv__DeleteReceiver(struct soap *soap, const char *tag, struct _trv__DeleteReceiver *a, const char *type)
{
	size_t soap_flag_ReceiverToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__DeleteReceiver *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__DeleteReceiver, sizeof(struct _trv__DeleteReceiver), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__DeleteReceiver(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trv:ReceiverToken", &a->ReceiverToken, "tt:ReferenceToken"))
				{	soap_flag_ReceiverToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__DeleteReceiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__DeleteReceiver, 0, sizeof(struct _trv__DeleteReceiver), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ReceiverToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__DeleteReceiver(struct soap *soap, const struct _trv__DeleteReceiver *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trv__DeleteReceiver);
	if (soap_out__trv__DeleteReceiver(soap, tag?tag:"trv:DeleteReceiver", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__DeleteReceiver * SOAP_FMAC4 soap_get__trv__DeleteReceiver(struct soap *soap, struct _trv__DeleteReceiver *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__DeleteReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__CreateReceiverResponse(struct soap *soap, struct _trv__CreateReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Receiver = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__CreateReceiverResponse(struct soap *soap, const struct _trv__CreateReceiverResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Receiver(soap, &a->Receiver);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__CreateReceiverResponse(struct soap *soap, const char *tag, int id, const struct _trv__CreateReceiverResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__CreateReceiverResponse), type))
		return soap->error;
	if (a->Receiver)
		soap_element_result(soap, "trv:Receiver");
	if (a->Receiver)
	{	if (soap_out_PointerTott__Receiver(soap, "trv:Receiver", -1, &a->Receiver, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trv:Receiver"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__CreateReceiverResponse * SOAP_FMAC4 soap_in__trv__CreateReceiverResponse(struct soap *soap, const char *tag, struct _trv__CreateReceiverResponse *a, const char *type)
{
	size_t soap_flag_Receiver = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__CreateReceiverResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__CreateReceiverResponse, sizeof(struct _trv__CreateReceiverResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__CreateReceiverResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Receiver && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Receiver(soap, "trv:Receiver", &a->Receiver, "tt:Receiver"))
				{	soap_flag_Receiver--;
					continue;
				}
			soap_check_result(soap, "trv:Receiver");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__CreateReceiverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__CreateReceiverResponse, 0, sizeof(struct _trv__CreateReceiverResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Receiver > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__CreateReceiverResponse(struct soap *soap, const struct _trv__CreateReceiverResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trv__CreateReceiverResponse);
	if (soap_out__trv__CreateReceiverResponse(soap, tag?tag:"trv:CreateReceiverResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__CreateReceiverResponse * SOAP_FMAC4 soap_get__trv__CreateReceiverResponse(struct soap *soap, struct _trv__CreateReceiverResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__CreateReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__CreateReceiver(struct soap *soap, struct _trv__CreateReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Configuration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__CreateReceiver(struct soap *soap, const struct _trv__CreateReceiver *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ReceiverConfiguration(soap, &a->Configuration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__CreateReceiver(struct soap *soap, const char *tag, int id, const struct _trv__CreateReceiver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__CreateReceiver), type))
		return soap->error;
	if (a->Configuration)
	{	if (soap_out_PointerTott__ReceiverConfiguration(soap, "trv:Configuration", -1, &a->Configuration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trv:Configuration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__CreateReceiver * SOAP_FMAC4 soap_in__trv__CreateReceiver(struct soap *soap, const char *tag, struct _trv__CreateReceiver *a, const char *type)
{
	size_t soap_flag_Configuration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__CreateReceiver *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__CreateReceiver, sizeof(struct _trv__CreateReceiver), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__CreateReceiver(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Configuration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ReceiverConfiguration(soap, "trv:Configuration", &a->Configuration, "tt:ReceiverConfiguration"))
				{	soap_flag_Configuration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__CreateReceiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__CreateReceiver, 0, sizeof(struct _trv__CreateReceiver), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Configuration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__CreateReceiver(struct soap *soap, const struct _trv__CreateReceiver *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trv__CreateReceiver);
	if (soap_out__trv__CreateReceiver(soap, tag?tag:"trv:CreateReceiver", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__CreateReceiver * SOAP_FMAC4 soap_get__trv__CreateReceiver(struct soap *soap, struct _trv__CreateReceiver *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__CreateReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetReceiverResponse(struct soap *soap, struct _trv__GetReceiverResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Receiver = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetReceiverResponse(struct soap *soap, const struct _trv__GetReceiverResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Receiver(soap, &a->Receiver);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetReceiverResponse(struct soap *soap, const char *tag, int id, const struct _trv__GetReceiverResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetReceiverResponse), type))
		return soap->error;
	if (a->Receiver)
		soap_element_result(soap, "trv:Receiver");
	if (a->Receiver)
	{	if (soap_out_PointerTott__Receiver(soap, "trv:Receiver", -1, &a->Receiver, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trv:Receiver"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetReceiverResponse * SOAP_FMAC4 soap_in__trv__GetReceiverResponse(struct soap *soap, const char *tag, struct _trv__GetReceiverResponse *a, const char *type)
{
	size_t soap_flag_Receiver = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__GetReceiverResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiverResponse, sizeof(struct _trv__GetReceiverResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetReceiverResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Receiver && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Receiver(soap, "trv:Receiver", &a->Receiver, "tt:Receiver"))
				{	soap_flag_Receiver--;
					continue;
				}
			soap_check_result(soap, "trv:Receiver");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceiverResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiverResponse, 0, sizeof(struct _trv__GetReceiverResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Receiver > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetReceiverResponse(struct soap *soap, const struct _trv__GetReceiverResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trv__GetReceiverResponse);
	if (soap_out__trv__GetReceiverResponse(soap, tag?tag:"trv:GetReceiverResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiverResponse * SOAP_FMAC4 soap_get__trv__GetReceiverResponse(struct soap *soap, struct _trv__GetReceiverResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetReceiverResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetReceiver(struct soap *soap, struct _trv__GetReceiver *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ReceiverToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetReceiver(struct soap *soap, const struct _trv__GetReceiver *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ReceiverToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetReceiver(struct soap *soap, const char *tag, int id, const struct _trv__GetReceiver *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetReceiver), type))
		return soap->error;
	if (a->ReceiverToken)
	{	if (soap_out_tt__ReferenceToken(soap, "trv:ReceiverToken", -1, &a->ReceiverToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trv:ReceiverToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetReceiver * SOAP_FMAC4 soap_in__trv__GetReceiver(struct soap *soap, const char *tag, struct _trv__GetReceiver *a, const char *type)
{
	size_t soap_flag_ReceiverToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__GetReceiver *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiver, sizeof(struct _trv__GetReceiver), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetReceiver(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ReceiverToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "trv:ReceiverToken", &a->ReceiverToken, "tt:ReferenceToken"))
				{	soap_flag_ReceiverToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceiver *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiver, 0, sizeof(struct _trv__GetReceiver), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ReceiverToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetReceiver(struct soap *soap, const struct _trv__GetReceiver *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trv__GetReceiver);
	if (soap_out__trv__GetReceiver(soap, tag?tag:"trv:GetReceiver", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiver * SOAP_FMAC4 soap_get__trv__GetReceiver(struct soap *soap, struct _trv__GetReceiver *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetReceiver(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetReceiversResponse(struct soap *soap, struct _trv__GetReceiversResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeReceivers = 0;
	a->Receivers = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetReceiversResponse(struct soap *soap, const struct _trv__GetReceiversResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Receivers)
	{	int i;
		for (i = 0; i < a->__sizeReceivers; i++)
		{
			soap_embedded(soap, a->Receivers + i, SOAP_TYPE_tt__Receiver);
			soap_serialize_tt__Receiver(soap, a->Receivers + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetReceiversResponse(struct soap *soap, const char *tag, int id, const struct _trv__GetReceiversResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetReceiversResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeReceivers");
	if (a->Receivers)
	{	int i;
		for (i = 0; i < a->__sizeReceivers; i++)
			if (soap_out_tt__Receiver(soap, "trv:Receivers", -1, a->Receivers + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetReceiversResponse * SOAP_FMAC4 soap_in__trv__GetReceiversResponse(struct soap *soap, const char *tag, struct _trv__GetReceiversResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Receivers = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__GetReceiversResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceiversResponse, sizeof(struct _trv__GetReceiversResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetReceiversResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "trv:Receivers", 1, NULL))
			{	if (a->Receivers == NULL)
				{	if (soap_blist_Receivers == NULL)
						soap_blist_Receivers = soap_new_block(soap);
					a->Receivers = (struct tt__Receiver *)soap_push_block(soap, soap_blist_Receivers, sizeof(struct tt__Receiver));
					if (a->Receivers == NULL)
						return NULL;
					soap_default_tt__Receiver(soap, a->Receivers);
				}
				soap_revert(soap);
				if (soap_in_tt__Receiver(soap, "trv:Receivers", a->Receivers, "tt:Receiver"))
				{	a->__sizeReceivers++;
					a->Receivers = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeReceivers");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Receivers)
			soap_pop_block(soap, soap_blist_Receivers);
		if (a->__sizeReceivers)
			a->Receivers = (struct tt__Receiver *)soap_save_block(soap, soap_blist_Receivers, NULL, 1);
		else
		{	a->Receivers = NULL;
			if (soap_blist_Receivers)
				soap_end_block(soap, soap_blist_Receivers);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceiversResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceiversResponse, 0, sizeof(struct _trv__GetReceiversResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetReceiversResponse(struct soap *soap, const struct _trv__GetReceiversResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trv__GetReceiversResponse);
	if (soap_out__trv__GetReceiversResponse(soap, tag?tag:"trv:GetReceiversResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceiversResponse * SOAP_FMAC4 soap_get__trv__GetReceiversResponse(struct soap *soap, struct _trv__GetReceiversResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetReceiversResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetReceivers(struct soap *soap, struct _trv__GetReceivers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetReceivers(struct soap *soap, const struct _trv__GetReceivers *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetReceivers(struct soap *soap, const char *tag, int id, const struct _trv__GetReceivers *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetReceivers), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetReceivers * SOAP_FMAC4 soap_in__trv__GetReceivers(struct soap *soap, const char *tag, struct _trv__GetReceivers *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__GetReceivers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetReceivers, sizeof(struct _trv__GetReceivers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetReceivers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__GetReceivers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetReceivers, 0, sizeof(struct _trv__GetReceivers), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetReceivers(struct soap *soap, const struct _trv__GetReceivers *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trv__GetReceivers);
	if (soap_out__trv__GetReceivers(soap, tag?tag:"trv:GetReceivers", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetReceivers * SOAP_FMAC4 soap_get__trv__GetReceivers(struct soap *soap, struct _trv__GetReceivers *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetReceivers(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetServiceCapabilitiesResponse(struct soap *soap, struct _trv__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trv__GetServiceCapabilitiesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotrv__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _trv__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "trv:Capabilities");
	if (a->Capabilities)
	{	if (soap_out_PointerTotrv__Capabilities(soap, "trv:Capabilities", -1, &a->Capabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "trv:Capabilities"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__trv__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _trv__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetServiceCapabilitiesResponse, sizeof(struct _trv__GetServiceCapabilitiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotrv__Capabilities(soap, "trv:Capabilities", &a->Capabilities, "trv:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "trv:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetServiceCapabilitiesResponse, 0, sizeof(struct _trv__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetServiceCapabilitiesResponse(struct soap *soap, const struct _trv__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trv__GetServiceCapabilitiesResponse);
	if (soap_out__trv__GetServiceCapabilitiesResponse(soap, tag?tag:"trv:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__trv__GetServiceCapabilitiesResponse(struct soap *soap, struct _trv__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__trv__GetServiceCapabilities(struct soap *soap, struct _trv__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__trv__GetServiceCapabilities(struct soap *soap, const struct _trv__GetServiceCapabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__trv__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _trv__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__trv__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilities * SOAP_FMAC4 soap_in__trv__GetServiceCapabilities(struct soap *soap, const char *tag, struct _trv__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _trv__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__trv__GetServiceCapabilities, sizeof(struct _trv__GetServiceCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__trv__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _trv__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__trv__GetServiceCapabilities, 0, sizeof(struct _trv__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__trv__GetServiceCapabilities(struct soap *soap, const struct _trv__GetServiceCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__trv__GetServiceCapabilities);
	if (soap_out__trv__GetServiceCapabilities(soap, tag?tag:"trv:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _trv__GetServiceCapabilities * SOAP_FMAC4 soap_get__trv__GetServiceCapabilities(struct soap *soap, struct _trv__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__trv__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_trv__Capabilities(struct soap *soap, struct trv__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->RTP_USCOREMulticast = NULL;
	a->RTP_USCORETCP = NULL;
	a->RTP_USCORERTSP_USCORETCP = NULL;
	soap_default_int(soap, &a->SupportedReceivers);
	a->MaximumRTSPURILength = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_trv__Capabilities(struct soap *soap, const struct trv__Capabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_trv__Capabilities(struct soap *soap, const char *tag, int id, const struct trv__Capabilities *a, const char *type)
{
	if (a->RTP_USCOREMulticast)
		soap_set_attr(soap, "RTP_Multicast", soap_xsd__boolean2s(soap, *a->RTP_USCOREMulticast), 1);
	if (a->RTP_USCORETCP)
		soap_set_attr(soap, "RTP_TCP", soap_xsd__boolean2s(soap, *a->RTP_USCORETCP), 1);
	if (a->RTP_USCORERTSP_USCORETCP)
		soap_set_attr(soap, "RTP_RTSP_TCP", soap_xsd__boolean2s(soap, *a->RTP_USCORERTSP_USCORETCP), 1);
	soap_set_attr(soap, "SupportedReceivers", soap_int2s(soap, a->SupportedReceivers), 1);
	if (a->MaximumRTSPURILength)
		soap_set_attr(soap, "MaximumRTSPURILength", soap_int2s(soap, *a->MaximumRTSPURILength), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_trv__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct trv__Capabilities * SOAP_FMAC4 soap_in_trv__Capabilities(struct soap *soap, const char *tag, struct trv__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct trv__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_trv__Capabilities, sizeof(struct trv__Capabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_trv__Capabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "RTP_Multicast", 0);
		if (t)
		{
			if (!(a->RTP_USCOREMulticast = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RTP_USCOREMulticast))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "RTP_TCP", 0);
		if (t)
		{
			if (!(a->RTP_USCORETCP = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RTP_USCORETCP))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "RTP_RTSP_TCP", 0);
		if (t)
		{
			if (!(a->RTP_USCORERTSP_USCORETCP = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RTP_USCORERTSP_USCORETCP))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2int(soap, soap_attr_value(soap, "SupportedReceivers", 1), &a->SupportedReceivers))
		return NULL;
	{	const char *t = soap_attr_value(soap, "MaximumRTSPURILength", 0);
		if (t)
		{
			if (!(a->MaximumRTSPURILength = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaximumRTSPURILength))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct trv__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_trv__Capabilities, 0, sizeof(struct trv__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_trv__Capabilities(struct soap *soap, const struct trv__Capabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_trv__Capabilities);
	if (soap_out_trv__Capabilities(soap, tag?tag:"trv:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct trv__Capabilities * SOAP_FMAC4 soap_get_trv__Capabilities(struct soap *soap, struct trv__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_trv__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__RemovePresetTourResponse(struct soap *soap, struct _tptz__RemovePresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__RemovePresetTourResponse(struct soap *soap, const struct _tptz__RemovePresetTourResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RemovePresetTourResponse(struct soap *soap, const char *tag, int id, const struct _tptz__RemovePresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RemovePresetTourResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__RemovePresetTourResponse * SOAP_FMAC4 soap_in__tptz__RemovePresetTourResponse(struct soap *soap, const char *tag, struct _tptz__RemovePresetTourResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__RemovePresetTourResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePresetTourResponse, sizeof(struct _tptz__RemovePresetTourResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__RemovePresetTourResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__RemovePresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePresetTourResponse, 0, sizeof(struct _tptz__RemovePresetTourResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__RemovePresetTourResponse(struct soap *soap, const struct _tptz__RemovePresetTourResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__RemovePresetTourResponse);
	if (soap_out__tptz__RemovePresetTourResponse(soap, tag?tag:"tptz:RemovePresetTourResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePresetTourResponse * SOAP_FMAC4 soap_get__tptz__RemovePresetTourResponse(struct soap *soap, struct _tptz__RemovePresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RemovePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__RemovePresetTour(struct soap *soap, struct _tptz__RemovePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetTourToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__RemovePresetTour(struct soap *soap, const struct _tptz__RemovePresetTour *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, &a->PresetTourToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RemovePresetTour(struct soap *soap, const char *tag, int id, const struct _tptz__RemovePresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RemovePresetTour), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ProfileToken"))
		return soap->error;
	if (a->PresetTourToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetTourToken", -1, &a->PresetTourToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:PresetTourToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__RemovePresetTour * SOAP_FMAC4 soap_in__tptz__RemovePresetTour(struct soap *soap, const char *tag, struct _tptz__RemovePresetTour *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetTourToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__RemovePresetTour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePresetTour, sizeof(struct _tptz__RemovePresetTour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__RemovePresetTour(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PresetTourToken", &a->PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__RemovePresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePresetTour, 0, sizeof(struct _tptz__RemovePresetTour), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_PresetTourToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__RemovePresetTour(struct soap *soap, const struct _tptz__RemovePresetTour *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__RemovePresetTour);
	if (soap_out__tptz__RemovePresetTour(soap, tag?tag:"tptz:RemovePresetTour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePresetTour * SOAP_FMAC4 soap_get__tptz__RemovePresetTour(struct soap *soap, struct _tptz__RemovePresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RemovePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__OperatePresetTourResponse(struct soap *soap, struct _tptz__OperatePresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__OperatePresetTourResponse(struct soap *soap, const struct _tptz__OperatePresetTourResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__OperatePresetTourResponse(struct soap *soap, const char *tag, int id, const struct _tptz__OperatePresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__OperatePresetTourResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__OperatePresetTourResponse * SOAP_FMAC4 soap_in__tptz__OperatePresetTourResponse(struct soap *soap, const char *tag, struct _tptz__OperatePresetTourResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__OperatePresetTourResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__OperatePresetTourResponse, sizeof(struct _tptz__OperatePresetTourResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__OperatePresetTourResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__OperatePresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__OperatePresetTourResponse, 0, sizeof(struct _tptz__OperatePresetTourResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__OperatePresetTourResponse(struct soap *soap, const struct _tptz__OperatePresetTourResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__OperatePresetTourResponse);
	if (soap_out__tptz__OperatePresetTourResponse(soap, tag?tag:"tptz:OperatePresetTourResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__OperatePresetTourResponse * SOAP_FMAC4 soap_get__tptz__OperatePresetTourResponse(struct soap *soap, struct _tptz__OperatePresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__OperatePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__OperatePresetTour(struct soap *soap, struct _tptz__OperatePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetTourToken);
	soap_default_tt__PTZPresetTourOperation(soap, &a->Operation);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__OperatePresetTour(struct soap *soap, const struct _tptz__OperatePresetTour *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, &a->PresetTourToken);
	soap_embedded(soap, &a->Operation, SOAP_TYPE_tt__PTZPresetTourOperation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__OperatePresetTour(struct soap *soap, const char *tag, int id, const struct _tptz__OperatePresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__OperatePresetTour), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ProfileToken"))
		return soap->error;
	if (a->PresetTourToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetTourToken", -1, &a->PresetTourToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:PresetTourToken"))
		return soap->error;
	if (soap_out_tt__PTZPresetTourOperation(soap, "tptz:Operation", -1, &a->Operation, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__OperatePresetTour * SOAP_FMAC4 soap_in__tptz__OperatePresetTour(struct soap *soap, const char *tag, struct _tptz__OperatePresetTour *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetTourToken = 1;
	size_t soap_flag_Operation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__OperatePresetTour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__OperatePresetTour, sizeof(struct _tptz__OperatePresetTour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__OperatePresetTour(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PresetTourToken", &a->PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken--;
					continue;
				}
			if (soap_flag_Operation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__PTZPresetTourOperation(soap, "tptz:Operation", &a->Operation, "tt:PTZPresetTourOperation"))
				{	soap_flag_Operation--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__OperatePresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__OperatePresetTour, 0, sizeof(struct _tptz__OperatePresetTour), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_PresetTourToken > 0 || soap_flag_Operation > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__OperatePresetTour(struct soap *soap, const struct _tptz__OperatePresetTour *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__OperatePresetTour);
	if (soap_out__tptz__OperatePresetTour(soap, tag?tag:"tptz:OperatePresetTour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__OperatePresetTour * SOAP_FMAC4 soap_get__tptz__OperatePresetTour(struct soap *soap, struct _tptz__OperatePresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__OperatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__ModifyPresetTourResponse(struct soap *soap, struct _tptz__ModifyPresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__ModifyPresetTourResponse(struct soap *soap, const struct _tptz__ModifyPresetTourResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__ModifyPresetTourResponse(struct soap *soap, const char *tag, int id, const struct _tptz__ModifyPresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__ModifyPresetTourResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTourResponse * SOAP_FMAC4 soap_in__tptz__ModifyPresetTourResponse(struct soap *soap, const char *tag, struct _tptz__ModifyPresetTourResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__ModifyPresetTourResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ModifyPresetTourResponse, sizeof(struct _tptz__ModifyPresetTourResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__ModifyPresetTourResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__ModifyPresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ModifyPresetTourResponse, 0, sizeof(struct _tptz__ModifyPresetTourResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__ModifyPresetTourResponse(struct soap *soap, const struct _tptz__ModifyPresetTourResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__ModifyPresetTourResponse);
	if (soap_out__tptz__ModifyPresetTourResponse(soap, tag?tag:"tptz:ModifyPresetTourResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTourResponse * SOAP_FMAC4 soap_get__tptz__ModifyPresetTourResponse(struct soap *soap, struct _tptz__ModifyPresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__ModifyPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__ModifyPresetTour(struct soap *soap, struct _tptz__ModifyPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->PresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__ModifyPresetTour(struct soap *soap, const struct _tptz__ModifyPresetTour *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_PointerTott__PresetTour(soap, &a->PresetTour);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__ModifyPresetTour(struct soap *soap, const char *tag, int id, const struct _tptz__ModifyPresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__ModifyPresetTour), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ProfileToken"))
		return soap->error;
	if (a->PresetTour)
	{	if (soap_out_PointerTott__PresetTour(soap, "tptz:PresetTour", -1, &a->PresetTour, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:PresetTour"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTour * SOAP_FMAC4 soap_in__tptz__ModifyPresetTour(struct soap *soap, const char *tag, struct _tptz__ModifyPresetTour *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetTour = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__ModifyPresetTour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ModifyPresetTour, sizeof(struct _tptz__ModifyPresetTour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__ModifyPresetTour(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_PresetTour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PresetTour(soap, "tptz:PresetTour", &a->PresetTour, "tt:PresetTour"))
				{	soap_flag_PresetTour--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__ModifyPresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ModifyPresetTour, 0, sizeof(struct _tptz__ModifyPresetTour), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_PresetTour > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__ModifyPresetTour(struct soap *soap, const struct _tptz__ModifyPresetTour *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__ModifyPresetTour);
	if (soap_out__tptz__ModifyPresetTour(soap, tag?tag:"tptz:ModifyPresetTour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ModifyPresetTour * SOAP_FMAC4 soap_get__tptz__ModifyPresetTour(struct soap *soap, struct _tptz__ModifyPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__ModifyPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__CreatePresetTourResponse(struct soap *soap, struct _tptz__CreatePresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->PresetTourToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__CreatePresetTourResponse(struct soap *soap, const struct _tptz__CreatePresetTourResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->PresetTourToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__CreatePresetTourResponse(struct soap *soap, const char *tag, int id, const struct _tptz__CreatePresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__CreatePresetTourResponse), type))
		return soap->error;
	if (a->PresetTourToken)
		soap_element_result(soap, "tptz:PresetTourToken");
	if (a->PresetTourToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetTourToken", -1, &a->PresetTourToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:PresetTourToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__CreatePresetTourResponse * SOAP_FMAC4 soap_in__tptz__CreatePresetTourResponse(struct soap *soap, const char *tag, struct _tptz__CreatePresetTourResponse *a, const char *type)
{
	size_t soap_flag_PresetTourToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__CreatePresetTourResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__CreatePresetTourResponse, sizeof(struct _tptz__CreatePresetTourResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__CreatePresetTourResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PresetTourToken", &a->PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken--;
					continue;
				}
			soap_check_result(soap, "tptz:PresetTourToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__CreatePresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__CreatePresetTourResponse, 0, sizeof(struct _tptz__CreatePresetTourResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PresetTourToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__CreatePresetTourResponse(struct soap *soap, const struct _tptz__CreatePresetTourResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__CreatePresetTourResponse);
	if (soap_out__tptz__CreatePresetTourResponse(soap, tag?tag:"tptz:CreatePresetTourResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__CreatePresetTourResponse * SOAP_FMAC4 soap_get__tptz__CreatePresetTourResponse(struct soap *soap, struct _tptz__CreatePresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__CreatePresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__CreatePresetTour(struct soap *soap, struct _tptz__CreatePresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__CreatePresetTour(struct soap *soap, const struct _tptz__CreatePresetTour *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__CreatePresetTour(struct soap *soap, const char *tag, int id, const struct _tptz__CreatePresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__CreatePresetTour), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__CreatePresetTour * SOAP_FMAC4 soap_in__tptz__CreatePresetTour(struct soap *soap, const char *tag, struct _tptz__CreatePresetTour *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__CreatePresetTour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__CreatePresetTour, sizeof(struct _tptz__CreatePresetTour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__CreatePresetTour(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__CreatePresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__CreatePresetTour, 0, sizeof(struct _tptz__CreatePresetTour), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__CreatePresetTour(struct soap *soap, const struct _tptz__CreatePresetTour *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__CreatePresetTour);
	if (soap_out__tptz__CreatePresetTour(soap, tag?tag:"tptz:CreatePresetTour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__CreatePresetTour * SOAP_FMAC4 soap_get__tptz__CreatePresetTour(struct soap *soap, struct _tptz__CreatePresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__CreatePresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetTourOptionsResponse(struct soap *soap, struct _tptz__GetPresetTourOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Options = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetTourOptionsResponse(struct soap *soap, const struct _tptz__GetPresetTourOptionsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__PTZPresetTourOptions(soap, &a->Options);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTourOptionsResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetTourOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTourOptionsResponse), type))
		return soap->error;
	if (a->Options)
		soap_element_result(soap, "tptz:Options");
	if (a->Options)
	{	if (soap_out_PointerTott__PTZPresetTourOptions(soap, "tptz:Options", -1, &a->Options, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:Options"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptionsResponse * SOAP_FMAC4 soap_in__tptz__GetPresetTourOptionsResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetTourOptionsResponse *a, const char *type)
{
	size_t soap_flag_Options = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetPresetTourOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, sizeof(struct _tptz__GetPresetTourOptionsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetTourOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Options && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZPresetTourOptions(soap, "tptz:Options", &a->Options, "tt:PTZPresetTourOptions"))
				{	soap_flag_Options--;
					continue;
				}
			soap_check_result(soap, "tptz:Options");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTourOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTourOptionsResponse, 0, sizeof(struct _tptz__GetPresetTourOptionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Options > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetTourOptionsResponse(struct soap *soap, const struct _tptz__GetPresetTourOptionsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetPresetTourOptionsResponse);
	if (soap_out__tptz__GetPresetTourOptionsResponse(soap, tag?tag:"tptz:GetPresetTourOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptionsResponse * SOAP_FMAC4 soap_get__tptz__GetPresetTourOptionsResponse(struct soap *soap, struct _tptz__GetPresetTourOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTourOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetTourOptions(struct soap *soap, struct _tptz__GetPresetTourOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetTourToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetTourOptions(struct soap *soap, const struct _tptz__GetPresetTourOptions *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, &a->PresetTourToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTourOptions(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetTourOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTourOptions), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ProfileToken"))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetTourToken", -1, &a->PresetTourToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptions * SOAP_FMAC4 soap_in__tptz__GetPresetTourOptions(struct soap *soap, const char *tag, struct _tptz__GetPresetTourOptions *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetTourToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetPresetTourOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTourOptions, sizeof(struct _tptz__GetPresetTourOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetTourOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PresetTourToken", &a->PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTourOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTourOptions, 0, sizeof(struct _tptz__GetPresetTourOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetTourOptions(struct soap *soap, const struct _tptz__GetPresetTourOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetPresetTourOptions);
	if (soap_out__tptz__GetPresetTourOptions(soap, tag?tag:"tptz:GetPresetTourOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTourOptions * SOAP_FMAC4 soap_get__tptz__GetPresetTourOptions(struct soap *soap, struct _tptz__GetPresetTourOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTourOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetTourResponse(struct soap *soap, struct _tptz__GetPresetTourResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetTourResponse(struct soap *soap, const struct _tptz__GetPresetTourResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__PresetTour(soap, &a->PresetTour);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTourResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetTourResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTourResponse), type))
		return soap->error;
	if (a->PresetTour)
		soap_element_result(soap, "tptz:PresetTour");
	if (a->PresetTour)
	{	if (soap_out_PointerTott__PresetTour(soap, "tptz:PresetTour", -1, &a->PresetTour, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:PresetTour"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetTourResponse * SOAP_FMAC4 soap_in__tptz__GetPresetTourResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetTourResponse *a, const char *type)
{
	size_t soap_flag_PresetTour = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetPresetTourResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTourResponse, sizeof(struct _tptz__GetPresetTourResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetTourResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PresetTour && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PresetTour(soap, "tptz:PresetTour", &a->PresetTour, "tt:PresetTour"))
				{	soap_flag_PresetTour--;
					continue;
				}
			soap_check_result(soap, "tptz:PresetTour");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTourResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTourResponse, 0, sizeof(struct _tptz__GetPresetTourResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PresetTour > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetTourResponse(struct soap *soap, const struct _tptz__GetPresetTourResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetPresetTourResponse);
	if (soap_out__tptz__GetPresetTourResponse(soap, tag?tag:"tptz:GetPresetTourResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTourResponse * SOAP_FMAC4 soap_get__tptz__GetPresetTourResponse(struct soap *soap, struct _tptz__GetPresetTourResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTourResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetTour(struct soap *soap, struct _tptz__GetPresetTour *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetTourToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetTour(struct soap *soap, const struct _tptz__GetPresetTour *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, &a->PresetTourToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTour(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetTour *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTour), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ProfileToken"))
		return soap->error;
	if (a->PresetTourToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetTourToken", -1, &a->PresetTourToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:PresetTourToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetTour * SOAP_FMAC4 soap_in__tptz__GetPresetTour(struct soap *soap, const char *tag, struct _tptz__GetPresetTour *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetTourToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetPresetTour *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTour, sizeof(struct _tptz__GetPresetTour), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetTour(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_PresetTourToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PresetTourToken", &a->PresetTourToken, "tt:ReferenceToken"))
				{	soap_flag_PresetTourToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTour *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTour, 0, sizeof(struct _tptz__GetPresetTour), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_PresetTourToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetTour(struct soap *soap, const struct _tptz__GetPresetTour *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetPresetTour);
	if (soap_out__tptz__GetPresetTour(soap, tag?tag:"tptz:GetPresetTour", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTour * SOAP_FMAC4 soap_get__tptz__GetPresetTour(struct soap *soap, struct _tptz__GetPresetTour *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTour(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetToursResponse(struct soap *soap, struct _tptz__GetPresetToursResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePresetTour = 0;
	a->PresetTour = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetToursResponse(struct soap *soap, const struct _tptz__GetPresetToursResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->PresetTour)
	{	int i;
		for (i = 0; i < a->__sizePresetTour; i++)
		{
			soap_embedded(soap, a->PresetTour + i, SOAP_TYPE_tt__PresetTour);
			soap_serialize_tt__PresetTour(soap, a->PresetTour + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetToursResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetToursResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetToursResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizePresetTour");
	if (a->PresetTour)
	{	int i;
		for (i = 0; i < a->__sizePresetTour; i++)
			if (soap_out_tt__PresetTour(soap, "tptz:PresetTour", -1, a->PresetTour + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetToursResponse * SOAP_FMAC4 soap_in__tptz__GetPresetToursResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetToursResponse *a, const char *type)
{
	struct soap_blist *soap_blist_PresetTour = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetPresetToursResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetToursResponse, sizeof(struct _tptz__GetPresetToursResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetToursResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tptz:PresetTour", 1, NULL))
			{	if (a->PresetTour == NULL)
				{	if (soap_blist_PresetTour == NULL)
						soap_blist_PresetTour = soap_new_block(soap);
					a->PresetTour = (struct tt__PresetTour *)soap_push_block(soap, soap_blist_PresetTour, sizeof(struct tt__PresetTour));
					if (a->PresetTour == NULL)
						return NULL;
					soap_default_tt__PresetTour(soap, a->PresetTour);
				}
				soap_revert(soap);
				if (soap_in_tt__PresetTour(soap, "tptz:PresetTour", a->PresetTour, "tt:PresetTour"))
				{	a->__sizePresetTour++;
					a->PresetTour = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizePresetTour");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PresetTour)
			soap_pop_block(soap, soap_blist_PresetTour);
		if (a->__sizePresetTour)
			a->PresetTour = (struct tt__PresetTour *)soap_save_block(soap, soap_blist_PresetTour, NULL, 1);
		else
		{	a->PresetTour = NULL;
			if (soap_blist_PresetTour)
				soap_end_block(soap, soap_blist_PresetTour);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetToursResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetToursResponse, 0, sizeof(struct _tptz__GetPresetToursResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetToursResponse(struct soap *soap, const struct _tptz__GetPresetToursResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetPresetToursResponse);
	if (soap_out__tptz__GetPresetToursResponse(soap, tag?tag:"tptz:GetPresetToursResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetToursResponse * SOAP_FMAC4 soap_get__tptz__GetPresetToursResponse(struct soap *soap, struct _tptz__GetPresetToursResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetToursResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetTours(struct soap *soap, struct _tptz__GetPresetTours *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetTours(struct soap *soap, const struct _tptz__GetPresetTours *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetTours(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetTours *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetTours), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetTours * SOAP_FMAC4 soap_in__tptz__GetPresetTours(struct soap *soap, const char *tag, struct _tptz__GetPresetTours *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetPresetTours *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetTours, sizeof(struct _tptz__GetPresetTours), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetTours(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetTours *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetTours, 0, sizeof(struct _tptz__GetPresetTours), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetTours(struct soap *soap, const struct _tptz__GetPresetTours *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetPresetTours);
	if (soap_out__tptz__GetPresetTours(soap, tag?tag:"tptz:GetPresetTours", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetTours * SOAP_FMAC4 soap_get__tptz__GetPresetTours(struct soap *soap, struct _tptz__GetPresetTours *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetTours(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__StopResponse(struct soap *soap, struct _tptz__StopResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__StopResponse(struct soap *soap, const struct _tptz__StopResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__StopResponse(struct soap *soap, const char *tag, int id, const struct _tptz__StopResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__StopResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__StopResponse * SOAP_FMAC4 soap_in__tptz__StopResponse(struct soap *soap, const char *tag, struct _tptz__StopResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__StopResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__StopResponse, sizeof(struct _tptz__StopResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__StopResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__StopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__StopResponse, 0, sizeof(struct _tptz__StopResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__StopResponse(struct soap *soap, const struct _tptz__StopResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__StopResponse);
	if (soap_out__tptz__StopResponse(soap, tag?tag:"tptz:StopResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__StopResponse * SOAP_FMAC4 soap_get__tptz__StopResponse(struct soap *soap, struct _tptz__StopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__StopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__Stop(struct soap *soap, struct _tptz__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->PanTilt = NULL;
	a->Zoom = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__Stop(struct soap *soap, const struct _tptz__Stop *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_PointerToxsd__boolean(soap, &a->PanTilt);
	soap_serialize_PointerToxsd__boolean(soap, &a->Zoom);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__Stop(struct soap *soap, const char *tag, int id, const struct _tptz__Stop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__Stop), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ProfileToken"))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tptz:PanTilt", -1, &a->PanTilt, ""))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "tptz:Zoom", -1, &a->Zoom, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__Stop * SOAP_FMAC4 soap_in__tptz__Stop(struct soap *soap, const char *tag, struct _tptz__Stop *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PanTilt = 1;
	size_t soap_flag_Zoom = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__Stop *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__Stop, sizeof(struct _tptz__Stop), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__Stop(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_PanTilt && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tptz:PanTilt", &a->PanTilt, "xsd:boolean"))
				{	soap_flag_PanTilt--;
					continue;
				}
			if (soap_flag_Zoom && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "tptz:Zoom", &a->Zoom, "xsd:boolean"))
				{	soap_flag_Zoom--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__Stop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__Stop, 0, sizeof(struct _tptz__Stop), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__Stop(struct soap *soap, const struct _tptz__Stop *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__Stop);
	if (soap_out__tptz__Stop(soap, tag?tag:"tptz:Stop", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__Stop * SOAP_FMAC4 soap_get__tptz__Stop(struct soap *soap, struct _tptz__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__AbsoluteMoveResponse(struct soap *soap, struct _tptz__AbsoluteMoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__AbsoluteMoveResponse(struct soap *soap, const struct _tptz__AbsoluteMoveResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__AbsoluteMoveResponse(struct soap *soap, const char *tag, int id, const struct _tptz__AbsoluteMoveResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__AbsoluteMoveResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__AbsoluteMoveResponse * SOAP_FMAC4 soap_in__tptz__AbsoluteMoveResponse(struct soap *soap, const char *tag, struct _tptz__AbsoluteMoveResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__AbsoluteMoveResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__AbsoluteMoveResponse, sizeof(struct _tptz__AbsoluteMoveResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__AbsoluteMoveResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__AbsoluteMoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__AbsoluteMoveResponse, 0, sizeof(struct _tptz__AbsoluteMoveResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__AbsoluteMoveResponse(struct soap *soap, const struct _tptz__AbsoluteMoveResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__AbsoluteMoveResponse);
	if (soap_out__tptz__AbsoluteMoveResponse(soap, tag?tag:"tptz:AbsoluteMoveResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__AbsoluteMoveResponse * SOAP_FMAC4 soap_get__tptz__AbsoluteMoveResponse(struct soap *soap, struct _tptz__AbsoluteMoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__AbsoluteMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__AbsoluteMove(struct soap *soap, struct _tptz__AbsoluteMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->Position = NULL;
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__AbsoluteMove(struct soap *soap, const struct _tptz__AbsoluteMove *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_PointerTott__PTZVector(soap, &a->Position);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->Speed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__AbsoluteMove(struct soap *soap, const char *tag, int id, const struct _tptz__AbsoluteMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__AbsoluteMove), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ProfileToken"))
		return soap->error;
	if (a->Position)
	{	if (soap_out_PointerTott__PTZVector(soap, "tptz:Position", -1, &a->Position, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:Position"))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__AbsoluteMove * SOAP_FMAC4 soap_in__tptz__AbsoluteMove(struct soap *soap, const char *tag, struct _tptz__AbsoluteMove *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_Position = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__AbsoluteMove *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__AbsoluteMove, sizeof(struct _tptz__AbsoluteMove), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__AbsoluteMove(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_Position && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZVector(soap, "tptz:Position", &a->Position, "tt:PTZVector"))
				{	soap_flag_Position--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__AbsoluteMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__AbsoluteMove, 0, sizeof(struct _tptz__AbsoluteMove), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_Position > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__AbsoluteMove(struct soap *soap, const struct _tptz__AbsoluteMove *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__AbsoluteMove);
	if (soap_out__tptz__AbsoluteMove(soap, tag?tag:"tptz:AbsoluteMove", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__AbsoluteMove * SOAP_FMAC4 soap_get__tptz__AbsoluteMove(struct soap *soap, struct _tptz__AbsoluteMove *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__AbsoluteMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__RelativeMoveResponse(struct soap *soap, struct _tptz__RelativeMoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__RelativeMoveResponse(struct soap *soap, const struct _tptz__RelativeMoveResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RelativeMoveResponse(struct soap *soap, const char *tag, int id, const struct _tptz__RelativeMoveResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RelativeMoveResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__RelativeMoveResponse * SOAP_FMAC4 soap_in__tptz__RelativeMoveResponse(struct soap *soap, const char *tag, struct _tptz__RelativeMoveResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__RelativeMoveResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RelativeMoveResponse, sizeof(struct _tptz__RelativeMoveResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__RelativeMoveResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__RelativeMoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RelativeMoveResponse, 0, sizeof(struct _tptz__RelativeMoveResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__RelativeMoveResponse(struct soap *soap, const struct _tptz__RelativeMoveResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__RelativeMoveResponse);
	if (soap_out__tptz__RelativeMoveResponse(soap, tag?tag:"tptz:RelativeMoveResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RelativeMoveResponse * SOAP_FMAC4 soap_get__tptz__RelativeMoveResponse(struct soap *soap, struct _tptz__RelativeMoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RelativeMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__RelativeMove(struct soap *soap, struct _tptz__RelativeMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->Translation = NULL;
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__RelativeMove(struct soap *soap, const struct _tptz__RelativeMove *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_PointerTott__PTZVector(soap, &a->Translation);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->Speed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RelativeMove(struct soap *soap, const char *tag, int id, const struct _tptz__RelativeMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RelativeMove), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ProfileToken"))
		return soap->error;
	if (a->Translation)
	{	if (soap_out_PointerTott__PTZVector(soap, "tptz:Translation", -1, &a->Translation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:Translation"))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__RelativeMove * SOAP_FMAC4 soap_in__tptz__RelativeMove(struct soap *soap, const char *tag, struct _tptz__RelativeMove *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_Translation = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__RelativeMove *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RelativeMove, sizeof(struct _tptz__RelativeMove), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__RelativeMove(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_Translation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZVector(soap, "tptz:Translation", &a->Translation, "tt:PTZVector"))
				{	soap_flag_Translation--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__RelativeMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RelativeMove, 0, sizeof(struct _tptz__RelativeMove), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_Translation > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__RelativeMove(struct soap *soap, const struct _tptz__RelativeMove *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__RelativeMove);
	if (soap_out__tptz__RelativeMove(soap, tag?tag:"tptz:RelativeMove", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RelativeMove * SOAP_FMAC4 soap_get__tptz__RelativeMove(struct soap *soap, struct _tptz__RelativeMove *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RelativeMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__ContinuousMoveResponse(struct soap *soap, struct _tptz__ContinuousMoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__ContinuousMoveResponse(struct soap *soap, const struct _tptz__ContinuousMoveResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__ContinuousMoveResponse(struct soap *soap, const char *tag, int id, const struct _tptz__ContinuousMoveResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__ContinuousMoveResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__ContinuousMoveResponse * SOAP_FMAC4 soap_in__tptz__ContinuousMoveResponse(struct soap *soap, const char *tag, struct _tptz__ContinuousMoveResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__ContinuousMoveResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ContinuousMoveResponse, sizeof(struct _tptz__ContinuousMoveResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__ContinuousMoveResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__ContinuousMoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ContinuousMoveResponse, 0, sizeof(struct _tptz__ContinuousMoveResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__ContinuousMoveResponse(struct soap *soap, const struct _tptz__ContinuousMoveResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__ContinuousMoveResponse);
	if (soap_out__tptz__ContinuousMoveResponse(soap, tag?tag:"tptz:ContinuousMoveResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ContinuousMoveResponse * SOAP_FMAC4 soap_get__tptz__ContinuousMoveResponse(struct soap *soap, struct _tptz__ContinuousMoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__ContinuousMoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__ContinuousMove(struct soap *soap, struct _tptz__ContinuousMove *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->Velocity = NULL;
	a->Timeout = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__ContinuousMove(struct soap *soap, const struct _tptz__ContinuousMove *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->Velocity);
	soap_serialize_PointerToxsd__duration(soap, &a->Timeout);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__ContinuousMove(struct soap *soap, const char *tag, int id, const struct _tptz__ContinuousMove *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__ContinuousMove), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ProfileToken"))
		return soap->error;
	if (a->Velocity)
	{	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Velocity", -1, &a->Velocity, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:Velocity"))
		return soap->error;
	if (soap_out_PointerToxsd__duration(soap, "tptz:Timeout", -1, &a->Timeout, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__ContinuousMove * SOAP_FMAC4 soap_in__tptz__ContinuousMove(struct soap *soap, const char *tag, struct _tptz__ContinuousMove *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_Velocity = 1;
	size_t soap_flag_Timeout = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__ContinuousMove *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__ContinuousMove, sizeof(struct _tptz__ContinuousMove), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__ContinuousMove(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_Velocity && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Velocity", &a->Velocity, "tt:PTZSpeed"))
				{	soap_flag_Velocity--;
					continue;
				}
			if (soap_flag_Timeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__duration(soap, "tptz:Timeout", &a->Timeout, "xsd:duration"))
				{	soap_flag_Timeout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__ContinuousMove *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__ContinuousMove, 0, sizeof(struct _tptz__ContinuousMove), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_Velocity > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__ContinuousMove(struct soap *soap, const struct _tptz__ContinuousMove *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__ContinuousMove);
	if (soap_out__tptz__ContinuousMove(soap, tag?tag:"tptz:ContinuousMove", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__ContinuousMove * SOAP_FMAC4 soap_get__tptz__ContinuousMove(struct soap *soap, struct _tptz__ContinuousMove *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__ContinuousMove(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SetHomePositionResponse(struct soap *soap, struct _tptz__SetHomePositionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SetHomePositionResponse(struct soap *soap, const struct _tptz__SetHomePositionResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetHomePositionResponse(struct soap *soap, const char *tag, int id, const struct _tptz__SetHomePositionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetHomePositionResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SetHomePositionResponse * SOAP_FMAC4 soap_in__tptz__SetHomePositionResponse(struct soap *soap, const char *tag, struct _tptz__SetHomePositionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__SetHomePositionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetHomePositionResponse, sizeof(struct _tptz__SetHomePositionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SetHomePositionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetHomePositionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetHomePositionResponse, 0, sizeof(struct _tptz__SetHomePositionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SetHomePositionResponse(struct soap *soap, const struct _tptz__SetHomePositionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__SetHomePositionResponse);
	if (soap_out__tptz__SetHomePositionResponse(soap, tag?tag:"tptz:SetHomePositionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetHomePositionResponse * SOAP_FMAC4 soap_get__tptz__SetHomePositionResponse(struct soap *soap, struct _tptz__SetHomePositionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetHomePositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SetHomePosition(struct soap *soap, struct _tptz__SetHomePosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SetHomePosition(struct soap *soap, const struct _tptz__SetHomePosition *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetHomePosition(struct soap *soap, const char *tag, int id, const struct _tptz__SetHomePosition *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetHomePosition), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SetHomePosition * SOAP_FMAC4 soap_in__tptz__SetHomePosition(struct soap *soap, const char *tag, struct _tptz__SetHomePosition *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__SetHomePosition *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetHomePosition, sizeof(struct _tptz__SetHomePosition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SetHomePosition(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetHomePosition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetHomePosition, 0, sizeof(struct _tptz__SetHomePosition), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SetHomePosition(struct soap *soap, const struct _tptz__SetHomePosition *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__SetHomePosition);
	if (soap_out__tptz__SetHomePosition(soap, tag?tag:"tptz:SetHomePosition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetHomePosition * SOAP_FMAC4 soap_get__tptz__SetHomePosition(struct soap *soap, struct _tptz__SetHomePosition *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GotoHomePositionResponse(struct soap *soap, struct _tptz__GotoHomePositionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GotoHomePositionResponse(struct soap *soap, const struct _tptz__GotoHomePositionResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GotoHomePositionResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GotoHomePositionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GotoHomePositionResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GotoHomePositionResponse * SOAP_FMAC4 soap_in__tptz__GotoHomePositionResponse(struct soap *soap, const char *tag, struct _tptz__GotoHomePositionResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GotoHomePositionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoHomePositionResponse, sizeof(struct _tptz__GotoHomePositionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GotoHomePositionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GotoHomePositionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoHomePositionResponse, 0, sizeof(struct _tptz__GotoHomePositionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GotoHomePositionResponse(struct soap *soap, const struct _tptz__GotoHomePositionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GotoHomePositionResponse);
	if (soap_out__tptz__GotoHomePositionResponse(soap, tag?tag:"tptz:GotoHomePositionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoHomePositionResponse * SOAP_FMAC4 soap_get__tptz__GotoHomePositionResponse(struct soap *soap, struct _tptz__GotoHomePositionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GotoHomePositionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GotoHomePosition(struct soap *soap, struct _tptz__GotoHomePosition *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GotoHomePosition(struct soap *soap, const struct _tptz__GotoHomePosition *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->Speed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GotoHomePosition(struct soap *soap, const char *tag, int id, const struct _tptz__GotoHomePosition *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GotoHomePosition), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ProfileToken"))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GotoHomePosition * SOAP_FMAC4 soap_in__tptz__GotoHomePosition(struct soap *soap, const char *tag, struct _tptz__GotoHomePosition *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GotoHomePosition *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoHomePosition, sizeof(struct _tptz__GotoHomePosition), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GotoHomePosition(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GotoHomePosition *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoHomePosition, 0, sizeof(struct _tptz__GotoHomePosition), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GotoHomePosition(struct soap *soap, const struct _tptz__GotoHomePosition *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GotoHomePosition);
	if (soap_out__tptz__GotoHomePosition(soap, tag?tag:"tptz:GotoHomePosition", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoHomePosition * SOAP_FMAC4 soap_get__tptz__GotoHomePosition(struct soap *soap, struct _tptz__GotoHomePosition *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GotoHomePosition(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetStatusResponse(struct soap *soap, struct _tptz__GetStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetStatusResponse(struct soap *soap, const struct _tptz__GetStatusResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__PTZStatus(soap, &a->PTZStatus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetStatusResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetStatusResponse), type))
		return soap->error;
	if (a->PTZStatus)
		soap_element_result(soap, "tptz:PTZStatus");
	if (a->PTZStatus)
	{	if (soap_out_PointerTott__PTZStatus(soap, "tptz:PTZStatus", -1, &a->PTZStatus, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:PTZStatus"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetStatusResponse * SOAP_FMAC4 soap_in__tptz__GetStatusResponse(struct soap *soap, const char *tag, struct _tptz__GetStatusResponse *a, const char *type)
{
	size_t soap_flag_PTZStatus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetStatusResponse, sizeof(struct _tptz__GetStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZStatus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZStatus(soap, "tptz:PTZStatus", &a->PTZStatus, "tt:PTZStatus"))
				{	soap_flag_PTZStatus--;
					continue;
				}
			soap_check_result(soap, "tptz:PTZStatus");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetStatusResponse, 0, sizeof(struct _tptz__GetStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PTZStatus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetStatusResponse(struct soap *soap, const struct _tptz__GetStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetStatusResponse);
	if (soap_out__tptz__GetStatusResponse(soap, tag?tag:"tptz:GetStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetStatusResponse * SOAP_FMAC4 soap_get__tptz__GetStatusResponse(struct soap *soap, struct _tptz__GetStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetStatus(struct soap *soap, struct _tptz__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetStatus(struct soap *soap, const struct _tptz__GetStatus *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetStatus(struct soap *soap, const char *tag, int id, const struct _tptz__GetStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetStatus), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetStatus * SOAP_FMAC4 soap_in__tptz__GetStatus(struct soap *soap, const char *tag, struct _tptz__GetStatus *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetStatus, sizeof(struct _tptz__GetStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetStatus, 0, sizeof(struct _tptz__GetStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetStatus(struct soap *soap, const struct _tptz__GetStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetStatus);
	if (soap_out__tptz__GetStatus(soap, tag?tag:"tptz:GetStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetStatus * SOAP_FMAC4 soap_get__tptz__GetStatus(struct soap *soap, struct _tptz__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GotoPresetResponse(struct soap *soap, struct _tptz__GotoPresetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GotoPresetResponse(struct soap *soap, const struct _tptz__GotoPresetResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GotoPresetResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GotoPresetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GotoPresetResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GotoPresetResponse * SOAP_FMAC4 soap_in__tptz__GotoPresetResponse(struct soap *soap, const char *tag, struct _tptz__GotoPresetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GotoPresetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoPresetResponse, sizeof(struct _tptz__GotoPresetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GotoPresetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GotoPresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoPresetResponse, 0, sizeof(struct _tptz__GotoPresetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GotoPresetResponse(struct soap *soap, const struct _tptz__GotoPresetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GotoPresetResponse);
	if (soap_out__tptz__GotoPresetResponse(soap, tag?tag:"tptz:GotoPresetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoPresetResponse * SOAP_FMAC4 soap_get__tptz__GotoPresetResponse(struct soap *soap, struct _tptz__GotoPresetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GotoPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GotoPreset(struct soap *soap, struct _tptz__GotoPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetToken);
	a->Speed = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GotoPreset(struct soap *soap, const struct _tptz__GotoPreset *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, &a->PresetToken);
	soap_serialize_PointerTott__PTZSpeed(soap, &a->Speed);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GotoPreset(struct soap *soap, const char *tag, int id, const struct _tptz__GotoPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GotoPreset), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ProfileToken"))
		return soap->error;
	if (a->PresetToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetToken", -1, &a->PresetToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:PresetToken"))
		return soap->error;
	if (soap_out_PointerTott__PTZSpeed(soap, "tptz:Speed", -1, &a->Speed, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GotoPreset * SOAP_FMAC4 soap_in__tptz__GotoPreset(struct soap *soap, const char *tag, struct _tptz__GotoPreset *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetToken = 1;
	size_t soap_flag_Speed = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GotoPreset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GotoPreset, sizeof(struct _tptz__GotoPreset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GotoPreset(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_PresetToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PresetToken", &a->PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken--;
					continue;
				}
			if (soap_flag_Speed && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpeed(soap, "tptz:Speed", &a->Speed, "tt:PTZSpeed"))
				{	soap_flag_Speed--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GotoPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GotoPreset, 0, sizeof(struct _tptz__GotoPreset), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_PresetToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GotoPreset(struct soap *soap, const struct _tptz__GotoPreset *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GotoPreset);
	if (soap_out__tptz__GotoPreset(soap, tag?tag:"tptz:GotoPreset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GotoPreset * SOAP_FMAC4 soap_get__tptz__GotoPreset(struct soap *soap, struct _tptz__GotoPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GotoPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__RemovePresetResponse(struct soap *soap, struct _tptz__RemovePresetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__RemovePresetResponse(struct soap *soap, const struct _tptz__RemovePresetResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RemovePresetResponse(struct soap *soap, const char *tag, int id, const struct _tptz__RemovePresetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RemovePresetResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__RemovePresetResponse * SOAP_FMAC4 soap_in__tptz__RemovePresetResponse(struct soap *soap, const char *tag, struct _tptz__RemovePresetResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__RemovePresetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePresetResponse, sizeof(struct _tptz__RemovePresetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__RemovePresetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__RemovePresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePresetResponse, 0, sizeof(struct _tptz__RemovePresetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__RemovePresetResponse(struct soap *soap, const struct _tptz__RemovePresetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__RemovePresetResponse);
	if (soap_out__tptz__RemovePresetResponse(soap, tag?tag:"tptz:RemovePresetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePresetResponse * SOAP_FMAC4 soap_get__tptz__RemovePresetResponse(struct soap *soap, struct _tptz__RemovePresetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RemovePresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__RemovePreset(struct soap *soap, struct _tptz__RemovePreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__ReferenceToken(soap, &a->PresetToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__RemovePreset(struct soap *soap, const struct _tptz__RemovePreset *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_tt__ReferenceToken(soap, &a->PresetToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__RemovePreset(struct soap *soap, const char *tag, int id, const struct _tptz__RemovePreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__RemovePreset), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ProfileToken"))
		return soap->error;
	if (a->PresetToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetToken", -1, &a->PresetToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:PresetToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__RemovePreset * SOAP_FMAC4 soap_in__tptz__RemovePreset(struct soap *soap, const char *tag, struct _tptz__RemovePreset *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__RemovePreset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__RemovePreset, sizeof(struct _tptz__RemovePreset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__RemovePreset(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_PresetToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PresetToken", &a->PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__RemovePreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__RemovePreset, 0, sizeof(struct _tptz__RemovePreset), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_PresetToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__RemovePreset(struct soap *soap, const struct _tptz__RemovePreset *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__RemovePreset);
	if (soap_out__tptz__RemovePreset(soap, tag?tag:"tptz:RemovePreset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__RemovePreset * SOAP_FMAC4 soap_get__tptz__RemovePreset(struct soap *soap, struct _tptz__RemovePreset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__RemovePreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SetPresetResponse(struct soap *soap, struct _tptz__SetPresetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->PresetToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SetPresetResponse(struct soap *soap, const struct _tptz__SetPresetResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->PresetToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetPresetResponse(struct soap *soap, const char *tag, int id, const struct _tptz__SetPresetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetPresetResponse), type))
		return soap->error;
	if (a->PresetToken)
		soap_element_result(soap, "tptz:PresetToken");
	if (a->PresetToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetToken", -1, &a->PresetToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:PresetToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SetPresetResponse * SOAP_FMAC4 soap_in__tptz__SetPresetResponse(struct soap *soap, const char *tag, struct _tptz__SetPresetResponse *a, const char *type)
{
	size_t soap_flag_PresetToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__SetPresetResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetPresetResponse, sizeof(struct _tptz__SetPresetResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SetPresetResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PresetToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PresetToken", &a->PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken--;
					continue;
				}
			soap_check_result(soap, "tptz:PresetToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetPresetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetPresetResponse, 0, sizeof(struct _tptz__SetPresetResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PresetToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SetPresetResponse(struct soap *soap, const struct _tptz__SetPresetResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__SetPresetResponse);
	if (soap_out__tptz__SetPresetResponse(soap, tag?tag:"tptz:SetPresetResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetPresetResponse * SOAP_FMAC4 soap_get__tptz__SetPresetResponse(struct soap *soap, struct _tptz__SetPresetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetPresetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SetPreset(struct soap *soap, struct _tptz__SetPreset *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_string(soap, &a->PresetName);
	soap_default_tt__ReferenceToken(soap, &a->PresetToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SetPreset(struct soap *soap, const struct _tptz__SetPreset *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_string(soap, &a->PresetName);
	soap_serialize_tt__ReferenceToken(soap, &a->PresetToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetPreset(struct soap *soap, const char *tag, int id, const struct _tptz__SetPreset *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetPreset), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ProfileToken"))
		return soap->error;
	if (soap_out_string(soap, "tptz:PresetName", -1, &a->PresetName, ""))
		return soap->error;
	if (soap_out_tt__ReferenceToken(soap, "tptz:PresetToken", -1, &a->PresetToken, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SetPreset * SOAP_FMAC4 soap_in__tptz__SetPreset(struct soap *soap, const char *tag, struct _tptz__SetPreset *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_PresetName = 1;
	size_t soap_flag_PresetToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__SetPreset *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetPreset, sizeof(struct _tptz__SetPreset), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SetPreset(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_PresetName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tptz:PresetName", &a->PresetName, "xsd:string"))
				{	soap_flag_PresetName--;
					continue;
				}
			if (soap_flag_PresetToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PresetToken", &a->PresetToken, "tt:ReferenceToken"))
				{	soap_flag_PresetToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetPreset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetPreset, 0, sizeof(struct _tptz__SetPreset), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SetPreset(struct soap *soap, const struct _tptz__SetPreset *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__SetPreset);
	if (soap_out__tptz__SetPreset(soap, tag?tag:"tptz:SetPreset", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetPreset * SOAP_FMAC4 soap_get__tptz__SetPreset(struct soap *soap, struct _tptz__SetPreset *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetPreset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresetsResponse(struct soap *soap, struct _tptz__GetPresetsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePreset = 0;
	a->Preset = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresetsResponse(struct soap *soap, const struct _tptz__GetPresetsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Preset)
	{	int i;
		for (i = 0; i < a->__sizePreset; i++)
		{
			soap_embedded(soap, a->Preset + i, SOAP_TYPE_tt__PTZPreset);
			soap_serialize_tt__PTZPreset(soap, a->Preset + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresetsResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresetsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresetsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizePreset");
	if (a->Preset)
	{	int i;
		for (i = 0; i < a->__sizePreset; i++)
			if (soap_out_tt__PTZPreset(soap, "tptz:Preset", -1, a->Preset + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresetsResponse * SOAP_FMAC4 soap_in__tptz__GetPresetsResponse(struct soap *soap, const char *tag, struct _tptz__GetPresetsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Preset = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetPresetsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresetsResponse, sizeof(struct _tptz__GetPresetsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresetsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tptz:Preset", 1, NULL))
			{	if (a->Preset == NULL)
				{	if (soap_blist_Preset == NULL)
						soap_blist_Preset = soap_new_block(soap);
					a->Preset = (struct tt__PTZPreset *)soap_push_block(soap, soap_blist_Preset, sizeof(struct tt__PTZPreset));
					if (a->Preset == NULL)
						return NULL;
					soap_default_tt__PTZPreset(soap, a->Preset);
				}
				soap_revert(soap);
				if (soap_in_tt__PTZPreset(soap, "tptz:Preset", a->Preset, "tt:PTZPreset"))
				{	a->__sizePreset++;
					a->Preset = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizePreset");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Preset)
			soap_pop_block(soap, soap_blist_Preset);
		if (a->__sizePreset)
			a->Preset = (struct tt__PTZPreset *)soap_save_block(soap, soap_blist_Preset, NULL, 1);
		else
		{	a->Preset = NULL;
			if (soap_blist_Preset)
				soap_end_block(soap, soap_blist_Preset);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresetsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresetsResponse, 0, sizeof(struct _tptz__GetPresetsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresetsResponse(struct soap *soap, const struct _tptz__GetPresetsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetPresetsResponse);
	if (soap_out__tptz__GetPresetsResponse(soap, tag?tag:"tptz:GetPresetsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresetsResponse * SOAP_FMAC4 soap_get__tptz__GetPresetsResponse(struct soap *soap, struct _tptz__GetPresetsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresetsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetPresets(struct soap *soap, struct _tptz__GetPresets *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetPresets(struct soap *soap, const struct _tptz__GetPresets *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetPresets(struct soap *soap, const char *tag, int id, const struct _tptz__GetPresets *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetPresets), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ProfileToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetPresets * SOAP_FMAC4 soap_in__tptz__GetPresets(struct soap *soap, const char *tag, struct _tptz__GetPresets *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetPresets *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetPresets, sizeof(struct _tptz__GetPresets), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetPresets(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetPresets *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetPresets, 0, sizeof(struct _tptz__GetPresets), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetPresets(struct soap *soap, const struct _tptz__GetPresets *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetPresets);
	if (soap_out__tptz__GetPresets(soap, tag?tag:"tptz:GetPresets", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetPresets * SOAP_FMAC4 soap_get__tptz__GetPresets(struct soap *soap, struct _tptz__GetPresets *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetPresets(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SendAuxiliaryCommandResponse(struct soap *soap, struct _tptz__SendAuxiliaryCommandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AuxiliaryData(soap, &a->AuxiliaryResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SendAuxiliaryCommandResponse(struct soap *soap, const struct _tptz__SendAuxiliaryCommandResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__AuxiliaryData(soap, &a->AuxiliaryResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, const struct _tptz__SendAuxiliaryCommandResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse), type))
		return soap->error;
	if (a->AuxiliaryResponse)
		soap_element_result(soap, "tptz:AuxiliaryResponse");
	if (a->AuxiliaryResponse)
	{	if (soap_out_tt__AuxiliaryData(soap, "tptz:AuxiliaryResponse", -1, &a->AuxiliaryResponse, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:AuxiliaryResponse"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_in__tptz__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, struct _tptz__SendAuxiliaryCommandResponse *a, const char *type)
{
	size_t soap_flag_AuxiliaryResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__SendAuxiliaryCommandResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, sizeof(struct _tptz__SendAuxiliaryCommandResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SendAuxiliaryCommandResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryResponse && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__AuxiliaryData(soap, "tptz:AuxiliaryResponse", &a->AuxiliaryResponse, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryResponse--;
					continue;
				}
			soap_check_result(soap, "tptz:AuxiliaryResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__SendAuxiliaryCommandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse, 0, sizeof(struct _tptz__SendAuxiliaryCommandResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AuxiliaryResponse > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SendAuxiliaryCommandResponse(struct soap *soap, const struct _tptz__SendAuxiliaryCommandResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__SendAuxiliaryCommandResponse);
	if (soap_out__tptz__SendAuxiliaryCommandResponse(soap, tag?tag:"tptz:SendAuxiliaryCommandResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_get__tptz__SendAuxiliaryCommandResponse(struct soap *soap, struct _tptz__SendAuxiliaryCommandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SendAuxiliaryCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SendAuxiliaryCommand(struct soap *soap, struct _tptz__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_default_tt__AuxiliaryData(soap, &a->AuxiliaryData);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SendAuxiliaryCommand(struct soap *soap, const struct _tptz__SendAuxiliaryCommand *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ProfileToken);
	soap_serialize_tt__AuxiliaryData(soap, &a->AuxiliaryData);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, const struct _tptz__SendAuxiliaryCommand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SendAuxiliaryCommand), type))
		return soap->error;
	if (a->ProfileToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ProfileToken", -1, &a->ProfileToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ProfileToken"))
		return soap->error;
	if (a->AuxiliaryData)
	{	if (soap_out_tt__AuxiliaryData(soap, "tptz:AuxiliaryData", -1, &a->AuxiliaryData, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:AuxiliaryData"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommand * SOAP_FMAC4 soap_in__tptz__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct _tptz__SendAuxiliaryCommand *a, const char *type)
{
	size_t soap_flag_ProfileToken = 1;
	size_t soap_flag_AuxiliaryData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__SendAuxiliaryCommand *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SendAuxiliaryCommand, sizeof(struct _tptz__SendAuxiliaryCommand), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SendAuxiliaryCommand(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ProfileToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ProfileToken", &a->ProfileToken, "tt:ReferenceToken"))
				{	soap_flag_ProfileToken--;
					continue;
				}
			if (soap_flag_AuxiliaryData && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__AuxiliaryData(soap, "tptz:AuxiliaryData", &a->AuxiliaryData, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryData--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__SendAuxiliaryCommand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SendAuxiliaryCommand, 0, sizeof(struct _tptz__SendAuxiliaryCommand), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ProfileToken > 0 || soap_flag_AuxiliaryData > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SendAuxiliaryCommand(struct soap *soap, const struct _tptz__SendAuxiliaryCommand *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__SendAuxiliaryCommand);
	if (soap_out__tptz__SendAuxiliaryCommand(soap, tag?tag:"tptz:SendAuxiliaryCommand", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SendAuxiliaryCommand * SOAP_FMAC4 soap_get__tptz__SendAuxiliaryCommand(struct soap *soap, struct _tptz__SendAuxiliaryCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetConfigurationOptionsResponse(struct soap *soap, struct _tptz__GetConfigurationOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZConfigurationOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetConfigurationOptionsResponse(struct soap *soap, const struct _tptz__GetConfigurationOptionsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__PTZConfigurationOptions(soap, &a->PTZConfigurationOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurationOptionsResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetConfigurationOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurationOptionsResponse), type))
		return soap->error;
	if (a->PTZConfigurationOptions)
		soap_element_result(soap, "tptz:PTZConfigurationOptions");
	if (a->PTZConfigurationOptions)
	{	if (soap_out_PointerTott__PTZConfigurationOptions(soap, "tptz:PTZConfigurationOptions", -1, &a->PTZConfigurationOptions, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:PTZConfigurationOptions"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptionsResponse * SOAP_FMAC4 soap_in__tptz__GetConfigurationOptionsResponse(struct soap *soap, const char *tag, struct _tptz__GetConfigurationOptionsResponse *a, const char *type)
{
	size_t soap_flag_PTZConfigurationOptions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetConfigurationOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationOptionsResponse, sizeof(struct _tptz__GetConfigurationOptionsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetConfigurationOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZConfigurationOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZConfigurationOptions(soap, "tptz:PTZConfigurationOptions", &a->PTZConfigurationOptions, "tt:PTZConfigurationOptions"))
				{	soap_flag_PTZConfigurationOptions--;
					continue;
				}
			soap_check_result(soap, "tptz:PTZConfigurationOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationOptionsResponse, 0, sizeof(struct _tptz__GetConfigurationOptionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PTZConfigurationOptions > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetConfigurationOptionsResponse(struct soap *soap, const struct _tptz__GetConfigurationOptionsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetConfigurationOptionsResponse);
	if (soap_out__tptz__GetConfigurationOptionsResponse(soap, tag?tag:"tptz:GetConfigurationOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptionsResponse * SOAP_FMAC4 soap_get__tptz__GetConfigurationOptionsResponse(struct soap *soap, struct _tptz__GetConfigurationOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurationOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetConfigurationOptions(struct soap *soap, struct _tptz__GetConfigurationOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->ConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetConfigurationOptions(struct soap *soap, const struct _tptz__GetConfigurationOptions *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->ConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurationOptions(struct soap *soap, const char *tag, int id, const struct _tptz__GetConfigurationOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurationOptions), type))
		return soap->error;
	if (a->ConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:ConfigurationToken", -1, &a->ConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:ConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptions * SOAP_FMAC4 soap_in__tptz__GetConfigurationOptions(struct soap *soap, const char *tag, struct _tptz__GetConfigurationOptions *a, const char *type)
{
	size_t soap_flag_ConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetConfigurationOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationOptions, sizeof(struct _tptz__GetConfigurationOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetConfigurationOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:ConfigurationToken", &a->ConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_ConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationOptions, 0, sizeof(struct _tptz__GetConfigurationOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetConfigurationOptions(struct soap *soap, const struct _tptz__GetConfigurationOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetConfigurationOptions);
	if (soap_out__tptz__GetConfigurationOptions(soap, tag?tag:"tptz:GetConfigurationOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationOptions * SOAP_FMAC4 soap_get__tptz__GetConfigurationOptions(struct soap *soap, struct _tptz__GetConfigurationOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurationOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default___tptz__SetConfigurationResponse_sequence(struct soap *soap, struct __tptz__SetConfigurationResponse_sequence *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize___tptz__SetConfigurationResponse_sequence(struct soap *soap, const struct __tptz__SetConfigurationResponse_sequence *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___tptz__SetConfigurationResponse_sequence(struct soap *soap, const char *tag, int id, const struct __tptz__SetConfigurationResponse_sequence *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetConfigurationResponse_sequence * SOAP_FMAC4 soap_in___tptz__SetConfigurationResponse_sequence(struct soap *soap, const char *tag, struct __tptz__SetConfigurationResponse_sequence *a, const char *type)
{
	a = (struct __tptz__SetConfigurationResponse_sequence *)soap_id_enter(soap, "", a, SOAP_TYPE___tptz__SetConfigurationResponse_sequence, sizeof(struct __tptz__SetConfigurationResponse_sequence), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default___tptz__SetConfigurationResponse_sequence(soap, a);
	soap->error = SOAP_TAG_MISMATCH;
	a = NULL;
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put___tptz__SetConfigurationResponse_sequence(struct soap *soap, const struct __tptz__SetConfigurationResponse_sequence *a, const char *tag, const char *type)
{
	register int id = 0;
	if (soap_out___tptz__SetConfigurationResponse_sequence(soap, tag?tag:"-tptz:SetConfigurationResponse-sequence", id, a, type))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 struct __tptz__SetConfigurationResponse_sequence * SOAP_FMAC4 soap_get___tptz__SetConfigurationResponse_sequence(struct soap *soap, struct __tptz__SetConfigurationResponse_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___tptz__SetConfigurationResponse_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SetConfigurationResponse(struct soap *soap, struct _tptz__SetConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size_SetConfigurationResponse_sequence = 0;
	a->__SetConfigurationResponse_sequence = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SetConfigurationResponse(struct soap *soap, const struct _tptz__SetConfigurationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->__SetConfigurationResponse_sequence)
	{	int i;
		for (i = 0; i < a->__size_SetConfigurationResponse_sequence; i++)
		{
			soap_serialize___tptz__SetConfigurationResponse_sequence(soap, a->__SetConfigurationResponse_sequence + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tptz__SetConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetConfigurationResponse), type))
		return soap->error;
	soap_element_result(soap, "-size-SetConfigurationResponse-sequence");
	if (a->__SetConfigurationResponse_sequence)
	{	int i;
		for (i = 0; i < a->__size_SetConfigurationResponse_sequence; i++)
			if (soap_out___tptz__SetConfigurationResponse_sequence(soap, "-SetConfigurationResponse-sequence", -1, a->__SetConfigurationResponse_sequence + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SetConfigurationResponse * SOAP_FMAC4 soap_in__tptz__SetConfigurationResponse(struct soap *soap, const char *tag, struct _tptz__SetConfigurationResponse *a, const char *type)
{
	struct soap_blist *soap_blist___SetConfigurationResponse_sequence = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__SetConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetConfigurationResponse, sizeof(struct _tptz__SetConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SetConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__SetConfigurationResponse_sequence == NULL)
				{	if (soap_blist___SetConfigurationResponse_sequence == NULL)
						soap_blist___SetConfigurationResponse_sequence = soap_new_block(soap);
					a->__SetConfigurationResponse_sequence = (struct __tptz__SetConfigurationResponse_sequence *)soap_push_block(soap, soap_blist___SetConfigurationResponse_sequence, sizeof(struct __tptz__SetConfigurationResponse_sequence));
					if (a->__SetConfigurationResponse_sequence == NULL)
						return NULL;
					soap_default___tptz__SetConfigurationResponse_sequence(soap, a->__SetConfigurationResponse_sequence);
				}
				if (soap_in___tptz__SetConfigurationResponse_sequence(soap, "-SetConfigurationResponse-sequence", a->__SetConfigurationResponse_sequence, "-tptz:SetConfigurationResponse-sequence"))
				{	a->__size_SetConfigurationResponse_sequence++;
					a->__SetConfigurationResponse_sequence = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size-SetConfigurationResponse-sequence");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__SetConfigurationResponse_sequence)
			soap_pop_block(soap, soap_blist___SetConfigurationResponse_sequence);
		if (a->__size_SetConfigurationResponse_sequence)
			a->__SetConfigurationResponse_sequence = (struct __tptz__SetConfigurationResponse_sequence *)soap_save_block(soap, soap_blist___SetConfigurationResponse_sequence, NULL, 1);
		else
		{	a->__SetConfigurationResponse_sequence = NULL;
			if (soap_blist___SetConfigurationResponse_sequence)
				soap_end_block(soap, soap_blist___SetConfigurationResponse_sequence);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetConfigurationResponse, 0, sizeof(struct _tptz__SetConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SetConfigurationResponse(struct soap *soap, const struct _tptz__SetConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__SetConfigurationResponse);
	if (soap_out__tptz__SetConfigurationResponse(soap, tag?tag:"tptz:SetConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetConfigurationResponse * SOAP_FMAC4 soap_get__tptz__SetConfigurationResponse(struct soap *soap, struct _tptz__SetConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__SetConfiguration(struct soap *soap, struct _tptz__SetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZConfiguration = NULL;
	soap_default_xsd__boolean(soap, &a->ForcePersistence);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__SetConfiguration(struct soap *soap, const struct _tptz__SetConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__PTZConfiguration(soap, &a->PTZConfiguration);
	soap_embedded(soap, &a->ForcePersistence, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__SetConfiguration(struct soap *soap, const char *tag, int id, const struct _tptz__SetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__SetConfiguration), type))
		return soap->error;
	if (a->PTZConfiguration)
	{	if (soap_out_PointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", -1, &a->PTZConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:PTZConfiguration"))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tptz:ForcePersistence", -1, &a->ForcePersistence, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__SetConfiguration * SOAP_FMAC4 soap_in__tptz__SetConfiguration(struct soap *soap, const char *tag, struct _tptz__SetConfiguration *a, const char *type)
{
	size_t soap_flag_PTZConfiguration = 1;
	size_t soap_flag_ForcePersistence = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__SetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__SetConfiguration, sizeof(struct _tptz__SetConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__SetConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", &a->PTZConfiguration, "tt:PTZConfiguration"))
				{	soap_flag_PTZConfiguration--;
					continue;
				}
			if (soap_flag_ForcePersistence && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tptz:ForcePersistence", &a->ForcePersistence, "xsd:boolean"))
				{	soap_flag_ForcePersistence--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__SetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__SetConfiguration, 0, sizeof(struct _tptz__SetConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PTZConfiguration > 0 || soap_flag_ForcePersistence > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__SetConfiguration(struct soap *soap, const struct _tptz__SetConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__SetConfiguration);
	if (soap_out__tptz__SetConfiguration(soap, tag?tag:"tptz:SetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__SetConfiguration * SOAP_FMAC4 soap_get__tptz__SetConfiguration(struct soap *soap, struct _tptz__SetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__SetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetConfigurationResponse(struct soap *soap, struct _tptz__GetConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetConfigurationResponse(struct soap *soap, const struct _tptz__GetConfigurationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__PTZConfiguration(soap, &a->PTZConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurationResponse), type))
		return soap->error;
	if (a->PTZConfiguration)
		soap_element_result(soap, "tptz:PTZConfiguration");
	if (a->PTZConfiguration)
	{	if (soap_out_PointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", -1, &a->PTZConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:PTZConfiguration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetConfigurationResponse * SOAP_FMAC4 soap_in__tptz__GetConfigurationResponse(struct soap *soap, const char *tag, struct _tptz__GetConfigurationResponse *a, const char *type)
{
	size_t soap_flag_PTZConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationResponse, sizeof(struct _tptz__GetConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZConfiguration(soap, "tptz:PTZConfiguration", &a->PTZConfiguration, "tt:PTZConfiguration"))
				{	soap_flag_PTZConfiguration--;
					continue;
				}
			soap_check_result(soap, "tptz:PTZConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationResponse, 0, sizeof(struct _tptz__GetConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PTZConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetConfigurationResponse(struct soap *soap, const struct _tptz__GetConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetConfigurationResponse);
	if (soap_out__tptz__GetConfigurationResponse(soap, tag?tag:"tptz:GetConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationResponse * SOAP_FMAC4 soap_get__tptz__GetConfigurationResponse(struct soap *soap, struct _tptz__GetConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetConfiguration(struct soap *soap, struct _tptz__GetConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->PTZConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetConfiguration(struct soap *soap, const struct _tptz__GetConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->PTZConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfiguration(struct soap *soap, const char *tag, int id, const struct _tptz__GetConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfiguration), type))
		return soap->error;
	if (a->PTZConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:PTZConfigurationToken", -1, &a->PTZConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:PTZConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetConfiguration * SOAP_FMAC4 soap_in__tptz__GetConfiguration(struct soap *soap, const char *tag, struct _tptz__GetConfiguration *a, const char *type)
{
	size_t soap_flag_PTZConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfiguration, sizeof(struct _tptz__GetConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:PTZConfigurationToken", &a->PTZConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_PTZConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfiguration, 0, sizeof(struct _tptz__GetConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PTZConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetConfiguration(struct soap *soap, const struct _tptz__GetConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetConfiguration);
	if (soap_out__tptz__GetConfiguration(soap, tag?tag:"tptz:GetConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfiguration * SOAP_FMAC4 soap_get__tptz__GetConfiguration(struct soap *soap, struct _tptz__GetConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetConfigurationsResponse(struct soap *soap, struct _tptz__GetConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePTZConfiguration = 0;
	a->PTZConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetConfigurationsResponse(struct soap *soap, const struct _tptz__GetConfigurationsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->PTZConfiguration)
	{	int i;
		for (i = 0; i < a->__sizePTZConfiguration; i++)
		{
			soap_embedded(soap, a->PTZConfiguration + i, SOAP_TYPE_tt__PTZConfiguration);
			soap_serialize_tt__PTZConfiguration(soap, a->PTZConfiguration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizePTZConfiguration");
	if (a->PTZConfiguration)
	{	int i;
		for (i = 0; i < a->__sizePTZConfiguration; i++)
			if (soap_out_tt__PTZConfiguration(soap, "tptz:PTZConfiguration", -1, a->PTZConfiguration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetConfigurationsResponse * SOAP_FMAC4 soap_in__tptz__GetConfigurationsResponse(struct soap *soap, const char *tag, struct _tptz__GetConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_PTZConfiguration = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurationsResponse, sizeof(struct _tptz__GetConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tptz:PTZConfiguration", 1, NULL))
			{	if (a->PTZConfiguration == NULL)
				{	if (soap_blist_PTZConfiguration == NULL)
						soap_blist_PTZConfiguration = soap_new_block(soap);
					a->PTZConfiguration = (struct tt__PTZConfiguration *)soap_push_block(soap, soap_blist_PTZConfiguration, sizeof(struct tt__PTZConfiguration));
					if (a->PTZConfiguration == NULL)
						return NULL;
					soap_default_tt__PTZConfiguration(soap, a->PTZConfiguration);
				}
				soap_revert(soap);
				if (soap_in_tt__PTZConfiguration(soap, "tptz:PTZConfiguration", a->PTZConfiguration, "tt:PTZConfiguration"))
				{	a->__sizePTZConfiguration++;
					a->PTZConfiguration = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizePTZConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PTZConfiguration)
			soap_pop_block(soap, soap_blist_PTZConfiguration);
		if (a->__sizePTZConfiguration)
			a->PTZConfiguration = (struct tt__PTZConfiguration *)soap_save_block(soap, soap_blist_PTZConfiguration, NULL, 1);
		else
		{	a->PTZConfiguration = NULL;
			if (soap_blist_PTZConfiguration)
				soap_end_block(soap, soap_blist_PTZConfiguration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurationsResponse, 0, sizeof(struct _tptz__GetConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetConfigurationsResponse(struct soap *soap, const struct _tptz__GetConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetConfigurationsResponse);
	if (soap_out__tptz__GetConfigurationsResponse(soap, tag?tag:"tptz:GetConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurationsResponse * SOAP_FMAC4 soap_get__tptz__GetConfigurationsResponse(struct soap *soap, struct _tptz__GetConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetConfigurations(struct soap *soap, struct _tptz__GetConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetConfigurations(struct soap *soap, const struct _tptz__GetConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetConfigurations(struct soap *soap, const char *tag, int id, const struct _tptz__GetConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetConfigurations * SOAP_FMAC4 soap_in__tptz__GetConfigurations(struct soap *soap, const char *tag, struct _tptz__GetConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetConfigurations, sizeof(struct _tptz__GetConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetConfigurations, 0, sizeof(struct _tptz__GetConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetConfigurations(struct soap *soap, const struct _tptz__GetConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetConfigurations);
	if (soap_out__tptz__GetConfigurations(soap, tag?tag:"tptz:GetConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetConfigurations * SOAP_FMAC4 soap_get__tptz__GetConfigurations(struct soap *soap, struct _tptz__GetConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetNodeResponse(struct soap *soap, struct _tptz__GetNodeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PTZNode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetNodeResponse(struct soap *soap, const struct _tptz__GetNodeResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__PTZNode(soap, &a->PTZNode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetNodeResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetNodeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetNodeResponse), type))
		return soap->error;
	if (a->PTZNode)
		soap_element_result(soap, "tptz:PTZNode");
	if (a->PTZNode)
	{	if (soap_out_PointerTott__PTZNode(soap, "tptz:PTZNode", -1, &a->PTZNode, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:PTZNode"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetNodeResponse * SOAP_FMAC4 soap_in__tptz__GetNodeResponse(struct soap *soap, const char *tag, struct _tptz__GetNodeResponse *a, const char *type)
{
	size_t soap_flag_PTZNode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetNodeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNodeResponse, sizeof(struct _tptz__GetNodeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetNodeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PTZNode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZNode(soap, "tptz:PTZNode", &a->PTZNode, "tt:PTZNode"))
				{	soap_flag_PTZNode--;
					continue;
				}
			soap_check_result(soap, "tptz:PTZNode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetNodeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNodeResponse, 0, sizeof(struct _tptz__GetNodeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PTZNode > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetNodeResponse(struct soap *soap, const struct _tptz__GetNodeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetNodeResponse);
	if (soap_out__tptz__GetNodeResponse(soap, tag?tag:"tptz:GetNodeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNodeResponse * SOAP_FMAC4 soap_get__tptz__GetNodeResponse(struct soap *soap, struct _tptz__GetNodeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetNodeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetNode(struct soap *soap, struct _tptz__GetNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->NodeToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetNode(struct soap *soap, const struct _tptz__GetNode *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->NodeToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetNode(struct soap *soap, const char *tag, int id, const struct _tptz__GetNode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetNode), type))
		return soap->error;
	if (a->NodeToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tptz:NodeToken", -1, &a->NodeToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:NodeToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetNode * SOAP_FMAC4 soap_in__tptz__GetNode(struct soap *soap, const char *tag, struct _tptz__GetNode *a, const char *type)
{
	size_t soap_flag_NodeToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetNode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNode, sizeof(struct _tptz__GetNode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetNode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NodeToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tptz:NodeToken", &a->NodeToken, "tt:ReferenceToken"))
				{	soap_flag_NodeToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetNode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNode, 0, sizeof(struct _tptz__GetNode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NodeToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetNode(struct soap *soap, const struct _tptz__GetNode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetNode);
	if (soap_out__tptz__GetNode(soap, tag?tag:"tptz:GetNode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNode * SOAP_FMAC4 soap_get__tptz__GetNode(struct soap *soap, struct _tptz__GetNode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tt__PTZNode(struct soap *soap, struct tt__PTZNode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->token);
	soap_default_tt__Name(soap, &a->Name);
	a->SupportedPTZSpaces = NULL;
	soap_default_int(soap, &a->MaximumNumberOfPresets);
	soap_default_xsd__boolean(soap, &a->HomeSupported);
	a->__sizeAuxiliaryCommands = 0;
	a->AuxiliaryCommands = NULL;
	a->Extension = NULL;
	a->FixedHomePosition = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tt__PTZNode(struct soap *soap, const struct tt__PTZNode *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__Name(soap, &a->Name);
	soap_serialize_PointerTott__PTZSpaces(soap, &a->SupportedPTZSpaces);
	soap_embedded(soap, &a->MaximumNumberOfPresets, SOAP_TYPE_int);
	soap_embedded(soap, &a->HomeSupported, SOAP_TYPE_xsd__boolean);
	if (a->AuxiliaryCommands)
	{	int i;
		for (i = 0; i < a->__sizeAuxiliaryCommands; i++)
		{
			soap_serialize_tt__AuxiliaryData(soap, a->AuxiliaryCommands + i);
		}
	}
	soap_serialize_PointerTott__PTZNodeExtension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tt__PTZNode(struct soap *soap, const char *tag, int id, const struct tt__PTZNode *a, const char *type)
{
	if (a->token)
		soap_set_attr(soap, "token", a->token, 1);
	if (a->FixedHomePosition)
		soap_set_attr(soap, "FixedHomePosition", soap_xsd__boolean2s(soap, *a->FixedHomePosition), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tt__PTZNode), type))
		return soap->error;
	if (soap_out_tt__Name(soap, "tt:Name", -1, &a->Name, ""))
		return soap->error;
	if (a->SupportedPTZSpaces)
	{	if (soap_out_PointerTott__PTZSpaces(soap, "tt:SupportedPTZSpaces", -1, &a->SupportedPTZSpaces, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tt:SupportedPTZSpaces"))
		return soap->error;
	if (soap_out_int(soap, "tt:MaximumNumberOfPresets", -1, &a->MaximumNumberOfPresets, ""))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tt:HomeSupported", -1, &a->HomeSupported, ""))
		return soap->error;
	if (a->AuxiliaryCommands)
	{	int i;
		for (i = 0; i < a->__sizeAuxiliaryCommands; i++)
			if (soap_out_tt__AuxiliaryData(soap, "tt:AuxiliaryCommands", -1, a->AuxiliaryCommands + i, ""))
				return soap->error;
	}
	if (soap_out_PointerTott__PTZNodeExtension(soap, "tt:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tt__PTZNode * SOAP_FMAC4 soap_in_tt__PTZNode(struct soap *soap, const char *tag, struct tt__PTZNode *a, const char *type)
{
	size_t soap_flag_Name = 1;
	size_t soap_flag_SupportedPTZSpaces = 1;
	size_t soap_flag_MaximumNumberOfPresets = 1;
	size_t soap_flag_HomeSupported = 1;
	struct soap_blist *soap_blist_AuxiliaryCommands = NULL;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tt__PTZNode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tt__PTZNode, sizeof(struct tt__PTZNode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tt__PTZNode(soap, a);
	if (soap_s2string(soap, soap_attr_value(soap, "token", 1), &a->token, 0, 64))
		return NULL;
	{	const char *t = soap_attr_value(soap, "FixedHomePosition", 0);
		if (t)
		{
			if (!(a->FixedHomePosition = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->FixedHomePosition))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Name && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__Name(soap, "tt:Name", &a->Name, "tt:Name"))
				{	soap_flag_Name--;
					continue;
				}
			if (soap_flag_SupportedPTZSpaces && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZSpaces(soap, "tt:SupportedPTZSpaces", &a->SupportedPTZSpaces, "tt:PTZSpaces"))
				{	soap_flag_SupportedPTZSpaces--;
					continue;
				}
			if (soap_flag_MaximumNumberOfPresets && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tt:MaximumNumberOfPresets", &a->MaximumNumberOfPresets, "xsd:int"))
				{	soap_flag_MaximumNumberOfPresets--;
					continue;
				}
			if (soap_flag_HomeSupported && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tt:HomeSupported", &a->HomeSupported, "xsd:boolean"))
				{	soap_flag_HomeSupported--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tt:AuxiliaryCommands", 1, NULL))
			{	if (a->AuxiliaryCommands == NULL)
				{	if (soap_blist_AuxiliaryCommands == NULL)
						soap_blist_AuxiliaryCommands = soap_new_block(soap);
					a->AuxiliaryCommands = (char **)soap_push_block(soap, soap_blist_AuxiliaryCommands, sizeof(char *));
					if (a->AuxiliaryCommands == NULL)
						return NULL;
					*a->AuxiliaryCommands = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__AuxiliaryData(soap, "tt:AuxiliaryCommands", a->AuxiliaryCommands, "tt:AuxiliaryData"))
				{	a->__sizeAuxiliaryCommands++;
					a->AuxiliaryCommands = NULL;
					continue;
				}
			}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PTZNodeExtension(soap, "tt:Extension", &a->Extension, "tt:PTZNodeExtension"))
				{	soap_flag_Extension--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->AuxiliaryCommands)
			soap_pop_block(soap, soap_blist_AuxiliaryCommands);
		if (a->__sizeAuxiliaryCommands)
			a->AuxiliaryCommands = (char **)soap_save_block(soap, soap_blist_AuxiliaryCommands, NULL, 1);
		else
		{	a->AuxiliaryCommands = NULL;
			if (soap_blist_AuxiliaryCommands)
				soap_end_block(soap, soap_blist_AuxiliaryCommands);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tt__PTZNode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tt__PTZNode, 0, sizeof(struct tt__PTZNode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SupportedPTZSpaces > 0 || soap_flag_MaximumNumberOfPresets > 0 || soap_flag_HomeSupported > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tt__PTZNode(struct soap *soap, const struct tt__PTZNode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tt__PTZNode);
	if (soap_out_tt__PTZNode(soap, tag?tag:"tt:PTZNode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tt__PTZNode * SOAP_FMAC4 soap_get_tt__PTZNode(struct soap *soap, struct tt__PTZNode *p, const char *tag, const char *type)
{
	if ((p = soap_in_tt__PTZNode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetNodesResponse(struct soap *soap, struct _tptz__GetNodesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePTZNode = 0;
	a->PTZNode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetNodesResponse(struct soap *soap, const struct _tptz__GetNodesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->PTZNode)
	{	int i;
		for (i = 0; i < a->__sizePTZNode; i++)
		{
			soap_embedded(soap, a->PTZNode + i, SOAP_TYPE_tt__PTZNode);
			soap_serialize_tt__PTZNode(soap, a->PTZNode + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetNodesResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetNodesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetNodesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizePTZNode");
	if (a->PTZNode)
	{	int i;
		for (i = 0; i < a->__sizePTZNode; i++)
			if (soap_out_tt__PTZNode(soap, "tptz:PTZNode", -1, a->PTZNode + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetNodesResponse * SOAP_FMAC4 soap_in__tptz__GetNodesResponse(struct soap *soap, const char *tag, struct _tptz__GetNodesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_PTZNode = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetNodesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNodesResponse, sizeof(struct _tptz__GetNodesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetNodesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tptz:PTZNode", 1, NULL))
			{	if (a->PTZNode == NULL)
				{	if (soap_blist_PTZNode == NULL)
						soap_blist_PTZNode = soap_new_block(soap);
					a->PTZNode = (struct tt__PTZNode *)soap_push_block(soap, soap_blist_PTZNode, sizeof(struct tt__PTZNode));
					if (a->PTZNode == NULL)
						return NULL;
					soap_default_tt__PTZNode(soap, a->PTZNode);
				}
				soap_revert(soap);
				if (soap_in_tt__PTZNode(soap, "tptz:PTZNode", a->PTZNode, "tt:PTZNode"))
				{	a->__sizePTZNode++;
					a->PTZNode = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizePTZNode");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PTZNode)
			soap_pop_block(soap, soap_blist_PTZNode);
		if (a->__sizePTZNode)
			a->PTZNode = (struct tt__PTZNode *)soap_save_block(soap, soap_blist_PTZNode, NULL, 1);
		else
		{	a->PTZNode = NULL;
			if (soap_blist_PTZNode)
				soap_end_block(soap, soap_blist_PTZNode);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetNodesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNodesResponse, 0, sizeof(struct _tptz__GetNodesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetNodesResponse(struct soap *soap, const struct _tptz__GetNodesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetNodesResponse);
	if (soap_out__tptz__GetNodesResponse(soap, tag?tag:"tptz:GetNodesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNodesResponse * SOAP_FMAC4 soap_get__tptz__GetNodesResponse(struct soap *soap, struct _tptz__GetNodesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetNodesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetNodes(struct soap *soap, struct _tptz__GetNodes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetNodes(struct soap *soap, const struct _tptz__GetNodes *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetNodes(struct soap *soap, const char *tag, int id, const struct _tptz__GetNodes *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetNodes), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetNodes * SOAP_FMAC4 soap_in__tptz__GetNodes(struct soap *soap, const char *tag, struct _tptz__GetNodes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetNodes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetNodes, sizeof(struct _tptz__GetNodes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetNodes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetNodes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetNodes, 0, sizeof(struct _tptz__GetNodes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetNodes(struct soap *soap, const struct _tptz__GetNodes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetNodes);
	if (soap_out__tptz__GetNodes(soap, tag?tag:"tptz:GetNodes", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetNodes * SOAP_FMAC4 soap_get__tptz__GetNodes(struct soap *soap, struct _tptz__GetNodes *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetNodes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetServiceCapabilitiesResponse(struct soap *soap, struct _tptz__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tptz__GetServiceCapabilitiesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotptz__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tptz__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tptz:Capabilities");
	if (a->Capabilities)
	{	if (soap_out_PointerTotptz__Capabilities(soap, "tptz:Capabilities", -1, &a->Capabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tptz:Capabilities"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tptz__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tptz__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse, sizeof(struct _tptz__GetServiceCapabilitiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotptz__Capabilities(soap, "tptz:Capabilities", &a->Capabilities, "tptz:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "tptz:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse, 0, sizeof(struct _tptz__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tptz__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetServiceCapabilitiesResponse);
	if (soap_out__tptz__GetServiceCapabilitiesResponse(soap, tag?tag:"tptz:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tptz__GetServiceCapabilitiesResponse(struct soap *soap, struct _tptz__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tptz__GetServiceCapabilities(struct soap *soap, struct _tptz__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tptz__GetServiceCapabilities(struct soap *soap, const struct _tptz__GetServiceCapabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tptz__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tptz__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tptz__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilities * SOAP_FMAC4 soap_in__tptz__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tptz__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tptz__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tptz__GetServiceCapabilities, sizeof(struct _tptz__GetServiceCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tptz__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tptz__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tptz__GetServiceCapabilities, 0, sizeof(struct _tptz__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tptz__GetServiceCapabilities(struct soap *soap, const struct _tptz__GetServiceCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tptz__GetServiceCapabilities);
	if (soap_out__tptz__GetServiceCapabilities(soap, tag?tag:"tptz:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tptz__GetServiceCapabilities * SOAP_FMAC4 soap_get__tptz__GetServiceCapabilities(struct soap *soap, struct _tptz__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tptz__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tptz__Capabilities(struct soap *soap, struct tptz__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->EFlip = NULL;
	a->Reverse = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tptz__Capabilities(struct soap *soap, const struct tptz__Capabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tptz__Capabilities(struct soap *soap, const char *tag, int id, const struct tptz__Capabilities *a, const char *type)
{
	if (a->EFlip)
		soap_set_attr(soap, "EFlip", soap_xsd__boolean2s(soap, *a->EFlip), 1);
	if (a->Reverse)
		soap_set_attr(soap, "Reverse", soap_xsd__boolean2s(soap, *a->Reverse), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tptz__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tptz__Capabilities * SOAP_FMAC4 soap_in_tptz__Capabilities(struct soap *soap, const char *tag, struct tptz__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tptz__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tptz__Capabilities, sizeof(struct tptz__Capabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tptz__Capabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "EFlip", 0);
		if (t)
		{
			if (!(a->EFlip = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->EFlip))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "Reverse", 0);
		if (t)
		{
			if (!(a->Reverse = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->Reverse))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tptz__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tptz__Capabilities, 0, sizeof(struct tptz__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tptz__Capabilities(struct soap *soap, const struct tptz__Capabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tptz__Capabilities);
	if (soap_out_tptz__Capabilities(soap, tag?tag:"tptz:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tptz__Capabilities * SOAP_FMAC4 soap_get_tptz__Capabilities(struct soap *soap, struct tptz__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tptz__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetStatusResponse(struct soap *soap, struct _timg__GetStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Status = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetStatusResponse(struct soap *soap, const struct _timg__GetStatusResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ImagingStatus20(soap, &a->Status);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetStatusResponse(struct soap *soap, const char *tag, int id, const struct _timg__GetStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetStatusResponse), type))
		return soap->error;
	if (a->Status)
		soap_element_result(soap, "timg:Status");
	if (a->Status)
	{	if (soap_out_PointerTott__ImagingStatus20(soap, "timg:Status", -1, &a->Status, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:Status"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetStatusResponse * SOAP_FMAC4 soap_in__timg__GetStatusResponse(struct soap *soap, const char *tag, struct _timg__GetStatusResponse *a, const char *type)
{
	size_t soap_flag_Status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetStatusResponse, sizeof(struct _timg__GetStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingStatus20(soap, "timg:Status", &a->Status, "tt:ImagingStatus20"))
				{	soap_flag_Status--;
					continue;
				}
			soap_check_result(soap, "timg:Status");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetStatusResponse, 0, sizeof(struct _timg__GetStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetStatusResponse(struct soap *soap, const struct _timg__GetStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetStatusResponse);
	if (soap_out__timg__GetStatusResponse(soap, tag?tag:"timg:GetStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetStatusResponse * SOAP_FMAC4 soap_get__timg__GetStatusResponse(struct soap *soap, struct _timg__GetStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetStatus(struct soap *soap, struct _timg__GetStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetStatus(struct soap *soap, const struct _timg__GetStatus *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoSourceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetStatus(struct soap *soap, const char *tag, int id, const struct _timg__GetStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetStatus), type))
		return soap->error;
	if (a->VideoSourceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->VideoSourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:VideoSourceToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetStatus * SOAP_FMAC4 soap_in__timg__GetStatus(struct soap *soap, const char *tag, struct _timg__GetStatus *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetStatus, sizeof(struct _timg__GetStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetStatus, 0, sizeof(struct _timg__GetStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetStatus(struct soap *soap, const struct _timg__GetStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetStatus);
	if (soap_out__timg__GetStatus(soap, tag?tag:"timg:GetStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetStatus * SOAP_FMAC4 soap_get__timg__GetStatus(struct soap *soap, struct _timg__GetStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__StopResponse(struct soap *soap, struct _timg__StopResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__StopResponse(struct soap *soap, const struct _timg__StopResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__StopResponse(struct soap *soap, const char *tag, int id, const struct _timg__StopResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__StopResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__StopResponse * SOAP_FMAC4 soap_in__timg__StopResponse(struct soap *soap, const char *tag, struct _timg__StopResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__StopResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__StopResponse, sizeof(struct _timg__StopResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__StopResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__StopResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__StopResponse, 0, sizeof(struct _timg__StopResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__StopResponse(struct soap *soap, const struct _timg__StopResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__StopResponse);
	if (soap_out__timg__StopResponse(soap, tag?tag:"timg:StopResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__StopResponse * SOAP_FMAC4 soap_get__timg__StopResponse(struct soap *soap, struct _timg__StopResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__StopResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__Stop(struct soap *soap, struct _timg__Stop *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__Stop(struct soap *soap, const struct _timg__Stop *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoSourceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__Stop(struct soap *soap, const char *tag, int id, const struct _timg__Stop *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__Stop), type))
		return soap->error;
	if (a->VideoSourceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->VideoSourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:VideoSourceToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__Stop * SOAP_FMAC4 soap_in__timg__Stop(struct soap *soap, const char *tag, struct _timg__Stop *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__Stop *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__Stop, sizeof(struct _timg__Stop), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__Stop(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__Stop *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__Stop, 0, sizeof(struct _timg__Stop), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__Stop(struct soap *soap, const struct _timg__Stop *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__Stop);
	if (soap_out__timg__Stop(soap, tag?tag:"timg:Stop", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__Stop * SOAP_FMAC4 soap_get__timg__Stop(struct soap *soap, struct _timg__Stop *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__Stop(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetMoveOptionsResponse(struct soap *soap, struct _timg__GetMoveOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->MoveOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetMoveOptionsResponse(struct soap *soap, const struct _timg__GetMoveOptionsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__MoveOptions20(soap, &a->MoveOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetMoveOptionsResponse(struct soap *soap, const char *tag, int id, const struct _timg__GetMoveOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetMoveOptionsResponse), type))
		return soap->error;
	if (a->MoveOptions)
		soap_element_result(soap, "timg:MoveOptions");
	if (a->MoveOptions)
	{	if (soap_out_PointerTott__MoveOptions20(soap, "timg:MoveOptions", -1, &a->MoveOptions, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:MoveOptions"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetMoveOptionsResponse * SOAP_FMAC4 soap_in__timg__GetMoveOptionsResponse(struct soap *soap, const char *tag, struct _timg__GetMoveOptionsResponse *a, const char *type)
{
	size_t soap_flag_MoveOptions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetMoveOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetMoveOptionsResponse, sizeof(struct _timg__GetMoveOptionsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetMoveOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MoveOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__MoveOptions20(soap, "timg:MoveOptions", &a->MoveOptions, "tt:MoveOptions20"))
				{	soap_flag_MoveOptions--;
					continue;
				}
			soap_check_result(soap, "timg:MoveOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetMoveOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetMoveOptionsResponse, 0, sizeof(struct _timg__GetMoveOptionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MoveOptions > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetMoveOptionsResponse(struct soap *soap, const struct _timg__GetMoveOptionsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetMoveOptionsResponse);
	if (soap_out__timg__GetMoveOptionsResponse(soap, tag?tag:"timg:GetMoveOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetMoveOptionsResponse * SOAP_FMAC4 soap_get__timg__GetMoveOptionsResponse(struct soap *soap, struct _timg__GetMoveOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetMoveOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetMoveOptions(struct soap *soap, struct _timg__GetMoveOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetMoveOptions(struct soap *soap, const struct _timg__GetMoveOptions *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoSourceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetMoveOptions(struct soap *soap, const char *tag, int id, const struct _timg__GetMoveOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetMoveOptions), type))
		return soap->error;
	if (a->VideoSourceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->VideoSourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:VideoSourceToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetMoveOptions * SOAP_FMAC4 soap_in__timg__GetMoveOptions(struct soap *soap, const char *tag, struct _timg__GetMoveOptions *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetMoveOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetMoveOptions, sizeof(struct _timg__GetMoveOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetMoveOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetMoveOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetMoveOptions, 0, sizeof(struct _timg__GetMoveOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetMoveOptions(struct soap *soap, const struct _timg__GetMoveOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetMoveOptions);
	if (soap_out__timg__GetMoveOptions(soap, tag?tag:"timg:GetMoveOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetMoveOptions * SOAP_FMAC4 soap_get__timg__GetMoveOptions(struct soap *soap, struct _timg__GetMoveOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetMoveOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__MoveResponse(struct soap *soap, struct _timg__MoveResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__MoveResponse(struct soap *soap, const struct _timg__MoveResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__MoveResponse(struct soap *soap, const char *tag, int id, const struct _timg__MoveResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__MoveResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__MoveResponse * SOAP_FMAC4 soap_in__timg__MoveResponse(struct soap *soap, const char *tag, struct _timg__MoveResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__MoveResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__MoveResponse, sizeof(struct _timg__MoveResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__MoveResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__MoveResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__MoveResponse, 0, sizeof(struct _timg__MoveResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__MoveResponse(struct soap *soap, const struct _timg__MoveResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__MoveResponse);
	if (soap_out__timg__MoveResponse(soap, tag?tag:"timg:MoveResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__MoveResponse * SOAP_FMAC4 soap_get__timg__MoveResponse(struct soap *soap, struct _timg__MoveResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__MoveResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__Move(struct soap *soap, struct _timg__Move *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
	a->Focus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__Move(struct soap *soap, const struct _timg__Move *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoSourceToken);
	soap_serialize_PointerTott__FocusMove(soap, &a->Focus);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__Move(struct soap *soap, const char *tag, int id, const struct _timg__Move *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__Move), type))
		return soap->error;
	if (a->VideoSourceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->VideoSourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:VideoSourceToken"))
		return soap->error;
	if (a->Focus)
	{	if (soap_out_PointerTott__FocusMove(soap, "timg:Focus", -1, &a->Focus, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:Focus"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__Move * SOAP_FMAC4 soap_in__timg__Move(struct soap *soap, const char *tag, struct _timg__Move *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	size_t soap_flag_Focus = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__Move *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__Move, sizeof(struct _timg__Move), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__Move(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap_flag_Focus && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__FocusMove(soap, "timg:Focus", &a->Focus, "tt:FocusMove"))
				{	soap_flag_Focus--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__Move *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__Move, 0, sizeof(struct _timg__Move), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0 || soap_flag_Focus > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__Move(struct soap *soap, const struct _timg__Move *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__Move);
	if (soap_out__timg__Move(soap, tag?tag:"timg:Move", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__Move * SOAP_FMAC4 soap_get__timg__Move(struct soap *soap, struct _timg__Move *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__Move(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetOptionsResponse(struct soap *soap, struct _timg__GetOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ImagingOptions = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetOptionsResponse(struct soap *soap, const struct _timg__GetOptionsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ImagingOptions20(soap, &a->ImagingOptions);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetOptionsResponse(struct soap *soap, const char *tag, int id, const struct _timg__GetOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetOptionsResponse), type))
		return soap->error;
	if (a->ImagingOptions)
		soap_element_result(soap, "timg:ImagingOptions");
	if (a->ImagingOptions)
	{	if (soap_out_PointerTott__ImagingOptions20(soap, "timg:ImagingOptions", -1, &a->ImagingOptions, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:ImagingOptions"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetOptionsResponse * SOAP_FMAC4 soap_in__timg__GetOptionsResponse(struct soap *soap, const char *tag, struct _timg__GetOptionsResponse *a, const char *type)
{
	size_t soap_flag_ImagingOptions = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetOptionsResponse, sizeof(struct _timg__GetOptionsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImagingOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingOptions20(soap, "timg:ImagingOptions", &a->ImagingOptions, "tt:ImagingOptions20"))
				{	soap_flag_ImagingOptions--;
					continue;
				}
			soap_check_result(soap, "timg:ImagingOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetOptionsResponse, 0, sizeof(struct _timg__GetOptionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ImagingOptions > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetOptionsResponse(struct soap *soap, const struct _timg__GetOptionsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetOptionsResponse);
	if (soap_out__timg__GetOptionsResponse(soap, tag?tag:"timg:GetOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetOptionsResponse * SOAP_FMAC4 soap_get__timg__GetOptionsResponse(struct soap *soap, struct _timg__GetOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetOptions(struct soap *soap, struct _timg__GetOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetOptions(struct soap *soap, const struct _timg__GetOptions *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoSourceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetOptions(struct soap *soap, const char *tag, int id, const struct _timg__GetOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetOptions), type))
		return soap->error;
	if (a->VideoSourceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->VideoSourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:VideoSourceToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetOptions * SOAP_FMAC4 soap_in__timg__GetOptions(struct soap *soap, const char *tag, struct _timg__GetOptions *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetOptions, sizeof(struct _timg__GetOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetOptions, 0, sizeof(struct _timg__GetOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetOptions(struct soap *soap, const struct _timg__GetOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetOptions);
	if (soap_out__timg__GetOptions(soap, tag?tag:"timg:GetOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetOptions * SOAP_FMAC4 soap_get__timg__GetOptions(struct soap *soap, struct _timg__GetOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__SetImagingSettingsResponse(struct soap *soap, struct _timg__SetImagingSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__SetImagingSettingsResponse(struct soap *soap, const struct _timg__SetImagingSettingsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__SetImagingSettingsResponse(struct soap *soap, const char *tag, int id, const struct _timg__SetImagingSettingsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__SetImagingSettingsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__SetImagingSettingsResponse * SOAP_FMAC4 soap_in__timg__SetImagingSettingsResponse(struct soap *soap, const char *tag, struct _timg__SetImagingSettingsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__SetImagingSettingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__SetImagingSettingsResponse, sizeof(struct _timg__SetImagingSettingsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__SetImagingSettingsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__SetImagingSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__SetImagingSettingsResponse, 0, sizeof(struct _timg__SetImagingSettingsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__SetImagingSettingsResponse(struct soap *soap, const struct _timg__SetImagingSettingsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__SetImagingSettingsResponse);
	if (soap_out__timg__SetImagingSettingsResponse(soap, tag?tag:"timg:SetImagingSettingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__SetImagingSettingsResponse * SOAP_FMAC4 soap_get__timg__SetImagingSettingsResponse(struct soap *soap, struct _timg__SetImagingSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__SetImagingSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__SetImagingSettings(struct soap *soap, struct _timg__SetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
	a->ImagingSettings = NULL;
	a->ForcePersistence_x0020 = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__SetImagingSettings(struct soap *soap, const struct _timg__SetImagingSettings *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoSourceToken);
	soap_serialize_PointerTott__ImagingSettings20(soap, &a->ImagingSettings);
	soap_serialize_PointerToxsd__boolean(soap, &a->ForcePersistence_x0020);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__SetImagingSettings(struct soap *soap, const char *tag, int id, const struct _timg__SetImagingSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__SetImagingSettings), type))
		return soap->error;
	if (a->VideoSourceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->VideoSourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:VideoSourceToken"))
		return soap->error;
	if (a->ImagingSettings)
	{	if (soap_out_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", -1, &a->ImagingSettings, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:ImagingSettings"))
		return soap->error;
	if (soap_out_PointerToxsd__boolean(soap, "timg:ForcePersistence ", -1, &a->ForcePersistence_x0020, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__SetImagingSettings * SOAP_FMAC4 soap_in__timg__SetImagingSettings(struct soap *soap, const char *tag, struct _timg__SetImagingSettings *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	size_t soap_flag_ImagingSettings = 1;
	size_t soap_flag_ForcePersistence_x0020 = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__SetImagingSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__SetImagingSettings, sizeof(struct _timg__SetImagingSettings), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__SetImagingSettings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap_flag_ImagingSettings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", &a->ImagingSettings, "tt:ImagingSettings20"))
				{	soap_flag_ImagingSettings--;
					continue;
				}
			if (soap_flag_ForcePersistence_x0020 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__boolean(soap, "timg:ForcePersistence ", &a->ForcePersistence_x0020, "xsd:boolean"))
				{	soap_flag_ForcePersistence_x0020--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__SetImagingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__SetImagingSettings, 0, sizeof(struct _timg__SetImagingSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0 || soap_flag_ImagingSettings > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__SetImagingSettings(struct soap *soap, const struct _timg__SetImagingSettings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__SetImagingSettings);
	if (soap_out__timg__SetImagingSettings(soap, tag?tag:"timg:SetImagingSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__SetImagingSettings * SOAP_FMAC4 soap_get__timg__SetImagingSettings(struct soap *soap, struct _timg__SetImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__SetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetImagingSettingsResponse(struct soap *soap, struct _timg__GetImagingSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->ImagingSettings = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetImagingSettingsResponse(struct soap *soap, const struct _timg__GetImagingSettingsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__ImagingSettings20(soap, &a->ImagingSettings);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetImagingSettingsResponse(struct soap *soap, const char *tag, int id, const struct _timg__GetImagingSettingsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetImagingSettingsResponse), type))
		return soap->error;
	if (a->ImagingSettings)
		soap_element_result(soap, "timg:ImagingSettings");
	if (a->ImagingSettings)
	{	if (soap_out_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", -1, &a->ImagingSettings, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:ImagingSettings"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetImagingSettingsResponse * SOAP_FMAC4 soap_in__timg__GetImagingSettingsResponse(struct soap *soap, const char *tag, struct _timg__GetImagingSettingsResponse *a, const char *type)
{
	size_t soap_flag_ImagingSettings = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetImagingSettingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetImagingSettingsResponse, sizeof(struct _timg__GetImagingSettingsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetImagingSettingsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_ImagingSettings && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__ImagingSettings20(soap, "timg:ImagingSettings", &a->ImagingSettings, "tt:ImagingSettings20"))
				{	soap_flag_ImagingSettings--;
					continue;
				}
			soap_check_result(soap, "timg:ImagingSettings");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetImagingSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetImagingSettingsResponse, 0, sizeof(struct _timg__GetImagingSettingsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_ImagingSettings > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetImagingSettingsResponse(struct soap *soap, const struct _timg__GetImagingSettingsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetImagingSettingsResponse);
	if (soap_out__timg__GetImagingSettingsResponse(soap, tag?tag:"timg:GetImagingSettingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetImagingSettingsResponse * SOAP_FMAC4 soap_get__timg__GetImagingSettingsResponse(struct soap *soap, struct _timg__GetImagingSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetImagingSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetImagingSettings(struct soap *soap, struct _timg__GetImagingSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoSourceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetImagingSettings(struct soap *soap, const struct _timg__GetImagingSettings *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoSourceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetImagingSettings(struct soap *soap, const char *tag, int id, const struct _timg__GetImagingSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetImagingSettings), type))
		return soap->error;
	if (a->VideoSourceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "timg:VideoSourceToken", -1, &a->VideoSourceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:VideoSourceToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetImagingSettings * SOAP_FMAC4 soap_in__timg__GetImagingSettings(struct soap *soap, const char *tag, struct _timg__GetImagingSettings *a, const char *type)
{
	size_t soap_flag_VideoSourceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetImagingSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetImagingSettings, sizeof(struct _timg__GetImagingSettings), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetImagingSettings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoSourceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "timg:VideoSourceToken", &a->VideoSourceToken, "tt:ReferenceToken"))
				{	soap_flag_VideoSourceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetImagingSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetImagingSettings, 0, sizeof(struct _timg__GetImagingSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoSourceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetImagingSettings(struct soap *soap, const struct _timg__GetImagingSettings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetImagingSettings);
	if (soap_out__timg__GetImagingSettings(soap, tag?tag:"timg:GetImagingSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetImagingSettings * SOAP_FMAC4 soap_get__timg__GetImagingSettings(struct soap *soap, struct _timg__GetImagingSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetImagingSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetServiceCapabilitiesResponse(struct soap *soap, struct _timg__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetServiceCapabilitiesResponse(struct soap *soap, const struct _timg__GetServiceCapabilitiesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotimg__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _timg__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "timg:Capabilities");
	if (a->Capabilities)
	{	if (soap_out_PointerTotimg__Capabilities(soap, "timg:Capabilities", -1, &a->Capabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "timg:Capabilities"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__timg__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _timg__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetServiceCapabilitiesResponse, sizeof(struct _timg__GetServiceCapabilitiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotimg__Capabilities(soap, "timg:Capabilities", &a->Capabilities, "timg:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "timg:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetServiceCapabilitiesResponse, 0, sizeof(struct _timg__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetServiceCapabilitiesResponse(struct soap *soap, const struct _timg__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetServiceCapabilitiesResponse);
	if (soap_out__timg__GetServiceCapabilitiesResponse(soap, tag?tag:"timg:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__timg__GetServiceCapabilitiesResponse(struct soap *soap, struct _timg__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__timg__GetServiceCapabilities(struct soap *soap, struct _timg__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__timg__GetServiceCapabilities(struct soap *soap, const struct _timg__GetServiceCapabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__timg__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _timg__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__timg__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilities * SOAP_FMAC4 soap_in__timg__GetServiceCapabilities(struct soap *soap, const char *tag, struct _timg__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _timg__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__timg__GetServiceCapabilities, sizeof(struct _timg__GetServiceCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__timg__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _timg__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__timg__GetServiceCapabilities, 0, sizeof(struct _timg__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__timg__GetServiceCapabilities(struct soap *soap, const struct _timg__GetServiceCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__timg__GetServiceCapabilities);
	if (soap_out__timg__GetServiceCapabilities(soap, tag?tag:"timg:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _timg__GetServiceCapabilities * SOAP_FMAC4 soap_get__timg__GetServiceCapabilities(struct soap *soap, struct _timg__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__timg__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_timg__Capabilities(struct soap *soap, struct timg__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->ImageStabilization = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_timg__Capabilities(struct soap *soap, const struct timg__Capabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_timg__Capabilities(struct soap *soap, const char *tag, int id, const struct timg__Capabilities *a, const char *type)
{
	if (a->ImageStabilization)
		soap_set_attr(soap, "ImageStabilization", soap_xsd__boolean2s(soap, *a->ImageStabilization), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_timg__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct timg__Capabilities * SOAP_FMAC4 soap_in_timg__Capabilities(struct soap *soap, const char *tag, struct timg__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct timg__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_timg__Capabilities, sizeof(struct timg__Capabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_timg__Capabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "ImageStabilization", 0);
		if (t)
		{
			if (!(a->ImageStabilization = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->ImageStabilization))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct timg__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_timg__Capabilities, 0, sizeof(struct timg__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_timg__Capabilities(struct soap *soap, const struct timg__Capabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_timg__Capabilities);
	if (soap_out_timg__Capabilities(soap, tag?tag:"timg:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct timg__Capabilities * SOAP_FMAC4 soap_get_timg__Capabilities(struct soap *soap, struct timg__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_timg__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__GetEventPropertiesResponse(struct soap *soap, struct _tev__GetEventPropertiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeTopicNamespaceLocation = 0;
	a->TopicNamespaceLocation = NULL;
	soap_default_xsd__boolean(soap, &a->wsnt__FixedTopicSet);
	a->wstop__TopicSet = NULL;
	a->__sizeTopicExpressionDialect = 0;
	a->wsnt__TopicExpressionDialect = NULL;
	a->__sizeMessageContentFilterDialect = 0;
	a->MessageContentFilterDialect = NULL;
	a->__sizeProducerPropertiesFilterDialect = 0;
	a->ProducerPropertiesFilterDialect = NULL;
	a->__sizeMessageContentSchemaLocation = 0;
	a->MessageContentSchemaLocation = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__GetEventPropertiesResponse(struct soap *soap, const struct _tev__GetEventPropertiesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->TopicNamespaceLocation)
	{	int i;
		for (i = 0; i < a->__sizeTopicNamespaceLocation; i++)
		{
			soap_serialize_xsd__anyURI(soap, a->TopicNamespaceLocation + i);
		}
	}
	soap_embedded(soap, &a->wsnt__FixedTopicSet, SOAP_TYPE_xsd__boolean);
	soap_serialize_PointerTowstop__TopicSetType(soap, &a->wstop__TopicSet);
	if (a->wsnt__TopicExpressionDialect)
	{	int i;
		for (i = 0; i < a->__sizeTopicExpressionDialect; i++)
		{
			soap_serialize_xsd__anyURI(soap, a->wsnt__TopicExpressionDialect + i);
		}
	}
	if (a->MessageContentFilterDialect)
	{	int i;
		for (i = 0; i < a->__sizeMessageContentFilterDialect; i++)
		{
			soap_serialize_xsd__anyURI(soap, a->MessageContentFilterDialect + i);
		}
	}
	if (a->ProducerPropertiesFilterDialect)
	{	int i;
		for (i = 0; i < a->__sizeProducerPropertiesFilterDialect; i++)
		{
			soap_serialize_xsd__anyURI(soap, a->ProducerPropertiesFilterDialect + i);
		}
	}
	if (a->MessageContentSchemaLocation)
	{	int i;
		for (i = 0; i < a->__sizeMessageContentSchemaLocation; i++)
		{
			soap_serialize_xsd__anyURI(soap, a->MessageContentSchemaLocation + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetEventPropertiesResponse(struct soap *soap, const char *tag, int id, const struct _tev__GetEventPropertiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetEventPropertiesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeTopicNamespaceLocation");
	if (a->TopicNamespaceLocation)
	{	int i;
		for (i = 0; i < a->__sizeTopicNamespaceLocation; i++)
			if (soap_out_xsd__anyURI(soap, "tev:TopicNamespaceLocation", -1, a->TopicNamespaceLocation + i, ""))
				return soap->error;
	}
	if (soap_out_xsd__boolean(soap, "wsnt:FixedTopicSet", -1, &a->wsnt__FixedTopicSet, ""))
		return soap->error;
	if (a->wstop__TopicSet)
	{	if (soap_out_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", -1, &a->wstop__TopicSet, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "wstop:TopicSet"))
		return soap->error;
	if (a->wsnt__TopicExpressionDialect)
	{	int i;
		for (i = 0; i < a->__sizeTopicExpressionDialect; i++)
			if (soap_out_xsd__anyURI(soap, "wsnt:TopicExpressionDialect", -1, a->wsnt__TopicExpressionDialect + i, ""))
				return soap->error;
	}
	if (a->MessageContentFilterDialect)
	{	int i;
		for (i = 0; i < a->__sizeMessageContentFilterDialect; i++)
			if (soap_out_xsd__anyURI(soap, "tev:MessageContentFilterDialect", -1, a->MessageContentFilterDialect + i, ""))
				return soap->error;
	}
	if (a->ProducerPropertiesFilterDialect)
	{	int i;
		for (i = 0; i < a->__sizeProducerPropertiesFilterDialect; i++)
			if (soap_out_xsd__anyURI(soap, "tev:ProducerPropertiesFilterDialect", -1, a->ProducerPropertiesFilterDialect + i, ""))
				return soap->error;
	}
	if (a->MessageContentSchemaLocation)
	{	int i;
		for (i = 0; i < a->__sizeMessageContentSchemaLocation; i++)
			if (soap_out_xsd__anyURI(soap, "tev:MessageContentSchemaLocation", -1, a->MessageContentSchemaLocation + i, ""))
				return soap->error;
	}
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__GetEventPropertiesResponse * SOAP_FMAC4 soap_in__tev__GetEventPropertiesResponse(struct soap *soap, const char *tag, struct _tev__GetEventPropertiesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_TopicNamespaceLocation = NULL;
	size_t soap_flag_wsnt__FixedTopicSet = 1;
	size_t soap_flag_wstop__TopicSet = 1;
	struct soap_blist *soap_blist_wsnt__TopicExpressionDialect = NULL;
	struct soap_blist *soap_blist_MessageContentFilterDialect = NULL;
	struct soap_blist *soap_blist_ProducerPropertiesFilterDialect = NULL;
	struct soap_blist *soap_blist_MessageContentSchemaLocation = NULL;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__GetEventPropertiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetEventPropertiesResponse, sizeof(struct _tev__GetEventPropertiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__GetEventPropertiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tev:TopicNamespaceLocation", 1, NULL))
			{	if (a->TopicNamespaceLocation == NULL)
				{	if (soap_blist_TopicNamespaceLocation == NULL)
						soap_blist_TopicNamespaceLocation = soap_new_block(soap);
					a->TopicNamespaceLocation = (char **)soap_push_block(soap, soap_blist_TopicNamespaceLocation, sizeof(char *));
					if (a->TopicNamespaceLocation == NULL)
						return NULL;
					*a->TopicNamespaceLocation = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tev:TopicNamespaceLocation", a->TopicNamespaceLocation, "xsd:anyURI"))
				{	a->__sizeTopicNamespaceLocation++;
					a->TopicNamespaceLocation = NULL;
					continue;
				}
			}
			if (soap_flag_wsnt__FixedTopicSet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "wsnt:FixedTopicSet", &a->wsnt__FixedTopicSet, "xsd:boolean"))
				{	soap_flag_wsnt__FixedTopicSet--;
					continue;
				}
			if (soap_flag_wstop__TopicSet && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowstop__TopicSetType(soap, "wstop:TopicSet", &a->wstop__TopicSet, "wstop:TopicSetType"))
				{	soap_flag_wstop__TopicSet--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:TopicExpressionDialect", 1, NULL))
			{	if (a->wsnt__TopicExpressionDialect == NULL)
				{	if (soap_blist_wsnt__TopicExpressionDialect == NULL)
						soap_blist_wsnt__TopicExpressionDialect = soap_new_block(soap);
					a->wsnt__TopicExpressionDialect = (char **)soap_push_block(soap, soap_blist_wsnt__TopicExpressionDialect, sizeof(char *));
					if (a->wsnt__TopicExpressionDialect == NULL)
						return NULL;
					*a->wsnt__TopicExpressionDialect = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "wsnt:TopicExpressionDialect", a->wsnt__TopicExpressionDialect, "xsd:anyURI"))
				{	a->__sizeTopicExpressionDialect++;
					a->wsnt__TopicExpressionDialect = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tev:MessageContentFilterDialect", 1, NULL))
			{	if (a->MessageContentFilterDialect == NULL)
				{	if (soap_blist_MessageContentFilterDialect == NULL)
						soap_blist_MessageContentFilterDialect = soap_new_block(soap);
					a->MessageContentFilterDialect = (char **)soap_push_block(soap, soap_blist_MessageContentFilterDialect, sizeof(char *));
					if (a->MessageContentFilterDialect == NULL)
						return NULL;
					*a->MessageContentFilterDialect = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tev:MessageContentFilterDialect", a->MessageContentFilterDialect, "xsd:anyURI"))
				{	a->__sizeMessageContentFilterDialect++;
					a->MessageContentFilterDialect = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tev:ProducerPropertiesFilterDialect", 1, NULL))
			{	if (a->ProducerPropertiesFilterDialect == NULL)
				{	if (soap_blist_ProducerPropertiesFilterDialect == NULL)
						soap_blist_ProducerPropertiesFilterDialect = soap_new_block(soap);
					a->ProducerPropertiesFilterDialect = (char **)soap_push_block(soap, soap_blist_ProducerPropertiesFilterDialect, sizeof(char *));
					if (a->ProducerPropertiesFilterDialect == NULL)
						return NULL;
					*a->ProducerPropertiesFilterDialect = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tev:ProducerPropertiesFilterDialect", a->ProducerPropertiesFilterDialect, "xsd:anyURI"))
				{	a->__sizeProducerPropertiesFilterDialect++;
					a->ProducerPropertiesFilterDialect = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tev:MessageContentSchemaLocation", 1, NULL))
			{	if (a->MessageContentSchemaLocation == NULL)
				{	if (soap_blist_MessageContentSchemaLocation == NULL)
						soap_blist_MessageContentSchemaLocation = soap_new_block(soap);
					a->MessageContentSchemaLocation = (char **)soap_push_block(soap, soap_blist_MessageContentSchemaLocation, sizeof(char *));
					if (a->MessageContentSchemaLocation == NULL)
						return NULL;
					*a->MessageContentSchemaLocation = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__anyURI(soap, "tev:MessageContentSchemaLocation", a->MessageContentSchemaLocation, "xsd:anyURI"))
				{	a->__sizeMessageContentSchemaLocation++;
					a->MessageContentSchemaLocation = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeTopicNamespaceLocation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->TopicNamespaceLocation)
			soap_pop_block(soap, soap_blist_TopicNamespaceLocation);
		if (a->__sizeTopicNamespaceLocation)
			a->TopicNamespaceLocation = (char **)soap_save_block(soap, soap_blist_TopicNamespaceLocation, NULL, 1);
		else
		{	a->TopicNamespaceLocation = NULL;
			if (soap_blist_TopicNamespaceLocation)
				soap_end_block(soap, soap_blist_TopicNamespaceLocation);
		}
		if (a->wsnt__TopicExpressionDialect)
			soap_pop_block(soap, soap_blist_wsnt__TopicExpressionDialect);
		if (a->__sizeTopicExpressionDialect)
			a->wsnt__TopicExpressionDialect = (char **)soap_save_block(soap, soap_blist_wsnt__TopicExpressionDialect, NULL, 1);
		else
		{	a->wsnt__TopicExpressionDialect = NULL;
			if (soap_blist_wsnt__TopicExpressionDialect)
				soap_end_block(soap, soap_blist_wsnt__TopicExpressionDialect);
		}
		if (a->MessageContentFilterDialect)
			soap_pop_block(soap, soap_blist_MessageContentFilterDialect);
		if (a->__sizeMessageContentFilterDialect)
			a->MessageContentFilterDialect = (char **)soap_save_block(soap, soap_blist_MessageContentFilterDialect, NULL, 1);
		else
		{	a->MessageContentFilterDialect = NULL;
			if (soap_blist_MessageContentFilterDialect)
				soap_end_block(soap, soap_blist_MessageContentFilterDialect);
		}
		if (a->ProducerPropertiesFilterDialect)
			soap_pop_block(soap, soap_blist_ProducerPropertiesFilterDialect);
		if (a->__sizeProducerPropertiesFilterDialect)
			a->ProducerPropertiesFilterDialect = (char **)soap_save_block(soap, soap_blist_ProducerPropertiesFilterDialect, NULL, 1);
		else
		{	a->ProducerPropertiesFilterDialect = NULL;
			if (soap_blist_ProducerPropertiesFilterDialect)
				soap_end_block(soap, soap_blist_ProducerPropertiesFilterDialect);
		}
		if (a->MessageContentSchemaLocation)
			soap_pop_block(soap, soap_blist_MessageContentSchemaLocation);
		if (a->__sizeMessageContentSchemaLocation)
			a->MessageContentSchemaLocation = (char **)soap_save_block(soap, soap_blist_MessageContentSchemaLocation, NULL, 1);
		else
		{	a->MessageContentSchemaLocation = NULL;
			if (soap_blist_MessageContentSchemaLocation)
				soap_end_block(soap, soap_blist_MessageContentSchemaLocation);
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__GetEventPropertiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetEventPropertiesResponse, 0, sizeof(struct _tev__GetEventPropertiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeTopicNamespaceLocation < 1 || soap_flag_wsnt__FixedTopicSet > 0 || soap_flag_wstop__TopicSet > 0 || a->__sizeTopicExpressionDialect < 1 || a->__sizeMessageContentFilterDialect < 1 || a->__sizeMessageContentSchemaLocation < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__GetEventPropertiesResponse(struct soap *soap, const struct _tev__GetEventPropertiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tev__GetEventPropertiesResponse);
	if (soap_out__tev__GetEventPropertiesResponse(soap, tag?tag:"tev:GetEventPropertiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetEventPropertiesResponse * SOAP_FMAC4 soap_get__tev__GetEventPropertiesResponse(struct soap *soap, struct _tev__GetEventPropertiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetEventPropertiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__GetEventProperties(struct soap *soap, struct _tev__GetEventProperties *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__GetEventProperties(struct soap *soap, const struct _tev__GetEventProperties *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetEventProperties(struct soap *soap, const char *tag, int id, const struct _tev__GetEventProperties *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetEventProperties), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__GetEventProperties * SOAP_FMAC4 soap_in__tev__GetEventProperties(struct soap *soap, const char *tag, struct _tev__GetEventProperties *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__GetEventProperties *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetEventProperties, sizeof(struct _tev__GetEventProperties), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__GetEventProperties(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__GetEventProperties *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetEventProperties, 0, sizeof(struct _tev__GetEventProperties), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__GetEventProperties(struct soap *soap, const struct _tev__GetEventProperties *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tev__GetEventProperties);
	if (soap_out__tev__GetEventProperties(soap, tag?tag:"tev:GetEventProperties", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetEventProperties * SOAP_FMAC4 soap_get__tev__GetEventProperties(struct soap *soap, struct _tev__GetEventProperties *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetEventProperties(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__SetSynchronizationPointResponse(struct soap *soap, struct _tev__SetSynchronizationPointResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__SetSynchronizationPointResponse(struct soap *soap, const struct _tev__SetSynchronizationPointResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__SetSynchronizationPointResponse(struct soap *soap, const char *tag, int id, const struct _tev__SetSynchronizationPointResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__SetSynchronizationPointResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPointResponse * SOAP_FMAC4 soap_in__tev__SetSynchronizationPointResponse(struct soap *soap, const char *tag, struct _tev__SetSynchronizationPointResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__SetSynchronizationPointResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__SetSynchronizationPointResponse, sizeof(struct _tev__SetSynchronizationPointResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__SetSynchronizationPointResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__SetSynchronizationPointResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__SetSynchronizationPointResponse, 0, sizeof(struct _tev__SetSynchronizationPointResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__SetSynchronizationPointResponse(struct soap *soap, const struct _tev__SetSynchronizationPointResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tev__SetSynchronizationPointResponse);
	if (soap_out__tev__SetSynchronizationPointResponse(soap, tag?tag:"tev:SetSynchronizationPointResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPointResponse * SOAP_FMAC4 soap_get__tev__SetSynchronizationPointResponse(struct soap *soap, struct _tev__SetSynchronizationPointResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__SetSynchronizationPointResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__SetSynchronizationPoint(struct soap *soap, struct _tev__SetSynchronizationPoint *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__SetSynchronizationPoint(struct soap *soap, const struct _tev__SetSynchronizationPoint *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__SetSynchronizationPoint(struct soap *soap, const char *tag, int id, const struct _tev__SetSynchronizationPoint *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__SetSynchronizationPoint), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPoint * SOAP_FMAC4 soap_in__tev__SetSynchronizationPoint(struct soap *soap, const char *tag, struct _tev__SetSynchronizationPoint *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__SetSynchronizationPoint *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__SetSynchronizationPoint, sizeof(struct _tev__SetSynchronizationPoint), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__SetSynchronizationPoint(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__SetSynchronizationPoint *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__SetSynchronizationPoint, 0, sizeof(struct _tev__SetSynchronizationPoint), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__SetSynchronizationPoint(struct soap *soap, const struct _tev__SetSynchronizationPoint *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tev__SetSynchronizationPoint);
	if (soap_out__tev__SetSynchronizationPoint(soap, tag?tag:"tev:SetSynchronizationPoint", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__SetSynchronizationPoint * SOAP_FMAC4 soap_get__tev__SetSynchronizationPoint(struct soap *soap, struct _tev__SetSynchronizationPoint *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__SetSynchronizationPoint(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__PullMessagesFaultResponse(struct soap *soap, struct _tev__PullMessagesFaultResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__duration(soap, &a->MaxTimeout);
	soap_default_int(soap, &a->MaxMessageLimit);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__PullMessagesFaultResponse(struct soap *soap, const struct _tev__PullMessagesFaultResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->MaxTimeout, SOAP_TYPE_xsd__duration);
	soap_embedded(soap, &a->MaxMessageLimit, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, int id, const struct _tev__PullMessagesFaultResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__PullMessagesFaultResponse), type))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tev:MaxTimeout", -1, &a->MaxTimeout, ""))
		return soap->error;
	if (soap_out_int(soap, "tev:MaxMessageLimit", -1, &a->MaxMessageLimit, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__PullMessagesFaultResponse * SOAP_FMAC4 soap_in__tev__PullMessagesFaultResponse(struct soap *soap, const char *tag, struct _tev__PullMessagesFaultResponse *a, const char *type)
{
	size_t soap_flag_MaxTimeout = 1;
	size_t soap_flag_MaxMessageLimit = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__PullMessagesFaultResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessagesFaultResponse, sizeof(struct _tev__PullMessagesFaultResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__PullMessagesFaultResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_MaxTimeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tev:MaxTimeout", &a->MaxTimeout, "xsd:duration"))
				{	soap_flag_MaxTimeout--;
					continue;
				}
			if (soap_flag_MaxMessageLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tev:MaxMessageLimit", &a->MaxMessageLimit, "xsd:int"))
				{	soap_flag_MaxMessageLimit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__PullMessagesFaultResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessagesFaultResponse, 0, sizeof(struct _tev__PullMessagesFaultResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_MaxTimeout > 0 || soap_flag_MaxMessageLimit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__PullMessagesFaultResponse(struct soap *soap, const struct _tev__PullMessagesFaultResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tev__PullMessagesFaultResponse);
	if (soap_out__tev__PullMessagesFaultResponse(soap, tag?tag:"tev:PullMessagesFaultResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__PullMessagesFaultResponse * SOAP_FMAC4 soap_get__tev__PullMessagesFaultResponse(struct soap *soap, struct _tev__PullMessagesFaultResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__PullMessagesFaultResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__PullMessagesResponse(struct soap *soap, struct _tev__PullMessagesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_time(soap, &a->CurrentTime);
	soap_default_time(soap, &a->TerminationTime);
	a->__sizeNotificationMessage = 0;
	a->wsnt__NotificationMessage = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__PullMessagesResponse(struct soap *soap, const struct _tev__PullMessagesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->CurrentTime, SOAP_TYPE_time);
	soap_embedded(soap, &a->TerminationTime, SOAP_TYPE_time);
	if (a->wsnt__NotificationMessage)
	{	int i;
		for (i = 0; i < a->__sizeNotificationMessage; i++)
		{
			soap_embedded(soap, a->wsnt__NotificationMessage + i, SOAP_TYPE_wsnt__NotificationMessageHolderType);
			soap_serialize_wsnt__NotificationMessageHolderType(soap, a->wsnt__NotificationMessage + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__PullMessagesResponse(struct soap *soap, const char *tag, int id, const struct _tev__PullMessagesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__PullMessagesResponse), type))
		return soap->error;
	soap_element_result(soap, "tev:CurrentTime");
	if (soap_out_time(soap, "tev:CurrentTime", -1, &a->CurrentTime, ""))
		return soap->error;
	if (soap_out_time(soap, "tev:TerminationTime", -1, &a->TerminationTime, ""))
		return soap->error;
	if (a->wsnt__NotificationMessage)
	{	int i;
		for (i = 0; i < a->__sizeNotificationMessage; i++)
			if (soap_out_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", -1, a->wsnt__NotificationMessage + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__PullMessagesResponse * SOAP_FMAC4 soap_in__tev__PullMessagesResponse(struct soap *soap, const char *tag, struct _tev__PullMessagesResponse *a, const char *type)
{
	size_t soap_flag_CurrentTime = 1;
	size_t soap_flag_TerminationTime = 1;
	struct soap_blist *soap_blist_wsnt__NotificationMessage = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__PullMessagesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessagesResponse, sizeof(struct _tev__PullMessagesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__PullMessagesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CurrentTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tev:CurrentTime", &a->CurrentTime, "xsd:dateTime"))
				{	soap_flag_CurrentTime--;
					continue;
				}
			if (soap_flag_TerminationTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "tev:TerminationTime", &a->TerminationTime, "xsd:dateTime"))
				{	soap_flag_TerminationTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "wsnt:NotificationMessage", 1, NULL))
			{	if (a->wsnt__NotificationMessage == NULL)
				{	if (soap_blist_wsnt__NotificationMessage == NULL)
						soap_blist_wsnt__NotificationMessage = soap_new_block(soap);
					a->wsnt__NotificationMessage = (struct wsnt__NotificationMessageHolderType *)soap_push_block(soap, soap_blist_wsnt__NotificationMessage, sizeof(struct wsnt__NotificationMessageHolderType));
					if (a->wsnt__NotificationMessage == NULL)
						return NULL;
					soap_default_wsnt__NotificationMessageHolderType(soap, a->wsnt__NotificationMessage);
				}
				soap_revert(soap);
				if (soap_in_wsnt__NotificationMessageHolderType(soap, "wsnt:NotificationMessage", a->wsnt__NotificationMessage, "wsnt:NotificationMessageHolderType"))
				{	a->__sizeNotificationMessage++;
					a->wsnt__NotificationMessage = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tev:CurrentTime");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->wsnt__NotificationMessage)
			soap_pop_block(soap, soap_blist_wsnt__NotificationMessage);
		if (a->__sizeNotificationMessage)
			a->wsnt__NotificationMessage = (struct wsnt__NotificationMessageHolderType *)soap_save_block(soap, soap_blist_wsnt__NotificationMessage, NULL, 1);
		else
		{	a->wsnt__NotificationMessage = NULL;
			if (soap_blist_wsnt__NotificationMessage)
				soap_end_block(soap, soap_blist_wsnt__NotificationMessage);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__PullMessagesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessagesResponse, 0, sizeof(struct _tev__PullMessagesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CurrentTime > 0 || soap_flag_TerminationTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__PullMessagesResponse(struct soap *soap, const struct _tev__PullMessagesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tev__PullMessagesResponse);
	if (soap_out__tev__PullMessagesResponse(soap, tag?tag:"tev:PullMessagesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__PullMessagesResponse * SOAP_FMAC4 soap_get__tev__PullMessagesResponse(struct soap *soap, struct _tev__PullMessagesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__PullMessagesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__PullMessages(struct soap *soap, struct _tev__PullMessages *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__duration(soap, &a->Timeout);
	soap_default_int(soap, &a->MessageLimit);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__PullMessages(struct soap *soap, const struct _tev__PullMessages *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Timeout, SOAP_TYPE_xsd__duration);
	soap_embedded(soap, &a->MessageLimit, SOAP_TYPE_int);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__PullMessages(struct soap *soap, const char *tag, int id, const struct _tev__PullMessages *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__PullMessages), type))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tev:Timeout", -1, &a->Timeout, ""))
		return soap->error;
	if (soap_out_int(soap, "tev:MessageLimit", -1, &a->MessageLimit, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__PullMessages * SOAP_FMAC4 soap_in__tev__PullMessages(struct soap *soap, const char *tag, struct _tev__PullMessages *a, const char *type)
{
	size_t soap_flag_Timeout = 1;
	size_t soap_flag_MessageLimit = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__PullMessages *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__PullMessages, sizeof(struct _tev__PullMessages), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__PullMessages(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Timeout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tev:Timeout", &a->Timeout, "xsd:duration"))
				{	soap_flag_Timeout--;
					continue;
				}
			if (soap_flag_MessageLimit && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "tev:MessageLimit", &a->MessageLimit, "xsd:int"))
				{	soap_flag_MessageLimit--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__PullMessages *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__PullMessages, 0, sizeof(struct _tev__PullMessages), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Timeout > 0 || soap_flag_MessageLimit > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__PullMessages(struct soap *soap, const struct _tev__PullMessages *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tev__PullMessages);
	if (soap_out__tev__PullMessages(soap, tag?tag:"tev:PullMessages", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__PullMessages * SOAP_FMAC4 soap_get__tev__PullMessages(struct soap *soap, struct _tev__PullMessages *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__PullMessages(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__CreatePullPointSubscriptionResponse(struct soap *soap, struct _tev__CreatePullPointSubscriptionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_default_time(soap, &a->wsnt__CurrentTime);
	soap_default_time(soap, &a->wsnt__TerminationTime);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const struct _tev__CreatePullPointSubscriptionResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->SubscriptionReference, SOAP_TYPE_wsa5__EndpointReferenceType);
	soap_serialize_wsa5__EndpointReferenceType(soap, &a->SubscriptionReference);
	soap_embedded(soap, &a->wsnt__CurrentTime, SOAP_TYPE_time);
	soap_embedded(soap, &a->wsnt__TerminationTime, SOAP_TYPE_time);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const char *tag, int id, const struct _tev__CreatePullPointSubscriptionResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse), type))
		return soap->error;
	soap_element_result(soap, "tev:SubscriptionReference");
	if (soap_out_wsa5__EndpointReferenceType(soap, "tev:SubscriptionReference", -1, &a->SubscriptionReference, ""))
		return soap->error;
	if (soap_out_time(soap, "wsnt:CurrentTime", -1, &a->wsnt__CurrentTime, ""))
		return soap->error;
	if (soap_out_time(soap, "wsnt:TerminationTime", -1, &a->wsnt__TerminationTime, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC4 soap_in__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const char *tag, struct _tev__CreatePullPointSubscriptionResponse *a, const char *type)
{
	size_t soap_flag_SubscriptionReference = 1;
	size_t soap_flag_wsnt__CurrentTime = 1;
	size_t soap_flag_wsnt__TerminationTime = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__CreatePullPointSubscriptionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, sizeof(struct _tev__CreatePullPointSubscriptionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__CreatePullPointSubscriptionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SubscriptionReference && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_wsa5__EndpointReferenceType(soap, "tev:SubscriptionReference", &a->SubscriptionReference, "wsa5:EndpointReferenceType"))
				{	soap_flag_SubscriptionReference--;
					continue;
				}
			if (soap_flag_wsnt__CurrentTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsnt:CurrentTime", &a->wsnt__CurrentTime, "xsd:dateTime"))
				{	soap_flag_wsnt__CurrentTime--;
					continue;
				}
			if (soap_flag_wsnt__TerminationTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_time(soap, "wsnt:TerminationTime", &a->wsnt__TerminationTime, "xsd:dateTime"))
				{	soap_flag_wsnt__TerminationTime--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tev:SubscriptionReference");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__CreatePullPointSubscriptionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse, 0, sizeof(struct _tev__CreatePullPointSubscriptionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_SubscriptionReference > 0 || soap_flag_wsnt__CurrentTime > 0 || soap_flag_wsnt__TerminationTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__CreatePullPointSubscriptionResponse(struct soap *soap, const struct _tev__CreatePullPointSubscriptionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tev__CreatePullPointSubscriptionResponse);
	if (soap_out__tev__CreatePullPointSubscriptionResponse(soap, tag?tag:"tev:CreatePullPointSubscriptionResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscriptionResponse * SOAP_FMAC4 soap_get__tev__CreatePullPointSubscriptionResponse(struct soap *soap, struct _tev__CreatePullPointSubscriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__CreatePullPointSubscriptionResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, int id, const struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_in__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const char *tag, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__CreatePullPointSubscription_SubscriptionPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy, 0, sizeof(struct _tev__CreatePullPointSubscription_SubscriptionPolicy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, const struct _tev__CreatePullPointSubscription_SubscriptionPolicy *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tev__CreatePullPointSubscription_SubscriptionPolicy);
	if (soap_out__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag?tag:"tev:CreatePullPointSubscription-SubscriptionPolicy", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription_SubscriptionPolicy * SOAP_FMAC4 soap_get__tev__CreatePullPointSubscription_SubscriptionPolicy(struct soap *soap, struct _tev__CreatePullPointSubscription_SubscriptionPolicy *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__CreatePullPointSubscription_SubscriptionPolicy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__CreatePullPointSubscription(struct soap *soap, struct _tev__CreatePullPointSubscription *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Filter = NULL;
	soap_default_wsnt__AbsoluteOrRelativeTimeType(soap, &a->InitialTerminationTime);
	a->SubscriptionPolicy = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__CreatePullPointSubscription(struct soap *soap, const struct _tev__CreatePullPointSubscription *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTowsnt__FilterType(soap, &a->Filter);
	soap_serialize_wsnt__AbsoluteOrRelativeTimeType(soap, &a->InitialTerminationTime);
	soap_serialize_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, &a->SubscriptionPolicy);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__CreatePullPointSubscription(struct soap *soap, const char *tag, int id, const struct _tev__CreatePullPointSubscription *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__CreatePullPointSubscription), type))
		return soap->error;
	if (soap_out_PointerTowsnt__FilterType(soap, "tev:Filter", -1, &a->Filter, ""))
		return soap->error;
	if (soap_out_wsnt__AbsoluteOrRelativeTimeType(soap, "tev:InitialTerminationTime", -1, &a->InitialTerminationTime, ""))
		return soap->error;
	if (soap_out_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, "tev:SubscriptionPolicy", -1, &a->SubscriptionPolicy, ""))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription * SOAP_FMAC4 soap_in__tev__CreatePullPointSubscription(struct soap *soap, const char *tag, struct _tev__CreatePullPointSubscription *a, const char *type)
{
	size_t soap_flag_Filter = 1;
	size_t soap_flag_InitialTerminationTime = 1;
	size_t soap_flag_SubscriptionPolicy = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__CreatePullPointSubscription *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__CreatePullPointSubscription, sizeof(struct _tev__CreatePullPointSubscription), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__CreatePullPointSubscription(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Filter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTowsnt__FilterType(soap, "tev:Filter", &a->Filter, "wsnt:FilterType"))
				{	soap_flag_Filter--;
					continue;
				}
			if (soap_flag_InitialTerminationTime && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_wsnt__AbsoluteOrRelativeTimeType(soap, "tev:InitialTerminationTime", &a->InitialTerminationTime, "wsnt:AbsoluteOrRelativeTimeType"))
				{	soap_flag_InitialTerminationTime--;
					continue;
				}
			if (soap_flag_SubscriptionPolicy && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tev__CreatePullPointSubscription_SubscriptionPolicy(soap, "tev:SubscriptionPolicy", &a->SubscriptionPolicy, ""))
				{	soap_flag_SubscriptionPolicy--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__CreatePullPointSubscription *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__CreatePullPointSubscription, 0, sizeof(struct _tev__CreatePullPointSubscription), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__CreatePullPointSubscription(struct soap *soap, const struct _tev__CreatePullPointSubscription *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tev__CreatePullPointSubscription);
	if (soap_out__tev__CreatePullPointSubscription(soap, tag?tag:"tev:CreatePullPointSubscription", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__CreatePullPointSubscription * SOAP_FMAC4 soap_get__tev__CreatePullPointSubscription(struct soap *soap, struct _tev__CreatePullPointSubscription *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__CreatePullPointSubscription(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__GetServiceCapabilitiesResponse(struct soap *soap, struct _tev__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tev__GetServiceCapabilitiesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotev__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tev__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tev:Capabilities");
	if (a->Capabilities)
	{	if (soap_out_PointerTotev__Capabilities(soap, "tev:Capabilities", -1, &a->Capabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tev:Capabilities"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tev__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tev__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, sizeof(struct _tev__GetServiceCapabilitiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotev__Capabilities(soap, "tev:Capabilities", &a->Capabilities, "tev:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "tev:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetServiceCapabilitiesResponse, 0, sizeof(struct _tev__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tev__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tev__GetServiceCapabilitiesResponse);
	if (soap_out__tev__GetServiceCapabilitiesResponse(soap, tag?tag:"tev:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tev__GetServiceCapabilitiesResponse(struct soap *soap, struct _tev__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tev__GetServiceCapabilities(struct soap *soap, struct _tev__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tev__GetServiceCapabilities(struct soap *soap, const struct _tev__GetServiceCapabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tev__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tev__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tev__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilities * SOAP_FMAC4 soap_in__tev__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tev__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tev__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tev__GetServiceCapabilities, sizeof(struct _tev__GetServiceCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tev__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tev__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tev__GetServiceCapabilities, 0, sizeof(struct _tev__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tev__GetServiceCapabilities(struct soap *soap, const struct _tev__GetServiceCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tev__GetServiceCapabilities);
	if (soap_out__tev__GetServiceCapabilities(soap, tag?tag:"tev:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tev__GetServiceCapabilities * SOAP_FMAC4 soap_get__tev__GetServiceCapabilities(struct soap *soap, struct _tev__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tev__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tev__Capabilities(struct soap *soap, struct tev__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->WSSubscriptionPolicySupport = NULL;
	a->WSPullPointSupport = NULL;
	a->WSPausableSubscriptionManagerInterfaceSupport = NULL;
	a->RateLimitPolicySupport = NULL;
	a->MaxNotificationProducers = NULL;
	a->MaxPullPoints = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tev__Capabilities(struct soap *soap, const struct tev__Capabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tev__Capabilities(struct soap *soap, const char *tag, int id, const struct tev__Capabilities *a, const char *type)
{
	if (a->WSSubscriptionPolicySupport)
		soap_set_attr(soap, "WSSubscriptionPolicySupport", soap_xsd__boolean2s(soap, *a->WSSubscriptionPolicySupport), 1);
	if (a->WSPullPointSupport)
		soap_set_attr(soap, "WSPullPointSupport", soap_xsd__boolean2s(soap, *a->WSPullPointSupport), 1);
	if (a->WSPausableSubscriptionManagerInterfaceSupport)
		soap_set_attr(soap, "WSPausableSubscriptionManagerInterfaceSupport", soap_xsd__boolean2s(soap, *a->WSPausableSubscriptionManagerInterfaceSupport), 1);
	if (a->RateLimitPolicySupport)
		soap_set_attr(soap, "RateLimitPolicySupport", soap_xsd__boolean2s(soap, *a->RateLimitPolicySupport), 1);
	if (a->MaxNotificationProducers)
		soap_set_attr(soap, "MaxNotificationProducers", soap_int2s(soap, *a->MaxNotificationProducers), 1);
	if (a->MaxPullPoints)
		soap_set_attr(soap, "MaxPullPoints", soap_int2s(soap, *a->MaxPullPoints), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tev__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tev__Capabilities * SOAP_FMAC4 soap_in_tev__Capabilities(struct soap *soap, const char *tag, struct tev__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tev__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tev__Capabilities, sizeof(struct tev__Capabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tev__Capabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "WSSubscriptionPolicySupport", 0);
		if (t)
		{
			if (!(a->WSSubscriptionPolicySupport = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->WSSubscriptionPolicySupport))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "WSPullPointSupport", 0);
		if (t)
		{
			if (!(a->WSPullPointSupport = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->WSPullPointSupport))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "WSPausableSubscriptionManagerInterfaceSupport", 0);
		if (t)
		{
			if (!(a->WSPausableSubscriptionManagerInterfaceSupport = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->WSPausableSubscriptionManagerInterfaceSupport))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "RateLimitPolicySupport", 0);
		if (t)
		{
			if (!(a->RateLimitPolicySupport = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->RateLimitPolicySupport))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "MaxNotificationProducers", 0);
		if (t)
		{
			if (!(a->MaxNotificationProducers = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxNotificationProducers))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	{	const char *t = soap_attr_value(soap, "MaxPullPoints", 0);
		if (t)
		{
			if (!(a->MaxPullPoints = (int *)soap_malloc(soap, sizeof(int))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2int(soap, t, a->MaxPullPoints))
				return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tev__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tev__Capabilities, 0, sizeof(struct tev__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tev__Capabilities(struct soap *soap, const struct tev__Capabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tev__Capabilities);
	if (soap_out_tev__Capabilities(soap, tag?tag:"tev:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tev__Capabilities * SOAP_FMAC4 soap_get_tev__Capabilities(struct soap *soap, struct tev__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tev__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__DeletePaneConfigurationResponse(struct soap *soap, struct _tls__DeletePaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__DeletePaneConfigurationResponse(struct soap *soap, const struct _tls__DeletePaneConfigurationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__DeletePaneConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tls__DeletePaneConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__DeletePaneConfigurationResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__DeletePaneConfigurationResponse * SOAP_FMAC4 soap_in__tls__DeletePaneConfigurationResponse(struct soap *soap, const char *tag, struct _tls__DeletePaneConfigurationResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__DeletePaneConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__DeletePaneConfigurationResponse, sizeof(struct _tls__DeletePaneConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__DeletePaneConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__DeletePaneConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__DeletePaneConfigurationResponse, 0, sizeof(struct _tls__DeletePaneConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__DeletePaneConfigurationResponse(struct soap *soap, const struct _tls__DeletePaneConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__DeletePaneConfigurationResponse);
	if (soap_out__tls__DeletePaneConfigurationResponse(soap, tag?tag:"tls:DeletePaneConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__DeletePaneConfigurationResponse * SOAP_FMAC4 soap_get__tls__DeletePaneConfigurationResponse(struct soap *soap, struct _tls__DeletePaneConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__DeletePaneConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__DeletePaneConfiguration(struct soap *soap, struct _tls__DeletePaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	soap_default_tt__ReferenceToken(soap, &a->PaneToken);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__DeletePaneConfiguration(struct soap *soap, const struct _tls__DeletePaneConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoOutput);
	soap_serialize_tt__ReferenceToken(soap, &a->PaneToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__DeletePaneConfiguration(struct soap *soap, const char *tag, int id, const struct _tls__DeletePaneConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__DeletePaneConfiguration), type))
		return soap->error;
	if (a->VideoOutput)
	{	if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, &a->VideoOutput, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tls:VideoOutput"))
		return soap->error;
	if (a->PaneToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tls:PaneToken", -1, &a->PaneToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tls:PaneToken"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__DeletePaneConfiguration * SOAP_FMAC4 soap_in__tls__DeletePaneConfiguration(struct soap *soap, const char *tag, struct _tls__DeletePaneConfiguration *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	size_t soap_flag_PaneToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__DeletePaneConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__DeletePaneConfiguration, sizeof(struct _tls__DeletePaneConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__DeletePaneConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", &a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			if (soap_flag_PaneToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:PaneToken", &a->PaneToken, "tt:ReferenceToken"))
				{	soap_flag_PaneToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__DeletePaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__DeletePaneConfiguration, 0, sizeof(struct _tls__DeletePaneConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoOutput > 0 || soap_flag_PaneToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__DeletePaneConfiguration(struct soap *soap, const struct _tls__DeletePaneConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__DeletePaneConfiguration);
	if (soap_out__tls__DeletePaneConfiguration(soap, tag?tag:"tls:DeletePaneConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__DeletePaneConfiguration * SOAP_FMAC4 soap_get__tls__DeletePaneConfiguration(struct soap *soap, struct _tls__DeletePaneConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__DeletePaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__CreatePaneConfigurationResponse(struct soap *soap, struct _tls__CreatePaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->PaneToken);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__CreatePaneConfigurationResponse(struct soap *soap, const struct _tls__CreatePaneConfigurationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->PaneToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__CreatePaneConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tls__CreatePaneConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__CreatePaneConfigurationResponse), type))
		return soap->error;
	if (a->PaneToken)
		soap_element_result(soap, "tls:PaneToken");
	if (a->PaneToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tls:PaneToken", -1, &a->PaneToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tls:PaneToken"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__CreatePaneConfigurationResponse * SOAP_FMAC4 soap_in__tls__CreatePaneConfigurationResponse(struct soap *soap, const char *tag, struct _tls__CreatePaneConfigurationResponse *a, const char *type)
{
	size_t soap_flag_PaneToken = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__CreatePaneConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__CreatePaneConfigurationResponse, sizeof(struct _tls__CreatePaneConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__CreatePaneConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PaneToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:PaneToken", &a->PaneToken, "tt:ReferenceToken"))
				{	soap_flag_PaneToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tls:PaneToken");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__CreatePaneConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__CreatePaneConfigurationResponse, 0, sizeof(struct _tls__CreatePaneConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PaneToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__CreatePaneConfigurationResponse(struct soap *soap, const struct _tls__CreatePaneConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__CreatePaneConfigurationResponse);
	if (soap_out__tls__CreatePaneConfigurationResponse(soap, tag?tag:"tls:CreatePaneConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__CreatePaneConfigurationResponse * SOAP_FMAC4 soap_get__tls__CreatePaneConfigurationResponse(struct soap *soap, struct _tls__CreatePaneConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__CreatePaneConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__CreatePaneConfiguration(struct soap *soap, struct _tls__CreatePaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	a->PaneConfiguration = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__CreatePaneConfiguration(struct soap *soap, const struct _tls__CreatePaneConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoOutput);
	soap_serialize_PointerTott__PaneConfiguration(soap, &a->PaneConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__CreatePaneConfiguration(struct soap *soap, const char *tag, int id, const struct _tls__CreatePaneConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__CreatePaneConfiguration), type))
		return soap->error;
	if (a->VideoOutput)
	{	if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, &a->VideoOutput, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tls:VideoOutput"))
		return soap->error;
	if (a->PaneConfiguration)
	{	if (soap_out_PointerTott__PaneConfiguration(soap, "tls:PaneConfiguration", -1, &a->PaneConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tls:PaneConfiguration"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__CreatePaneConfiguration * SOAP_FMAC4 soap_in__tls__CreatePaneConfiguration(struct soap *soap, const char *tag, struct _tls__CreatePaneConfiguration *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	size_t soap_flag_PaneConfiguration = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__CreatePaneConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__CreatePaneConfiguration, sizeof(struct _tls__CreatePaneConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__CreatePaneConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", &a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			if (soap_flag_PaneConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PaneConfiguration(soap, "tls:PaneConfiguration", &a->PaneConfiguration, "tt:PaneConfiguration"))
				{	soap_flag_PaneConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__CreatePaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__CreatePaneConfiguration, 0, sizeof(struct _tls__CreatePaneConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoOutput > 0 || soap_flag_PaneConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__CreatePaneConfiguration(struct soap *soap, const struct _tls__CreatePaneConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__CreatePaneConfiguration);
	if (soap_out__tls__CreatePaneConfiguration(soap, tag?tag:"tls:CreatePaneConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__CreatePaneConfiguration * SOAP_FMAC4 soap_get__tls__CreatePaneConfiguration(struct soap *soap, struct _tls__CreatePaneConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__CreatePaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__SetPaneConfigurationResponse(struct soap *soap, struct _tls__SetPaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__SetPaneConfigurationResponse(struct soap *soap, const struct _tls__SetPaneConfigurationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__SetPaneConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tls__SetPaneConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__SetPaneConfigurationResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationResponse * SOAP_FMAC4 soap_in__tls__SetPaneConfigurationResponse(struct soap *soap, const char *tag, struct _tls__SetPaneConfigurationResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__SetPaneConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetPaneConfigurationResponse, sizeof(struct _tls__SetPaneConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__SetPaneConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__SetPaneConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetPaneConfigurationResponse, 0, sizeof(struct _tls__SetPaneConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__SetPaneConfigurationResponse(struct soap *soap, const struct _tls__SetPaneConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__SetPaneConfigurationResponse);
	if (soap_out__tls__SetPaneConfigurationResponse(soap, tag?tag:"tls:SetPaneConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationResponse * SOAP_FMAC4 soap_get__tls__SetPaneConfigurationResponse(struct soap *soap, struct _tls__SetPaneConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__SetPaneConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__SetPaneConfiguration(struct soap *soap, struct _tls__SetPaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	a->PaneConfiguration = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__SetPaneConfiguration(struct soap *soap, const struct _tls__SetPaneConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoOutput);
	soap_serialize_PointerTott__PaneConfiguration(soap, &a->PaneConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__SetPaneConfiguration(struct soap *soap, const char *tag, int id, const struct _tls__SetPaneConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__SetPaneConfiguration), type))
		return soap->error;
	if (a->VideoOutput)
	{	if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, &a->VideoOutput, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tls:VideoOutput"))
		return soap->error;
	if (a->PaneConfiguration)
	{	if (soap_out_PointerTott__PaneConfiguration(soap, "tls:PaneConfiguration", -1, &a->PaneConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tls:PaneConfiguration"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__SetPaneConfiguration * SOAP_FMAC4 soap_in__tls__SetPaneConfiguration(struct soap *soap, const char *tag, struct _tls__SetPaneConfiguration *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	size_t soap_flag_PaneConfiguration = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__SetPaneConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetPaneConfiguration, sizeof(struct _tls__SetPaneConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__SetPaneConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", &a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			if (soap_flag_PaneConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PaneConfiguration(soap, "tls:PaneConfiguration", &a->PaneConfiguration, "tt:PaneConfiguration"))
				{	soap_flag_PaneConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__SetPaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetPaneConfiguration, 0, sizeof(struct _tls__SetPaneConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoOutput > 0 || soap_flag_PaneConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__SetPaneConfiguration(struct soap *soap, const struct _tls__SetPaneConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__SetPaneConfiguration);
	if (soap_out__tls__SetPaneConfiguration(soap, tag?tag:"tls:SetPaneConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetPaneConfiguration * SOAP_FMAC4 soap_get__tls__SetPaneConfiguration(struct soap *soap, struct _tls__SetPaneConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__SetPaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__SetPaneConfigurationsResponse(struct soap *soap, struct _tls__SetPaneConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__SetPaneConfigurationsResponse(struct soap *soap, const struct _tls__SetPaneConfigurationsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__SetPaneConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _tls__SetPaneConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__SetPaneConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationsResponse * SOAP_FMAC4 soap_in__tls__SetPaneConfigurationsResponse(struct soap *soap, const char *tag, struct _tls__SetPaneConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__SetPaneConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetPaneConfigurationsResponse, sizeof(struct _tls__SetPaneConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__SetPaneConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__SetPaneConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetPaneConfigurationsResponse, 0, sizeof(struct _tls__SetPaneConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__SetPaneConfigurationsResponse(struct soap *soap, const struct _tls__SetPaneConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__SetPaneConfigurationsResponse);
	if (soap_out__tls__SetPaneConfigurationsResponse(soap, tag?tag:"tls:SetPaneConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurationsResponse * SOAP_FMAC4 soap_get__tls__SetPaneConfigurationsResponse(struct soap *soap, struct _tls__SetPaneConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__SetPaneConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__SetPaneConfigurations(struct soap *soap, struct _tls__SetPaneConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	a->__sizePaneConfiguration = 0;
	a->PaneConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__SetPaneConfigurations(struct soap *soap, const struct _tls__SetPaneConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoOutput);
	if (a->PaneConfiguration)
	{	int i;
		for (i = 0; i < a->__sizePaneConfiguration; i++)
		{
			soap_embedded(soap, a->PaneConfiguration + i, SOAP_TYPE_tt__PaneConfiguration);
			soap_serialize_tt__PaneConfiguration(soap, a->PaneConfiguration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__SetPaneConfigurations(struct soap *soap, const char *tag, int id, const struct _tls__SetPaneConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__SetPaneConfigurations), type))
		return soap->error;
	if (a->VideoOutput)
	{	if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, &a->VideoOutput, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tls:VideoOutput"))
		return soap->error;
	if (a->PaneConfiguration)
	{	int i;
		for (i = 0; i < a->__sizePaneConfiguration; i++)
			if (soap_out_tt__PaneConfiguration(soap, "tls:PaneConfiguration", -1, a->PaneConfiguration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurations * SOAP_FMAC4 soap_in__tls__SetPaneConfigurations(struct soap *soap, const char *tag, struct _tls__SetPaneConfigurations *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	struct soap_blist *soap_blist_PaneConfiguration = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__SetPaneConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetPaneConfigurations, sizeof(struct _tls__SetPaneConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__SetPaneConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", &a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tls:PaneConfiguration", 1, NULL))
			{	if (a->PaneConfiguration == NULL)
				{	if (soap_blist_PaneConfiguration == NULL)
						soap_blist_PaneConfiguration = soap_new_block(soap);
					a->PaneConfiguration = (struct tt__PaneConfiguration *)soap_push_block(soap, soap_blist_PaneConfiguration, sizeof(struct tt__PaneConfiguration));
					if (a->PaneConfiguration == NULL)
						return NULL;
					soap_default_tt__PaneConfiguration(soap, a->PaneConfiguration);
				}
				soap_revert(soap);
				if (soap_in_tt__PaneConfiguration(soap, "tls:PaneConfiguration", a->PaneConfiguration, "tt:PaneConfiguration"))
				{	a->__sizePaneConfiguration++;
					a->PaneConfiguration = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PaneConfiguration)
			soap_pop_block(soap, soap_blist_PaneConfiguration);
		if (a->__sizePaneConfiguration)
			a->PaneConfiguration = (struct tt__PaneConfiguration *)soap_save_block(soap, soap_blist_PaneConfiguration, NULL, 1);
		else
		{	a->PaneConfiguration = NULL;
			if (soap_blist_PaneConfiguration)
				soap_end_block(soap, soap_blist_PaneConfiguration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__SetPaneConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetPaneConfigurations, 0, sizeof(struct _tls__SetPaneConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoOutput > 0 || a->__sizePaneConfiguration < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__SetPaneConfigurations(struct soap *soap, const struct _tls__SetPaneConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__SetPaneConfigurations);
	if (soap_out__tls__SetPaneConfigurations(soap, tag?tag:"tls:SetPaneConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetPaneConfigurations * SOAP_FMAC4 soap_get__tls__SetPaneConfigurations(struct soap *soap, struct _tls__SetPaneConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__SetPaneConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetPaneConfigurationResponse(struct soap *soap, struct _tls__GetPaneConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PaneConfiguration = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetPaneConfigurationResponse(struct soap *soap, const struct _tls__GetPaneConfigurationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__PaneConfiguration(soap, &a->PaneConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetPaneConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tls__GetPaneConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetPaneConfigurationResponse), type))
		return soap->error;
	if (a->PaneConfiguration)
		soap_element_result(soap, "tls:PaneConfiguration");
	if (a->PaneConfiguration)
	{	if (soap_out_PointerTott__PaneConfiguration(soap, "tls:PaneConfiguration", -1, &a->PaneConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tls:PaneConfiguration"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationResponse * SOAP_FMAC4 soap_in__tls__GetPaneConfigurationResponse(struct soap *soap, const char *tag, struct _tls__GetPaneConfigurationResponse *a, const char *type)
{
	size_t soap_flag_PaneConfiguration = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetPaneConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetPaneConfigurationResponse, sizeof(struct _tls__GetPaneConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetPaneConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PaneConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__PaneConfiguration(soap, "tls:PaneConfiguration", &a->PaneConfiguration, "tt:PaneConfiguration"))
				{	soap_flag_PaneConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tls:PaneConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__GetPaneConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetPaneConfigurationResponse, 0, sizeof(struct _tls__GetPaneConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PaneConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetPaneConfigurationResponse(struct soap *soap, const struct _tls__GetPaneConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__GetPaneConfigurationResponse);
	if (soap_out__tls__GetPaneConfigurationResponse(soap, tag?tag:"tls:GetPaneConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationResponse * SOAP_FMAC4 soap_get__tls__GetPaneConfigurationResponse(struct soap *soap, struct _tls__GetPaneConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetPaneConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetPaneConfiguration(struct soap *soap, struct _tls__GetPaneConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	soap_default_tt__ReferenceToken(soap, &a->Pane);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetPaneConfiguration(struct soap *soap, const struct _tls__GetPaneConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoOutput);
	soap_serialize_tt__ReferenceToken(soap, &a->Pane);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetPaneConfiguration(struct soap *soap, const char *tag, int id, const struct _tls__GetPaneConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetPaneConfiguration), type))
		return soap->error;
	if (a->VideoOutput)
	{	if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, &a->VideoOutput, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tls:VideoOutput"))
		return soap->error;
	if (a->Pane)
	{	if (soap_out_tt__ReferenceToken(soap, "tls:Pane", -1, &a->Pane, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tls:Pane"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetPaneConfiguration * SOAP_FMAC4 soap_in__tls__GetPaneConfiguration(struct soap *soap, const char *tag, struct _tls__GetPaneConfiguration *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	size_t soap_flag_Pane = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetPaneConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetPaneConfiguration, sizeof(struct _tls__GetPaneConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetPaneConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", &a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			if (soap_flag_Pane && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:Pane", &a->Pane, "tt:ReferenceToken"))
				{	soap_flag_Pane--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__GetPaneConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetPaneConfiguration, 0, sizeof(struct _tls__GetPaneConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoOutput > 0 || soap_flag_Pane > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetPaneConfiguration(struct soap *soap, const struct _tls__GetPaneConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__GetPaneConfiguration);
	if (soap_out__tls__GetPaneConfiguration(soap, tag?tag:"tls:GetPaneConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetPaneConfiguration * SOAP_FMAC4 soap_get__tls__GetPaneConfiguration(struct soap *soap, struct _tls__GetPaneConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetPaneConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetPaneConfigurationsResponse(struct soap *soap, struct _tls__GetPaneConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizePaneConfiguration = 0;
	a->PaneConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetPaneConfigurationsResponse(struct soap *soap, const struct _tls__GetPaneConfigurationsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->PaneConfiguration)
	{	int i;
		for (i = 0; i < a->__sizePaneConfiguration; i++)
		{
			soap_embedded(soap, a->PaneConfiguration + i, SOAP_TYPE_tt__PaneConfiguration);
			soap_serialize_tt__PaneConfiguration(soap, a->PaneConfiguration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetPaneConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _tls__GetPaneConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetPaneConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizePaneConfiguration");
	if (a->PaneConfiguration)
	{	int i;
		for (i = 0; i < a->__sizePaneConfiguration; i++)
			if (soap_out_tt__PaneConfiguration(soap, "tls:PaneConfiguration", -1, a->PaneConfiguration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationsResponse * SOAP_FMAC4 soap_in__tls__GetPaneConfigurationsResponse(struct soap *soap, const char *tag, struct _tls__GetPaneConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_PaneConfiguration = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetPaneConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetPaneConfigurationsResponse, sizeof(struct _tls__GetPaneConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetPaneConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tls:PaneConfiguration", 1, NULL))
			{	if (a->PaneConfiguration == NULL)
				{	if (soap_blist_PaneConfiguration == NULL)
						soap_blist_PaneConfiguration = soap_new_block(soap);
					a->PaneConfiguration = (struct tt__PaneConfiguration *)soap_push_block(soap, soap_blist_PaneConfiguration, sizeof(struct tt__PaneConfiguration));
					if (a->PaneConfiguration == NULL)
						return NULL;
					soap_default_tt__PaneConfiguration(soap, a->PaneConfiguration);
				}
				soap_revert(soap);
				if (soap_in_tt__PaneConfiguration(soap, "tls:PaneConfiguration", a->PaneConfiguration, "tt:PaneConfiguration"))
				{	a->__sizePaneConfiguration++;
					a->PaneConfiguration = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizePaneConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->PaneConfiguration)
			soap_pop_block(soap, soap_blist_PaneConfiguration);
		if (a->__sizePaneConfiguration)
			a->PaneConfiguration = (struct tt__PaneConfiguration *)soap_save_block(soap, soap_blist_PaneConfiguration, NULL, 1);
		else
		{	a->PaneConfiguration = NULL;
			if (soap_blist_PaneConfiguration)
				soap_end_block(soap, soap_blist_PaneConfiguration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__GetPaneConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetPaneConfigurationsResponse, 0, sizeof(struct _tls__GetPaneConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizePaneConfiguration < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetPaneConfigurationsResponse(struct soap *soap, const struct _tls__GetPaneConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__GetPaneConfigurationsResponse);
	if (soap_out__tls__GetPaneConfigurationsResponse(soap, tag?tag:"tls:GetPaneConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurationsResponse * SOAP_FMAC4 soap_get__tls__GetPaneConfigurationsResponse(struct soap *soap, struct _tls__GetPaneConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetPaneConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetPaneConfigurations(struct soap *soap, struct _tls__GetPaneConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetPaneConfigurations(struct soap *soap, const struct _tls__GetPaneConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoOutput);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetPaneConfigurations(struct soap *soap, const char *tag, int id, const struct _tls__GetPaneConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetPaneConfigurations), type))
		return soap->error;
	if (a->VideoOutput)
	{	if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, &a->VideoOutput, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tls:VideoOutput"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurations * SOAP_FMAC4 soap_in__tls__GetPaneConfigurations(struct soap *soap, const char *tag, struct _tls__GetPaneConfigurations *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetPaneConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetPaneConfigurations, sizeof(struct _tls__GetPaneConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetPaneConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", &a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__GetPaneConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetPaneConfigurations, 0, sizeof(struct _tls__GetPaneConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoOutput > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetPaneConfigurations(struct soap *soap, const struct _tls__GetPaneConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__GetPaneConfigurations);
	if (soap_out__tls__GetPaneConfigurations(soap, tag?tag:"tls:GetPaneConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetPaneConfigurations * SOAP_FMAC4 soap_get__tls__GetPaneConfigurations(struct soap *soap, struct _tls__GetPaneConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetPaneConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetDisplayOptionsResponse(struct soap *soap, struct _tls__GetDisplayOptionsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->LayoutOptions = NULL;
	a->CodingCapabilities = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetDisplayOptionsResponse(struct soap *soap, const struct _tls__GetDisplayOptionsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__LayoutOptions(soap, &a->LayoutOptions);
	soap_serialize_PointerTott__CodingCapabilities(soap, &a->CodingCapabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetDisplayOptionsResponse(struct soap *soap, const char *tag, int id, const struct _tls__GetDisplayOptionsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetDisplayOptionsResponse), type))
		return soap->error;
	if (a->LayoutOptions)
		soap_element_result(soap, "tls:LayoutOptions");
	if (soap_out_PointerTott__LayoutOptions(soap, "tls:LayoutOptions", -1, &a->LayoutOptions, ""))
		return soap->error;
	if (a->CodingCapabilities)
	{	if (soap_out_PointerTott__CodingCapabilities(soap, "tls:CodingCapabilities", -1, &a->CodingCapabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tls:CodingCapabilities"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetDisplayOptionsResponse * SOAP_FMAC4 soap_in__tls__GetDisplayOptionsResponse(struct soap *soap, const char *tag, struct _tls__GetDisplayOptionsResponse *a, const char *type)
{
	size_t soap_flag_LayoutOptions = 1;
	size_t soap_flag_CodingCapabilities = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetDisplayOptionsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetDisplayOptionsResponse, sizeof(struct _tls__GetDisplayOptionsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetDisplayOptionsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_LayoutOptions && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__LayoutOptions(soap, "tls:LayoutOptions", &a->LayoutOptions, "tt:LayoutOptions"))
				{	soap_flag_LayoutOptions--;
					continue;
				}
			if (soap_flag_CodingCapabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__CodingCapabilities(soap, "tls:CodingCapabilities", &a->CodingCapabilities, "tt:CodingCapabilities"))
				{	soap_flag_CodingCapabilities--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tls:LayoutOptions");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__GetDisplayOptionsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetDisplayOptionsResponse, 0, sizeof(struct _tls__GetDisplayOptionsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CodingCapabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetDisplayOptionsResponse(struct soap *soap, const struct _tls__GetDisplayOptionsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__GetDisplayOptionsResponse);
	if (soap_out__tls__GetDisplayOptionsResponse(soap, tag?tag:"tls:GetDisplayOptionsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetDisplayOptionsResponse * SOAP_FMAC4 soap_get__tls__GetDisplayOptionsResponse(struct soap *soap, struct _tls__GetDisplayOptionsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetDisplayOptionsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetDisplayOptions(struct soap *soap, struct _tls__GetDisplayOptions *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetDisplayOptions(struct soap *soap, const struct _tls__GetDisplayOptions *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoOutput);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetDisplayOptions(struct soap *soap, const char *tag, int id, const struct _tls__GetDisplayOptions *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetDisplayOptions), type))
		return soap->error;
	if (a->VideoOutput)
	{	if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, &a->VideoOutput, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tls:VideoOutput"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetDisplayOptions * SOAP_FMAC4 soap_in__tls__GetDisplayOptions(struct soap *soap, const char *tag, struct _tls__GetDisplayOptions *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetDisplayOptions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetDisplayOptions, sizeof(struct _tls__GetDisplayOptions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetDisplayOptions(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", &a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__GetDisplayOptions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetDisplayOptions, 0, sizeof(struct _tls__GetDisplayOptions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoOutput > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetDisplayOptions(struct soap *soap, const struct _tls__GetDisplayOptions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__GetDisplayOptions);
	if (soap_out__tls__GetDisplayOptions(soap, tag?tag:"tls:GetDisplayOptions", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetDisplayOptions * SOAP_FMAC4 soap_get__tls__GetDisplayOptions(struct soap *soap, struct _tls__GetDisplayOptions *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetDisplayOptions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__SetLayoutResponse(struct soap *soap, struct _tls__SetLayoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__SetLayoutResponse(struct soap *soap, const struct _tls__SetLayoutResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__SetLayoutResponse(struct soap *soap, const char *tag, int id, const struct _tls__SetLayoutResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__SetLayoutResponse), type))
		return soap->error;
	soap_element_result(soap, "-size");
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__SetLayoutResponse * SOAP_FMAC4 soap_in__tls__SetLayoutResponse(struct soap *soap, const char *tag, struct _tls__SetLayoutResponse *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__SetLayoutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetLayoutResponse, sizeof(struct _tls__SetLayoutResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__SetLayoutResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-size");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__SetLayoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetLayoutResponse, 0, sizeof(struct _tls__SetLayoutResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__SetLayoutResponse(struct soap *soap, const struct _tls__SetLayoutResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__SetLayoutResponse);
	if (soap_out__tls__SetLayoutResponse(soap, tag?tag:"tls:SetLayoutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetLayoutResponse * SOAP_FMAC4 soap_get__tls__SetLayoutResponse(struct soap *soap, struct _tls__SetLayoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__SetLayoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__SetLayout(struct soap *soap, struct _tls__SetLayout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	a->Layout = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__SetLayout(struct soap *soap, const struct _tls__SetLayout *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoOutput);
	soap_serialize_PointerTott__Layout(soap, &a->Layout);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__SetLayout(struct soap *soap, const char *tag, int id, const struct _tls__SetLayout *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__SetLayout), type))
		return soap->error;
	if (a->VideoOutput)
	{	if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, &a->VideoOutput, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tls:VideoOutput"))
		return soap->error;
	if (a->Layout)
	{	if (soap_out_PointerTott__Layout(soap, "tls:Layout", -1, &a->Layout, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tls:Layout"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__SetLayout * SOAP_FMAC4 soap_in__tls__SetLayout(struct soap *soap, const char *tag, struct _tls__SetLayout *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	size_t soap_flag_Layout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__SetLayout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__SetLayout, sizeof(struct _tls__SetLayout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__SetLayout(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", &a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			if (soap_flag_Layout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Layout(soap, "tls:Layout", &a->Layout, "tt:Layout"))
				{	soap_flag_Layout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__SetLayout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__SetLayout, 0, sizeof(struct _tls__SetLayout), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoOutput > 0 || soap_flag_Layout > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__SetLayout(struct soap *soap, const struct _tls__SetLayout *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__SetLayout);
	if (soap_out__tls__SetLayout(soap, tag?tag:"tls:SetLayout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__SetLayout * SOAP_FMAC4 soap_get__tls__SetLayout(struct soap *soap, struct _tls__SetLayout *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__SetLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetLayoutResponse(struct soap *soap, struct _tls__GetLayoutResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Layout = NULL;
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetLayoutResponse(struct soap *soap, const struct _tls__GetLayoutResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Layout(soap, &a->Layout);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetLayoutResponse(struct soap *soap, const char *tag, int id, const struct _tls__GetLayoutResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetLayoutResponse), type))
		return soap->error;
	if (a->Layout)
		soap_element_result(soap, "tls:Layout");
	if (a->Layout)
	{	if (soap_out_PointerTott__Layout(soap, "tls:Layout", -1, &a->Layout, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tls:Layout"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetLayoutResponse * SOAP_FMAC4 soap_in__tls__GetLayoutResponse(struct soap *soap, const char *tag, struct _tls__GetLayoutResponse *a, const char *type)
{
	size_t soap_flag_Layout = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetLayoutResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetLayoutResponse, sizeof(struct _tls__GetLayoutResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetLayoutResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Layout && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Layout(soap, "tls:Layout", &a->Layout, "tt:Layout"))
				{	soap_flag_Layout--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			soap_check_result(soap, "tls:Layout");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__GetLayoutResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetLayoutResponse, 0, sizeof(struct _tls__GetLayoutResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Layout > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetLayoutResponse(struct soap *soap, const struct _tls__GetLayoutResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__GetLayoutResponse);
	if (soap_out__tls__GetLayoutResponse(soap, tag?tag:"tls:GetLayoutResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetLayoutResponse * SOAP_FMAC4 soap_get__tls__GetLayoutResponse(struct soap *soap, struct _tls__GetLayoutResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetLayoutResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetLayout(struct soap *soap, struct _tls__GetLayout *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->VideoOutput);
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetLayout(struct soap *soap, const struct _tls__GetLayout *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->VideoOutput);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetLayout(struct soap *soap, const char *tag, int id, const struct _tls__GetLayout *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetLayout), type))
		return soap->error;
	if (a->VideoOutput)
	{	if (soap_out_tt__ReferenceToken(soap, "tls:VideoOutput", -1, &a->VideoOutput, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tls:VideoOutput"))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetLayout * SOAP_FMAC4 soap_in__tls__GetLayout(struct soap *soap, const char *tag, struct _tls__GetLayout *a, const char *type)
{
	size_t soap_flag_VideoOutput = 1;
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetLayout *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetLayout, sizeof(struct _tls__GetLayout), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetLayout(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_VideoOutput && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tls:VideoOutput", &a->VideoOutput, "tt:ReferenceToken"))
				{	soap_flag_VideoOutput--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__GetLayout *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetLayout, 0, sizeof(struct _tls__GetLayout), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_VideoOutput > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetLayout(struct soap *soap, const struct _tls__GetLayout *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__GetLayout);
	if (soap_out__tls__GetLayout(soap, tag?tag:"tls:GetLayout", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetLayout * SOAP_FMAC4 soap_get__tls__GetLayout(struct soap *soap, struct _tls__GetLayout *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetLayout(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetServiceCapabilitiesResponse(struct soap *soap, struct _tls__GetServiceCapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tls__GetServiceCapabilitiesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTotls__Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tls__GetServiceCapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetServiceCapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tls:Capabilities");
	if (a->Capabilities)
	{	if (soap_out_PointerTotls__Capabilities(soap, "tls:Capabilities", -1, &a->Capabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tls:Capabilities"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_in__tls__GetServiceCapabilitiesResponse(struct soap *soap, const char *tag, struct _tls__GetServiceCapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetServiceCapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetServiceCapabilitiesResponse, sizeof(struct _tls__GetServiceCapabilitiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetServiceCapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotls__Capabilities(soap, "tls:Capabilities", &a->Capabilities, "tls:Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "tls:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__GetServiceCapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetServiceCapabilitiesResponse, 0, sizeof(struct _tls__GetServiceCapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetServiceCapabilitiesResponse(struct soap *soap, const struct _tls__GetServiceCapabilitiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__GetServiceCapabilitiesResponse);
	if (soap_out__tls__GetServiceCapabilitiesResponse(soap, tag?tag:"tls:GetServiceCapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetServiceCapabilitiesResponse * SOAP_FMAC4 soap_get__tls__GetServiceCapabilitiesResponse(struct soap *soap, struct _tls__GetServiceCapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetServiceCapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tls__GetServiceCapabilities(struct soap *soap, struct _tls__GetServiceCapabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tls__GetServiceCapabilities(struct soap *soap, const struct _tls__GetServiceCapabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tls__GetServiceCapabilities(struct soap *soap, const char *tag, int id, const struct _tls__GetServiceCapabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tls__GetServiceCapabilities), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tls__GetServiceCapabilities * SOAP_FMAC4 soap_in__tls__GetServiceCapabilities(struct soap *soap, const char *tag, struct _tls__GetServiceCapabilities *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tls__GetServiceCapabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tls__GetServiceCapabilities, sizeof(struct _tls__GetServiceCapabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tls__GetServiceCapabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tls__GetServiceCapabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tls__GetServiceCapabilities, 0, sizeof(struct _tls__GetServiceCapabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tls__GetServiceCapabilities(struct soap *soap, const struct _tls__GetServiceCapabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tls__GetServiceCapabilities);
	if (soap_out__tls__GetServiceCapabilities(soap, tag?tag:"tls:GetServiceCapabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tls__GetServiceCapabilities * SOAP_FMAC4 soap_get__tls__GetServiceCapabilities(struct soap *soap, struct _tls__GetServiceCapabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tls__GetServiceCapabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_tls__Capabilities(struct soap *soap, struct tls__Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
	a->FixedLayout = NULL;
	a->__anyAttribute = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_tls__Capabilities(struct soap *soap, const struct tls__Capabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_tls__Capabilities(struct soap *soap, const char *tag, int id, const struct tls__Capabilities *a, const char *type)
{
	if (a->FixedLayout)
		soap_set_attr(soap, "FixedLayout", soap_xsd__boolean2s(soap, *a->FixedLayout), 1);
	if (a->__anyAttribute)
		soap_set_attr(soap, "-anyAttribute", a->__anyAttribute, 1);
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tls__Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct tls__Capabilities * SOAP_FMAC4 soap_in_tls__Capabilities(struct soap *soap, const char *tag, struct tls__Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct tls__Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tls__Capabilities, sizeof(struct tls__Capabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_tls__Capabilities(soap, a);
	{	const char *t = soap_attr_value(soap, "FixedLayout", 0);
		if (t)
		{
			if (!(a->FixedLayout = (enum xsd__boolean *)soap_malloc(soap, sizeof(enum xsd__boolean))))
			{	soap->error = SOAP_EOM;
				return NULL;
			}
			if (soap_s2xsd__boolean(soap, t, a->FixedLayout))
			return NULL;
		}
		else if (soap->error)
			return NULL;
	}
	if (soap_s2string(soap, soap_attr_value(soap, "-anyAttribute", 0), &a->__anyAttribute, 0, -1))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct tls__Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_tls__Capabilities, 0, sizeof(struct tls__Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_tls__Capabilities(struct soap *soap, const struct tls__Capabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_tls__Capabilities);
	if (soap_out_tls__Capabilities(soap, tag?tag:"tls:Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct tls__Capabilities * SOAP_FMAC4 soap_get_tls__Capabilities(struct soap *soap, struct tls__Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in_tls__Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__StartSystemRestoreResponse(struct soap *soap, struct _tds__StartSystemRestoreResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->UploadUri);
	soap_default_xsd__duration(soap, &a->ExpectedDownTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__StartSystemRestoreResponse(struct soap *soap, const struct _tds__StartSystemRestoreResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->UploadUri);
	soap_embedded(soap, &a->ExpectedDownTime, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, int id, const struct _tds__StartSystemRestoreResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartSystemRestoreResponse), type))
		return soap->error;
	if (a->UploadUri)
		soap_element_result(soap, "tds:UploadUri");
	if (a->UploadUri)
	{	if (soap_out_xsd__anyURI(soap, "tds:UploadUri", -1, &a->UploadUri, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:UploadUri"))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tds:ExpectedDownTime", -1, &a->ExpectedDownTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__StartSystemRestoreResponse * SOAP_FMAC4 soap_in__tds__StartSystemRestoreResponse(struct soap *soap, const char *tag, struct _tds__StartSystemRestoreResponse *a, const char *type)
{
	size_t soap_flag_UploadUri = 1;
	size_t soap_flag_ExpectedDownTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__StartSystemRestoreResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartSystemRestoreResponse, sizeof(struct _tds__StartSystemRestoreResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__StartSystemRestoreResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tds:UploadUri", &a->UploadUri, "xsd:anyURI"))
				{	soap_flag_UploadUri--;
					continue;
				}
			if (soap_flag_ExpectedDownTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tds:ExpectedDownTime", &a->ExpectedDownTime, "xsd:duration"))
				{	soap_flag_ExpectedDownTime--;
					continue;
				}
			soap_check_result(soap, "tds:UploadUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__StartSystemRestoreResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartSystemRestoreResponse, 0, sizeof(struct _tds__StartSystemRestoreResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UploadUri > 0 || soap_flag_ExpectedDownTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__StartSystemRestoreResponse(struct soap *soap, const struct _tds__StartSystemRestoreResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__StartSystemRestoreResponse);
	if (soap_out__tds__StartSystemRestoreResponse(soap, tag?tag:"tds:StartSystemRestoreResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartSystemRestoreResponse * SOAP_FMAC4 soap_get__tds__StartSystemRestoreResponse(struct soap *soap, struct _tds__StartSystemRestoreResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartSystemRestoreResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__StartSystemRestore(struct soap *soap, struct _tds__StartSystemRestore *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__StartSystemRestore(struct soap *soap, const struct _tds__StartSystemRestore *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartSystemRestore(struct soap *soap, const char *tag, int id, const struct _tds__StartSystemRestore *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartSystemRestore), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__StartSystemRestore * SOAP_FMAC4 soap_in__tds__StartSystemRestore(struct soap *soap, const char *tag, struct _tds__StartSystemRestore *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__StartSystemRestore *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartSystemRestore, sizeof(struct _tds__StartSystemRestore), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__StartSystemRestore(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__StartSystemRestore *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartSystemRestore, 0, sizeof(struct _tds__StartSystemRestore), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__StartSystemRestore(struct soap *soap, const struct _tds__StartSystemRestore *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__StartSystemRestore);
	if (soap_out__tds__StartSystemRestore(soap, tag?tag:"tds:StartSystemRestore", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartSystemRestore * SOAP_FMAC4 soap_get__tds__StartSystemRestore(struct soap *soap, struct _tds__StartSystemRestore *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartSystemRestore(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__StartFirmwareUpgradeResponse(struct soap *soap, struct _tds__StartFirmwareUpgradeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__anyURI(soap, &a->UploadUri);
	soap_default_xsd__duration(soap, &a->UploadDelay);
	soap_default_xsd__duration(soap, &a->ExpectedDownTime);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__StartFirmwareUpgradeResponse(struct soap *soap, const struct _tds__StartFirmwareUpgradeResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__anyURI(soap, &a->UploadUri);
	soap_embedded(soap, &a->UploadDelay, SOAP_TYPE_xsd__duration);
	soap_embedded(soap, &a->ExpectedDownTime, SOAP_TYPE_xsd__duration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, int id, const struct _tds__StartFirmwareUpgradeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse), type))
		return soap->error;
	if (a->UploadUri)
		soap_element_result(soap, "tds:UploadUri");
	if (a->UploadUri)
	{	if (soap_out_xsd__anyURI(soap, "tds:UploadUri", -1, &a->UploadUri, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:UploadUri"))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tds:UploadDelay", -1, &a->UploadDelay, ""))
		return soap->error;
	if (soap_out_xsd__duration(soap, "tds:ExpectedDownTime", -1, &a->ExpectedDownTime, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgradeResponse * SOAP_FMAC4 soap_in__tds__StartFirmwareUpgradeResponse(struct soap *soap, const char *tag, struct _tds__StartFirmwareUpgradeResponse *a, const char *type)
{
	size_t soap_flag_UploadUri = 1;
	size_t soap_flag_UploadDelay = 1;
	size_t soap_flag_ExpectedDownTime = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__StartFirmwareUpgradeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, sizeof(struct _tds__StartFirmwareUpgradeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__StartFirmwareUpgradeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_UploadUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tds:UploadUri", &a->UploadUri, "xsd:anyURI"))
				{	soap_flag_UploadUri--;
					continue;
				}
			if (soap_flag_UploadDelay && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tds:UploadDelay", &a->UploadDelay, "xsd:duration"))
				{	soap_flag_UploadDelay--;
					continue;
				}
			if (soap_flag_ExpectedDownTime && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__duration(soap, "tds:ExpectedDownTime", &a->ExpectedDownTime, "xsd:duration"))
				{	soap_flag_ExpectedDownTime--;
					continue;
				}
			soap_check_result(soap, "tds:UploadUri");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__StartFirmwareUpgradeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartFirmwareUpgradeResponse, 0, sizeof(struct _tds__StartFirmwareUpgradeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_UploadUri > 0 || soap_flag_UploadDelay > 0 || soap_flag_ExpectedDownTime > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__StartFirmwareUpgradeResponse(struct soap *soap, const struct _tds__StartFirmwareUpgradeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__StartFirmwareUpgradeResponse);
	if (soap_out__tds__StartFirmwareUpgradeResponse(soap, tag?tag:"tds:StartFirmwareUpgradeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgradeResponse * SOAP_FMAC4 soap_get__tds__StartFirmwareUpgradeResponse(struct soap *soap, struct _tds__StartFirmwareUpgradeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartFirmwareUpgradeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__StartFirmwareUpgrade(struct soap *soap, struct _tds__StartFirmwareUpgrade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__StartFirmwareUpgrade(struct soap *soap, const struct _tds__StartFirmwareUpgrade *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, int id, const struct _tds__StartFirmwareUpgrade *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__StartFirmwareUpgrade), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_in__tds__StartFirmwareUpgrade(struct soap *soap, const char *tag, struct _tds__StartFirmwareUpgrade *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__StartFirmwareUpgrade *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__StartFirmwareUpgrade, sizeof(struct _tds__StartFirmwareUpgrade), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__StartFirmwareUpgrade(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__StartFirmwareUpgrade *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__StartFirmwareUpgrade, 0, sizeof(struct _tds__StartFirmwareUpgrade), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__StartFirmwareUpgrade(struct soap *soap, const struct _tds__StartFirmwareUpgrade *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__StartFirmwareUpgrade);
	if (soap_out__tds__StartFirmwareUpgrade(soap, tag?tag:"tds:StartFirmwareUpgrade", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__StartFirmwareUpgrade * SOAP_FMAC4 soap_get__tds__StartFirmwareUpgrade(struct soap *soap, struct _tds__StartFirmwareUpgrade *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__StartFirmwareUpgrade(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemUrisResponse_Extension(struct soap *soap, const struct _tds__GetSystemUrisResponse_Extension *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemUrisResponse_Extension *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse_Extension * SOAP_FMAC4 soap_in__tds__GetSystemUrisResponse_Extension(struct soap *soap, const char *tag, struct _tds__GetSystemUrisResponse_Extension *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemUrisResponse_Extension *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, sizeof(struct _tds__GetSystemUrisResponse_Extension), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemUrisResponse_Extension(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUrisResponse_Extension *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUrisResponse_Extension, 0, sizeof(struct _tds__GetSystemUrisResponse_Extension), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemUrisResponse_Extension(struct soap *soap, const struct _tds__GetSystemUrisResponse_Extension *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetSystemUrisResponse_Extension);
	if (soap_out__tds__GetSystemUrisResponse_Extension(soap, tag?tag:"tds:GetSystemUrisResponse-Extension", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse_Extension * SOAP_FMAC4 soap_get__tds__GetSystemUrisResponse_Extension(struct soap *soap, struct _tds__GetSystemUrisResponse_Extension *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUrisResponse_Extension(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemUrisResponse(struct soap *soap, struct _tds__GetSystemUrisResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->SystemLogUris = NULL;
	soap_default_xsd__anyURI(soap, &a->SupportInfoUri);
	soap_default_xsd__anyURI(soap, &a->SystemBackupUri);
	a->Extension = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemUrisResponse(struct soap *soap, const struct _tds__GetSystemUrisResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__SystemLogUriList(soap, &a->SystemLogUris);
	soap_serialize_xsd__anyURI(soap, &a->SupportInfoUri);
	soap_serialize_xsd__anyURI(soap, &a->SystemBackupUri);
	soap_serialize_PointerTo_tds__GetSystemUrisResponse_Extension(soap, &a->Extension);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUrisResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemUrisResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUrisResponse), type))
		return soap->error;
	if (a->SystemLogUris)
		soap_element_result(soap, "tds:SystemLogUris");
	if (soap_out_PointerTott__SystemLogUriList(soap, "tds:SystemLogUris", -1, &a->SystemLogUris, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tds:SupportInfoUri", -1, &a->SupportInfoUri, ""))
		return soap->error;
	if (soap_out_xsd__anyURI(soap, "tds:SystemBackupUri", -1, &a->SystemBackupUri, ""))
		return soap->error;
	if (soap_out_PointerTo_tds__GetSystemUrisResponse_Extension(soap, "tds:Extension", -1, &a->Extension, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse * SOAP_FMAC4 soap_in__tds__GetSystemUrisResponse(struct soap *soap, const char *tag, struct _tds__GetSystemUrisResponse *a, const char *type)
{
	size_t soap_flag_SystemLogUris = 1;
	size_t soap_flag_SupportInfoUri = 1;
	size_t soap_flag_SystemBackupUri = 1;
	size_t soap_flag_Extension = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemUrisResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUrisResponse, sizeof(struct _tds__GetSystemUrisResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemUrisResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SystemLogUris && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__SystemLogUriList(soap, "tds:SystemLogUris", &a->SystemLogUris, "tt:SystemLogUriList"))
				{	soap_flag_SystemLogUris--;
					continue;
				}
			if (soap_flag_SupportInfoUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tds:SupportInfoUri", &a->SupportInfoUri, "xsd:anyURI"))
				{	soap_flag_SupportInfoUri--;
					continue;
				}
			if (soap_flag_SystemBackupUri && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__anyURI(soap, "tds:SystemBackupUri", &a->SystemBackupUri, "xsd:anyURI"))
				{	soap_flag_SystemBackupUri--;
					continue;
				}
			if (soap_flag_Extension && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_tds__GetSystemUrisResponse_Extension(soap, "tds:Extension", &a->Extension, ""))
				{	soap_flag_Extension--;
					continue;
				}
			soap_check_result(soap, "tds:SystemLogUris");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUrisResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUrisResponse, 0, sizeof(struct _tds__GetSystemUrisResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemUrisResponse(struct soap *soap, const struct _tds__GetSystemUrisResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetSystemUrisResponse);
	if (soap_out__tds__GetSystemUrisResponse(soap, tag?tag:"tds:GetSystemUrisResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUrisResponse * SOAP_FMAC4 soap_get__tds__GetSystemUrisResponse(struct soap *soap, struct _tds__GetSystemUrisResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUrisResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetSystemUris(struct soap *soap, struct _tds__GetSystemUris *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetSystemUris(struct soap *soap, const struct _tds__GetSystemUris *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetSystemUris(struct soap *soap, const char *tag, int id, const struct _tds__GetSystemUris *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetSystemUris), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetSystemUris * SOAP_FMAC4 soap_in__tds__GetSystemUris(struct soap *soap, const char *tag, struct _tds__GetSystemUris *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetSystemUris *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetSystemUris, sizeof(struct _tds__GetSystemUris), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetSystemUris(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetSystemUris *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetSystemUris, 0, sizeof(struct _tds__GetSystemUris), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetSystemUris(struct soap *soap, const struct _tds__GetSystemUris *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetSystemUris);
	if (soap_out__tds__GetSystemUris(soap, tag?tag:"tds:GetSystemUris", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetSystemUris * SOAP_FMAC4 soap_get__tds__GetSystemUris(struct soap *soap, struct _tds__GetSystemUris *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetSystemUris(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, struct _tds__ScanAvailableDot11NetworksResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNetworks = 0;
	a->Networks = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const struct _tds__ScanAvailableDot11NetworksResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Networks)
	{	int i;
		for (i = 0; i < a->__sizeNetworks; i++)
		{
			soap_embedded(soap, a->Networks + i, SOAP_TYPE_tt__Dot11AvailableNetworks);
			soap_serialize_tt__Dot11AvailableNetworks(soap, a->Networks + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, int id, const struct _tds__ScanAvailableDot11NetworksResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNetworks");
	if (a->Networks)
	{	int i;
		for (i = 0; i < a->__sizeNetworks; i++)
			if (soap_out_tt__Dot11AvailableNetworks(soap, "tds:Networks", -1, a->Networks + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC4 soap_in__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const char *tag, struct _tds__ScanAvailableDot11NetworksResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Networks = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__ScanAvailableDot11NetworksResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, sizeof(struct _tds__ScanAvailableDot11NetworksResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__ScanAvailableDot11NetworksResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Networks", 1, NULL))
			{	if (a->Networks == NULL)
				{	if (soap_blist_Networks == NULL)
						soap_blist_Networks = soap_new_block(soap);
					a->Networks = (struct tt__Dot11AvailableNetworks *)soap_push_block(soap, soap_blist_Networks, sizeof(struct tt__Dot11AvailableNetworks));
					if (a->Networks == NULL)
						return NULL;
					soap_default_tt__Dot11AvailableNetworks(soap, a->Networks);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot11AvailableNetworks(soap, "tds:Networks", a->Networks, "tt:Dot11AvailableNetworks"))
				{	a->__sizeNetworks++;
					a->Networks = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeNetworks");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Networks)
			soap_pop_block(soap, soap_blist_Networks);
		if (a->__sizeNetworks)
			a->Networks = (struct tt__Dot11AvailableNetworks *)soap_save_block(soap, soap_blist_Networks, NULL, 1);
		else
		{	a->Networks = NULL;
			if (soap_blist_Networks)
				soap_end_block(soap, soap_blist_Networks);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__ScanAvailableDot11NetworksResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse, 0, sizeof(struct _tds__ScanAvailableDot11NetworksResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, const struct _tds__ScanAvailableDot11NetworksResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__ScanAvailableDot11NetworksResponse);
	if (soap_out__tds__ScanAvailableDot11NetworksResponse(soap, tag?tag:"tds:ScanAvailableDot11NetworksResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11NetworksResponse * SOAP_FMAC4 soap_get__tds__ScanAvailableDot11NetworksResponse(struct soap *soap, struct _tds__ScanAvailableDot11NetworksResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__ScanAvailableDot11NetworksResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__ScanAvailableDot11Networks(struct soap *soap, struct _tds__ScanAvailableDot11Networks *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->InterfaceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__ScanAvailableDot11Networks(struct soap *soap, const struct _tds__ScanAvailableDot11Networks *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->InterfaceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, int id, const struct _tds__ScanAvailableDot11Networks *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__ScanAvailableDot11Networks), type))
		return soap->error;
	if (a->InterfaceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->InterfaceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:InterfaceToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_in__tds__ScanAvailableDot11Networks(struct soap *soap, const char *tag, struct _tds__ScanAvailableDot11Networks *a, const char *type)
{
	size_t soap_flag_InterfaceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__ScanAvailableDot11Networks *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__ScanAvailableDot11Networks, sizeof(struct _tds__ScanAvailableDot11Networks), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__ScanAvailableDot11Networks(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &a->InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__ScanAvailableDot11Networks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__ScanAvailableDot11Networks, 0, sizeof(struct _tds__ScanAvailableDot11Networks), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__ScanAvailableDot11Networks(struct soap *soap, const struct _tds__ScanAvailableDot11Networks *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__ScanAvailableDot11Networks);
	if (soap_out__tds__ScanAvailableDot11Networks(soap, tag?tag:"tds:ScanAvailableDot11Networks", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__ScanAvailableDot11Networks * SOAP_FMAC4 soap_get__tds__ScanAvailableDot11Networks(struct soap *soap, struct _tds__ScanAvailableDot11Networks *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__ScanAvailableDot11Networks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot11StatusResponse(struct soap *soap, struct _tds__GetDot11StatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Status = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot11StatusResponse(struct soap *soap, const struct _tds__GetDot11StatusResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Dot11Status(soap, &a->Status);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11StatusResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDot11StatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11StatusResponse), type))
		return soap->error;
	if (a->Status)
		soap_element_result(soap, "tds:Status");
	if (a->Status)
	{	if (soap_out_PointerTott__Dot11Status(soap, "tds:Status", -1, &a->Status, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Status"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot11StatusResponse * SOAP_FMAC4 soap_in__tds__GetDot11StatusResponse(struct soap *soap, const char *tag, struct _tds__GetDot11StatusResponse *a, const char *type)
{
	size_t soap_flag_Status = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot11StatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11StatusResponse, sizeof(struct _tds__GetDot11StatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot11StatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Status && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11Status(soap, "tds:Status", &a->Status, "tt:Dot11Status"))
				{	soap_flag_Status--;
					continue;
				}
			soap_check_result(soap, "tds:Status");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot11StatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11StatusResponse, 0, sizeof(struct _tds__GetDot11StatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Status > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot11StatusResponse(struct soap *soap, const struct _tds__GetDot11StatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDot11StatusResponse);
	if (soap_out__tds__GetDot11StatusResponse(soap, tag?tag:"tds:GetDot11StatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11StatusResponse * SOAP_FMAC4 soap_get__tds__GetDot11StatusResponse(struct soap *soap, struct _tds__GetDot11StatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11StatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot11Status(struct soap *soap, struct _tds__GetDot11Status *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->InterfaceToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot11Status(struct soap *soap, const struct _tds__GetDot11Status *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->InterfaceToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11Status(struct soap *soap, const char *tag, int id, const struct _tds__GetDot11Status *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11Status), type))
		return soap->error;
	if (a->InterfaceToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tds:InterfaceToken", -1, &a->InterfaceToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:InterfaceToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot11Status * SOAP_FMAC4 soap_in__tds__GetDot11Status(struct soap *soap, const char *tag, struct _tds__GetDot11Status *a, const char *type)
{
	size_t soap_flag_InterfaceToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot11Status *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11Status, sizeof(struct _tds__GetDot11Status), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot11Status(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_InterfaceToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:InterfaceToken", &a->InterfaceToken, "tt:ReferenceToken"))
				{	soap_flag_InterfaceToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot11Status *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11Status, 0, sizeof(struct _tds__GetDot11Status), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_InterfaceToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot11Status(struct soap *soap, const struct _tds__GetDot11Status *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDot11Status);
	if (soap_out__tds__GetDot11Status(soap, tag?tag:"tds:GetDot11Status", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11Status * SOAP_FMAC4 soap_get__tds__GetDot11Status(struct soap *soap, struct _tds__GetDot11Status *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11Status(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot11CapabilitiesResponse(struct soap *soap, struct _tds__GetDot11CapabilitiesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Capabilities = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot11CapabilitiesResponse(struct soap *soap, const struct _tds__GetDot11CapabilitiesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Dot11Capabilities(soap, &a->Capabilities);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDot11CapabilitiesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse), type))
		return soap->error;
	if (a->Capabilities)
		soap_element_result(soap, "tds:Capabilities");
	if (a->Capabilities)
	{	if (soap_out_PointerTott__Dot11Capabilities(soap, "tds:Capabilities", -1, &a->Capabilities, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Capabilities"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot11CapabilitiesResponse * SOAP_FMAC4 soap_in__tds__GetDot11CapabilitiesResponse(struct soap *soap, const char *tag, struct _tds__GetDot11CapabilitiesResponse *a, const char *type)
{
	size_t soap_flag_Capabilities = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot11CapabilitiesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, sizeof(struct _tds__GetDot11CapabilitiesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot11CapabilitiesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Capabilities && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot11Capabilities(soap, "tds:Capabilities", &a->Capabilities, "tt:Dot11Capabilities"))
				{	soap_flag_Capabilities--;
					continue;
				}
			soap_check_result(soap, "tds:Capabilities");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot11CapabilitiesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11CapabilitiesResponse, 0, sizeof(struct _tds__GetDot11CapabilitiesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Capabilities > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot11CapabilitiesResponse(struct soap *soap, const struct _tds__GetDot11CapabilitiesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDot11CapabilitiesResponse);
	if (soap_out__tds__GetDot11CapabilitiesResponse(soap, tag?tag:"tds:GetDot11CapabilitiesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11CapabilitiesResponse * SOAP_FMAC4 soap_get__tds__GetDot11CapabilitiesResponse(struct soap *soap, struct _tds__GetDot11CapabilitiesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11CapabilitiesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot11Capabilities(struct soap *soap, struct _tds__GetDot11Capabilities *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__size = 0;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot11Capabilities(struct soap *soap, const struct _tds__GetDot11Capabilities *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot11Capabilities(struct soap *soap, const char *tag, int id, const struct _tds__GetDot11Capabilities *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot11Capabilities), type))
		return soap->error;
	if (a->__any)
	{	int i;
		for (i = 0; i < a->__size; i++)
			if (soap_out_byte(soap, "-any", -1, a->__any + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot11Capabilities * SOAP_FMAC4 soap_in__tds__GetDot11Capabilities(struct soap *soap, const char *tag, struct _tds__GetDot11Capabilities *a, const char *type)
{
	struct soap_blist *soap_blist___any = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot11Capabilities *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot11Capabilities, sizeof(struct _tds__GetDot11Capabilities), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot11Capabilities(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_peek_element(soap))
			{	if (a->__any == NULL)
				{	if (soap_blist___any == NULL)
						soap_blist___any = soap_new_block(soap);
					a->__any = (char *)soap_push_block(soap, soap_blist___any, sizeof(char));
					if (a->__any == NULL)
						return NULL;
					soap_default_byte(soap, a->__any);
				}
				if (soap_in_byte(soap, "-any", a->__any, "xsd:byte"))
				{	a->__size++;
					a->__any = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->__any)
			soap_pop_block(soap, soap_blist___any);
		if (a->__size)
			a->__any = (char *)soap_save_block(soap, soap_blist___any, NULL, 1);
		else
		{	a->__any = NULL;
			if (soap_blist___any)
				soap_end_block(soap, soap_blist___any);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot11Capabilities *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot11Capabilities, 0, sizeof(struct _tds__GetDot11Capabilities), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot11Capabilities(struct soap *soap, const struct _tds__GetDot11Capabilities *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDot11Capabilities);
	if (soap_out__tds__GetDot11Capabilities(soap, tag?tag:"tds:GetDot11Capabilities", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot11Capabilities * SOAP_FMAC4 soap_get__tds__GetDot11Capabilities(struct soap *soap, struct _tds__GetDot11Capabilities *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot11Capabilities(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SendAuxiliaryCommandResponse(struct soap *soap, struct _tds__SendAuxiliaryCommandResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AuxiliaryData(soap, &a->AuxiliaryCommandResponse);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SendAuxiliaryCommandResponse(struct soap *soap, const struct _tds__SendAuxiliaryCommandResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__AuxiliaryData(soap, &a->AuxiliaryCommandResponse);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, int id, const struct _tds__SendAuxiliaryCommandResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse), type))
		return soap->error;
	if (a->AuxiliaryCommandResponse)
		soap_element_result(soap, "tds:AuxiliaryCommandResponse");
	if (soap_out_tt__AuxiliaryData(soap, "tds:AuxiliaryCommandResponse", -1, &a->AuxiliaryCommandResponse, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_in__tds__SendAuxiliaryCommandResponse(struct soap *soap, const char *tag, struct _tds__SendAuxiliaryCommandResponse *a, const char *type)
{
	size_t soap_flag_AuxiliaryCommandResponse = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SendAuxiliaryCommandResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, sizeof(struct _tds__SendAuxiliaryCommandResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SendAuxiliaryCommandResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryCommandResponse && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__AuxiliaryData(soap, "tds:AuxiliaryCommandResponse", &a->AuxiliaryCommandResponse, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryCommandResponse--;
					continue;
				}
			soap_check_result(soap, "tds:AuxiliaryCommandResponse");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SendAuxiliaryCommandResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommandResponse, 0, sizeof(struct _tds__SendAuxiliaryCommandResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SendAuxiliaryCommandResponse(struct soap *soap, const struct _tds__SendAuxiliaryCommandResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SendAuxiliaryCommandResponse);
	if (soap_out__tds__SendAuxiliaryCommandResponse(soap, tag?tag:"tds:SendAuxiliaryCommandResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommandResponse * SOAP_FMAC4 soap_get__tds__SendAuxiliaryCommandResponse(struct soap *soap, struct _tds__SendAuxiliaryCommandResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SendAuxiliaryCommandResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SendAuxiliaryCommand(struct soap *soap, struct _tds__SendAuxiliaryCommand *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__AuxiliaryData(soap, &a->AuxiliaryCommand);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SendAuxiliaryCommand(struct soap *soap, const struct _tds__SendAuxiliaryCommand *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__AuxiliaryData(soap, &a->AuxiliaryCommand);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, int id, const struct _tds__SendAuxiliaryCommand *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SendAuxiliaryCommand), type))
		return soap->error;
	if (a->AuxiliaryCommand)
	{	if (soap_out_tt__AuxiliaryData(soap, "tds:AuxiliaryCommand", -1, &a->AuxiliaryCommand, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:AuxiliaryCommand"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_in__tds__SendAuxiliaryCommand(struct soap *soap, const char *tag, struct _tds__SendAuxiliaryCommand *a, const char *type)
{
	size_t soap_flag_AuxiliaryCommand = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SendAuxiliaryCommand *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SendAuxiliaryCommand, sizeof(struct _tds__SendAuxiliaryCommand), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SendAuxiliaryCommand(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_AuxiliaryCommand && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__AuxiliaryData(soap, "tds:AuxiliaryCommand", &a->AuxiliaryCommand, "tt:AuxiliaryData"))
				{	soap_flag_AuxiliaryCommand--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SendAuxiliaryCommand *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SendAuxiliaryCommand, 0, sizeof(struct _tds__SendAuxiliaryCommand), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_AuxiliaryCommand > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SendAuxiliaryCommand(struct soap *soap, const struct _tds__SendAuxiliaryCommand *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SendAuxiliaryCommand);
	if (soap_out__tds__SendAuxiliaryCommand(soap, tag?tag:"tds:SendAuxiliaryCommand", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SendAuxiliaryCommand * SOAP_FMAC4 soap_get__tds__SendAuxiliaryCommand(struct soap *soap, struct _tds__SendAuxiliaryCommand *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SendAuxiliaryCommand(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputStateResponse(struct soap *soap, struct _tds__SetRelayOutputStateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputStateResponse(struct soap *soap, const struct _tds__SetRelayOutputStateResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputStateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputStateResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_in__tds__SetRelayOutputStateResponse(struct soap *soap, const char *tag, struct _tds__SetRelayOutputStateResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRelayOutputStateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputStateResponse, sizeof(struct _tds__SetRelayOutputStateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRelayOutputStateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputStateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputStateResponse, 0, sizeof(struct _tds__SetRelayOutputStateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputStateResponse(struct soap *soap, const struct _tds__SetRelayOutputStateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetRelayOutputStateResponse);
	if (soap_out__tds__SetRelayOutputStateResponse(soap, tag?tag:"tds:SetRelayOutputStateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputStateResponse * SOAP_FMAC4 soap_get__tds__SetRelayOutputStateResponse(struct soap *soap, struct _tds__SetRelayOutputStateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputStateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputState(struct soap *soap, struct _tds__SetRelayOutputState *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->RelayOutputToken);
	soap_default_tt__RelayLogicalState(soap, &a->LogicalState);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputState(struct soap *soap, const struct _tds__SetRelayOutputState *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->RelayOutputToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputState(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputState *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputState), type))
		return soap->error;
	if (a->RelayOutputToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tds:RelayOutputToken", -1, &a->RelayOutputToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:RelayOutputToken"))
		return soap->error;
	if (soap_out_tt__RelayLogicalState(soap, "tds:LogicalState", -1, &a->LogicalState, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputState * SOAP_FMAC4 soap_in__tds__SetRelayOutputState(struct soap *soap, const char *tag, struct _tds__SetRelayOutputState *a, const char *type)
{
	size_t soap_flag_RelayOutputToken = 1;
	size_t soap_flag_LogicalState = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRelayOutputState *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputState, sizeof(struct _tds__SetRelayOutputState), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRelayOutputState(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:RelayOutputToken", &a->RelayOutputToken, "tt:ReferenceToken"))
				{	soap_flag_RelayOutputToken--;
					continue;
				}
			if (soap_flag_LogicalState && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_tt__RelayLogicalState(soap, "tds:LogicalState", &a->LogicalState, "tt:RelayLogicalState"))
				{	soap_flag_LogicalState--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputState *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputState, 0, sizeof(struct _tds__SetRelayOutputState), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RelayOutputToken > 0 || soap_flag_LogicalState > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputState(struct soap *soap, const struct _tds__SetRelayOutputState *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetRelayOutputState);
	if (soap_out__tds__SetRelayOutputState(soap, tag?tag:"tds:SetRelayOutputState", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputState * SOAP_FMAC4 soap_get__tds__SetRelayOutputState(struct soap *soap, struct _tds__SetRelayOutputState *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputState(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputSettingsResponse(struct soap *soap, struct _tds__SetRelayOutputSettingsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputSettingsResponse(struct soap *soap, const struct _tds__SetRelayOutputSettingsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputSettingsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_in__tds__SetRelayOutputSettingsResponse(struct soap *soap, const char *tag, struct _tds__SetRelayOutputSettingsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRelayOutputSettingsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, sizeof(struct _tds__SetRelayOutputSettingsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRelayOutputSettingsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputSettingsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettingsResponse, 0, sizeof(struct _tds__SetRelayOutputSettingsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputSettingsResponse(struct soap *soap, const struct _tds__SetRelayOutputSettingsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetRelayOutputSettingsResponse);
	if (soap_out__tds__SetRelayOutputSettingsResponse(soap, tag?tag:"tds:SetRelayOutputSettingsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettingsResponse * SOAP_FMAC4 soap_get__tds__SetRelayOutputSettingsResponse(struct soap *soap, struct _tds__SetRelayOutputSettingsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputSettingsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetRelayOutputSettings(struct soap *soap, struct _tds__SetRelayOutputSettings *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->RelayOutputToken);
	a->Properties = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetRelayOutputSettings(struct soap *soap, const struct _tds__SetRelayOutputSettings *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->RelayOutputToken);
	soap_serialize_PointerTott__RelayOutputSettings(soap, &a->Properties);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetRelayOutputSettings(struct soap *soap, const char *tag, int id, const struct _tds__SetRelayOutputSettings *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetRelayOutputSettings), type))
		return soap->error;
	if (a->RelayOutputToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tds:RelayOutputToken", -1, &a->RelayOutputToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:RelayOutputToken"))
		return soap->error;
	if (a->Properties)
	{	if (soap_out_PointerTott__RelayOutputSettings(soap, "tds:Properties", -1, &a->Properties, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Properties"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_in__tds__SetRelayOutputSettings(struct soap *soap, const char *tag, struct _tds__SetRelayOutputSettings *a, const char *type)
{
	size_t soap_flag_RelayOutputToken = 1;
	size_t soap_flag_Properties = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetRelayOutputSettings *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetRelayOutputSettings, sizeof(struct _tds__SetRelayOutputSettings), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetRelayOutputSettings(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_RelayOutputToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:RelayOutputToken", &a->RelayOutputToken, "tt:ReferenceToken"))
				{	soap_flag_RelayOutputToken--;
					continue;
				}
			if (soap_flag_Properties && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__RelayOutputSettings(soap, "tds:Properties", &a->Properties, "tt:RelayOutputSettings"))
				{	soap_flag_Properties--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetRelayOutputSettings *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetRelayOutputSettings, 0, sizeof(struct _tds__SetRelayOutputSettings), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_RelayOutputToken > 0 || soap_flag_Properties > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetRelayOutputSettings(struct soap *soap, const struct _tds__SetRelayOutputSettings *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetRelayOutputSettings);
	if (soap_out__tds__SetRelayOutputSettings(soap, tag?tag:"tds:SetRelayOutputSettings", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetRelayOutputSettings * SOAP_FMAC4 soap_get__tds__SetRelayOutputSettings(struct soap *soap, struct _tds__SetRelayOutputSettings *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetRelayOutputSettings(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRelayOutputsResponse(struct soap *soap, struct _tds__GetRelayOutputsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeRelayOutputs = 0;
	a->RelayOutputs = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRelayOutputsResponse(struct soap *soap, const struct _tds__GetRelayOutputsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->RelayOutputs)
	{	int i;
		for (i = 0; i < a->__sizeRelayOutputs; i++)
		{
			soap_embedded(soap, a->RelayOutputs + i, SOAP_TYPE_tt__RelayOutput);
			soap_serialize_tt__RelayOutput(soap, a->RelayOutputs + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetRelayOutputsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRelayOutputsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeRelayOutputs");
	if (a->RelayOutputs)
	{	int i;
		for (i = 0; i < a->__sizeRelayOutputs; i++)
			if (soap_out_tt__RelayOutput(soap, "tds:RelayOutputs", -1, a->RelayOutputs + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_in__tds__GetRelayOutputsResponse(struct soap *soap, const char *tag, struct _tds__GetRelayOutputsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_RelayOutputs = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetRelayOutputsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputsResponse, sizeof(struct _tds__GetRelayOutputsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRelayOutputsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:RelayOutputs", 1, NULL))
			{	if (a->RelayOutputs == NULL)
				{	if (soap_blist_RelayOutputs == NULL)
						soap_blist_RelayOutputs = soap_new_block(soap);
					a->RelayOutputs = (struct tt__RelayOutput *)soap_push_block(soap, soap_blist_RelayOutputs, sizeof(struct tt__RelayOutput));
					if (a->RelayOutputs == NULL)
						return NULL;
					soap_default_tt__RelayOutput(soap, a->RelayOutputs);
				}
				soap_revert(soap);
				if (soap_in_tt__RelayOutput(soap, "tds:RelayOutputs", a->RelayOutputs, "tt:RelayOutput"))
				{	a->__sizeRelayOutputs++;
					a->RelayOutputs = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeRelayOutputs");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->RelayOutputs)
			soap_pop_block(soap, soap_blist_RelayOutputs);
		if (a->__sizeRelayOutputs)
			a->RelayOutputs = (struct tt__RelayOutput *)soap_save_block(soap, soap_blist_RelayOutputs, NULL, 1);
		else
		{	a->RelayOutputs = NULL;
			if (soap_blist_RelayOutputs)
				soap_end_block(soap, soap_blist_RelayOutputs);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRelayOutputsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputsResponse, 0, sizeof(struct _tds__GetRelayOutputsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRelayOutputsResponse(struct soap *soap, const struct _tds__GetRelayOutputsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetRelayOutputsResponse);
	if (soap_out__tds__GetRelayOutputsResponse(soap, tag?tag:"tds:GetRelayOutputsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRelayOutputsResponse * SOAP_FMAC4 soap_get__tds__GetRelayOutputsResponse(struct soap *soap, struct _tds__GetRelayOutputsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRelayOutputsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetRelayOutputs(struct soap *soap, struct _tds__GetRelayOutputs *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetRelayOutputs(struct soap *soap, const struct _tds__GetRelayOutputs *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetRelayOutputs(struct soap *soap, const char *tag, int id, const struct _tds__GetRelayOutputs *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetRelayOutputs), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetRelayOutputs * SOAP_FMAC4 soap_in__tds__GetRelayOutputs(struct soap *soap, const char *tag, struct _tds__GetRelayOutputs *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetRelayOutputs *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetRelayOutputs, sizeof(struct _tds__GetRelayOutputs), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetRelayOutputs(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetRelayOutputs *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetRelayOutputs, 0, sizeof(struct _tds__GetRelayOutputs), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetRelayOutputs(struct soap *soap, const struct _tds__GetRelayOutputs *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetRelayOutputs);
	if (soap_out__tds__GetRelayOutputs(soap, tag?tag:"tds:GetRelayOutputs", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetRelayOutputs * SOAP_FMAC4 soap_get__tds__GetRelayOutputs(struct soap *soap, struct _tds__GetRelayOutputs *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetRelayOutputs(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteDot1XConfigurationResponse(struct soap *soap, struct _tds__DeleteDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const struct _tds__DeleteDot1XConfigurationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__DeleteDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__DeleteDot1XConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__DeleteDot1XConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, sizeof(struct _tds__DeleteDot1XConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteDot1XConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse, 0, sizeof(struct _tds__DeleteDot1XConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteDot1XConfigurationResponse(struct soap *soap, const struct _tds__DeleteDot1XConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__DeleteDot1XConfigurationResponse);
	if (soap_out__tds__DeleteDot1XConfigurationResponse(soap, tag?tag:"tds:DeleteDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__DeleteDot1XConfigurationResponse(struct soap *soap, struct _tds__DeleteDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteDot1XConfiguration(struct soap *soap, struct _tds__DeleteDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDot1XConfigurationToken = 0;
	a->Dot1XConfigurationToken = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteDot1XConfiguration(struct soap *soap, const struct _tds__DeleteDot1XConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Dot1XConfigurationToken)
	{	int i;
		for (i = 0; i < a->__sizeDot1XConfigurationToken; i++)
		{
			soap_serialize_tt__ReferenceToken(soap, a->Dot1XConfigurationToken + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__DeleteDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteDot1XConfiguration), type))
		return soap->error;
	if (a->Dot1XConfigurationToken)
	{	int i;
		for (i = 0; i < a->__sizeDot1XConfigurationToken; i++)
			if (soap_out_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", -1, a->Dot1XConfigurationToken + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_in__tds__DeleteDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__DeleteDot1XConfiguration *a, const char *type)
{
	struct soap_blist *soap_blist_Dot1XConfigurationToken = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__DeleteDot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteDot1XConfiguration, sizeof(struct _tds__DeleteDot1XConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteDot1XConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Dot1XConfigurationToken", 1, NULL))
			{	if (a->Dot1XConfigurationToken == NULL)
				{	if (soap_blist_Dot1XConfigurationToken == NULL)
						soap_blist_Dot1XConfigurationToken = soap_new_block(soap);
					a->Dot1XConfigurationToken = (char **)soap_push_block(soap, soap_blist_Dot1XConfigurationToken, sizeof(char *));
					if (a->Dot1XConfigurationToken == NULL)
						return NULL;
					*a->Dot1XConfigurationToken = NULL;
				}
				soap_revert(soap);
				if (soap_in_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", a->Dot1XConfigurationToken, "tt:ReferenceToken"))
				{	a->__sizeDot1XConfigurationToken++;
					a->Dot1XConfigurationToken = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Dot1XConfigurationToken)
			soap_pop_block(soap, soap_blist_Dot1XConfigurationToken);
		if (a->__sizeDot1XConfigurationToken)
			a->Dot1XConfigurationToken = (char **)soap_save_block(soap, soap_blist_Dot1XConfigurationToken, NULL, 1);
		else
		{	a->Dot1XConfigurationToken = NULL;
			if (soap_blist_Dot1XConfigurationToken)
				soap_end_block(soap, soap_blist_Dot1XConfigurationToken);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteDot1XConfiguration, 0, sizeof(struct _tds__DeleteDot1XConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteDot1XConfiguration(struct soap *soap, const struct _tds__DeleteDot1XConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__DeleteDot1XConfiguration);
	if (soap_out__tds__DeleteDot1XConfiguration(soap, tag?tag:"tds:DeleteDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteDot1XConfiguration * SOAP_FMAC4 soap_get__tds__DeleteDot1XConfiguration(struct soap *soap, struct _tds__DeleteDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot1XConfigurationsResponse(struct soap *soap, struct _tds__GetDot1XConfigurationsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeDot1XConfiguration = 0;
	a->Dot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot1XConfigurationsResponse(struct soap *soap, const struct _tds__GetDot1XConfigurationsResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->Dot1XConfiguration)
	{	int i;
		for (i = 0; i < a->__sizeDot1XConfiguration; i++)
		{
			soap_embedded(soap, a->Dot1XConfiguration + i, SOAP_TYPE_tt__Dot1XConfiguration);
			soap_serialize_tt__Dot1XConfiguration(soap, a->Dot1XConfiguration + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDot1XConfigurationsResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeDot1XConfiguration");
	if (a->Dot1XConfiguration)
	{	int i;
		for (i = 0; i < a->__sizeDot1XConfiguration; i++)
			if (soap_out_tt__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, a->Dot1XConfiguration + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationsResponse * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurationsResponse(struct soap *soap, const char *tag, struct _tds__GetDot1XConfigurationsResponse *a, const char *type)
{
	struct soap_blist *soap_blist_Dot1XConfiguration = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot1XConfigurationsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, sizeof(struct _tds__GetDot1XConfigurationsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot1XConfigurationsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:Dot1XConfiguration", 1, NULL))
			{	if (a->Dot1XConfiguration == NULL)
				{	if (soap_blist_Dot1XConfiguration == NULL)
						soap_blist_Dot1XConfiguration = soap_new_block(soap);
					a->Dot1XConfiguration = (struct tt__Dot1XConfiguration *)soap_push_block(soap, soap_blist_Dot1XConfiguration, sizeof(struct tt__Dot1XConfiguration));
					if (a->Dot1XConfiguration == NULL)
						return NULL;
					soap_default_tt__Dot1XConfiguration(soap, a->Dot1XConfiguration);
				}
				soap_revert(soap);
				if (soap_in_tt__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", a->Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	a->__sizeDot1XConfiguration++;
					a->Dot1XConfiguration = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeDot1XConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->Dot1XConfiguration)
			soap_pop_block(soap, soap_blist_Dot1XConfiguration);
		if (a->__sizeDot1XConfiguration)
			a->Dot1XConfiguration = (struct tt__Dot1XConfiguration *)soap_save_block(soap, soap_blist_Dot1XConfiguration, NULL, 1);
		else
		{	a->Dot1XConfiguration = NULL;
			if (soap_blist_Dot1XConfiguration)
				soap_end_block(soap, soap_blist_Dot1XConfiguration);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfigurationsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurationsResponse, 0, sizeof(struct _tds__GetDot1XConfigurationsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot1XConfigurationsResponse(struct soap *soap, const struct _tds__GetDot1XConfigurationsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDot1XConfigurationsResponse);
	if (soap_out__tds__GetDot1XConfigurationsResponse(soap, tag?tag:"tds:GetDot1XConfigurationsResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationsResponse * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurationsResponse(struct soap *soap, struct _tds__GetDot1XConfigurationsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurationsResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot1XConfigurations(struct soap *soap, struct _tds__GetDot1XConfigurations *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot1XConfigurations(struct soap *soap, const struct _tds__GetDot1XConfigurations *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurations(struct soap *soap, const char *tag, int id, const struct _tds__GetDot1XConfigurations *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurations), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurations * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurations(struct soap *soap, const char *tag, struct _tds__GetDot1XConfigurations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot1XConfigurations *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurations, sizeof(struct _tds__GetDot1XConfigurations), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot1XConfigurations(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfigurations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurations, 0, sizeof(struct _tds__GetDot1XConfigurations), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot1XConfigurations(struct soap *soap, const struct _tds__GetDot1XConfigurations *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDot1XConfigurations);
	if (soap_out__tds__GetDot1XConfigurations(soap, tag?tag:"tds:GetDot1XConfigurations", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurations * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurations(struct soap *soap, struct _tds__GetDot1XConfigurations *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot1XConfigurationResponse(struct soap *soap, struct _tds__GetDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Dot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot1XConfigurationResponse(struct soap *soap, const struct _tds__GetDot1XConfigurationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &a->Dot1XConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfigurationResponse), type))
		return soap->error;
	if (a->Dot1XConfiguration)
		soap_element_result(soap, "tds:Dot1XConfiguration");
	if (a->Dot1XConfiguration)
	{	if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->Dot1XConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Dot1XConfiguration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__GetDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__GetDot1XConfigurationResponse *a, const char *type)
{
	size_t soap_flag_Dot1XConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot1XConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfigurationResponse, sizeof(struct _tds__GetDot1XConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot1XConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration--;
					continue;
				}
			soap_check_result(soap, "tds:Dot1XConfiguration");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfigurationResponse, 0, sizeof(struct _tds__GetDot1XConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1XConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot1XConfigurationResponse(struct soap *soap, const struct _tds__GetDot1XConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDot1XConfigurationResponse);
	if (soap_out__tds__GetDot1XConfigurationResponse(soap, tag?tag:"tds:GetDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__GetDot1XConfigurationResponse(struct soap *soap, struct _tds__GetDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetDot1XConfiguration(struct soap *soap, struct _tds__GetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_tt__ReferenceToken(soap, &a->Dot1XConfigurationToken);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetDot1XConfiguration(struct soap *soap, const struct _tds__GetDot1XConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_tt__ReferenceToken(soap, &a->Dot1XConfigurationToken);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__GetDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetDot1XConfiguration), type))
		return soap->error;
	if (a->Dot1XConfigurationToken)
	{	if (soap_out_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", -1, &a->Dot1XConfigurationToken, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Dot1XConfigurationToken"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetDot1XConfiguration * SOAP_FMAC4 soap_in__tds__GetDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__GetDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_Dot1XConfigurationToken = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetDot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetDot1XConfiguration, sizeof(struct _tds__GetDot1XConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetDot1XConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfigurationToken && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_tt__ReferenceToken(soap, "tds:Dot1XConfigurationToken", &a->Dot1XConfigurationToken, "tt:ReferenceToken"))
				{	soap_flag_Dot1XConfigurationToken--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetDot1XConfiguration, 0, sizeof(struct _tds__GetDot1XConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1XConfigurationToken > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetDot1XConfiguration(struct soap *soap, const struct _tds__GetDot1XConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetDot1XConfiguration);
	if (soap_out__tds__GetDot1XConfiguration(soap, tag?tag:"tds:GetDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetDot1XConfiguration * SOAP_FMAC4 soap_get__tds__GetDot1XConfiguration(struct soap *soap, struct _tds__GetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDot1XConfigurationResponse(struct soap *soap, struct _tds__SetDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDot1XConfigurationResponse(struct soap *soap, const struct _tds__SetDot1XConfigurationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDot1XConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__SetDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__SetDot1XConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDot1XConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDot1XConfigurationResponse, sizeof(struct _tds__SetDot1XConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDot1XConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDot1XConfigurationResponse, 0, sizeof(struct _tds__SetDot1XConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDot1XConfigurationResponse(struct soap *soap, const struct _tds__SetDot1XConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetDot1XConfigurationResponse);
	if (soap_out__tds__SetDot1XConfigurationResponse(soap, tag?tag:"tds:SetDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__SetDot1XConfigurationResponse(struct soap *soap, struct _tds__SetDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetDot1XConfiguration(struct soap *soap, struct _tds__SetDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Dot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetDot1XConfiguration(struct soap *soap, const struct _tds__SetDot1XConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &a->Dot1XConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__SetDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetDot1XConfiguration), type))
		return soap->error;
	if (a->Dot1XConfiguration)
	{	if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->Dot1XConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Dot1XConfiguration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetDot1XConfiguration * SOAP_FMAC4 soap_in__tds__SetDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__SetDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_Dot1XConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetDot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetDot1XConfiguration, sizeof(struct _tds__SetDot1XConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetDot1XConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetDot1XConfiguration, 0, sizeof(struct _tds__SetDot1XConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1XConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetDot1XConfiguration(struct soap *soap, const struct _tds__SetDot1XConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetDot1XConfiguration);
	if (soap_out__tds__SetDot1XConfiguration(soap, tag?tag:"tds:SetDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetDot1XConfiguration * SOAP_FMAC4 soap_get__tds__SetDot1XConfiguration(struct soap *soap, struct _tds__SetDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateDot1XConfigurationResponse(struct soap *soap, struct _tds__CreateDot1XConfigurationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateDot1XConfigurationResponse(struct soap *soap, const struct _tds__CreateDot1XConfigurationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, int id, const struct _tds__CreateDot1XConfigurationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfigurationResponse * SOAP_FMAC4 soap_in__tds__CreateDot1XConfigurationResponse(struct soap *soap, const char *tag, struct _tds__CreateDot1XConfigurationResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__CreateDot1XConfigurationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, sizeof(struct _tds__CreateDot1XConfigurationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateDot1XConfigurationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateDot1XConfigurationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateDot1XConfigurationResponse, 0, sizeof(struct _tds__CreateDot1XConfigurationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateDot1XConfigurationResponse(struct soap *soap, const struct _tds__CreateDot1XConfigurationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__CreateDot1XConfigurationResponse);
	if (soap_out__tds__CreateDot1XConfigurationResponse(soap, tag?tag:"tds:CreateDot1XConfigurationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfigurationResponse * SOAP_FMAC4 soap_get__tds__CreateDot1XConfigurationResponse(struct soap *soap, struct _tds__CreateDot1XConfigurationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateDot1XConfigurationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateDot1XConfiguration(struct soap *soap, struct _tds__CreateDot1XConfiguration *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Dot1XConfiguration = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateDot1XConfiguration(struct soap *soap, const struct _tds__CreateDot1XConfiguration *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Dot1XConfiguration(soap, &a->Dot1XConfiguration);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, int id, const struct _tds__CreateDot1XConfiguration *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateDot1XConfiguration), type))
		return soap->error;
	if (a->Dot1XConfiguration)
	{	if (soap_out_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", -1, &a->Dot1XConfiguration, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Dot1XConfiguration"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_in__tds__CreateDot1XConfiguration(struct soap *soap, const char *tag, struct _tds__CreateDot1XConfiguration *a, const char *type)
{
	size_t soap_flag_Dot1XConfiguration = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__CreateDot1XConfiguration *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateDot1XConfiguration, sizeof(struct _tds__CreateDot1XConfiguration), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateDot1XConfiguration(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Dot1XConfiguration && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Dot1XConfiguration(soap, "tds:Dot1XConfiguration", &a->Dot1XConfiguration, "tt:Dot1XConfiguration"))
				{	soap_flag_Dot1XConfiguration--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateDot1XConfiguration *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateDot1XConfiguration, 0, sizeof(struct _tds__CreateDot1XConfiguration), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Dot1XConfiguration > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateDot1XConfiguration(struct soap *soap, const struct _tds__CreateDot1XConfiguration *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__CreateDot1XConfiguration);
	if (soap_out__tds__CreateDot1XConfiguration(soap, tag?tag:"tds:CreateDot1XConfiguration", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateDot1XConfiguration * SOAP_FMAC4 soap_get__tds__CreateDot1XConfiguration(struct soap *soap, struct _tds__CreateDot1XConfiguration *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateDot1XConfiguration(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__LoadCACertificatesResponse(struct soap *soap, struct _tds__LoadCACertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__LoadCACertificatesResponse(struct soap *soap, const struct _tds__LoadCACertificatesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, int id, const struct _tds__LoadCACertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCACertificatesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__LoadCACertificatesResponse * SOAP_FMAC4 soap_in__tds__LoadCACertificatesResponse(struct soap *soap, const char *tag, struct _tds__LoadCACertificatesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__LoadCACertificatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCACertificatesResponse, sizeof(struct _tds__LoadCACertificatesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__LoadCACertificatesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCACertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCACertificatesResponse, 0, sizeof(struct _tds__LoadCACertificatesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__LoadCACertificatesResponse(struct soap *soap, const struct _tds__LoadCACertificatesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__LoadCACertificatesResponse);
	if (soap_out__tds__LoadCACertificatesResponse(soap, tag?tag:"tds:LoadCACertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCACertificatesResponse * SOAP_FMAC4 soap_get__tds__LoadCACertificatesResponse(struct soap *soap, struct _tds__LoadCACertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__LoadCACertificates(struct soap *soap, struct _tds__LoadCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCACertificate = 0;
	a->CACertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__LoadCACertificates(struct soap *soap, const struct _tds__LoadCACertificates *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->CACertificate)
	{	int i;
		for (i = 0; i < a->__sizeCACertificate; i++)
		{
			soap_embedded(soap, a->CACertificate + i, SOAP_TYPE_tt__Certificate);
			soap_serialize_tt__Certificate(soap, a->CACertificate + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCACertificates(struct soap *soap, const char *tag, int id, const struct _tds__LoadCACertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCACertificates), type))
		return soap->error;
	if (a->CACertificate)
	{	int i;
		for (i = 0; i < a->__sizeCACertificate; i++)
			if (soap_out_tt__Certificate(soap, "tds:CACertificate", -1, a->CACertificate + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__LoadCACertificates * SOAP_FMAC4 soap_in__tds__LoadCACertificates(struct soap *soap, const char *tag, struct _tds__LoadCACertificates *a, const char *type)
{
	struct soap_blist *soap_blist_CACertificate = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__LoadCACertificates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCACertificates, sizeof(struct _tds__LoadCACertificates), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__LoadCACertificates(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CACertificate", 1, NULL))
			{	if (a->CACertificate == NULL)
				{	if (soap_blist_CACertificate == NULL)
						soap_blist_CACertificate = soap_new_block(soap);
					a->CACertificate = (struct tt__Certificate *)soap_push_block(soap, soap_blist_CACertificate, sizeof(struct tt__Certificate));
					if (a->CACertificate == NULL)
						return NULL;
					soap_default_tt__Certificate(soap, a->CACertificate);
				}
				soap_revert(soap);
				if (soap_in_tt__Certificate(soap, "tds:CACertificate", a->CACertificate, "tt:Certificate"))
				{	a->__sizeCACertificate++;
					a->CACertificate = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CACertificate)
			soap_pop_block(soap, soap_blist_CACertificate);
		if (a->__sizeCACertificate)
			a->CACertificate = (struct tt__Certificate *)soap_save_block(soap, soap_blist_CACertificate, NULL, 1);
		else
		{	a->CACertificate = NULL;
			if (soap_blist_CACertificate)
				soap_end_block(soap, soap_blist_CACertificate);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCACertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCACertificates, 0, sizeof(struct _tds__LoadCACertificates), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeCACertificate < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__LoadCACertificates(struct soap *soap, const struct _tds__LoadCACertificates *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__LoadCACertificates);
	if (soap_out__tds__LoadCACertificates(soap, tag?tag:"tds:LoadCACertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCACertificates * SOAP_FMAC4 soap_get__tds__LoadCACertificates(struct soap *soap, struct _tds__LoadCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCertificateInformationResponse(struct soap *soap, struct _tds__GetCertificateInformationResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->CertificateInformation = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCertificateInformationResponse(struct soap *soap, const struct _tds__GetCertificateInformationResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__CertificateInformation(soap, &a->CertificateInformation);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetCertificateInformationResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificateInformationResponse), type))
		return soap->error;
	if (a->CertificateInformation)
		soap_element_result(soap, "tds:CertificateInformation");
	if (a->CertificateInformation)
	{	if (soap_out_PointerTott__CertificateInformation(soap, "tds:CertificateInformation", -1, &a->CertificateInformation, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:CertificateInformation"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCertificateInformationResponse * SOAP_FMAC4 soap_in__tds__GetCertificateInformationResponse(struct soap *soap, const char *tag, struct _tds__GetCertificateInformationResponse *a, const char *type)
{
	size_t soap_flag_CertificateInformation = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCertificateInformationResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificateInformationResponse, sizeof(struct _tds__GetCertificateInformationResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCertificateInformationResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateInformation && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__CertificateInformation(soap, "tds:CertificateInformation", &a->CertificateInformation, "tt:CertificateInformation"))
				{	soap_flag_CertificateInformation--;
					continue;
				}
			soap_check_result(soap, "tds:CertificateInformation");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificateInformationResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificateInformationResponse, 0, sizeof(struct _tds__GetCertificateInformationResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateInformation > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCertificateInformationResponse(struct soap *soap, const struct _tds__GetCertificateInformationResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCertificateInformationResponse);
	if (soap_out__tds__GetCertificateInformationResponse(soap, tag?tag:"tds:GetCertificateInformationResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificateInformationResponse * SOAP_FMAC4 soap_get__tds__GetCertificateInformationResponse(struct soap *soap, struct _tds__GetCertificateInformationResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificateInformationResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCertificateInformation(struct soap *soap, struct _tds__GetCertificateInformation *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCertificateInformation(struct soap *soap, const struct _tds__GetCertificateInformation *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->CertificateID);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificateInformation(struct soap *soap, const char *tag, int id, const struct _tds__GetCertificateInformation *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificateInformation), type))
		return soap->error;
	if (a->CertificateID)
	{	if (soap_out_xsd__token(soap, "tds:CertificateID", -1, &a->CertificateID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:CertificateID"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCertificateInformation * SOAP_FMAC4 soap_in__tds__GetCertificateInformation(struct soap *soap, const char *tag, struct _tds__GetCertificateInformation *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCertificateInformation *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificateInformation, sizeof(struct _tds__GetCertificateInformation), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCertificateInformation(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tds:CertificateID", &a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificateInformation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificateInformation, 0, sizeof(struct _tds__GetCertificateInformation), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCertificateInformation(struct soap *soap, const struct _tds__GetCertificateInformation *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCertificateInformation);
	if (soap_out__tds__GetCertificateInformation(soap, tag?tag:"tds:GetCertificateInformation", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificateInformation * SOAP_FMAC4 soap_get__tds__GetCertificateInformation(struct soap *soap, struct _tds__GetCertificateInformation *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificateInformation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, struct _tds__LoadCertificateWithPrivateKeyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const struct _tds__LoadCertificateWithPrivateKeyResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, int id, const struct _tds__LoadCertificateWithPrivateKeyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC4 soap_in__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const char *tag, struct _tds__LoadCertificateWithPrivateKeyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__LoadCertificateWithPrivateKeyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, sizeof(struct _tds__LoadCertificateWithPrivateKeyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__LoadCertificateWithPrivateKeyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificateWithPrivateKeyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse, 0, sizeof(struct _tds__LoadCertificateWithPrivateKeyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, const struct _tds__LoadCertificateWithPrivateKeyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__LoadCertificateWithPrivateKeyResponse);
	if (soap_out__tds__LoadCertificateWithPrivateKeyResponse(soap, tag?tag:"tds:LoadCertificateWithPrivateKeyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKeyResponse * SOAP_FMAC4 soap_get__tds__LoadCertificateWithPrivateKeyResponse(struct soap *soap, struct _tds__LoadCertificateWithPrivateKeyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificateWithPrivateKeyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__LoadCertificateWithPrivateKey(struct soap *soap, struct _tds__LoadCertificateWithPrivateKey *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCertificateWithPrivateKey = 0;
	a->CertificateWithPrivateKey = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__LoadCertificateWithPrivateKey(struct soap *soap, const struct _tds__LoadCertificateWithPrivateKey *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->CertificateWithPrivateKey)
	{	int i;
		for (i = 0; i < a->__sizeCertificateWithPrivateKey; i++)
		{
			soap_embedded(soap, a->CertificateWithPrivateKey + i, SOAP_TYPE_tt__CertificateWithPrivateKey);
			soap_serialize_tt__CertificateWithPrivateKey(soap, a->CertificateWithPrivateKey + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, int id, const struct _tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey), type))
		return soap->error;
	if (a->CertificateWithPrivateKey)
	{	int i;
		for (i = 0; i < a->__sizeCertificateWithPrivateKey; i++)
			if (soap_out_tt__CertificateWithPrivateKey(soap, "tds:CertificateWithPrivateKey", -1, a->CertificateWithPrivateKey + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_in__tds__LoadCertificateWithPrivateKey(struct soap *soap, const char *tag, struct _tds__LoadCertificateWithPrivateKey *a, const char *type)
{
	struct soap_blist *soap_blist_CertificateWithPrivateKey = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__LoadCertificateWithPrivateKey *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, sizeof(struct _tds__LoadCertificateWithPrivateKey), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__LoadCertificateWithPrivateKey(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateWithPrivateKey", 1, NULL))
			{	if (a->CertificateWithPrivateKey == NULL)
				{	if (soap_blist_CertificateWithPrivateKey == NULL)
						soap_blist_CertificateWithPrivateKey = soap_new_block(soap);
					a->CertificateWithPrivateKey = (struct tt__CertificateWithPrivateKey *)soap_push_block(soap, soap_blist_CertificateWithPrivateKey, sizeof(struct tt__CertificateWithPrivateKey));
					if (a->CertificateWithPrivateKey == NULL)
						return NULL;
					soap_default_tt__CertificateWithPrivateKey(soap, a->CertificateWithPrivateKey);
				}
				soap_revert(soap);
				if (soap_in_tt__CertificateWithPrivateKey(soap, "tds:CertificateWithPrivateKey", a->CertificateWithPrivateKey, "tt:CertificateWithPrivateKey"))
				{	a->__sizeCertificateWithPrivateKey++;
					a->CertificateWithPrivateKey = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CertificateWithPrivateKey)
			soap_pop_block(soap, soap_blist_CertificateWithPrivateKey);
		if (a->__sizeCertificateWithPrivateKey)
			a->CertificateWithPrivateKey = (struct tt__CertificateWithPrivateKey *)soap_save_block(soap, soap_blist_CertificateWithPrivateKey, NULL, 1);
		else
		{	a->CertificateWithPrivateKey = NULL;
			if (soap_blist_CertificateWithPrivateKey)
				soap_end_block(soap, soap_blist_CertificateWithPrivateKey);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificateWithPrivateKey *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificateWithPrivateKey, 0, sizeof(struct _tds__LoadCertificateWithPrivateKey), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeCertificateWithPrivateKey < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__LoadCertificateWithPrivateKey(struct soap *soap, const struct _tds__LoadCertificateWithPrivateKey *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__LoadCertificateWithPrivateKey);
	if (soap_out__tds__LoadCertificateWithPrivateKey(soap, tag?tag:"tds:LoadCertificateWithPrivateKey", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificateWithPrivateKey * SOAP_FMAC4 soap_get__tds__LoadCertificateWithPrivateKey(struct soap *soap, struct _tds__LoadCertificateWithPrivateKey *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificateWithPrivateKey(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCACertificatesResponse(struct soap *soap, struct _tds__GetCACertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCACertificate = 0;
	a->CACertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCACertificatesResponse(struct soap *soap, const struct _tds__GetCACertificatesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->CACertificate)
	{	int i;
		for (i = 0; i < a->__sizeCACertificate; i++)
		{
			soap_embedded(soap, a->CACertificate + i, SOAP_TYPE_tt__Certificate);
			soap_serialize_tt__Certificate(soap, a->CACertificate + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCACertificatesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetCACertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCACertificatesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeCACertificate");
	if (a->CACertificate)
	{	int i;
		for (i = 0; i < a->__sizeCACertificate; i++)
			if (soap_out_tt__Certificate(soap, "tds:CACertificate", -1, a->CACertificate + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCACertificatesResponse * SOAP_FMAC4 soap_in__tds__GetCACertificatesResponse(struct soap *soap, const char *tag, struct _tds__GetCACertificatesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_CACertificate = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCACertificatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCACertificatesResponse, sizeof(struct _tds__GetCACertificatesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCACertificatesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CACertificate", 1, NULL))
			{	if (a->CACertificate == NULL)
				{	if (soap_blist_CACertificate == NULL)
						soap_blist_CACertificate = soap_new_block(soap);
					a->CACertificate = (struct tt__Certificate *)soap_push_block(soap, soap_blist_CACertificate, sizeof(struct tt__Certificate));
					if (a->CACertificate == NULL)
						return NULL;
					soap_default_tt__Certificate(soap, a->CACertificate);
				}
				soap_revert(soap);
				if (soap_in_tt__Certificate(soap, "tds:CACertificate", a->CACertificate, "tt:Certificate"))
				{	a->__sizeCACertificate++;
					a->CACertificate = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeCACertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CACertificate)
			soap_pop_block(soap, soap_blist_CACertificate);
		if (a->__sizeCACertificate)
			a->CACertificate = (struct tt__Certificate *)soap_save_block(soap, soap_blist_CACertificate, NULL, 1);
		else
		{	a->CACertificate = NULL;
			if (soap_blist_CACertificate)
				soap_end_block(soap, soap_blist_CACertificate);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCACertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCACertificatesResponse, 0, sizeof(struct _tds__GetCACertificatesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCACertificatesResponse(struct soap *soap, const struct _tds__GetCACertificatesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCACertificatesResponse);
	if (soap_out__tds__GetCACertificatesResponse(soap, tag?tag:"tds:GetCACertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCACertificatesResponse * SOAP_FMAC4 soap_get__tds__GetCACertificatesResponse(struct soap *soap, struct _tds__GetCACertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCACertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCACertificates(struct soap *soap, struct _tds__GetCACertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCACertificates(struct soap *soap, const struct _tds__GetCACertificates *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCACertificates(struct soap *soap, const char *tag, int id, const struct _tds__GetCACertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCACertificates), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCACertificates * SOAP_FMAC4 soap_in__tds__GetCACertificates(struct soap *soap, const char *tag, struct _tds__GetCACertificates *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCACertificates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCACertificates, sizeof(struct _tds__GetCACertificates), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCACertificates(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCACertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCACertificates, 0, sizeof(struct _tds__GetCACertificates), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCACertificates(struct soap *soap, const struct _tds__GetCACertificates *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCACertificates);
	if (soap_out__tds__GetCACertificates(soap, tag?tag:"tds:GetCACertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCACertificates * SOAP_FMAC4 soap_get__tds__GetCACertificates(struct soap *soap, struct _tds__GetCACertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCACertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetClientCertificateModeResponse(struct soap *soap, struct _tds__SetClientCertificateModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetClientCertificateModeResponse(struct soap *soap, const struct _tds__SetClientCertificateModeResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetClientCertificateModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetClientCertificateModeResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetClientCertificateModeResponse * SOAP_FMAC4 soap_in__tds__SetClientCertificateModeResponse(struct soap *soap, const char *tag, struct _tds__SetClientCertificateModeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetClientCertificateModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetClientCertificateModeResponse, sizeof(struct _tds__SetClientCertificateModeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetClientCertificateModeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetClientCertificateModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetClientCertificateModeResponse, 0, sizeof(struct _tds__SetClientCertificateModeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetClientCertificateModeResponse(struct soap *soap, const struct _tds__SetClientCertificateModeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetClientCertificateModeResponse);
	if (soap_out__tds__SetClientCertificateModeResponse(soap, tag?tag:"tds:SetClientCertificateModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetClientCertificateModeResponse * SOAP_FMAC4 soap_get__tds__SetClientCertificateModeResponse(struct soap *soap, struct _tds__SetClientCertificateModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetClientCertificateMode(struct soap *soap, struct _tds__SetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Enabled);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetClientCertificateMode(struct soap *soap, const struct _tds__SetClientCertificateMode *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetClientCertificateMode(struct soap *soap, const char *tag, int id, const struct _tds__SetClientCertificateMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetClientCertificateMode), type))
		return soap->error;
	if (soap_out_xsd__boolean(soap, "tds:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetClientCertificateMode * SOAP_FMAC4 soap_in__tds__SetClientCertificateMode(struct soap *soap, const char *tag, struct _tds__SetClientCertificateMode *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetClientCertificateMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetClientCertificateMode, sizeof(struct _tds__SetClientCertificateMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetClientCertificateMode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tds:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetClientCertificateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetClientCertificateMode, 0, sizeof(struct _tds__SetClientCertificateMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetClientCertificateMode(struct soap *soap, const struct _tds__SetClientCertificateMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetClientCertificateMode);
	if (soap_out__tds__SetClientCertificateMode(soap, tag?tag:"tds:SetClientCertificateMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetClientCertificateMode * SOAP_FMAC4 soap_get__tds__SetClientCertificateMode(struct soap *soap, struct _tds__SetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetClientCertificateModeResponse(struct soap *soap, struct _tds__GetClientCertificateModeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__boolean(soap, &a->Enabled);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetClientCertificateModeResponse(struct soap *soap, const struct _tds__GetClientCertificateModeResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->Enabled, SOAP_TYPE_xsd__boolean);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetClientCertificateModeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetClientCertificateModeResponse), type))
		return soap->error;
	soap_element_result(soap, "tds:Enabled");
	if (soap_out_xsd__boolean(soap, "tds:Enabled", -1, &a->Enabled, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetClientCertificateModeResponse * SOAP_FMAC4 soap_in__tds__GetClientCertificateModeResponse(struct soap *soap, const char *tag, struct _tds__GetClientCertificateModeResponse *a, const char *type)
{
	size_t soap_flag_Enabled = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetClientCertificateModeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetClientCertificateModeResponse, sizeof(struct _tds__GetClientCertificateModeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetClientCertificateModeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Enabled && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "tds:Enabled", &a->Enabled, "xsd:boolean"))
				{	soap_flag_Enabled--;
					continue;
				}
			soap_check_result(soap, "tds:Enabled");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetClientCertificateModeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetClientCertificateModeResponse, 0, sizeof(struct _tds__GetClientCertificateModeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Enabled > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetClientCertificateModeResponse(struct soap *soap, const struct _tds__GetClientCertificateModeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetClientCertificateModeResponse);
	if (soap_out__tds__GetClientCertificateModeResponse(soap, tag?tag:"tds:GetClientCertificateModeResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetClientCertificateModeResponse * SOAP_FMAC4 soap_get__tds__GetClientCertificateModeResponse(struct soap *soap, struct _tds__GetClientCertificateModeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetClientCertificateModeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetClientCertificateMode(struct soap *soap, struct _tds__GetClientCertificateMode *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetClientCertificateMode(struct soap *soap, const struct _tds__GetClientCertificateMode *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetClientCertificateMode(struct soap *soap, const char *tag, int id, const struct _tds__GetClientCertificateMode *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetClientCertificateMode), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetClientCertificateMode * SOAP_FMAC4 soap_in__tds__GetClientCertificateMode(struct soap *soap, const char *tag, struct _tds__GetClientCertificateMode *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetClientCertificateMode *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetClientCertificateMode, sizeof(struct _tds__GetClientCertificateMode), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetClientCertificateMode(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetClientCertificateMode *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetClientCertificateMode, 0, sizeof(struct _tds__GetClientCertificateMode), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetClientCertificateMode(struct soap *soap, const struct _tds__GetClientCertificateMode *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetClientCertificateMode);
	if (soap_out__tds__GetClientCertificateMode(soap, tag?tag:"tds:GetClientCertificateMode", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetClientCertificateMode * SOAP_FMAC4 soap_get__tds__GetClientCertificateMode(struct soap *soap, struct _tds__GetClientCertificateMode *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetClientCertificateMode(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__LoadCertificatesResponse(struct soap *soap, struct _tds__LoadCertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__LoadCertificatesResponse(struct soap *soap, const struct _tds__LoadCertificatesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificatesResponse(struct soap *soap, const char *tag, int id, const struct _tds__LoadCertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificatesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__LoadCertificatesResponse * SOAP_FMAC4 soap_in__tds__LoadCertificatesResponse(struct soap *soap, const char *tag, struct _tds__LoadCertificatesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__LoadCertificatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificatesResponse, sizeof(struct _tds__LoadCertificatesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__LoadCertificatesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificatesResponse, 0, sizeof(struct _tds__LoadCertificatesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__LoadCertificatesResponse(struct soap *soap, const struct _tds__LoadCertificatesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__LoadCertificatesResponse);
	if (soap_out__tds__LoadCertificatesResponse(soap, tag?tag:"tds:LoadCertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificatesResponse * SOAP_FMAC4 soap_get__tds__LoadCertificatesResponse(struct soap *soap, struct _tds__LoadCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__LoadCertificates(struct soap *soap, struct _tds__LoadCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNVTCertificate = 0;
	a->NVTCertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__LoadCertificates(struct soap *soap, const struct _tds__LoadCertificates *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->NVTCertificate)
	{	int i;
		for (i = 0; i < a->__sizeNVTCertificate; i++)
		{
			soap_embedded(soap, a->NVTCertificate + i, SOAP_TYPE_tt__Certificate);
			soap_serialize_tt__Certificate(soap, a->NVTCertificate + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__LoadCertificates(struct soap *soap, const char *tag, int id, const struct _tds__LoadCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__LoadCertificates), type))
		return soap->error;
	if (a->NVTCertificate)
	{	int i;
		for (i = 0; i < a->__sizeNVTCertificate; i++)
			if (soap_out_tt__Certificate(soap, "tds:NVTCertificate", -1, a->NVTCertificate + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__LoadCertificates * SOAP_FMAC4 soap_in__tds__LoadCertificates(struct soap *soap, const char *tag, struct _tds__LoadCertificates *a, const char *type)
{
	struct soap_blist *soap_blist_NVTCertificate = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__LoadCertificates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__LoadCertificates, sizeof(struct _tds__LoadCertificates), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__LoadCertificates(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NVTCertificate", 1, NULL))
			{	if (a->NVTCertificate == NULL)
				{	if (soap_blist_NVTCertificate == NULL)
						soap_blist_NVTCertificate = soap_new_block(soap);
					a->NVTCertificate = (struct tt__Certificate *)soap_push_block(soap, soap_blist_NVTCertificate, sizeof(struct tt__Certificate));
					if (a->NVTCertificate == NULL)
						return NULL;
					soap_default_tt__Certificate(soap, a->NVTCertificate);
				}
				soap_revert(soap);
				if (soap_in_tt__Certificate(soap, "tds:NVTCertificate", a->NVTCertificate, "tt:Certificate"))
				{	a->__sizeNVTCertificate++;
					a->NVTCertificate = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NVTCertificate)
			soap_pop_block(soap, soap_blist_NVTCertificate);
		if (a->__sizeNVTCertificate)
			a->NVTCertificate = (struct tt__Certificate *)soap_save_block(soap, soap_blist_NVTCertificate, NULL, 1);
		else
		{	a->NVTCertificate = NULL;
			if (soap_blist_NVTCertificate)
				soap_end_block(soap, soap_blist_NVTCertificate);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__LoadCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__LoadCertificates, 0, sizeof(struct _tds__LoadCertificates), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeNVTCertificate < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__LoadCertificates(struct soap *soap, const struct _tds__LoadCertificates *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__LoadCertificates);
	if (soap_out__tds__LoadCertificates(soap, tag?tag:"tds:LoadCertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__LoadCertificates * SOAP_FMAC4 soap_get__tds__LoadCertificates(struct soap *soap, struct _tds__LoadCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__LoadCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetPkcs10RequestResponse(struct soap *soap, struct _tds__GetPkcs10RequestResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->Pkcs10Request = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetPkcs10RequestResponse(struct soap *soap, const struct _tds__GetPkcs10RequestResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__BinaryData(soap, &a->Pkcs10Request);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetPkcs10RequestResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPkcs10RequestResponse), type))
		return soap->error;
	if (a->Pkcs10Request)
		soap_element_result(soap, "tds:Pkcs10Request");
	if (a->Pkcs10Request)
	{	if (soap_out_PointerTott__BinaryData(soap, "tds:Pkcs10Request", -1, &a->Pkcs10Request, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:Pkcs10Request"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetPkcs10RequestResponse * SOAP_FMAC4 soap_in__tds__GetPkcs10RequestResponse(struct soap *soap, const char *tag, struct _tds__GetPkcs10RequestResponse *a, const char *type)
{
	size_t soap_flag_Pkcs10Request = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetPkcs10RequestResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPkcs10RequestResponse, sizeof(struct _tds__GetPkcs10RequestResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetPkcs10RequestResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_Pkcs10Request && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BinaryData(soap, "tds:Pkcs10Request", &a->Pkcs10Request, "tt:BinaryData"))
				{	soap_flag_Pkcs10Request--;
					continue;
				}
			soap_check_result(soap, "tds:Pkcs10Request");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetPkcs10RequestResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPkcs10RequestResponse, 0, sizeof(struct _tds__GetPkcs10RequestResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_Pkcs10Request > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetPkcs10RequestResponse(struct soap *soap, const struct _tds__GetPkcs10RequestResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetPkcs10RequestResponse);
	if (soap_out__tds__GetPkcs10RequestResponse(soap, tag?tag:"tds:GetPkcs10RequestResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetPkcs10RequestResponse * SOAP_FMAC4 soap_get__tds__GetPkcs10RequestResponse(struct soap *soap, struct _tds__GetPkcs10RequestResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPkcs10RequestResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetPkcs10Request(struct soap *soap, struct _tds__GetPkcs10Request *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	soap_default_string(soap, &a->Subject);
	a->Attributes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetPkcs10Request(struct soap *soap, const struct _tds__GetPkcs10Request *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->CertificateID);
	soap_serialize_string(soap, &a->Subject);
	soap_serialize_PointerTott__BinaryData(soap, &a->Attributes);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetPkcs10Request(struct soap *soap, const char *tag, int id, const struct _tds__GetPkcs10Request *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetPkcs10Request), type))
		return soap->error;
	if (a->CertificateID)
	{	if (soap_out_xsd__token(soap, "tds:CertificateID", -1, &a->CertificateID, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:CertificateID"))
		return soap->error;
	if (soap_out_string(soap, "tds:Subject", -1, &a->Subject, ""))
		return soap->error;
	if (soap_out_PointerTott__BinaryData(soap, "tds:Attributes", -1, &a->Attributes, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetPkcs10Request * SOAP_FMAC4 soap_in__tds__GetPkcs10Request(struct soap *soap, const char *tag, struct _tds__GetPkcs10Request *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Subject = 1;
	size_t soap_flag_Attributes = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetPkcs10Request *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetPkcs10Request, sizeof(struct _tds__GetPkcs10Request), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetPkcs10Request(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tds:CertificateID", &a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap_flag_Subject && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:Subject", &a->Subject, "xsd:string"))
				{	soap_flag_Subject--;
					continue;
				}
			if (soap_flag_Attributes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BinaryData(soap, "tds:Attributes", &a->Attributes, "tt:BinaryData"))
				{	soap_flag_Attributes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetPkcs10Request *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetPkcs10Request, 0, sizeof(struct _tds__GetPkcs10Request), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_CertificateID > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetPkcs10Request(struct soap *soap, const struct _tds__GetPkcs10Request *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetPkcs10Request);
	if (soap_out__tds__GetPkcs10Request(soap, tag?tag:"tds:GetPkcs10Request", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetPkcs10Request * SOAP_FMAC4 soap_get__tds__GetPkcs10Request(struct soap *soap, struct _tds__GetPkcs10Request *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetPkcs10Request(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteCertificatesResponse(struct soap *soap, struct _tds__DeleteCertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteCertificatesResponse(struct soap *soap, const struct _tds__DeleteCertificatesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, int id, const struct _tds__DeleteCertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteCertificatesResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteCertificatesResponse * SOAP_FMAC4 soap_in__tds__DeleteCertificatesResponse(struct soap *soap, const char *tag, struct _tds__DeleteCertificatesResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__DeleteCertificatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteCertificatesResponse, sizeof(struct _tds__DeleteCertificatesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteCertificatesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteCertificatesResponse, 0, sizeof(struct _tds__DeleteCertificatesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteCertificatesResponse(struct soap *soap, const struct _tds__DeleteCertificatesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__DeleteCertificatesResponse);
	if (soap_out__tds__DeleteCertificatesResponse(soap, tag?tag:"tds:DeleteCertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteCertificatesResponse * SOAP_FMAC4 soap_get__tds__DeleteCertificatesResponse(struct soap *soap, struct _tds__DeleteCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__DeleteCertificates(struct soap *soap, struct _tds__DeleteCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCertificateID = 0;
	a->CertificateID = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__DeleteCertificates(struct soap *soap, const struct _tds__DeleteCertificates *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->CertificateID)
	{	int i;
		for (i = 0; i < a->__sizeCertificateID; i++)
		{
			soap_serialize_xsd__token(soap, a->CertificateID + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__DeleteCertificates(struct soap *soap, const char *tag, int id, const struct _tds__DeleteCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__DeleteCertificates), type))
		return soap->error;
	if (a->CertificateID)
	{	int i;
		for (i = 0; i < a->__sizeCertificateID; i++)
			if (soap_out_xsd__token(soap, "tds:CertificateID", -1, a->CertificateID + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__DeleteCertificates * SOAP_FMAC4 soap_in__tds__DeleteCertificates(struct soap *soap, const char *tag, struct _tds__DeleteCertificates *a, const char *type)
{
	struct soap_blist *soap_blist_CertificateID = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__DeleteCertificates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__DeleteCertificates, sizeof(struct _tds__DeleteCertificates), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__DeleteCertificates(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateID", 1, NULL))
			{	if (a->CertificateID == NULL)
				{	if (soap_blist_CertificateID == NULL)
						soap_blist_CertificateID = soap_new_block(soap);
					a->CertificateID = (char **)soap_push_block(soap, soap_blist_CertificateID, sizeof(char *));
					if (a->CertificateID == NULL)
						return NULL;
					*a->CertificateID = NULL;
				}
				soap_revert(soap);
				if (soap_in_xsd__token(soap, "tds:CertificateID", a->CertificateID, "xsd:token"))
				{	a->__sizeCertificateID++;
					a->CertificateID = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CertificateID)
			soap_pop_block(soap, soap_blist_CertificateID);
		if (a->__sizeCertificateID)
			a->CertificateID = (char **)soap_save_block(soap, soap_blist_CertificateID, NULL, 1);
		else
		{	a->CertificateID = NULL;
			if (soap_blist_CertificateID)
				soap_end_block(soap, soap_blist_CertificateID);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__DeleteCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__DeleteCertificates, 0, sizeof(struct _tds__DeleteCertificates), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (a->__sizeCertificateID < 1))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__DeleteCertificates(struct soap *soap, const struct _tds__DeleteCertificates *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__DeleteCertificates);
	if (soap_out__tds__DeleteCertificates(soap, tag?tag:"tds:DeleteCertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__DeleteCertificates * SOAP_FMAC4 soap_get__tds__DeleteCertificates(struct soap *soap, struct _tds__DeleteCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__DeleteCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetCertificatesStatusResponse(struct soap *soap, struct _tds__SetCertificatesStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetCertificatesStatusResponse(struct soap *soap, const struct _tds__SetCertificatesStatusResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetCertificatesStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetCertificatesStatusResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatusResponse * SOAP_FMAC4 soap_in__tds__SetCertificatesStatusResponse(struct soap *soap, const char *tag, struct _tds__SetCertificatesStatusResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetCertificatesStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetCertificatesStatusResponse, sizeof(struct _tds__SetCertificatesStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetCertificatesStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetCertificatesStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetCertificatesStatusResponse, 0, sizeof(struct _tds__SetCertificatesStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetCertificatesStatusResponse(struct soap *soap, const struct _tds__SetCertificatesStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetCertificatesStatusResponse);
	if (soap_out__tds__SetCertificatesStatusResponse(soap, tag?tag:"tds:SetCertificatesStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatusResponse * SOAP_FMAC4 soap_get__tds__SetCertificatesStatusResponse(struct soap *soap, struct _tds__SetCertificatesStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetCertificatesStatus(struct soap *soap, struct _tds__SetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCertificateStatus = 0;
	a->CertificateStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetCertificatesStatus(struct soap *soap, const struct _tds__SetCertificatesStatus *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->CertificateStatus)
	{	int i;
		for (i = 0; i < a->__sizeCertificateStatus; i++)
		{
			soap_embedded(soap, a->CertificateStatus + i, SOAP_TYPE_tt__CertificateStatus);
			soap_serialize_tt__CertificateStatus(soap, a->CertificateStatus + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetCertificatesStatus(struct soap *soap, const char *tag, int id, const struct _tds__SetCertificatesStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetCertificatesStatus), type))
		return soap->error;
	if (a->CertificateStatus)
	{	int i;
		for (i = 0; i < a->__sizeCertificateStatus; i++)
			if (soap_out_tt__CertificateStatus(soap, "tds:CertificateStatus", -1, a->CertificateStatus + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatus * SOAP_FMAC4 soap_in__tds__SetCertificatesStatus(struct soap *soap, const char *tag, struct _tds__SetCertificatesStatus *a, const char *type)
{
	struct soap_blist *soap_blist_CertificateStatus = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetCertificatesStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetCertificatesStatus, sizeof(struct _tds__SetCertificatesStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetCertificatesStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateStatus", 1, NULL))
			{	if (a->CertificateStatus == NULL)
				{	if (soap_blist_CertificateStatus == NULL)
						soap_blist_CertificateStatus = soap_new_block(soap);
					a->CertificateStatus = (struct tt__CertificateStatus *)soap_push_block(soap, soap_blist_CertificateStatus, sizeof(struct tt__CertificateStatus));
					if (a->CertificateStatus == NULL)
						return NULL;
					soap_default_tt__CertificateStatus(soap, a->CertificateStatus);
				}
				soap_revert(soap);
				if (soap_in_tt__CertificateStatus(soap, "tds:CertificateStatus", a->CertificateStatus, "tt:CertificateStatus"))
				{	a->__sizeCertificateStatus++;
					a->CertificateStatus = NULL;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CertificateStatus)
			soap_pop_block(soap, soap_blist_CertificateStatus);
		if (a->__sizeCertificateStatus)
			a->CertificateStatus = (struct tt__CertificateStatus *)soap_save_block(soap, soap_blist_CertificateStatus, NULL, 1);
		else
		{	a->CertificateStatus = NULL;
			if (soap_blist_CertificateStatus)
				soap_end_block(soap, soap_blist_CertificateStatus);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetCertificatesStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetCertificatesStatus, 0, sizeof(struct _tds__SetCertificatesStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetCertificatesStatus(struct soap *soap, const struct _tds__SetCertificatesStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetCertificatesStatus);
	if (soap_out__tds__SetCertificatesStatus(soap, tag?tag:"tds:SetCertificatesStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetCertificatesStatus * SOAP_FMAC4 soap_get__tds__SetCertificatesStatus(struct soap *soap, struct _tds__SetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCertificatesStatusResponse(struct soap *soap, struct _tds__GetCertificatesStatusResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeCertificateStatus = 0;
	a->CertificateStatus = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCertificatesStatusResponse(struct soap *soap, const struct _tds__GetCertificatesStatusResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->CertificateStatus)
	{	int i;
		for (i = 0; i < a->__sizeCertificateStatus; i++)
		{
			soap_embedded(soap, a->CertificateStatus + i, SOAP_TYPE_tt__CertificateStatus);
			soap_serialize_tt__CertificateStatus(soap, a->CertificateStatus + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetCertificatesStatusResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesStatusResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeCertificateStatus");
	if (a->CertificateStatus)
	{	int i;
		for (i = 0; i < a->__sizeCertificateStatus; i++)
			if (soap_out_tt__CertificateStatus(soap, "tds:CertificateStatus", -1, a->CertificateStatus + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatusResponse * SOAP_FMAC4 soap_in__tds__GetCertificatesStatusResponse(struct soap *soap, const char *tag, struct _tds__GetCertificatesStatusResponse *a, const char *type)
{
	struct soap_blist *soap_blist_CertificateStatus = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCertificatesStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesStatusResponse, sizeof(struct _tds__GetCertificatesStatusResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCertificatesStatusResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:CertificateStatus", 1, NULL))
			{	if (a->CertificateStatus == NULL)
				{	if (soap_blist_CertificateStatus == NULL)
						soap_blist_CertificateStatus = soap_new_block(soap);
					a->CertificateStatus = (struct tt__CertificateStatus *)soap_push_block(soap, soap_blist_CertificateStatus, sizeof(struct tt__CertificateStatus));
					if (a->CertificateStatus == NULL)
						return NULL;
					soap_default_tt__CertificateStatus(soap, a->CertificateStatus);
				}
				soap_revert(soap);
				if (soap_in_tt__CertificateStatus(soap, "tds:CertificateStatus", a->CertificateStatus, "tt:CertificateStatus"))
				{	a->__sizeCertificateStatus++;
					a->CertificateStatus = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeCertificateStatus");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->CertificateStatus)
			soap_pop_block(soap, soap_blist_CertificateStatus);
		if (a->__sizeCertificateStatus)
			a->CertificateStatus = (struct tt__CertificateStatus *)soap_save_block(soap, soap_blist_CertificateStatus, NULL, 1);
		else
		{	a->CertificateStatus = NULL;
			if (soap_blist_CertificateStatus)
				soap_end_block(soap, soap_blist_CertificateStatus);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificatesStatusResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesStatusResponse, 0, sizeof(struct _tds__GetCertificatesStatusResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCertificatesStatusResponse(struct soap *soap, const struct _tds__GetCertificatesStatusResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCertificatesStatusResponse);
	if (soap_out__tds__GetCertificatesStatusResponse(soap, tag?tag:"tds:GetCertificatesStatusResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatusResponse * SOAP_FMAC4 soap_get__tds__GetCertificatesStatusResponse(struct soap *soap, struct _tds__GetCertificatesStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesStatusResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCertificatesStatus(struct soap *soap, struct _tds__GetCertificatesStatus *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCertificatesStatus(struct soap *soap, const struct _tds__GetCertificatesStatus *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesStatus(struct soap *soap, const char *tag, int id, const struct _tds__GetCertificatesStatus *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesStatus), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatus * SOAP_FMAC4 soap_in__tds__GetCertificatesStatus(struct soap *soap, const char *tag, struct _tds__GetCertificatesStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCertificatesStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesStatus, sizeof(struct _tds__GetCertificatesStatus), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCertificatesStatus(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificatesStatus *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesStatus, 0, sizeof(struct _tds__GetCertificatesStatus), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCertificatesStatus(struct soap *soap, const struct _tds__GetCertificatesStatus *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCertificatesStatus);
	if (soap_out__tds__GetCertificatesStatus(soap, tag?tag:"tds:GetCertificatesStatus", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificatesStatus * SOAP_FMAC4 soap_get__tds__GetCertificatesStatus(struct soap *soap, struct _tds__GetCertificatesStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesStatus(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCertificatesResponse(struct soap *soap, struct _tds__GetCertificatesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__sizeNvtCertificate = 0;
	a->NvtCertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCertificatesResponse(struct soap *soap, const struct _tds__GetCertificatesResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	if (a->NvtCertificate)
	{	int i;
		for (i = 0; i < a->__sizeNvtCertificate; i++)
		{
			soap_embedded(soap, a->NvtCertificate + i, SOAP_TYPE_tt__Certificate);
			soap_serialize_tt__Certificate(soap, a->NvtCertificate + i);
		}
	}
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificatesResponse(struct soap *soap, const char *tag, int id, const struct _tds__GetCertificatesResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificatesResponse), type))
		return soap->error;
	soap_element_result(soap, "-sizeNvtCertificate");
	if (a->NvtCertificate)
	{	int i;
		for (i = 0; i < a->__sizeNvtCertificate; i++)
			if (soap_out_tt__Certificate(soap, "tds:NvtCertificate", -1, a->NvtCertificate + i, ""))
				return soap->error;
	}
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCertificatesResponse * SOAP_FMAC4 soap_in__tds__GetCertificatesResponse(struct soap *soap, const char *tag, struct _tds__GetCertificatesResponse *a, const char *type)
{
	struct soap_blist *soap_blist_NvtCertificate = NULL;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCertificatesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificatesResponse, sizeof(struct _tds__GetCertificatesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCertificatesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH && !soap_element_begin_in(soap, "tds:NvtCertificate", 1, NULL))
			{	if (a->NvtCertificate == NULL)
				{	if (soap_blist_NvtCertificate == NULL)
						soap_blist_NvtCertificate = soap_new_block(soap);
					a->NvtCertificate = (struct tt__Certificate *)soap_push_block(soap, soap_blist_NvtCertificate, sizeof(struct tt__Certificate));
					if (a->NvtCertificate == NULL)
						return NULL;
					soap_default_tt__Certificate(soap, a->NvtCertificate);
				}
				soap_revert(soap);
				if (soap_in_tt__Certificate(soap, "tds:NvtCertificate", a->NvtCertificate, "tt:Certificate"))
				{	a->__sizeNvtCertificate++;
					a->NvtCertificate = NULL;
					continue;
				}
			}
			soap_check_result(soap, "-sizeNvtCertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (a->NvtCertificate)
			soap_pop_block(soap, soap_blist_NvtCertificate);
		if (a->__sizeNvtCertificate)
			a->NvtCertificate = (struct tt__Certificate *)soap_save_block(soap, soap_blist_NvtCertificate, NULL, 1);
		else
		{	a->NvtCertificate = NULL;
			if (soap_blist_NvtCertificate)
				soap_end_block(soap, soap_blist_NvtCertificate);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificatesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificatesResponse, 0, sizeof(struct _tds__GetCertificatesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCertificatesResponse(struct soap *soap, const struct _tds__GetCertificatesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCertificatesResponse);
	if (soap_out__tds__GetCertificatesResponse(soap, tag?tag:"tds:GetCertificatesResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificatesResponse * SOAP_FMAC4 soap_get__tds__GetCertificatesResponse(struct soap *soap, struct _tds__GetCertificatesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificatesResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__GetCertificates(struct soap *soap, struct _tds__GetCertificates *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__GetCertificates(struct soap *soap, const struct _tds__GetCertificates *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__GetCertificates(struct soap *soap, const char *tag, int id, const struct _tds__GetCertificates *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__GetCertificates), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__GetCertificates * SOAP_FMAC4 soap_in__tds__GetCertificates(struct soap *soap, const char *tag, struct _tds__GetCertificates *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__GetCertificates *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__GetCertificates, sizeof(struct _tds__GetCertificates), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__GetCertificates(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__GetCertificates *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__GetCertificates, 0, sizeof(struct _tds__GetCertificates), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__GetCertificates(struct soap *soap, const struct _tds__GetCertificates *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__GetCertificates);
	if (soap_out__tds__GetCertificates(soap, tag?tag:"tds:GetCertificates", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__GetCertificates * SOAP_FMAC4 soap_get__tds__GetCertificates(struct soap *soap, struct _tds__GetCertificates *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__GetCertificates(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateCertificateResponse(struct soap *soap, struct _tds__CreateCertificateResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->NvtCertificate = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateCertificateResponse(struct soap *soap, const struct _tds__CreateCertificateResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__Certificate(soap, &a->NvtCertificate);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateCertificateResponse(struct soap *soap, const char *tag, int id, const struct _tds__CreateCertificateResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateCertificateResponse), type))
		return soap->error;
	if (a->NvtCertificate)
		soap_element_result(soap, "tds:NvtCertificate");
	if (a->NvtCertificate)
	{	if (soap_out_PointerTott__Certificate(soap, "tds:NvtCertificate", -1, &a->NvtCertificate, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:NvtCertificate"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateCertificateResponse * SOAP_FMAC4 soap_in__tds__CreateCertificateResponse(struct soap *soap, const char *tag, struct _tds__CreateCertificateResponse *a, const char *type)
{
	size_t soap_flag_NvtCertificate = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__CreateCertificateResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateCertificateResponse, sizeof(struct _tds__CreateCertificateResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateCertificateResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_NvtCertificate && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__Certificate(soap, "tds:NvtCertificate", &a->NvtCertificate, "tt:Certificate"))
				{	soap_flag_NvtCertificate--;
					continue;
				}
			soap_check_result(soap, "tds:NvtCertificate");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateCertificateResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateCertificateResponse, 0, sizeof(struct _tds__CreateCertificateResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_NvtCertificate > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateCertificateResponse(struct soap *soap, const struct _tds__CreateCertificateResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__CreateCertificateResponse);
	if (soap_out__tds__CreateCertificateResponse(soap, tag?tag:"tds:CreateCertificateResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateCertificateResponse * SOAP_FMAC4 soap_get__tds__CreateCertificateResponse(struct soap *soap, struct _tds__CreateCertificateResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateCertificateResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__CreateCertificate(struct soap *soap, struct _tds__CreateCertificate *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_xsd__token(soap, &a->CertificateID);
	soap_default_string(soap, &a->Subject);
	a->ValidNotBefore = NULL;
	a->ValidNotAfter = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__CreateCertificate(struct soap *soap, const struct _tds__CreateCertificate *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_xsd__token(soap, &a->CertificateID);
	soap_serialize_string(soap, &a->Subject);
	soap_serialize_PointerTotime(soap, &a->ValidNotBefore);
	soap_serialize_PointerTotime(soap, &a->ValidNotAfter);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__CreateCertificate(struct soap *soap, const char *tag, int id, const struct _tds__CreateCertificate *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__CreateCertificate), type))
		return soap->error;
	if (soap_out_xsd__token(soap, "tds:CertificateID", -1, &a->CertificateID, ""))
		return soap->error;
	if (soap_out_string(soap, "tds:Subject", -1, &a->Subject, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "tds:ValidNotBefore", -1, &a->ValidNotBefore, ""))
		return soap->error;
	if (soap_out_PointerTotime(soap, "tds:ValidNotAfter", -1, &a->ValidNotAfter, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__CreateCertificate * SOAP_FMAC4 soap_in__tds__CreateCertificate(struct soap *soap, const char *tag, struct _tds__CreateCertificate *a, const char *type)
{
	size_t soap_flag_CertificateID = 1;
	size_t soap_flag_Subject = 1;
	size_t soap_flag_ValidNotBefore = 1;
	size_t soap_flag_ValidNotAfter = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__CreateCertificate *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__CreateCertificate, sizeof(struct _tds__CreateCertificate), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__CreateCertificate(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_CertificateID && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__token(soap, "tds:CertificateID", &a->CertificateID, "xsd:token"))
				{	soap_flag_CertificateID--;
					continue;
				}
			if (soap_flag_Subject && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "tds:Subject", &a->Subject, "xsd:string"))
				{	soap_flag_Subject--;
					continue;
				}
			if (soap_flag_ValidNotBefore && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "tds:ValidNotBefore", &a->ValidNotBefore, "xsd:dateTime"))
				{	soap_flag_ValidNotBefore--;
					continue;
				}
			if (soap_flag_ValidNotAfter && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTotime(soap, "tds:ValidNotAfter", &a->ValidNotAfter, "xsd:dateTime"))
				{	soap_flag_ValidNotAfter--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__CreateCertificate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__CreateCertificate, 0, sizeof(struct _tds__CreateCertificate), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__CreateCertificate(struct soap *soap, const struct _tds__CreateCertificate *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__CreateCertificate);
	if (soap_out__tds__CreateCertificate(soap, tag?tag:"tds:CreateCertificate", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__CreateCertificate * SOAP_FMAC4 soap_get__tds__CreateCertificate(struct soap *soap, struct _tds__CreateCertificate *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__CreateCertificate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetAccessPolicyResponse(struct soap *soap, struct _tds__SetAccessPolicyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetAccessPolicyResponse(struct soap *soap, const struct _tds__SetAccessPolicyResponse *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, int id, const struct _tds__SetAccessPolicyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetAccessPolicyResponse), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetAccessPolicyResponse * SOAP_FMAC4 soap_in__tds__SetAccessPolicyResponse(struct soap *soap, const char *tag, struct _tds__SetAccessPolicyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetAccessPolicyResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAccessPolicyResponse, sizeof(struct _tds__SetAccessPolicyResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetAccessPolicyResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetAccessPolicyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAccessPolicyResponse, 0, sizeof(struct _tds__SetAccessPolicyResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__tds__SetAccessPolicyResponse(struct soap *soap, const struct _tds__SetAccessPolicyResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__tds__SetAccessPolicyResponse);
	if (soap_out__tds__SetAccessPolicyResponse(soap, tag?tag:"tds:SetAccessPolicyResponse", id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct _tds__SetAccessPolicyResponse * SOAP_FMAC4 soap_get__tds__SetAccessPolicyResponse(struct soap *soap, struct _tds__SetAccessPolicyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in__tds__SetAccessPolicyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__tds__SetAccessPolicy(struct soap *soap, struct _tds__SetAccessPolicy *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->PolicyFile = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__tds__SetAccessPolicy(struct soap *soap, const struct _tds__SetAccessPolicy *a)
{
#ifndef WITH_NOIDREF
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTott__BinaryData(soap, &a->PolicyFile);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__tds__SetAccessPolicy(struct soap *soap, const char *tag, int id, const struct _tds__SetAccessPolicy *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)type;
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__tds__SetAccessPolicy), type))
		return soap->error;
	if (a->PolicyFile)
	{	if (soap_out_PointerTott__BinaryData(soap, "tds:PolicyFile", -1, &a->PolicyFile, ""))
			return soap->error;
	}
	else if (soap_element_nil(soap, "tds:PolicyFile"))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct _tds__SetAccessPolicy * SOAP_FMAC4 soap_in__tds__SetAccessPolicy(struct soap *soap, const char *tag, struct _tds__SetAccessPolicy *a, const char *type)
{
	size_t soap_flag_PolicyFile = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct _tds__SetAccessPolicy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__tds__SetAccessPolicy, sizeof(struct _tds__SetAccessPolicy), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default__tds__SetAccessPolicy(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_PolicyFile && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTott__BinaryData(soap, "tds:PolicyFile", &a->PolicyFile, "tt:BinaryData"))
				{	soap_flag_PolicyFile--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct _tds__SetAccessPolicy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__tds__SetAccessPolicy, 0, sizeof(struct _tds__SetAccessPolicy), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_PolicyFile > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

#ifdef __cplusplus
}
#endif